diff --git a/arch/arm/cpu/arm926ejs/aspeed/COMMINF.H b/arch/arm/cpu/arm926ejs/aspeed/COMMINF.H
new file mode 100644
index 0000000..44b7540
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/aspeed/COMMINF.H
@@ -0,0 +1,641 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef COMMINF_H
+#define COMMINF_H
+
+#include "SWFUNC.H"
+
+#if defined(LinuxAP)
+#endif
+#ifdef SLT_UBOOT
+#endif
+#ifdef SLT_DOS
+  #include <stdio.h>
+  #include <time.h>
+  #include <dos.h>    // For delay()
+#endif
+
+#include "TYPEDEF.H"
+#include "LIB.H"
+
+//---------------------------------------------------------
+// Print Message 
+//---------------------------------------------------------
+// for function
+#define FP_LOG    0
+#define FP_IO     1    
+#define STD_OUT   2    
+    
+#ifdef SLT_UBOOT
+    #define PRINT     printf
+    #define OUT_OBJ   
+    #define FILE_VAR  
+
+    #define GET_OBJ( i )    \
+    do {                    \
+        if ( i != STD_OUT ) \
+            return;         \
+    } while ( 0 );
+            
+#else
+    #define PRINT     fprintf
+    #define OUT_OBJ   fp,    
+    #define FILE_VAR  FILE *fp;
+    
+    #define GET_OBJ( i )     \
+        switch( i ) {        \
+            case FP_LOG:     \
+                fp = fp_log; \
+                break;       \
+            case FP_IO:      \
+                fp = fp_io;  \
+                break;       \
+            case STD_OUT:    \
+                fp = stdout; \
+                break;       \
+            default : break; \
+        }                
+#endif
+
+//---------------------------------------------------------
+// Function
+//---------------------------------------------------------
+#ifdef SLT_UBOOT
+    #define DELAY( x )  udelay( x * 1000 ) // For Uboot, the unit of udelay() is us.
+    #define GET_CAHR    getc
+#endif
+#ifdef SLT_DOS
+    #define DELAY( x )  delay( x )         // For DOS, the unit of delay() is ms.
+    #define GET_CAHR    getchar
+#endif
+
+//---------------------------------------------------------
+// Default argument
+//---------------------------------------------------------
+#define  DEF_USER_DEF_PACKET_VAL      0x66666666     //0xff00ff00, 0xf0f0f0f0, 0xcccccccc, 0x55aa55aa, 0x5a5a5a5a, 0x66666666
+#define  DEF_IOTIMINGBUND             5              //0/1/3/5/7
+#define  DEF_PHY_ADR                  0
+#define  DEF_TESTMODE                 0              //[0]0: no burst mode, 1: 0xff, 2: 0x55, 3: random, 4: ARP, 5: ARP, 6: IO timing, 7: IO timing+IO Strength
+#define  DEF_LOOP_MAX                 1
+#define  DEF_MAC_LOOP_BACK            0              //GCtrl bit6
+#define  DEF_SKIP_CHECK_PHY           0              //GCtrl bit4
+#define  DEF_INIT_PHY                 1              //GCtrl bit3
+
+#define  SET_1GBPS                    0              // 1G bps
+#define  SET_100MBPS                  1              // 100M bps
+#define  SET_10MBPS                   2              // 10M bps
+#define  SET_1G_100M_10MBPS           3              // 1G and 100M and 10M bps
+#define  DEF_SPEED                    SET_1G_100M_10MBPS 
+#define  DEF_ARPNUMCNT                0
+
+//---------------------------------------------------------
+// MAC information
+//---------------------------------------------------------
+#if ( AST1010_IOMAP == 1 )
+  // AST1010 only has a MAC
+  #define MAC_BASE1               AST_MAC1_BASE
+  #define MAC_BASE2               AST_MAC1_BASE
+  #define MAC_BASE3               AST_MAC1_BASE
+  #define MAC_BASE4               AST_MAC1_BASE
+#endif
+
+#if ( AST1010_IOMAP == 2 )
+  // AST1010 only has a MAC
+  #define MAC_BASE1               0x0830000
+  #define MAC_BASE2               0x0830000
+  #define MAC_BASE3               0x0830000
+  #define MAC_BASE4               0x0830000
+#endif
+
+#ifndef AST1010_IOMAP
+  #define MAC_BASE1               0x1e660000
+  #define MAC_BASE2               0x1e680000
+  #define MAC_BASE3               0x1e670000
+  #define MAC_BASE4               0x1e690000
+#endif
+
+#define MDC_Thres                 0x3f
+#define MAC_PHYWr                 0x08000000
+#define MAC_PHYRd                 0x04000000
+
+#define MAC_PHYWr_New             0x00009400
+#define MAC_PHYRd_New             0x00009800
+#define MAC_PHYBusy_New           0x00008000
+
+//#define MAC_30h                   0x00001010
+//#define MAC_34h                   0x00000000
+//#define MAC_38h                   0x00d22f00 //default 0x22f00
+//#define MAC_38h                   0x00022f00 //default 0x22f00
+
+#define MAC_40h                   0x40000000
+
+#ifdef Enable_BufMerge
+    #define MAC_48h               0x007702F1 //default 0xf1
+#else
+  #ifdef AST1010_IOMAP
+    #define MAC_48h               0x000002F1 //default 0xf1
+  #else
+    #define MAC_48h               0x000001F1 //default 0xf1
+  #endif
+#endif
+
+//---------------------------------------------------------
+// Data information
+//---------------------------------------------------------
+#ifdef SelectSimpleBoundary
+  #define ZeroCopy_OFFSET       0
+#else
+  #define ZeroCopy_OFFSET       ( (BurstEnable) ? 0 : 2 )
+#endif
+
+//      --------------------------------- DRAM_MapAdr            = TDES_BASE1
+//              | TX descriptor ring #1 |
+//              ------------------------- DRAM_MapAdr + 0x040000 = RDES_BASE1
+//              | RX descriptor ring #1 |
+//              ------------------------- DRAM_MapAdr + 0x080000 = TDES_BASE2
+//              | TX descriptor ring #2 |
+//              ------------------------- DRAM_MapAdr + 0x0C0000 = RDES_BASE2
+//              | RX descriptor ring #2 |
+//      --------------------------------- DRAM_MapAdr + 0x100000 = DMA_BASE    -------------------------
+//              |   #1                  |  \                                   |     #1     Tx         |
+//  DMA buffer  |                       |   DMA_BufSize                        |      LOOP = 0         |
+// ( Tx/Rx )    -------------------------  /                                   --------------------------------------------------
+//              |   #2                  |                                      |     #2     Rx         |  #2     Tx             |
+//              |                       |                                      |      LOOP = 0         |   LOOP = 1             |
+//              -------------------------                                      --------------------------------------------------
+//              |   #3                  |                                                              |  #3     Rx             |
+//              |                       |                                                              |   LOOP = 1             |
+//              -------------------------                                                              -------------------------
+//              |   #4                  |                                                                                     ..........
+//              |                       |
+//              -------------------------
+//              |   #5                  | 
+//              |                       | 
+//              ------------------------- 
+//              |   #6                  |
+//              |                       |
+//              -------------------------
+//                           .           
+//                           .           
+//              -------------------------
+//              |   #n, n = DMA_BufNum  |
+//              |                       |
+//      --------------------------------- 
+
+#if ( AST1010_IOMAP == 1 )
+    #define DRAM_MapAdr                 ( CONFIG_DRAM_SWAP_BASE + 0x00200000 ) // We use 0xA00000 to 0xEFFFFF
+    #define CPU_BUS_ADDR_SDRAM_OFFSET   0x01000000                             // In ReMapping function, MAC engine need Bus address
+                                                                               // But Coldfire need CPU address, so need to do offset
+#endif
+
+#if ( AST1010_IOMAP == 2 )
+    #define DRAM_MapAdr                 0x0A00000                              // We use 0xA00000 to 0xEFFFFF
+    #define CPU_BUS_ADDR_SDRAM_OFFSET   0
+#endif
+                                                                               
+#ifndef AST1010_IOMAP
+  #ifdef AST3200_IOMAP
+    #define DRAM_MapAdr           0x80000000
+  #else
+    #define DRAM_MapAdr           0x44000000   
+  #endif
+  
+  #define   CPU_BUS_ADDR_SDRAM_OFFSET   0
+#endif  
+
+  #define TDES_BASE1              ( 0x00000000 + DRAM_MapAdr   )
+  #define RDES_BASE1              ( 0x00040000 + DRAM_MapAdr   )
+  #define TDES_BASE2              ( 0x00080000 + DRAM_MapAdr   )
+  #define RDES_BASE2              ( 0x000C0000 + DRAM_MapAdr   )
+                                               
+  #define TDES_IniVal             ( 0xb0000000 + FRAME_LEN_Cur )
+  #define RDES_IniVal             ( 0x00000fff )
+  #define EOR_IniVal              ( 0x40008000 )
+  #define HWOwnTx(dat)            (   (dat) & 0x80000000  )
+  #define HWOwnRx(dat)            ( !((dat) & 0x80000000) )
+  #define HWEOR(dat)              (    dat  & 0x40000000  )
+
+//---------------------------------------------------------
+// Error Flag Bits
+//---------------------------------------------------------
+#define Err_MACMode                            ( 1 <<  0 )   // MAC interface mode mismatch
+#define Err_PHY_Type                           ( 1 <<  1 )   // Unidentifiable PHY
+#define Err_MALLOC_FrmSize                     ( 1 <<  2 )   // Malloc fail at frame size buffer
+#define Err_MALLOC_LastWP                      ( 1 <<  3 )   // Malloc fail at last WP buffer
+#define Err_Check_Buf_Data                     ( 1 <<  4 )   // Received data mismatch
+#define Err_Check_Des                          ( 1 <<  5 )   // Descriptor error
+#define Err_NCSI_LinkFail                      ( 1 <<  6 )   // NCSI packet retry number over flows
+#define Err_NCSI_Check_TxOwnTimeOut            ( 1 <<  7 )   // Time out of checking Tx owner bit in NCSI packet
+#define Err_NCSI_Check_RxOwnTimeOut            ( 1 <<  8 )   // Time out of checking Rx owner bit in NCSI packet
+#define Err_NCSI_Check_ARPOwnTimeOut           ( 1 <<  9 )   // Time out of checking ARP owner bit in NCSI packet
+#define Err_NCSI_No_PHY                        ( 1 << 10 )   // Can not find NCSI PHY
+#define Err_NCSI_Channel_Num                   ( 1 << 11 )   // NCSI Channel Number Mismatch
+#define Err_NCSI_Package_Num                   ( 1 << 12 )   // NCSI Package Number Mismatch
+#define Err_PHY_TimeOut                        ( 1 << 13 )   // Time out of read/write/reset PHY register
+#define Err_RXBUF_UNAVA                        ( 1 << 14 )   // MAC00h[2]:Receiving buffer unavailable
+#define Err_RPKT_LOST                          ( 1 << 15 )   // MAC00h[3]:Received packet lost due to RX FIFO full
+#define Err_NPTXBUF_UNAVA                      ( 1 << 16 )   // MAC00h[6]:Normal priority transmit buffer unavailable
+#define Err_TPKT_LOST                          ( 1 << 17 )   // MAC00h[7]:Packets transmitted to Ethernet lost
+#define Err_DMABufNum                          ( 1 << 18 )   // DMA Buffer is not enough
+#define Err_IOMargin                           ( 1 << 19 )   // IO timing margin is not enough
+#define Err_IOMarginOUF                        ( 1 << 20 )   // IO timing testing out of boundary
+#define Err_MHCLK_Ratio                        ( 1 << 21 )   // Error setting of MAC AHB bus clock (SCU08[18:16])
+                                                                
+#define Check_Des_TxOwnTimeOut                 ( 1 <<  0 )   // Time out of checking Tx owner bit
+#define Check_Des_RxOwnTimeOut                 ( 1 <<  1 )   // Time out of checking Rx owner bit
+#define Check_Des_RxErr                        ( 1 <<  2 )   // Input signal RxErr
+#define Check_Des_OddNibble                    ( 1 <<  3 )   // Nibble bit happen
+#define Check_Des_CRC                          ( 1 <<  4 )   // CRC error of frame
+#define Check_Des_RxFIFOFull                   ( 1 <<  5 )   // Rx FIFO full
+#define Check_Des_FrameLen                     ( 1 <<  6 )   // Frame length mismatch
+
+#define NCSI_LinkFail_Get_Version_ID           ( 1 <<  0 )   // Time out when Get Version ID
+#define NCSI_LinkFail_Get_Capabilities         ( 1 <<  1 )   // Time out when Get Capabilities
+#define NCSI_LinkFail_Select_Active_Package    ( 1 <<  2 )   // Time out when Select Active Package
+#define NCSI_LinkFail_Enable_Set_MAC_Address   ( 1 <<  3 )   // Time out when Enable Set MAC Address
+#define NCSI_LinkFail_Enable_Broadcast_Filter  ( 1 <<  4 )   // Time out when Enable Broadcast Filter
+#define NCSI_LinkFail_Enable_Network_TX        ( 1 <<  5 )   // Time out when Enable Network TX
+#define NCSI_LinkFail_Enable_Channel           ( 1 <<  6 )   // Time out when Enable Channel
+#define NCSI_LinkFail_Disable_Network_TX       ( 1 <<  7 )   // Time out when Disable Network TX
+#define NCSI_LinkFail_Disable_Channel          ( 1 <<  8 )   // Time out when Disable Channel
+
+//---------------------------------------------------------
+// SCU information
+//---------------------------------------------------------
+#if ( AST1010_IOMAP == 1 )
+    #define SCU_BASE              AST_SCU_BASE
+#endif
+#if ( AST1010_IOMAP == 2 )
+    #define SCU_BASE              0x0841000
+#endif
+
+#ifndef AST1010_IOMAP                         
+  #define SCU_BASE                0x1e6e2000
+#endif                            
+
+#define SCU_48h_AST1010           0x00000200
+#define SCU_48h_AST2300           0x00222255
+
+//#ifdef SLT_DOS
+//  #define SCU_80h               0x00000000
+//  #define SCU_88h               0x00000000
+//  #define SCU_90h               0x00000000
+//  #define SCU_74h               0x00000000
+//#else
+//  #define SCU_80h               0x0000000f     //AST2300[3:0]MAC1~4 PHYLINK
+//  #define SCU_88h               0xc0000000     //AST2300[31]MAC1 MDIO, [30]MAC1 MDC
+//  #define SCU_90h               0x00000004     //AST2300[2 ]MAC2 MDC/MDIO
+//  #define SCU_74h               0x06300000     //AST3000[20]MAC2 MDC/MDIO, [21]MAC2 MII, [25]MAC1 PHYLINK, [26]MAC2 PHYLINK
+//#endif
+
+//---------------------------------------------------------
+// DMA Buffer information
+//---------------------------------------------------------
+#ifdef FPGA
+        #define DRAM_KByteSize    ( 56 * 1024 )
+#else
+  #ifdef AST1010_IOMAP
+        #define DRAM_KByteSize    ( 3 * 1024 )      // DATA buffer only use 0xB00000 to 0xE00000
+  #else
+      #define DRAM_KByteSize      ( 18 * 1024 )
+  #endif
+#endif
+
+#define DMA_BASE                ( 0x00100000 + DRAM_MapAdr )
+
+#ifdef Enable_Jumbo
+  #define DMA_PakSize           ( 10 * 1024 )
+#else
+  #define DMA_PakSize           ( 2 * 1024 ) // The size of one LAN packet
+#endif
+
+#ifdef SelectSimpleBoundary
+  #define DMA_BufSize           (    ( ( ( ( DES_NUMBER + 15 ) * DMA_PakSize ) >> 2 ) << 2 ) ) //vary by DES_NUMBER
+#else                                                                                        
+  #define DMA_BufSize           (4 + ( ( ( ( DES_NUMBER + 15 ) * DMA_PakSize ) >> 2 ) << 2 ) ) //vary by DES_NUMBER
+#endif
+
+#define DMA_BufNum              ( ( DRAM_KByteSize * 1024 ) / ( DMA_BufSize ) )                //vary by DES_NUMBER
+#define GET_DMA_BASE_SETUP      ( DMA_BASE )
+#define GET_DMA_BASE(x)         ( DMA_BASE + ( ( ( ( x ) % DMA_BufNum ) + 1 ) * DMA_BufSize ) )//vary by DES_NUMBER
+
+#define SEED_START              8
+#define DATA_SEED(seed)         ( ( seed ) | (( seed + 1 ) << 16 ) )
+#define DATA_IncVal             0x00020001
+//#define DATA_IncVal             0x01000001     //fail
+//#define DATA_IncVal             0x10000001     //fail
+//#define DATA_IncVal             0x10000000     //fail
+//#define DATA_IncVal             0x80000000     //fail
+//#define DATA_IncVal             0x00000001     //ok
+//#define DATA_IncVal             0x01000100     //ok
+//#define DATA_IncVal             0x01010000     //ok
+//#define DATA_IncVal             0x01010101     //ok
+//#define DATA_IncVal             0x00000101     //ok
+//#define DATA_IncVal             0x00001111     //fail
+//#define DATA_IncVal             0x00000011     //fail
+//#define DATA_IncVal             0x10100101     //fail
+//#define DATA_IncVal             0xfeff0201
+//#define DATA_IncVal             0x00010001
+#define PktByteSize              ( ( ( ( ZeroCopy_OFFSET + FRAME_LEN_Cur - 1 ) >> 2 ) + 1) << 2 )
+
+//---------------------------------------------------------
+// Delay (ms)
+//---------------------------------------------------------
+//#define Delay_DesGap              1000        //off
+//#define Delay_DesGap              700         //off
+
+//#define Delay_ChkRxOwn            10
+//#define Delay_ChkTxOwn            10
+#define Delay_CntMax              100000000
+//#define Delay_CntMax              1000
+//#define Delay_CntMax              8465
+//#define Delay_CntMaxIncVal        50000
+#define Delay_CntMaxIncVal        47500
+
+#define Delay_PHYRst              100
+#define Delay_PHYRd               5
+
+#define Delay_SCU                 11
+#define Delay_MACRst              1
+#define Delay_MACDump             100
+
+//#define Delay_DES                 1
+
+//---------------------------------------------------------
+// Time Out
+//---------------------------------------------------------
+#define TIME_OUT_Des              10000
+#define TIME_OUT_PHY_RW           10000
+#define TIME_OUT_PHY_Rst          10000
+
+//#define TIME_OUT_NCSI             300000
+#define TIME_OUT_NCSI             30000
+
+
+
+//---------------------------------------------------------
+// Chip memory MAP
+//---------------------------------------------------------
+#define LITTLE_ENDIAN_ADDRESS   0
+#define BIG_ENDIAN_ADDRESS      1
+
+typedef struct {
+    ULONG StartAddr;
+    ULONG EndAddr;
+}  LittleEndian_Area;
+
+#if ( AST1010_IOMAP == 1 )
+  static const LittleEndian_Area LittleEndianArea[] = { 
+            { AST_IO_BASE, (AST_IO_BASE + 0x000FFFFF) },
+            { 0xFFFFFFFF, 0xFFFFFFFF }  // End
+            };
+#else
+  static const LittleEndian_Area LittleEndianArea[] = { 
+            { 0xFFFFFFFF, 0xFFFFFFFF }  // End
+            };            
+#endif
+
+// ========================================================
+// For ncsi.c 
+
+#define DEF_PACKAGE2NUM                         1      // Default value
+#define DEF_CHANNEL2NUM                         2      // Default value
+
+typedef struct {
+    unsigned char Package_ID;
+    unsigned char Channel_ID;
+    unsigned long Capabilities_Flags;
+    unsigned long Broadcast_Packet_Filter_Capabilities;
+    unsigned long Multicast_Packet_Filter_Capabilities;
+    unsigned long Buffering_Capabilities;
+    unsigned long AEN_Control_Support;
+    unsigned long PCI_DID_VID;
+    unsigned long ManufacturerID;
+} NCSI_Capability;
+
+#undef GLOBAL
+#ifdef NCSI_C
+#define GLOBAL
+#else
+#define GLOBAL    extern
+#endif
+
+GLOBAL  NCSI_Capability     NCSI_Cap_SLT;
+GLOBAL  BYTE                number_chl;
+
+GLOBAL  char phy_ncsi (void);
+           
+// ========================================================
+// For mactest 
+
+#undef GLOBAL
+#ifdef MACTEST_C
+#define GLOBAL
+#else
+#define GLOBAL    extern
+#endif
+
+GLOBAL  ULONG    NCSI_DiSChannel;
+
+// 
+#ifdef SLT_UBOOT
+#else 
+// SLT_DOS
+GLOBAL  FILE        *fp_log;
+GLOBAL  FILE        *fp_io;
+#endif
+
+GLOBAL  CHAR        dlymap[16][16];
+GLOBAL  CHAR        PrintNCSIEn;
+GLOBAL  ULONG       ARPNumCnt;
+GLOBAL  CHAR        FileNameMain[256];
+GLOBAL  CHAR        FileName[256];
+GLOBAL  CHAR        ASTChipName[256];
+GLOBAL  CHAR        LOOP_Str[256];
+GLOBAL  BYTE        IOTimingBund;
+GLOBAL  BYTE        ChannelTolNum;
+GLOBAL  BYTE        PackageTolNum;
+GLOBAL  ULONG       IOdly_out_reg;
+GLOBAL  BYTE        IOdly_out_reg_idx;
+GLOBAL  ULONG       Dat_ULONG;
+GLOBAL  ULONG       IOdly_incval;
+GLOBAL  ULONG       IOdly_in_reg;
+GLOBAL  BYTE        IOdly_in_reg_idx;
+GLOBAL  ULONG       *wp_lst;
+GLOBAL  ULONG       *FRAME_LEN;
+GLOBAL  ULONG       DES_NUMBER;
+GLOBAL  ULONG       DES_NUMBER_Org;
+GLOBAL  int         LOOP_MAX;
+GLOBAL  ULONG       LOOP_CheckNum;
+GLOBAL  int         Loop;
+GLOBAL  ULONG       CheckBuf_MBSize;
+GLOBAL  ULONG       Err_Flag;
+GLOBAL  ULONG       SCU_f0h_old;
+#ifdef AST1010_IOMAP
+  GLOBAL  ULONG       SCU_11Ch_old;
+#endif
+GLOBAL  ULONG       SCU_04h;
+GLOBAL  ULONG       SCU_90h_old;
+GLOBAL  ULONG       SCU_7ch_old;
+GLOBAL  ULONG       MAC_50h;
+GLOBAL  ULONG       SCU_ach_old;
+GLOBAL  ULONG       SCU_70h_old;
+GLOBAL  ULONG       MAC_50h_Speed;
+GLOBAL  ULONG       SCU_48h_old;
+GLOBAL  ULONG       SCU_48h_mix;
+GLOBAL  ULONG       MAC_08h_old;
+GLOBAL  ULONG       MAC_0ch_old;
+GLOBAL  ULONG       MAC_40h_old;
+GLOBAL  ULONG       SCU_08h_old;
+GLOBAL  ULONG       MAC_PHYBASE;
+GLOBAL  ULONG       LOOP_MAX_arg;
+GLOBAL  BYTE        GRun_Mode;
+GLOBAL  ULONG       GSpeed_idx;
+GLOBAL  CHAR        GSpeed_sel[3];
+GLOBAL  CHAR        PHY_ADR;
+GLOBAL  CHAR        PHY_ADR_arg;
+GLOBAL  CHAR        PHYName[256];
+GLOBAL  ULONG       PHY_ID3;
+GLOBAL  ULONG       PHY_ID2;
+GLOBAL  BYTE        number_pak;
+GLOBAL  BYTE        TestMode;
+GLOBAL  ULONG       IOStr_i;
+GLOBAL  BYTE        IOTimingBund_arg;
+GLOBAL  BYTE        GSpeed;
+GLOBAL  BYTE        GCtrl;
+GLOBAL  ULONG       UserDVal;
+GLOBAL  ULONG       H_MAC_BASE;
+GLOBAL  ULONG       H_TDES_BASE;
+GLOBAL  ULONG       H_RDES_BASE;
+GLOBAL  CHAR         Loop_rl[3];
+GLOBAL  CHAR        IOTiming;
+GLOBAL  CHAR        LOOP_INFINI;
+GLOBAL  CHAR        SelectMAC;
+GLOBAL  CHAR        Enable_SkipChkPHY;
+GLOBAL  CHAR        Enable_MAC34;
+GLOBAL  CHAR        IOStrength;
+GLOBAL  CHAR        DataDelay;
+GLOBAL  CHAR        SA[6];
+GLOBAL  CHAR        RxDataEnable;
+GLOBAL  CHAR        IEEETesting;
+GLOBAL  CHAR        BurstEnable;
+GLOBAL  CHAR        MAC_Mode;
+GLOBAL  CHAR        Enable_MACLoopback;
+GLOBAL  CHAR        Enable_InitPHY;
+GLOBAL  CHAR        MAC1_1GEn;
+GLOBAL  CHAR        MAC2_RMII;
+GLOBAL  CHAR        Enable_RMII;
+GLOBAL  CHAR        MAC2_1GEn;
+GLOBAL  CHAR        TxDataEnable;
+GLOBAL  CHAR        AST2300_NewMDIO;
+GLOBAL  CHAR        ASTChipType;
+GLOBAL  CHAR        Err_Flag_PrintEn;
+GLOBAL  CHAR        AST2400;
+GLOBAL  CHAR        AST2300;
+GLOBAL  CHAR        AST1100;//Different in phy & dram initiation & dram size & RMII
+GLOBAL  CHAR        AST3200;
+GLOBAL  CHAR        AST1010;
+GLOBAL  SCHAR       IOdly_i_min;
+GLOBAL  SCHAR       IOdly_j_min;
+GLOBAL  SCHAR       IOdly_i_max;
+GLOBAL  SCHAR       IOdly_j_max;
+GLOBAL  BYTE        IOdly_i;
+GLOBAL  BYTE        IOdly_j;
+GLOBAL  BYTE        IOdly_in;
+GLOBAL  BYTE        IOdly_out;
+GLOBAL  SCHAR       IOdly_in_str;
+GLOBAL  BYTE        IOdly_in_end;
+GLOBAL  BYTE        IOdly_out_end;
+GLOBAL  BYTE        IOdly_out_shf;
+GLOBAL  BYTE        IOdly_in_shf;
+GLOBAL  SCHAR       IOdly_out_str;
+GLOBAL  BYTE        valary[16];
+
+#define MODE_DEDICATED      0x01
+#define MODE_NSCI           0x02
+GLOBAL  CHAR        ModeSwitch;
+
+#ifdef SLT_UBOOT
+#else
+    GLOBAL  time_t      timestart;
+#endif
+
+#ifdef SPI_BUS
+    GLOBAL ULONG   mmiobase;
+#else    
+    // ( USE_P2A | USE_LPC )
+    GLOBAL  UCHAR       *mmiobase;
+    GLOBAL  ULONG       ulPCIBaseAddress;
+    GLOBAL  ULONG       ulMMIOBaseAddress;
+#endif
+
+   
+// ========================================================
+// For mac.c 
+#undef GLOBAL
+#ifdef MAC_C
+#define GLOBAL
+#else
+#define GLOBAL    extern
+#endif
+    
+GLOBAL  ULONG   ARP_data[16];
+GLOBAL  ULONG   NCSI_LinkFail_Val;
+static  const  char version_name[] = VER_NAME;
+
+GLOBAL void    Debug_delay (void);
+GLOBAL void    read_scu (void);
+GLOBAL void    Setting_scu (void);
+GLOBAL void    PrintMode (void);
+GLOBAL void    PrintPakNUm (void);
+GLOBAL void    PrintChlNUm (void);
+GLOBAL void    PrintTest (void);
+GLOBAL void    PrintIOTimingBund (void);
+GLOBAL void    PrintSpeed (void);
+GLOBAL void    PrintCtrl (void);
+GLOBAL void    PrintLoop (void);
+GLOBAL void    PrintPHYAdr (void);
+GLOBAL void    Finish_Close (void);
+GLOBAL void    Calculate_LOOP_CheckNum (void);
+GLOBAL char    Finish_Check (int value);
+GLOBAL void    init_scu1 (void);
+GLOBAL void    init_scu_macrst (void);
+GLOBAL void    setup_arp (void);
+GLOBAL void    TestingSetup (void);
+GLOBAL void    init_scu2 (void);
+GLOBAL void    init_scu3 (void);
+GLOBAL void    init_mac (ULONG base, ULONG tdexbase, ULONG rdexbase);
+GLOBAL char    TestingLoop (ULONG loop_checknum);
+GLOBAL void    PrintIO_Line_LOG (void);
+GLOBAL void    init_phy (int loop_phy);
+GLOBAL void    recov_phy (int loop_phy);
+GLOBAL int     FindErr (int value);
+GLOBAL int     FindErr_Des (int value);
+GLOBAL void    PrintIO_Header (BYTE option);
+GLOBAL void    Print_Header (BYTE option);
+GLOBAL void    PrintIO_LineS (BYTE option);
+GLOBAL void    PrintIO_Line (BYTE option);
+GLOBAL void    FPri_ErrFlag (BYTE option);
+
+#ifdef SUPPORT_PHY_LAN9303
+// ========================================================
+// For LAN9303.c 
+#undef GLOBAL
+#ifdef LAN9303_C
+#define GLOBAL
+#else
+#define GLOBAL    extern
+#endif
+
+GLOBAL void LAN9303(int num, int phy_adr, int speed, int int_loopback);
+#endif // SUPPORT_PHY_LAN9303
+#endif // End COMMINF_H
+
diff --git a/arch/arm/cpu/arm926ejs/aspeed/DEF_SPI.H b/arch/arm/cpu/arm926ejs/aspeed/DEF_SPI.H
new file mode 100644
index 0000000..02353e7
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/aspeed/DEF_SPI.H
@@ -0,0 +1,35 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef DEF_SPI_H
+#define DEF_SPI_H
+
+#include "TYPEDEF.H"
+#include "SWFUNC.H"
+
+typedef struct _DEVICE_PCI_INFO
+{
+    USHORT    usVendorID;
+    USHORT    usDeviceID;
+    ULONG     ulPCIConfigurationBaseAddress;
+    ULONG     ulPhysicalBaseAddress;
+    ULONG     ulMMIOBaseAddress;
+    USHORT    usRelocateIO;
+} DEVICE_PCI_INFO;
+
+//VIDEO Engine Info
+typedef struct _VIDEO_ENGINE_INFO {
+    USHORT             iEngVersion;
+    DEVICE_PCI_INFO    VGAPCIInfo;
+} VIDEO_ENGINE_INFO;
+
+BOOLEAN  GetDevicePCIInfo (VIDEO_ENGINE_INFO *VideoEngineInfo);
+
+#endif // DEF_SPI_H
diff --git a/arch/arm/cpu/arm926ejs/aspeed/DRAM_SPI.c b/arch/arm/cpu/arm926ejs/aspeed/DRAM_SPI.c
new file mode 100644
index 0000000..fe2b5cf
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/aspeed/DRAM_SPI.c
@@ -0,0 +1,78 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#define DRAM_SPI_C
+static const char ThisFile[] = "DRAM_SPI.c";
+
+#include "SWFUNC.H"
+
+#ifdef SPI_BUS
+#include <stdio.h>
+#include "DEF_SPI.H"
+#include "LIB_SPI.H"
+
+VOID Set_MMIO_Base(ULONG PCI_BASE, ULONG addr)
+{
+  static ULONG MMIO_BASE = -1;
+
+  if(MMIO_BASE != (addr & 0xffff0000)){
+    if(MMIO_BASE == -1){
+      *(ULONG *)(PCI_BASE + 0xF000) = 1;
+    }
+    *(ULONG *)(PCI_BASE + 0xF004) = addr;
+    MMIO_BASE = addr & 0xffff0000;
+  }
+}
+
+VOID  MOutbm(ULONG PCI_BASE, ULONG Offset, BYTE Data)
+{
+  Set_MMIO_Base(PCI_BASE, Offset);
+  *(BYTE *)(PCI_BASE + 0x10000 + (Offset & 0xffff)) = Data;
+}
+
+VOID  MOutwm(ULONG PCI_BASE, ULONG Offset, USHORT Data)
+{
+  Set_MMIO_Base(PCI_BASE, Offset);
+  *(USHORT *)(PCI_BASE + 0x10000 + (Offset & 0xffff)) = Data;
+}
+
+VOID  MOutdwm(ULONG PCI_BASE, ULONG Offset, ULONG Data)
+{
+  Set_MMIO_Base(PCI_BASE, Offset);
+  *(ULONG *)(PCI_BASE + 0x10000 + (Offset & 0xffff)) = Data;
+}
+
+BYTE  MInbm(ULONG PCI_BASE, ULONG Offset)
+{
+  BYTE jData;
+
+  Set_MMIO_Base(PCI_BASE, Offset);
+  jData = *(BYTE *)(PCI_BASE + 0x10000 + (Offset & 0xffff));
+  return(jData);
+}
+
+USHORT  MInwm(ULONG PCI_BASE, ULONG Offset)
+{
+  USHORT usData;
+
+  Set_MMIO_Base(PCI_BASE, Offset);
+  usData = *(USHORT *)(PCI_BASE + 0x10000 + (Offset & 0xffff));
+  return(usData);
+}
+
+ULONG  MIndwm(ULONG PCI_BASE, ULONG Offset)
+{
+  ULONG ulData;
+
+  Set_MMIO_Base(PCI_BASE, Offset);
+  ulData = *(ULONG *)(PCI_BASE + 0x10000 + (Offset & 0xffff));
+  return(ulData);
+}
+#endif // End SPI_BUS
diff --git a/arch/arm/cpu/arm926ejs/aspeed/IO.H b/arch/arm/cpu/arm926ejs/aspeed/IO.H
new file mode 100644
index 0000000..5fe03f0
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/aspeed/IO.H
@@ -0,0 +1,36 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef IO_H
+#define IO_H
+
+#include "SWFUNC.H"
+
+//
+// Macro
+//
+#if 	defined(LinuxAP)
+    #define delay(val)	usleep(val*1000)
+    #define ob(p,d) outb(d,p)
+    #define ib(p) inb(p)
+#else
+    #define ob(p,d)	outp(p,d)
+    #define ib(p) inp(p)
+#endif
+
+#ifdef USE_LPC
+void open_aspeed_sio_password(void);
+void enable_aspeed_LDU(BYTE jldu_number);
+int findlpcport(BYTE jldu_number);
+#endif
+
+void WriteSOC_DD(ULONG addr, ULONG data);
+ULONG ReadSOC_DD(ULONG addr);
+#endif
diff --git a/arch/arm/cpu/arm926ejs/aspeed/IO.c b/arch/arm/cpu/arm926ejs/aspeed/IO.c
new file mode 100644
index 0000000..86e9918
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/aspeed/IO.c
@@ -0,0 +1,356 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#define IO_C
+static const char ThisFile[] = "IO.c";
+
+#include "SWFUNC.H"
+
+#if defined(LinuxAP)
+  #include <stdio.h>
+  #include <string.h>
+  #include <stdlib.h>
+  #include <stdarg.h>
+  #include <unistd.h>
+  #include <string.h>
+  #include <fcntl.h>
+  #include <pthread.h>
+  #include <sys/mman.h>
+  #include <sys/io.h>
+#endif
+#ifdef SLT_UBOOT
+  #include <common.h>
+  #include <command.h>
+  #include <post.h>
+  #include <malloc.h>
+  #include <net.h>
+  #include <COMMINF.H>
+#endif
+#ifdef SLT_DOS
+  #include <stdlib.h>
+  #include <stdio.h>
+  #include <time.h>
+  #include <conio.h>
+  #include <dos.h>
+  #include <mem.h>
+  #include "TYPEDEF.H"
+  #include "LIB.H"
+  #include "COMMINF.H"
+#endif
+
+#include "TYPEDEF.H"
+#include "IO.H"
+#include "LIB_SPI.H"
+
+#ifdef SPI_BUS
+#endif
+#ifdef USE_LPC
+    USHORT	usLPCPort;
+#endif
+#ifdef USE_P2A
+#endif
+
+#ifdef USE_LPC
+//------------------------------------------------------------
+// LPC access
+//------------------------------------------------------------
+void open_aspeed_sio_password(void)
+{
+    ob (usLPCPort, 0xaa);
+
+    ob (usLPCPort, 0xa5);
+    ob (usLPCPort, 0xa5);
+}
+
+//------------------------------------------------------------
+void close_aspeed_sio_password(void)
+{
+    ob (usLPCPort, 0xaa);
+}
+
+//------------------------------------------------------------
+void enable_aspeed_LDU(BYTE jldu_number)
+{
+    ob (usLPCPort, 0x07);
+    ob ((usLPCPort + 1), jldu_number);
+    ob (usLPCPort, 0x30);
+    ob ((usLPCPort + 1), 0x01);
+}
+
+//------------------------------------------------------------
+void disable_aspeed_LDU(BYTE jldu_number)
+{
+    ob (usLPCPort, 0x07);
+    ob ((usLPCPort + 1), jldu_number);
+    ob (usLPCPort, 0x30);
+    ob ((usLPCPort + 1), 0x00);
+}
+
+//------------------------------------------------------------
+/*
+ulAddress = AHB address
+jmode = 0: byte mode
+        1: word mode
+        2: dword mode
+*/
+static ULONG lpc_read (ULONG ulAddress, BYTE jmode)
+{
+    ULONG    uldata = 0;
+    ULONG    ultemp = 0;
+    BYTE     jtemp;
+
+    //Write Address
+    ob (  usLPCPort,        0xf0);
+    ob ( (usLPCPort + 1  ), ((ulAddress & 0xff000000) >> 24));
+    ob (  usLPCPort,        0xf1);
+    ob ( (usLPCPort + 1)  , ((ulAddress & 0x00ff0000) >> 16));
+    ob (  usLPCPort,        0xf2);
+    ob ( (usLPCPort + 1),   ((ulAddress & 0x0000ff00) >> 8));
+    ob (  usLPCPort,        0xf3);
+    ob ( (usLPCPort + 1),   ulAddress & 0xff);
+    
+    //Write Mode
+    ob (usLPCPort, 0xf8);
+    jtemp = ib ((usLPCPort + 1));
+    ob ((usLPCPort + 1), ((jtemp & 0xfc) | jmode));
+    
+    //Fire
+    ob (usLPCPort, 0xfe);
+    jtemp = ib ((usLPCPort + 1));
+    
+    //Get Data
+    switch ( jmode )
+    {
+        case 0:
+            ob (usLPCPort, 0xf7);
+            ultemp  = ib ((usLPCPort + 1));
+            uldata |= (ultemp);
+            break;
+        
+        case 1:
+            ob (usLPCPort, 0xf6);
+            ultemp  = ib ((usLPCPort + 1));
+            uldata |= (ultemp << 8);
+            ob (usLPCPort, 0xf7);
+            ultemp  = ib ((usLPCPort + 1));
+            uldata |= (ultemp << 0);
+            break;
+        
+        case 2:
+            ob (usLPCPort, 0xf4);
+            ultemp  = ib ((usLPCPort + 1));
+            uldata |= (ultemp << 24);
+            ob (usLPCPort, 0xf5);
+            ultemp  = ib ((usLPCPort + 1));
+            uldata |= (ultemp << 16);
+            ob (usLPCPort, 0xf6);
+            ultemp  = ib ((usLPCPort + 1));
+            uldata |= (ultemp << 8);
+            ob (usLPCPort, 0xf7);
+            ultemp  = ib ((usLPCPort + 1));
+            uldata |= ultemp;
+            break;
+    } // End switch ( jmode )
+
+    return uldata;
+} // End static ULONG lpc_read (ULONG ulAddress, BYTE jmode)
+
+//------------------------------------------------------------
+static void lpc_write (ULONG ulAddress, ULONG uldata, BYTE jmode)
+{
+    BYTE     jtemp;
+
+    //Write Address
+    ob ( usLPCPort,      0xf0);
+    ob ((usLPCPort + 1), ((ulAddress & 0xff000000) >> 24));
+    ob ( usLPCPort,      0xf1);
+    ob ((usLPCPort + 1), ((ulAddress & 0x00ff0000) >> 16));
+    ob ( usLPCPort,      0xf2);
+    ob ((usLPCPort + 1), ((ulAddress & 0x0000ff00) >> 8));
+    ob ( usLPCPort,      0xf3);
+    ob ((usLPCPort + 1), ulAddress & 0xff);
+    
+    //Write Data
+    switch ( jmode )
+    {
+        case 0:
+            ob ( usLPCPort,      0xf7);
+            ob ((usLPCPort + 1), (uldata & 0xff));
+            break;
+        case 1:
+            ob ( usLPCPort,      0xf6);
+            ob ((usLPCPort + 1), ((uldata & 0xff00) >> 8));
+            ob ( usLPCPort,      0xf7);
+            ob ((usLPCPort + 1), (uldata & 0x00ff));
+            break;
+        case 2:
+            ob ( usLPCPort,      0xf4);
+            ob ((usLPCPort + 1), ((uldata & 0xff000000) >> 24));
+            ob ( usLPCPort,      0xf5);
+            ob ((usLPCPort + 1), ((uldata & 0x00ff0000) >> 16));
+            ob ( usLPCPort,      0xf6);
+            ob ((usLPCPort + 1), ((uldata & 0x0000ff00) >> 8));
+            ob ( usLPCPort,      0xf7);
+            ob ((usLPCPort + 1), uldata & 0xff);
+            break;
+    } // End switch ( jmode )
+    
+    //Write Mode
+    ob (usLPCPort, 0xf8);
+    jtemp = ib ((usLPCPort + 1));
+    ob ((usLPCPort + 1), ((jtemp & 0xfc) | jmode));
+
+    //Fire
+    ob (usLPCPort, 0xfe);
+    ob ((usLPCPort + 1), 0xcf);
+    
+} // End static void lpc_write (ULONG ulAddress, ULONG uldata, BYTE jmode)
+
+//------------------------------------------------------------
+static USHORT usLPCPortList[] = {0x2e, 0x4e, 0xff};
+int findlpcport(BYTE jldu_number)
+{
+    USHORT  *jLPCPortPtr;
+    ULONG   ulData;
+
+    jLPCPortPtr = usLPCPortList;
+    while (*(USHORT *)(jLPCPortPtr) != 0xff )
+    {
+        usLPCPort = *(USHORT *)(jLPCPortPtr++);
+
+        open_aspeed_sio_password();
+        enable_aspeed_LDU(0x0d);
+
+        ulData  = lpc_read(0x1e6e207c, 2);
+        
+        if ( (ulData != 0x00000000)	&&
+             (ulData != 0xFFFFFFFF)   )
+        {
+            printf("Find LPC IO port at 0x%2x \n", usLPCPort);
+            return 1;
+        }
+
+        disable_aspeed_LDU(0x0d);
+        close_aspeed_sio_password();
+    }
+
+    //printf("[Error] Fail to find proper LPC IO Port \n");
+    return 0;
+}
+#endif // End ifdef USE_LPC
+
+#ifdef USE_P2A
+//------------------------------------------------------------
+// A2P Access
+//------------------------------------------------------------
+void mm_write (ULONG addr, ULONG data, BYTE jmode)
+{
+    *(ULONG *) (mmiobase + 0xF004) = (ULONG) ((addr) & 0xFFFF0000);
+    *(ULONG *) (mmiobase + 0xF000) = (ULONG) 0x00000001;
+    
+    switch ( jmode )
+    {
+        case 0:
+            *(BYTE *) (mmiobase + 0x10000 + ((addr) & 0x0000FFFF)) = (BYTE) data;
+            break;
+        case 1:
+            *(USHORT *) (mmiobase + 0x10000 + ((addr) & 0x0000FFFF)) = (USHORT) data;
+            break;
+        case 2:
+        default:
+            *(ULONG *) (mmiobase + 0x10000 + ((addr) & 0x0000FFFF)) = data;
+            break;
+    } //switch
+}
+
+//------------------------------------------------------------
+ULONG mm_read (ULONG addr, BYTE jmode)
+{
+    *(ULONG *) (mmiobase + 0xF004) = (ULONG) ((addr) & 0xFFFF0000);
+    *(ULONG *) (mmiobase + 0xF000) = (ULONG) 0x00000001;
+    switch (jmode)
+    {
+    case 0:
+        return ( *(BYTE *) (mmiobase + 0x10000 + ((addr) & 0x0000FFFF)) );
+        break;
+    case 1:
+        return ( *(USHORT *) (mmiobase + 0x10000 + ((addr) & 0x0000FFFF)) );
+        break;
+    default:
+    case 2:
+        return ( *(ULONG *) (mmiobase + 0x10000 + ((addr) & 0x0000FFFF)) );
+        break;
+    } //switch
+
+    return 0;
+}
+#endif // End ifdef USE_P2A
+
+//------------------------------------------------------------
+// General Access API
+//------------------------------------------------------------
+#ifdef SLT_UBOOT
+BYTE Check_BEorLN ( ULONG chkaddr )
+{
+    BYTE ret = BIG_ENDIAN_ADDRESS;
+    BYTE i   = 0;
+    
+    do {
+        if ( LittleEndianArea[i].StartAddr == LittleEndianArea[i].EndAddr )
+            break;
+        
+        if ( ( LittleEndianArea[i].StartAddr <= chkaddr ) &&
+             ( LittleEndianArea[i].EndAddr   >= chkaddr )    ) {
+            ret = LITTLE_ENDIAN_ADDRESS;
+            break;
+        }
+        i++;
+    } while ( 1 );
+    
+    return ret;
+}
+#endif
+
+void WriteSOC_DD(ULONG addr, ULONG data)
+{
+#ifdef SLT_UBOOT
+    if ( Check_BEorLN( addr ) == BIG_ENDIAN_ADDRESS )
+        *(volatile unsigned long *)(addr) = cpu_to_le32(data);
+    else
+        *(volatile unsigned long *)(addr) = data;
+#else
+    #ifdef USE_LPC
+        lpc_write(addr, data, 2);
+    #endif
+    #ifdef USE_P2A
+        mm_write(addr, data, 2);
+    #endif
+#endif
+}
+
+//------------------------------------------------------------
+ULONG ReadSOC_DD(ULONG addr)
+{
+#ifdef SLT_UBOOT
+    if ( Check_BEorLN( addr ) == BIG_ENDIAN_ADDRESS )
+        return le32_to_cpu(*(volatile unsigned long *) (addr));
+    else
+        return (*(volatile unsigned long *) (addr));
+#else
+    #ifdef USE_LPC
+        return (lpc_read(addr, 2));
+    #endif
+    #ifdef USE_P2A
+        return (mm_read(addr, 2));
+    #endif
+#endif
+    return 0;
+}
+
diff --git a/arch/arm/cpu/arm926ejs/aspeed/LAN9303.c b/arch/arm/cpu/arm926ejs/aspeed/LAN9303.c
new file mode 100644
index 0000000..498d4fd
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/aspeed/LAN9303.c
@@ -0,0 +1,525 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#define LAN9303_C
+static const char ThisFile[] = "LAN9303.c";
+
+#include "SWFUNC.H"
+#ifdef SLT_UBOOT
+  #include <COMMINF.H>
+  #include <MAC.H>
+  #include <IO.H>
+#endif
+
+#ifdef SLT_DOS
+  #include "COMMINF.H"
+  #include <stdlib.h>
+  #include "IO.H"
+#endif
+
+#ifdef SUPPORT_PHY_LAN9303
+//#define LAN9303M
+#define I2C_Debug           0
+#define Print_DWRW          0
+#define Print_PHYRW         0
+#define I2C_TIMEOUT         10000000
+
+ULONG   devbase;
+ULONG   busnum;
+ULONG   byte;
+ULONG   data_rd;
+
+//------------------------------------------------------------
+// Basic
+//------------------------------------------------------------
+void actime(ULONG ac1, ULONG ac2, ULONG *fact, ULONG *ckh, ULONG *ckl)
+{
+        static int      divcnt;
+
+        ac1 = ac1 * 50 + 1;
+        ac2 = ac2 * 50 + 1;
+
+        divcnt = 0;
+        while (ac1 > 8 || ac2 > 8) {
+                divcnt++;
+                ac1 >>= 1;
+                ac2 >>= 1;
+        }
+
+        if (ac1 < 2  ) ac1  = 2;
+        if (ac2 < 2  ) ac2  = 2;
+        if (ac1 > ac2) ac2  = 1;
+        else           ac1 += 1;
+
+#ifdef PRINT_MSG
+        printf("Divcnt = %d, ckdiv = %d, ckh = %d, ckl = %d\n",(1<<divcnt)*(ac1+ac2),divcnt,ac1-1,ac2-1);
+        printf("CKH = %d us, CKL = %d us\n",(1<<divcnt)*ac1/50,(1<<divcnt)*ac2/50);
+#endif
+
+        *fact = divcnt;
+        *ckh  = ac1 - 1;
+        *ckl  = ac2 - 1;
+}
+
+//------------------------------------------------------------
+ULONG PollStatus()
+{
+        static ULONG    status;
+        static ULONG    cnt = 0;
+
+        do {
+                status = ReadSOC_DD( devbase + 0x14 ) & 0xff;
+
+                if ( ++cnt > I2C_TIMEOUT ) {
+                        printf("\nWait1 Timeout at bus %d!\n", busnum);
+                        printf("Status 14 = %08x\n", ReadSOC_DD(devbase + 0x14));
+                        exit(0);
+                }
+        } while (status != 0);
+        
+        cnt = 0;
+        do {
+                status = ReadSOC_DD( devbase + 0x10 );
+                if ( ++cnt > I2C_TIMEOUT ) {
+                        printf("\nWait2 Timeout at bus %d!\n", busnum);
+                        printf("Status 14 = %08x\n", ReadSOC_DD(devbase + 0x14));
+                        exit(0);
+                }
+        } while (status == 0);
+
+        WriteSOC_DD( devbase + 0x10, status );
+
+        return(status);
+}
+
+
+//------------------------------------------------------------
+ULONG writeb(ULONG start, ULONG data, ULONG stop)
+{
+        WriteSOC_DD( devbase + 0x20, data);
+        WriteSOC_DD( devbase + 0x14, 0x02 | start | (stop << 5) );
+        return(PollStatus());
+}
+
+//------------------------------------------------------------
+ULONG readb(ULONG last, ULONG stop)
+{
+        static ULONG    data;
+
+        WriteSOC_DD( devbase + 0x14, 0x08 | (last << 4) | (stop << 5) );
+        data = PollStatus();
+        
+        if (data & 0x4) {
+                data = ReadSOC_DD( devbase + 0x20 );
+                return(data >> 8);
+        } 
+        else {
+                return(-1);
+        }
+}
+                                                              
+//------------------------------------------------------------
+void Initial(ULONG base, ULONG ckh, ULONG ckl)
+{
+        static ULONG    ackh;
+        static ULONG    ackl;
+        static ULONG    divx;
+
+        actime(ckh, ckl, &divx, &ackh, &ackl);
+        WriteSOC_DD(base + 0x00, 0x1);
+        if (ReadSOC_DD(base + 0x00) != 0x1) {
+                printf("Controller initial fail : %x\n",base);
+                exit(0);
+        }
+        WriteSOC_DD(base + 0x04, 0x77700360 | (ackh << 16) | (ackl << 12) | divx);
+        WriteSOC_DD(base + 0x08, 0x0);
+        WriteSOC_DD(base + 0x0c, 0x0);
+        WriteSOC_DD(base + 0x10, 0xffffffff);
+        WriteSOC_DD(base + 0x14, 0x00);
+        WriteSOC_DD(base + 0x1C, 0xff0000);
+        WriteSOC_DD(base + 0x20, 0x00);
+}
+
+//------------------------------------------------------------
+void print_status(ULONG status)
+{
+        if ( status & 0x02 ) printf( "Device NAK\n"       );
+        if ( status & 0x08 ) printf( "Arbitration Loss\n" );
+        if ( status & 0x10 ) printf( "STOP\n"             );
+        if ( status & 0x20 ) printf( "Abnormal STOP\n"    );
+        if ( status & 0x40 ) printf( "SCL Low timeout\n"  );
+}
+
+//------------------------------------------------------------
+void readme()
+{
+        printf("\nVersion:%s\n", version_name);
+#ifdef LAN9303M
+        printf("LAN9303M [bus] [vir_PHY_adr] [speed] [func]\n");
+#else
+        printf("LAN9303 [bus] [vir_PHY_adr] [speed] [func]\n" );
+#endif
+        printf("[bus]         | 1~14: I2C bus number\n"       );
+        printf("[vir_PHY_adr] | 0~1: virtual PHY address\n"   );
+        printf("[speed]       | 1: 100M\n"                    );
+        printf("              | 2: 10 M\n"                    );
+        printf("[func]        | 0: external loopback\n"       );
+        printf("              | 1: internal loopback\n"       );
+}
+
+//------------------------------------------------------------
+void quit()
+{
+        WriteSOC_DD( devbase + 0x14, 0x20 );
+        PollStatus();
+        readme();
+}
+
+//------------------------------------------------------------
+// Double-Word Read/Write
+//------------------------------------------------------------
+ULONG I2C_DWRead(ULONG adr)
+{
+        static ULONG    status;
+        int             i;
+
+        Initial(devbase, 10, 10);
+        
+        if ( Print_DWRW ) 
+            printf("RAdr %02x: ", adr);
+
+        status = writeb( 1, LAN9303_I2C_ADR, 0 );
+        if ( I2C_Debug ) 
+            printf("R1W[%02x]%02x ", status, LAN9303_I2C_ADR);
+            
+        if ( status != 0x1 ) {
+                print_status(status);
+                quit();
+                exit(0);
+        }
+        
+        status = writeb(0, adr, 0);
+        if ( I2C_Debug ) 
+            printf("R2W[%02x]%02x ", status, adr);
+        if ( !(status & 0x1) ) {
+                print_status(status);
+                quit();
+                exit(0);
+        }
+
+        status = writeb(1, LAN9303_I2C_ADR | 0x1, 0);
+        if ( I2C_Debug ) 
+            printf("R3W[%02x]%02x ", status, LAN9303_I2C_ADR | 0x1);
+        if ( status != 0x1 ) {
+                print_status(status);
+                quit();
+                exit(0);
+        }
+
+        if ( I2C_Debug ) 
+            printf("R4");
+            
+        data_rd = 0;
+        for (i = 24; i >= 0; i-=8) {
+                if (i == 0) byte = readb(1, 1);
+                else        byte = readb(0, 0);
+                    
+                if ( I2C_Debug ) 
+                    printf("%02x ", byte);
+                data_rd = data_rd | (byte << i);
+        }
+
+        if ( Print_DWRW ) 
+            printf("%08x\n", data_rd);
+
+        return (data_rd);
+} // End ULONG I2C_DWRead(ULONG adr)
+
+//------------------------------------------------------------
+void I2C_DWWrite(ULONG adr, ULONG dwdata)
+{
+        static ULONG    status;
+        int             i;
+        ULONG           endx;
+
+        Initial(devbase, 10, 10);
+        if (Print_DWRW) 
+            printf("WAdr %02x: ", adr);
+
+        status = writeb(1, LAN9303_I2C_ADR, 0);
+        if ( I2C_Debug ) 
+            printf("W1[%02x]%02x ", status, LAN9303_I2C_ADR);
+        if ( status != 0x1 ) {
+                print_status(status);
+                quit();
+                exit(0);
+        }
+        status = writeb(0, adr, 0);
+        if ( I2C_Debug ) 
+            printf("W2[%02x]%02x ", status, adr);
+        if ( !(status & 0x1) ) {
+                print_status(status);
+                quit();
+                exit(0);
+        }
+
+        if (I2C_Debug) 
+            printf("W3");
+        endx = 0;
+        for (i = 24; i >= 0; i-=8) {
+                if (i == 0) 
+                    endx = 1;
+                byte   = (dwdata >> i) & 0xff;
+                status = writeb(0, byte, endx);
+                
+            if (I2C_Debug) 
+                printf("[%02x]%02x ", status, byte);
+                if (!(status & 0x1)) {
+                        print_status(status);
+                        quit();
+                        exit(0);
+                }
+        }
+
+        if (Print_DWRW) printf("%08x\n", dwdata);
+} // End void I2C_DWWrite(ULONG adr, ULONG dwdata)
+
+//------------------------------------------------------------
+// PHY Read/Write
+//------------------------------------------------------------
+ULONG LAN9303_PHY_Read(ULONG phy_adr, ULONG reg_adr)
+{
+        static ULONG    data_rd;
+
+        I2C_DWWrite(0x2a, ((phy_adr & 0x1f) << 11) | ((reg_adr & 0x1f) << 6));//[0A8h]PMI_ACCESS
+        do {
+            data_rd = I2C_DWRead (0x2a);
+        } while(data_rd & 0x00000001);//[0A8h]PMI_ACCESS
+
+        data_rd = I2C_DWRead (0x29);//[0A4h]PMI_DATA
+        if (Print_PHYRW) 
+            printf("PHY:%2d, Reg:%2d, Data:%08x\n", phy_adr, reg_adr, data_rd);
+            
+        return(data_rd);
+}
+
+//------------------------------------------------------------
+void LAN9303_PHY_Write(ULONG phy_adr, ULONG reg_adr, ULONG data_wr)
+{
+        static ULONG    data_rd;
+
+        I2C_DWWrite(0x29, data_wr);//[0A4h]PMI_DATA
+
+        I2C_DWWrite(0x2a, ((phy_adr & 0x1f) << 11) | ((reg_adr & 0x1f) << 6) | 0x2);//[0A8h]PMI_ACCESS
+        do {
+            data_rd = I2C_DWRead (0x2a);
+        } while(data_rd & 0x00000001);//[0A8h]PMI_ACCESS
+}
+
+//------------------------------------------------------------
+ULONG LAN9303_PHY_Read_WD(ULONG data_ctl)
+{
+        static ULONG    data_rd;
+
+        I2C_DWWrite(0x2a, data_ctl);//[0A8h]PMI_ACCESS
+        do {
+            data_rd = I2C_DWRead (0x2a);
+        } while(data_rd & 0x00000001);//[0A8h]PMI_ACCESS
+
+        data_rd = I2C_DWRead (0x29);//[0A4h]PMI_DATA
+        if (Print_PHYRW) 
+            printf("WD Data:%08x\n", data_ctl);
+            
+        return(data_rd);
+}
+
+//------------------------------------------------------------
+void LAN9303_PHY_Write_WD(ULONG data_ctl, ULONG data_wr)
+{
+        static ULONG    data_rd;
+
+        I2C_DWWrite( 0x29, data_wr  ); //[0A4h]PMI_DATA
+        I2C_DWWrite( 0x2a, data_ctl ); //[0A8h]PMI_ACCESS
+        do {
+            data_rd = I2C_DWRead (0x2a);
+        } while(data_rd & 0x00000001); //[0A8h]PMI_ACCESS
+}
+
+//------------------------------------------------------------
+// Virtual PHY Read/Write
+//------------------------------------------------------------
+ULONG LAN9303_VirPHY_Read(ULONG reg_adr)
+{
+        static ULONG    data_rd;
+
+        data_rd = I2C_DWRead (0x70+reg_adr);//[1C0h]
+        if ( Print_PHYRW ) 
+            printf("VirPHY Reg:%2d, Data:%08x\n", reg_adr, data_rd);
+            
+        return(data_rd);
+}
+
+//------------------------------------------------------------
+void LAN9303_VirPHY_Write(ULONG reg_adr, ULONG data_wr)
+{
+        I2C_DWWrite(0x70+reg_adr, data_wr);//[1C0h]
+}
+
+//------------------------------------------------------------
+void LAN9303_VirPHY_RW(ULONG reg_adr, ULONG data_clr, ULONG data_set)
+{
+        I2C_DWWrite(0x70+reg_adr, (LAN9303_VirPHY_Read(reg_adr) & (~data_clr)) | data_set);//[1C0h]
+}
+
+//------------------------------------------------------------
+// PHY Read/Write
+//------------------------------------------------------------
+ULONG LAN9303_Read(ULONG adr)
+{
+        static ULONG    data_rd;
+
+        I2C_DWWrite(0x6c, 0xc00f0000 | adr & 0xffff);//[1B0h]SWITCH_CSR_CMD
+        do {
+            data_rd = I2C_DWRead (0x6c);
+        } while(data_rd & 0x80000000);//[1B0h]SWITCH_CSR_CMD
+
+        return(I2C_DWRead (0x6b));//[1ACh]SWITCH_CSR_DATA
+}
+
+//------------------------------------------------------------
+void LAN9303_Write(ULONG adr, ULONG data)
+{
+        static ULONG    data_rd;
+
+        I2C_DWWrite(0x6b, data);//[1ACh]SWITCH_CSR_DATA
+        I2C_DWWrite(0x6c, 0x800f0000 | adr & 0xffff);//[1B0h]SWITCH_CSR_CMD
+
+        do {
+            data_rd = I2C_DWRead (0x6c);
+        } while(data_rd & 0x80000000);//[1B0h]SWITCH_CSR_CMD
+}
+
+//------------------------------------------------------------
+void LAN9303(int num, int phy_adr, int speed, int int_loopback)
+{
+        static ULONG    data_rd;
+
+    //------------------------------------------------------------
+    // I2C Initial
+    //------------------------------------------------------------
+        busnum = num;
+        if (busnum <= 7) devbase = 0x1E78A000 + ( busnum    * 0x40);
+        else             devbase = 0x1E78A300 + ((busnum-8) * 0x40);
+        Initial(devbase, 10, 10);
+
+    //------------------------------------------------------------
+    // LAN9303 Register Setting
+    //------------------------------------------------------------
+    printf("----> Start\n");
+        if (int_loopback == 0) { 
+            //Force Speed & external loopback
+                if (speed == 1) { //100M
+                        LAN9303_VirPHY_RW(  0, 0xffff, 0x2300 );      //adr clr set //VPHY_BASIC_CTRL
+                        LAN9303_VirPHY_RW( 11, 0xffff, 0x2300 );      //adr clr set //P1_MII_BASIC_CONTROL
+                        LAN9303_PHY_Write( phy_adr + 1, 0, 0x2300 );
+                        LAN9303_PHY_Write( phy_adr + 2, 0, 0x2300 );
+                } 
+                else {
+                        LAN9303_VirPHY_RW(  0, 0xffff, 0x0100 );      //adr clr set //VPHY_BASIC_CTRL
+                        LAN9303_VirPHY_RW( 11, 0xffff, 0x0100 );      //adr clr set //P1_MII_BASIC_CONTROL
+                        LAN9303_PHY_Write( phy_adr + 1, 0, 0x0100);
+                        LAN9303_PHY_Write( phy_adr + 2, 0, 0x0100);
+                }
+
+                LAN9303_Write( 0x180c, 0x00000001 ); // SWE_VLAN_WR_DATA
+                LAN9303_Write( 0x180b, 0x00000010 ); // SWE_VLAN_CMD
+                do {data_rd = LAN9303_Read (0x1810);} while(data_rd & 0x1);
+
+                LAN9303_Write( 0x180c, 0x00000002 ); // SWE_VLAN_WR_DATA
+                LAN9303_Write( 0x180b, 0x00000011 ); // SWE_VLAN_CMD
+                do {data_rd = LAN9303_Read (0x1810);} while(data_rd & 0x1);
+
+                LAN9303_Write( 0x180c, 0x00000003 ); // SWE_VLAN_WR_DATA
+                LAN9303_Write( 0x180b, 0x00000012 ); // SWE_VLAN_CMD
+                do {data_rd = LAN9303_Read (0x1810);} while(data_rd & 0x1);
+
+#ifdef LAN9303M
+                LAN9303_Write( 0x180c, 0x00022001 ); // SWE_VLAN_WR_DATA
+                LAN9303_Write( 0x180b, 0x00000000 ); // SWE_VLAN_CMD
+                do {data_rd = LAN9303_Read (0x1810);} while(data_rd & 0x1);
+
+                LAN9303_Write( 0x180c, 0x00024002 ); // SWE_VLAN_WR_DATA
+                LAN9303_Write( 0x180b, 0x00000001 ); // SWE_VLAN_CMD
+                do {data_rd = LAN9303_Read (0x1810);} while(data_rd & 0x1);
+
+                LAN9303_Write( 0x180c, 0x0002a003 ); // SWE_VLAN_WR_DATA
+                LAN9303_Write( 0x180b, 0x00000002 ); // SWE_VLAN_CMD
+                do {data_rd = LAN9303_Read (0x1810);} while(data_rd & 0x1);
+#else
+                LAN9303_Write( 0x180c, 0x0002a001 ); // SWE_VLAN_WR_DATA
+                LAN9303_Write( 0x180b, 0x00000000 ); // SWE_VLAN_CMD
+                do {data_rd = LAN9303_Read (0x1810);} while(data_rd & 0x1);
+
+                LAN9303_Write( 0x180c, 0x0000a002 ); // SWE_VLAN_WR_DATA
+                LAN9303_Write( 0x180b, 0x00000001 ); // SWE_VLAN_CMD
+                do {data_rd = LAN9303_Read (0x1810);} while(data_rd & 0x1);
+
+                LAN9303_Write( 0x180c, 0x00022003 ); // SWE_VLAN_WR_DATA
+                LAN9303_Write( 0x180b, 0x00000002 ); // SWE_VLAN_CMD
+                do {data_rd = LAN9303_Read (0x1810);} while(data_rd & 0x1);
+#endif
+                LAN9303_Write( 0x1840, 0x00000007);
+        } 
+        else if ( int_loopback == 1 ) { 
+            //Force Speed & internal loopback
+                if ( speed == 1 ) { 
+                    //100M
+                        LAN9303_VirPHY_RW(  0, 0xffff, 0x6300 ); // adr clr set //VPHY_BASIC_CTRL
+                        LAN9303_VirPHY_RW( 11, 0xffff, 0x6300 ); // adr clr set //P1_MII_BASIC_CONTROL
+                        LAN9303_PHY_Write( phy_adr + 1, 0, 0x6300 );
+                        LAN9303_PHY_Write( phy_adr + 2, 0, 0x6300 );
+                } 
+                else {
+                        LAN9303_VirPHY_RW(  0, 0xffff, 0x4100 ); // adr clr set //VPHY_BASIC_CTRL
+                        LAN9303_VirPHY_RW( 11, 0xffff, 0x4100 ); // adr clr set //P1_MII_BASIC_CONTROL
+                        LAN9303_PHY_Write( phy_adr + 1, 0, 0x4100 );
+                        LAN9303_PHY_Write( phy_adr + 2, 0, 0x4100 );
+                }
+        } 
+        else { 
+            //Force Speed
+                if (speed == 1) { 
+                    //100M
+                        LAN9303_VirPHY_RW(  0, 0xffff, 0x2300 ); // adr clr set //VPHY_BASIC_CTRL
+                        LAN9303_VirPHY_RW( 11, 0xffff, 0x2300 ); // adr clr set //P1_MII_BASIC_CONTROL
+                        LAN9303_PHY_Write( phy_adr + 1, 0, 0x2300 );
+                        LAN9303_PHY_Write( phy_adr + 2, 0, 0x2300 );
+                } 
+                else {
+                        LAN9303_VirPHY_RW(  0, 0xffff, 0x0100 ); // adr clr set //VPHY_BASIC_CTRL
+                        LAN9303_VirPHY_RW( 11, 0xffff, 0x0100 ); // adr clr set //P1_MII_BASIC_CONTROL
+                        LAN9303_PHY_Write( phy_adr + 1, 0, 0x0100 );
+                        LAN9303_PHY_Write( phy_adr + 2, 0, 0x0100 );
+                }
+#ifdef LAN9303M
+#else
+                if (int_loopback == 3) { 
+                    //[LAN9303]IEEE measurement
+                        data_rd = LAN9303_PHY_Read(phy_adr+1, 27);//PHY_SPECIAL_CONTROL_STAT_IND_x
+                        LAN9303_PHY_Write(phy_adr+1, 27, (data_rd & 0x9fff) | 0x8000);//PHY_SPECIAL_CONTROL_STAT_IND_x
+
+                        data_rd = LAN9303_PHY_Read(phy_adr+2, 27);//PHY_SPECIAL_CONTROL_STAT_IND_x
+                        LAN9303_PHY_Write(phy_adr+2, 27, (data_rd & 0x9fff) | 0x8000);//PHY_SPECIAL_CONTROL_STAT_IND_x
+                }
+#endif
+        } // End if (int_loopback == 0)
+} // End void LAN9303(int num, int phy_adr, int speed, int int_loopback)
+#endif // SUPPORT_PHY_LAN9303
+
diff --git a/arch/arm/cpu/arm926ejs/aspeed/LIB.H b/arch/arm/cpu/arm926ejs/aspeed/LIB.H
new file mode 100644
index 0000000..a7c61dd
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/aspeed/LIB.H
@@ -0,0 +1,37 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef LIB_H
+#define LIB_H
+
+#include "TYPEDEF.H"
+
+//
+// Macro
+//
+#define   INTFUNC              int386
+
+#define   OUTDWPORT         	outpd
+#define   INDWPORT          	inpd
+#define   OUTPUT            	outp
+#define   INPUT             	inp
+
+//
+// PCI
+//
+ULONG ReadPCIReg (ULONG ulPCIConfigAddress, BYTE jOffest, ULONG ulMask);
+ULONG FindPCIDevice (USHORT usVendorID, USHORT usDeviceID, USHORT usBusType);
+VOID  WritePCIReg (ULONG ulPCIConfigAddress, BYTE jOffest, ULONG ulMask, ULONG ulData);
+
+//
+// Map Resource
+//
+ULONG    MapPhysicalToLinear (ULONG ulBaseAddress, ULONG ulSize);
+#endif
diff --git a/arch/arm/cpu/arm926ejs/aspeed/LIB.c b/arch/arm/cpu/arm926ejs/aspeed/LIB.c
new file mode 100644
index 0000000..f2a0c54
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/aspeed/LIB.c
@@ -0,0 +1,184 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#define LIB_C
+static const char ThisFile[] = "LIB.c";
+
+#include "SWFUNC.H"
+
+#ifdef SLT_UBOOT
+  #include <common.h>
+  #include <command.h>
+#endif
+#ifdef SLT_DOS
+#include <stdlib.h>
+#include <stdio.h>
+#include <time.h>
+#include <conio.h>
+#include <dos.h>
+#include <mem.h>
+#endif
+
+#include "LIB.H"
+#include "TYPEDEF.H"
+
+#ifdef USE_P2A
+//------------------------------------------------------------
+// PCI
+//------------------------------------------------------------
+ULONG ReadPCIReg (ULONG ulPCIConfigAddress, BYTE jOffest, ULONG ulMask)
+{
+#ifndef Windows
+    OUTDWPORT(0xcf8, ulPCIConfigAddress + jOffest);
+
+    return (((ULONG)INDWPORT(0xcfc)) & ulMask);
+#else
+    WRITE_PORT_ULONG((PULONG)0xcf8, ulPCIConfigAddress + jOffest);
+    
+    return (READ_PORT_ULONG((PULONG)0xcfc) & ulMask);
+#endif
+}
+
+//------------------------------------------------------------
+VOID WritePCIReg (ULONG ulPCIConfigAddress, BYTE jOffest, ULONG ulMask, ULONG ulData)
+{
+#ifndef Windows
+    OUTDWPORT(0xcf8, ulPCIConfigAddress + jOffest);
+    OUTDWPORT(0xcfc, (INDWPORT(0xcfc) & ulMask | ulData));
+#else
+    WRITE_PORT_ULONG((PULONG)0xcf8, ulPCIConfigAddress + jOffest);
+    WRITE_PORT_ULONG((PULONG)0xcfc, (READ_PORT_ULONG((PULONG)0xcfc) & ulMask | ulData));
+#endif
+}
+
+//------------------------------------------------------------
+ULONG FindPCIDevice (USHORT usVendorID, USHORT usDeviceID, USHORT usBusType)
+{
+//Return: ulPCIConfigAddress
+//usBusType: ACTIVE/PCI/AGP/PCI-E
+
+    ULONG   Base[256];
+    ULONG   ebx;
+    USHORT  i;
+    USHORT  j;
+    
+    for (i = 0; i < 256; i++) {
+        Base[i] = 0x80000000 + 0x10000 * i;
+    }
+    
+    if (usBusType == PCI)
+    {
+      ebx = 0x80000000;
+    }
+    else if (usBusType == PCIE)
+    {
+      ebx = 0x80020000;
+    }
+    else     // AGP and ACTIVE
+    {
+      ebx = 0x80010000;
+    }
+    
+    if ( usBusType != ACTIVE )    //AGP, PCI, PCIE
+    {
+      for (i = 0; i < 32; i++)
+      {
+        ebx = ebx + (0x800);
+        if (((USHORT)ReadPCIReg(ebx, 0, 0xffff) == usVendorID) && ((USHORT)(ReadPCIReg(ebx, 0, 0xffff0000) >> 16) == usDeviceID))
+        {
+          return ebx;
+        }
+      }
+      return 0;
+    }
+    else     //ACTIVE
+    {
+      for (j = 0; j < 256; j++)
+      {
+        ebx = Base[j];
+        for (i = 0; i < 32; i++)
+        {
+          ebx = ebx + (0x800);
+          if (((USHORT)ReadPCIReg(ebx, 0, 0xffff) == usVendorID) && ((USHORT)(ReadPCIReg(ebx, 0, 0xffff0000) >> 16) == usDeviceID))
+          {
+            return ebx;
+          }
+        }
+      }
+      return 0;
+    }
+} // End ULONG FindPCIDevice (USHORT usVendorID, USHORT usDeviceID, USHORT usBusType)
+#endif
+//------------------------------------------------------------
+// Allocate Resource
+//------------------------------------------------------------
+#ifdef SLT_DOS
+ULONG InitDOS32()
+{
+  union REGS regs ;
+
+  regs.w.ax = 0xee00;
+  INTFUNC(0x31, &regs, &regs) ;
+
+  if(regs.w.ax >= 0x301)    // DOS32 version >= 3.01 ?
+    return 1;
+  else
+    return 0;
+}
+
+//------------------------------------------------------------
+USHORT CheckDOS()
+{
+    union REGS  regs;
+
+    regs.w.ax = 0xeeff;
+    int386(0x31, &regs, &regs);
+    if (regs.x.eax == 0x504d4457)
+    {
+        return 0;
+    } else {
+        printf("PMODEW Init. fail\n");
+        return 1;
+    }
+}
+
+//------------------------------------------------------------
+ULONG MapPhysicalToLinear (ULONG ulBaseAddress, ULONG ulSize)
+{
+  union REGS regs;
+
+  regs.w.ax = 0x0800;                        // map physcial memory
+  regs.w.bx = ulBaseAddress >> 16;           // bx:cx = physical address
+  regs.w.cx = ulBaseAddress;
+  regs.w.si = ulSize >> 16;                  // si:di = mapped memory block size
+  regs.w.di = ulSize;
+  INTFUNC(0x31, &regs, &regs);               // int386(0x31, &regs, &regs);
+  if (regs.w.cflag == 0)
+    return (ULONG) (regs.w.bx << 16 + regs.w.cx);  // Linear Addr = bx:cx
+  else
+    return 0;
+}
+
+//------------------------------------------------------------
+USHORT FreePhysicalMapping(ULONG udwLinAddress)
+{
+    union REGS regs;
+
+    regs.w.ax = 0x0801;
+    regs.w.bx = udwLinAddress >> 16;
+    regs.w.cx = udwLinAddress & 0xFFFF;
+    int386(0x31, &regs, &regs);
+
+    if (regs.x.cflag)
+        return ((USHORT) 0);
+    else return ((USHORT) 1);
+}
+#endif
+
diff --git a/arch/arm/cpu/arm926ejs/aspeed/LIB_SPI.H b/arch/arm/cpu/arm926ejs/aspeed/LIB_SPI.H
new file mode 100644
index 0000000..78c8f1e
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/aspeed/LIB_SPI.H
@@ -0,0 +1,23 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef LIB_SPI_H
+#define LIB_SPI_H
+
+#ifdef SPI_BUS
+    // MMIO Functions
+    VOID       MOutwm (ULONG, ULONG, USHORT);
+    VOID       MOutdwm (ULONG, ULONG, ULONG);
+    ULONG      MIndwm (ULONG, ULONG);
+    
+    void spim_init(int cs);
+#endif
+
+#endif // LIB_SPI_H
diff --git a/arch/arm/cpu/arm926ejs/aspeed/MAC.H b/arch/arm/cpu/arm926ejs/aspeed/MAC.H
new file mode 100644
index 0000000..6732117
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/aspeed/MAC.H
@@ -0,0 +1,157 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef MAC_H
+#define MAC_H
+
+#ifdef SPI_BUS
+  #include <stdio.h>
+  #include <stdlib.h>
+  #include <time.h>
+  #define SPI_CS            1
+#endif
+// ( USE_P2A | USE_LPC )
+
+#if defined(LinuxAP)
+  #include <stdio.h>
+  #include <stdlib.h>
+  #include <string.h>
+  #include <stdarg.h>
+  #include <unistd.h>
+  #include <string.h>
+  #include <fcntl.h>
+  #include <pthread.h>
+  #include <sys/mman.h>
+  #include <sys/io.h>
+#endif
+#ifdef SLT_UBOOT
+  #include <common.h>
+  #include <command.h>
+#endif
+#ifdef SLT_DOS
+  #include <stdio.h>
+  #include <stdlib.h>
+  #include <time.h>
+  #include <conio.h>
+  #include <dos.h>
+  #include <mem.h>
+#endif
+
+#include "NCSI.H"
+#include "IO.H"
+
+// --------------------------------------------------------------
+// Define                                                        
+// --------------------------------------------------------------
+
+//#define Force_Enable_MAC34             //[ON][SLT:off] (Force enable mac34)
+//#define Force_Enable_NewMDIO           //[off][SLT:off] (Force enable new MDC/MDIO)
+//#define Enable_Fast_SCU                //[off]
+//#define Enable_Old_Style               //[off]
+#define ENABLE_DASA                    //[ON]
+//#define Enable_AST2300_Int125MHz       //[off]
+//#define ENABLE_ARP_2_WOL               //[off]
+//#define Enable_MAC_SWRst               //[off]
+
+#define Enable_Runt
+//#define Enable_Jumbo
+//#define Enable_BufMerge
+//#define Disable_VGA
+
+//#define SelectSimpleBoundary                        //[off] Using in debug
+//#define SelectSimpleData                            //[off] Using in debug
+//#define SelectSimpleLength         1512             //[off] 60(0x3c) ~ 1514(0x5ea); 1512(0x5e8)
+//#define SelectDesNumber            8                //[off] 1 ~
+//#define SelectSimpleDA                              //[off] Using in debug
+//#define SelectSimpleDes                             //[off]
+//#define SelectLengthInc                             //[off] Using in debug
+
+#define   SimpleData_Fix                                                //[ON] Using in debug
+#define   SimpleData_FixNum          12
+#define   SimpleData_FixVal00        0x00000000     //[0]no SelectSimpleDA: (60: 0412 8908)(1512: e20d e9da)
+#define   SimpleData_FixVal01        0xffffffff     //[0]no SelectSimpleDA: (60: f48c f14d)(1512: af05 260c)
+#define   SimpleData_FixVal02        0x55555555     //[0]no SelectSimpleDA: (60: 5467 5ecb)(1512: d90a 5368)
+#define   SimpleData_FixVal03        0xaaaaaaaa     //[0]no SelectSimpleDA: (60: a4f9 268e)(1512: 9402 9cbe)
+#define   SimpleData_FixVal04        0x5a5a5a5a     //[1]no SelectSimpleDA: (60: 7f01 e22d)(1512: 4fd3 8012)
+#define   SimpleData_FixVal05        0xc3c3c3c3     //[1]no SelectSimpleDA: (60: 5916 02d5)(1512: 99f1 6127)
+#define   SimpleData_FixVal06        0x96969696     //[1]no SelectSimpleDA: (60: 0963 d516)(1512: a2f6 db95)
+#define   SimpleData_FixVal07        0xf0f0f0f0     //[1]no SelectSimpleDA: (60: dfea 4dab)(1512: 39dc f576)
+#define   SimpleData_FixVal08        0x5555aaaa     //[2]no SelectSimpleDA: (60: b61b 5777)(1512: 4652 ddb0)
+#define   SimpleData_FixVal09        0xffff0000     //[2]no SelectSimpleDA: (60: 16f0 f8f1)(1512: 305d a8d4)
+#define   SimpleData_FixVal10        0x5a5aa5a5     //[2]no SelectSimpleDA: (60: 9d7d eb91)(1512: d08b 0eca)
+#define   SimpleData_FixVal11        0xc3c33c3c     //[2]no SelectSimpleDA: (60: bb6a 0b69)(1512: 06a9 efff)
+
+#define   SelectSimpleDA_Dat0        0x67052301
+#define   SelectSimpleDA_Dat1        0xe0cda089
+#define   SelectSimpleDA_Dat2        0x98badcfe
+
+#define   SelectWOLDA_DatH           0x206a
+#define   SelectWOLDA_DatL           0x8a374d9b
+
+#define   MOVE_DATA_MB_SEC           800            // MByte per second to move data
+
+//---------------------------------------------------------
+// Frame size
+//---------------------------------------------------------
+#define  ENABLE_RAND_SIZE             0
+#define  Rand_Sed                     0xffccd
+#define  FRAME_Rand_Simple            0
+#define  MIN_FRAME_RAND_SIZE               60
+#define  MAX_FRAME_RAND_SIZE               1514
+
+#define FRAME_SELH_PERD               7
+#ifdef Enable_Jumbo
+//    #define FRAME_LENH                9212           //max:9212
+//    #define FRAME_LENL                9211           //max:9212
+    #define FRAME_LENH                9212           //max:9212
+    #define FRAME_LENL                9212           //max:9212
+//    #define FRAME_LENH                8120
+//    #define FRAME_LENL                8119
+//    #define FRAME_LENH                7000
+//    #define FRAME_LENL                6999
+//    #define FRAME_LENH                4095
+//    #define FRAME_LENL                4094
+//    #define FRAME_LENH                2040
+//    #define FRAME_LENL                2039
+#else
+  #ifdef SelectSimpleLength
+//    #define FRAME_LENH                  ( SelectSimpleLength + 1 )
+//    #define FRAME_LENL                  ( SelectSimpleLength     )
+    #define FRAME_LENH                  SelectSimpleLength
+    #define FRAME_LENL                  SelectSimpleLength
+  #else
+//    #define FRAME_LENH                  1514           //max:1514
+//    #define FRAME_LENL                  1513           //max:1514
+    #define FRAME_LENH                  1514           //max:1514
+    #define FRAME_LENL                  1514           //max:1514
+  #endif
+#endif
+
+const  ULONG   ARP_org_data[16] = {
+        0xffffffff,
+        0x0000ffff, // SA:00 00
+        0x12345678, // SA:12 34 56 78
+        0x01000608, // ARP(0x0806)
+        0x04060008,    
+        0x00000100, // sender MAC Address: 00 00
+        0x12345678, // sender MAC Address: 12 34 56 78
+        0xeb00a8c0, // sender IP Address:  192.168.0.235
+        0x00000000, // target MAC Address: 00 00 00 00
+        0xa8c00000, // target MAC Address: 00 00, sender IP Address:192.168
+        0x00000100, // sender IP Address:  0.1
+//      0x0000de00, // sender IP Address:  0.222
+        0x00000000,
+        0x00000000,
+        0x00000000,
+        0x00000000,
+        0xc68e2bd5
+};
+
+#endif // MAC_H
diff --git a/arch/arm/cpu/arm926ejs/aspeed/MAC.c b/arch/arm/cpu/arm926ejs/aspeed/MAC.c
new file mode 100644
index 0000000..829da92
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/aspeed/MAC.c
@@ -0,0 +1,2085 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#define MAC_C
+static const char ThisFile[] = "MAC.c";
+
+#include "SWFUNC.H"
+
+#ifdef SLT_UBOOT
+  #include <common.h>
+  #include <command.h>
+  #include <COMMINF.H>
+  #include "STDUBOOT.H"
+#endif
+#ifdef SLT_DOS
+  #include <stdio.h>
+  #include <stdlib.h>
+  #include <conio.h>
+  #include <string.h>
+  #include "COMMINF.H"
+#endif
+
+#include "MAC.H"
+
+double	Avg_frame_len;
+ULONG	Check_Des_Val;
+ULONG	wp_fir;
+ULONG	wp;
+ULONG	FRAME_LEN_Cur;
+ULONG	gdata;
+ULONG	CheckDesFail_DesNum;
+ULONG	VGAMode;
+ULONG	SCU_1ch_old;
+ULONG	SCU_0ch_old;
+ULONG	SCU_48h_default;
+ULONG	SCU_2ch_old;
+ULONG	SCU_80h_old;
+ULONG	SCU_74h_old;
+ULONG	SCU_a4h_old;
+ULONG	SCU_88h_old;
+ULONG	WDT_0ch_old;
+ULONG	SCU_04h_mix;
+ULONG	SCU_04h_old;
+ULONG	WDT_2ch_old;
+char	SCU_oldvld = 0;
+
+#ifdef SLT_UBOOT
+#else
+    static  double      timeused;
+#endif
+// -------------------------------------------------------------
+
+void Debug_delay (void) {
+    #ifdef DbgPrn_Enable_Debug_delay
+    GET_CAHR();
+    #endif
+}
+    
+
+
+
+void dump_mac_ROreg (void) {
+	DELAY(Delay_MACDump);
+	printf("\n");
+	printf("[MAC-H] ROReg A0h~ACh: %08lx %08lx %08lx %08lx\n", ReadSOC_DD(H_MAC_BASE+0xA0), ReadSOC_DD(H_MAC_BASE+0xA4), ReadSOC_DD(H_MAC_BASE+0xA8), ReadSOC_DD(H_MAC_BASE+0xAC));
+	printf("[MAC-H] ROReg B0h~BCh: %08lx %08lx %08lx %08lx\n", ReadSOC_DD(H_MAC_BASE+0xB0), ReadSOC_DD(H_MAC_BASE+0xB4), ReadSOC_DD(H_MAC_BASE+0xB8), ReadSOC_DD(H_MAC_BASE+0xBC));
+	printf("[MAC-H] ROReg C0h~C8h: %08lx %08lx %08lx      \n", ReadSOC_DD(H_MAC_BASE+0xC0), ReadSOC_DD(H_MAC_BASE+0xC4), ReadSOC_DD(H_MAC_BASE+0xC8));
+}
+
+//------------------------------------------------------------
+// SCU
+//------------------------------------------------------------
+void recov_scu (void) {
+    #ifdef  DbgPrn_FuncHeader
+	    printf ("recov_scu\n"); 
+	    Debug_delay();
+    #endif
+
+	//MAC
+	WriteSOC_DD( H_MAC_BASE + 0x08, MAC_08h_old );
+	WriteSOC_DD( H_MAC_BASE + 0x0c, MAC_0ch_old );
+	WriteSOC_DD( H_MAC_BASE + 0x40, MAC_40h_old );
+
+	//SCU
+	WriteSOC_DD( SCU_BASE + 0x04, SCU_04h_old );
+	WriteSOC_DD( SCU_BASE + 0x08, SCU_08h_old );
+	WriteSOC_DD( SCU_BASE + 0x0c, SCU_0ch_old );
+	WriteSOC_DD( SCU_BASE + 0x1c, SCU_1ch_old );
+	WriteSOC_DD( SCU_BASE + 0x2c, SCU_2ch_old );
+	WriteSOC_DD( SCU_BASE + 0x48, SCU_48h_old );
+//	WriteSOC_DD( SCU_BASE + 0x70, SCU_70h_old );
+	WriteSOC_DD( SCU_BASE + 0x74, SCU_74h_old );
+	WriteSOC_DD( SCU_BASE + 0x7c, SCU_7ch_old );
+	WriteSOC_DD( SCU_BASE + 0x80, SCU_80h_old );
+	WriteSOC_DD( SCU_BASE + 0x88, SCU_88h_old );
+	WriteSOC_DD( SCU_BASE + 0x90, SCU_90h_old );
+	WriteSOC_DD( SCU_BASE + 0xa4, SCU_a4h_old );
+	WriteSOC_DD( SCU_BASE + 0xac, SCU_ach_old );
+    #ifdef AST1010_IOMAP
+      WriteSOC_DD( SCU_BASE + 0x11C, SCU_11Ch_old );
+    #endif
+
+	//WDT
+    #ifdef AST1010_IOMAP
+    #else
+    //    WriteSOC_DD(0x1e78500c, WDT_0ch_old);
+    //    WriteSOC_DD(0x1e78502c, WDT_2ch_old);
+    #endif
+
+	if ( ASTChipType == 3 ) {
+		if ( SCU_f0h_old & 0x01 ) WriteSOC_DD( SCU_BASE + 0xf0, 0xAEED0001 ); //Enable MAC34
+		if ( SCU_f0h_old & 0x02 ) WriteSOC_DD( SCU_BASE + 0xf0, 0x2000DEEA ); //Enable Decode
+		if ( SCU_f0h_old & 0x04 ) WriteSOC_DD( SCU_BASE + 0xf0, 0xA0E0E0D3 ); //Enable I2S
+		if ( SCU_f0h_old & 0x08 ) WriteSOC_DD( SCU_BASE + 0xf0, 0x4D0E0E0A ); //Enable PCI Host
+		if ( SCU_f0h_old & 0x10 ) WriteSOC_DD( SCU_BASE + 0xf0, 0x10ADDEED ); //Enable IR
+		if ( SCU_f0h_old & 0x20 ) WriteSOC_DD( SCU_BASE + 0xf0, 0x66559959 ); //Enabel Buffer Merge
+		if ( SCU_f0h_old & 0x40 ) WriteSOC_DD( SCU_BASE + 0xf0, 0x68961A33 ); //Enable PS2 IO
+		if ( SCU_f0h_old & 0x80 ) WriteSOC_DD( SCU_BASE + 0xf0, 0x68971A33 ); //Enable PS2 IO
+	}
+} // End void recov_scu (void)
+
+void read_scu (void) {
+	#ifdef  DbgPrn_FuncHeader
+	    printf ("read_scu\n"); 
+	    Debug_delay();
+  #endif      
+
+	if (!SCU_oldvld) {
+		//SCU
+		SCU_04h_old = ReadSOC_DD( SCU_BASE + 0x04 );
+		SCU_08h_old = ReadSOC_DD( SCU_BASE + 0x08 );
+		SCU_0ch_old = ReadSOC_DD( SCU_BASE + 0x0c );
+		SCU_1ch_old = ReadSOC_DD( SCU_BASE + 0x1c );
+		SCU_2ch_old = ReadSOC_DD( SCU_BASE + 0x2c );
+		SCU_48h_old = ReadSOC_DD( SCU_BASE + 0x48 );
+		SCU_70h_old = ReadSOC_DD( SCU_BASE + 0x70 );
+		SCU_74h_old = ReadSOC_DD( SCU_BASE + 0x74 );
+		SCU_7ch_old = ReadSOC_DD( SCU_BASE + 0x7c );
+		SCU_80h_old = ReadSOC_DD( SCU_BASE + 0x80 );
+		SCU_88h_old = ReadSOC_DD( SCU_BASE + 0x88 );
+		SCU_90h_old = ReadSOC_DD( SCU_BASE + 0x90 );
+		SCU_a4h_old = ReadSOC_DD( SCU_BASE + 0xa4 );
+		SCU_ach_old = ReadSOC_DD( SCU_BASE + 0xac );
+		SCU_f0h_old = ReadSOC_DD( SCU_BASE + 0xf0 );
+        #ifdef AST1010_IOMAP
+          SCU_11Ch_old = ReadSOC_DD( SCU_BASE + 0x11C );
+		#endif
+
+		//WDT
+        #ifdef AST1010_IOMAP
+        #else
+		  WDT_0ch_old = ReadSOC_DD( 0x1e78500c );
+		  WDT_2ch_old = ReadSOC_DD( 0x1e78502c );
+        #endif
+
+		SCU_oldvld = 1;
+	} // End if (!SCU_oldvld) 
+} // End read_scu()
+
+void    Setting_scu (void)
+{
+    //SCU
+    if (AST1010) {
+        do {
+            WriteSOC_DD( SCU_BASE + 0x00 , 0x1688a8a8);
+            #ifndef SLT_UBOOT            
+            WriteSOC_DD( SCU_BASE + 0x70 , SCU_70h_old & 0xfffffffe);  // Disable CPU
+            #endif
+        } while ( ReadSOC_DD( SCU_BASE + 0x00 ) != 0x1 ); 
+
+        #if( AST1010_IOMAP == 1)
+  		WriteSOC_DD( SCU_BASE + 0x11C, 0x00000000); // Disable Cache functionn
+        #endif
+    } 
+    else {
+        do {
+            WriteSOC_DD( SCU_BASE + 0x00, 0x1688a8a8);
+            #ifndef SLT_UBOOT
+            WriteSOC_DD( SCU_BASE + 0x70, SCU_70h_old | 0x3 ); // Disable CPU
+            #endif
+        } while ( ReadSOC_DD( SCU_BASE + 0x00 ) != 0x1 );
+    } // End if (AST1010)
+
+    //WDT
+    #ifdef AST1010_IOMAP
+    #else
+        WriteSOC_DD( 0x1e78500c, WDT_0ch_old & 0xfffffffc );
+        WriteSOC_DD( 0x1e78502c, WDT_2ch_old & 0xfffffffc );
+    #endif      
+}
+
+//------------------------------------------------------------
+void init_scu1 (void) {
+	#ifdef  DbgPrn_FuncHeader
+	    printf ("init_scu1\n"); 
+	    Debug_delay();
+  #endif
+
+	if (AST3200) {
+		WriteSOC_DD( SCU_BASE + 0x0c, (SCU_0ch_old & 0xffefffff) );//Clock Stop Control
+	} 
+	else if (AST1010) {
+		WriteSOC_DD( SCU_BASE + 0x0c, ( SCU_0ch_old & 0xffffffbf ) );//Clock Stop Control
+		WriteSOC_DD( SCU_BASE + 0x88, ((SCU_88h_old & 0x003fffff ) | 0xffc00000) );//Multi-function Pin Control
+	} 
+	else if (AST2300) {
+#ifdef Enable_BufMerge
+		WriteSOC_DD( SCU_BASE + 0xf0, 0x66559959 );//MAC buffer merge
+#endif
+
+#ifdef Enable_AST2300_Int125MHz
+		SCU_48h_mix = (SCU_48h_old & 0xf0000000) | 0x80000000;
+//		WriteSOC_DD( SCU_BASE + 0xf0, 0xa0e0e0d3 );//Enable I2S
+//		WriteSOC_DD( SCU_BASE + 0x04, SCU_04h_old & 0xfffdffff );//Rst(Enable I2S)
+//
+////		WriteSOC_DD( 0x1e6e5020, ReadSOC_DD(0x1e6e5020) | 0x00010000 );//P_I2SPLLAdjEnable
+//		WriteSOC_DD( 0x1e6e5020, ReadSOC_DD(0x1e6e5020) | 0x00000000 );//P_I2SPLLAdjEnable
+//		WriteSOC_DD( 0x1e6e5024, 0x00000175 );//P_I2SPLLAdjCnt
+
+//		WriteSOC_DD( SCU_BASE + 0x1c, 0x0000a51a );//124800000(24MHz)
+//		WriteSOC_DD( SCU_BASE + 0x1c, 0x0000a92f );//125333333(24MHz)
+//		WriteSOC_DD( SCU_BASE + 0x1c, 0x0000587d );//125000000(24MHz)
+		WriteSOC_DD( SCU_BASE + 0x1c, 0x00006c7d );//125000000(24MHz)
+		WriteSOC_DD( SCU_BASE + 0x2c, 0x00300000 | (SCU_2ch_old & 0xffcfffef) );//D-PLL assigned to VGA, D2-PLL assigned to I2S.
+		WriteSOC_DD( SCU_BASE + 0x48, 0x80000000 | SCU_48h_old );//125MHz come from I2SPLL
+#else
+		SCU_48h_mix = (SCU_48h_old & 0xf0000000);
+#endif
+		switch (SelectMAC) {
+			case 0  :
+				WriteSOC_DD( SCU_BASE + 0x88, (SCU_88h_old & 0x3fffffff) | 0xc0000000 );//[31]MAC1 MDIO, [30]MAC1 MDC
+				break;
+			case 1  :
+				WriteSOC_DD( SCU_BASE + 0x90, (SCU_90h_old & 0xfffffffb) | 0x00000004 );//[2 ]MAC2 MDC/MDIO
+				break;
+			case 2  :
+			case 3  :
+			default : break;
+		}
+
+		WriteSOC_DD(SCU_BASE+0x0c, (SCU_0ch_old & 0xff0fffff)             );//Clock Stop Control
+//		WriteSOC_DD(SCU_BASE+0x80, (SCU_80h_old & 0xfffffff0) | 0x0000000f);//MAC1LINK/MAC2LINK
+	} 
+	else {
+		switch (SelectMAC) {
+			case 0  :
+//				WriteSOC_DD(SCU_BASE+0x74, (SCU_74h_old & 0xfdffffff) | 0x02000000);//[25]MAC1 PHYLINK
+				break;
+			case 1  :
+				if (MAC2_RMII) {
+//					WriteSOC_DD(SCU_BASE+0x74, (SCU_74h_old & 0xfbefffff) | 0x04100000);//[26]MAC2 PHYLINK, [21]MAC2 MII, [20]MAC2 MDC/MDIO
+					WriteSOC_DD(SCU_BASE+0x74, (SCU_74h_old & 0xffefffff) | 0x00100000);//[26]MAC2 PHYLINK, [21]MAC2 MII, [20]MAC2 MDC/MDIO
+				} else {
+//					WriteSOC_DD(SCU_BASE+0x74, (SCU_74h_old & 0xfbcfffff) | 0x04300000);//[26]MAC2 PHYLINK, [21]MAC2 MII, [20]MAC2 MDC/MDIO
+					WriteSOC_DD(SCU_BASE+0x74, (SCU_74h_old & 0xffcfffff) | 0x00300000);//[26]MAC2 PHYLINK, [21]MAC2 MII, [20]MAC2 MDC/MDIO
+				}
+				break;
+			default : break;
+		} // End switch (SelectMAC)
+	} // End if (AST3200)
+} // End void init_scu1 (void)
+
+//------------------------------------------------------------
+void init_scu_macrst (void) {
+    
+#ifdef Enable_AST2300_Int125MHz
+	if (ASTChipType == 3) {
+		SCU_04h_mix = SCU_04h_old & 0xfffdffff;
+	} else {
+		SCU_04h_mix = SCU_04h_old;
+	}
+#else
+	SCU_04h_mix = SCU_04h_old; 
+#endif
+
+	WriteSOC_DD ( SCU_BASE + 0x04, (SCU_04h_mix & ~SCU_04h) | SCU_04h);//Rst
+	DELAY(Delay_SCU);
+	WriteSOC_DD ( SCU_BASE + 0x04, (SCU_04h_mix & ~SCU_04h)          );//Enable Engine
+//	DELAY(Delay_SCU);
+} // End void init_scu_macrst (void)
+
+//------------------------------------------------------------
+void init_scu2 (void) {
+    
+#ifdef SCU_74h
+	#ifdef  DbgPrn_FuncHeader
+	    printf ("init_scu2\n"); 
+	    Debug_delay();
+  #endif
+
+	WriteSOC_DD( SCU_BASE + 0x74, SCU_74h_old | SCU_74h );//PinMux
+	delay(Delay_SCU);
+#endif
+
+} // End void init_scu2 (void)
+
+//------------------------------------------------------------
+void init_scu3 (void) {
+    
+#ifdef SCU_74h
+	#ifdef  DbgPrn_FuncHeader
+	    printf ("init_scu3\n"); 
+	    Debug_delay();
+  #endif
+
+	WriteSOC_DD( SCU_BASE + 0x74, SCU_74h_old | (SCU_74h & 0xffefffff) );//PinMux
+	delay(Delay_SCU);
+#endif
+
+} // End void init_scu3 (void)
+
+//------------------------------------------------------------
+// MAC
+//------------------------------------------------------------
+void init_mac (ULONG base, ULONG tdexbase, ULONG rdexbase) {
+	#ifdef  DbgPrn_FuncHeader
+	    printf ("init_mac\n"); 
+	    Debug_delay();
+  #endif
+
+#ifdef Enable_MAC_SWRst
+	WriteSOC_DD( base + 0x50, 0x80000000 | MAC_50h | MAC_50h_Speed);
+//	WriteSOC_DD( base + 0x50, 0x80000000);
+
+	while (0x80000000 & ReadSOC_DD(base+0x50)) {
+//printf(".");
+		DELAY(Delay_MACRst);
+	}
+	DELAY(Delay_MACRst);
+#endif
+
+	WriteSOC_DD( base + 0x20, (tdexbase + CPU_BUS_ADDR_SDRAM_OFFSET) ); // 20130730
+	WriteSOC_DD( base + 0x24, (rdexbase + CPU_BUS_ADDR_SDRAM_OFFSET) ); // 20130730
+	
+#ifdef MAC_30h          
+	WriteSOC_DD( base + 0x30, MAC_30h);//Int Thr/Cnt
+#endif
+                  
+#ifdef MAC_34h          
+	WriteSOC_DD( base + 0x34, MAC_34h);//Poll Cnt
+#endif
+
+#ifdef MAC_38h          
+	WriteSOC_DD( base + 0x38, MAC_38h);
+#endif
+
+#ifdef MAC_40h
+	if (Enable_MACLoopback) {
+		if (AST2300_NewMDIO) WriteSOC_DD( base + 0x40, MAC_40h | 0x80000000);
+		else                 WriteSOC_DD( base + 0x40, MAC_40h);
+	}
+#endif
+
+#ifdef MAC_48h
+	WriteSOC_DD( base + 0x48, MAC_48h);
+#endif
+
+	if ( ModeSwitch == MODE_NSCI )
+		WriteSOC_DD( base + 0x4c, NCSI_RxDMA_PakSize);   
+	else
+		WriteSOC_DD( base + 0x4c, DMA_PakSize);
+	
+	WriteSOC_DD( base + 0x50, MAC_50h | MAC_50h_Speed | 0xf);
+	DELAY(Delay_MACRst);
+} // End void init_mac (ULONG base, ULONG tdexbase, ULONG rdexbase)
+
+//------------------------------------------------------------
+// Basic
+//------------------------------------------------------------
+void FPri_RegValue (BYTE option) {
+    
+#ifdef SLT_UBOOT
+#else
+    time_t	timecur;
+#endif
+
+    FILE_VAR
+    
+    GET_OBJ( option )
+
+	PRINT(OUT_OBJ "[SCU] 04:%08lx 08:%08lx 0c:%08lx 48:%08lx\n", SCU_04h_old, SCU_08h_old, SCU_0ch_old, SCU_48h_old);
+	PRINT(OUT_OBJ "[SCU] 70:%08lx 74:%08lx 7c:%08lx\n",         SCU_70h_old, SCU_74h_old, SCU_7ch_old);
+	PRINT(OUT_OBJ "[SCU] 80:%08lx 88:%08lx 90:%08lx f0:%08lx\n", SCU_80h_old, SCU_88h_old, SCU_90h_old, SCU_f0h_old);
+	PRINT(OUT_OBJ "[SCU] a4:%08lx ac:%08lx\n", SCU_a4h_old, SCU_ach_old);
+	PRINT(OUT_OBJ "[WDT] 0c:%08lx 2c:%08lx\n", WDT_0ch_old, WDT_2ch_old);
+	PRINT(OUT_OBJ "[MAC] 08:%08lx 0c:%08lx\n", MAC_08h_old, MAC_0ch_old);
+            PRINT(OUT_OBJ "[MAC] A0|%08lx %08lx %08lx %08lx\n", ReadSOC_DD( MAC_PHYBASE + 0xa0), ReadSOC_DD( MAC_PHYBASE + 0xa4 ), ReadSOC_DD( MAC_PHYBASE + 0xa8 ), ReadSOC_DD(MAC_PHYBASE + 0xac ) );
+	PRINT(OUT_OBJ "[MAC] B0|%08lx %08lx %08lx %08lx\n", ReadSOC_DD( MAC_PHYBASE + 0xb0), ReadSOC_DD( MAC_PHYBASE + 0xb4 ), ReadSOC_DD( MAC_PHYBASE + 0xb8 ), ReadSOC_DD(MAC_PHYBASE + 0xbc ) );
+	PRINT(OUT_OBJ "[MAC] C0|%08lx %08lx %08lx\n",      ReadSOC_DD( MAC_PHYBASE + 0xc0), ReadSOC_DD( MAC_PHYBASE + 0xc4 ), ReadSOC_DD( MAC_PHYBASE + 0xc8 ));
+
+#ifdef SLT_UBOOT
+#else
+	fprintf(fp, "Time: %s", ctime(&timestart));
+	time(&timecur);
+	fprintf(fp, "----> %s", ctime(&timecur));
+#endif
+} // End void FPri_RegValue (BYTE *fp)
+
+//------------------------------------------------------------
+void FPri_End (BYTE option) {
+    
+    FILE_VAR
+    
+    GET_OBJ( option )
+    
+	if ( !RxDataEnable ) {
+	} 
+	else if ( Err_Flag ) {
+		PRINT(OUT_OBJ "                    \n----> fail !!!\n");
+	} else {
+		PRINT(OUT_OBJ "                    \n----> All Pass !!!\n");
+	}
+
+	if ( ModeSwitch == MODE_DEDICATED ) {
+		if (PHY_ADR_arg != PHY_ADR) 
+		    PRINT(OUT_OBJ "\n[Warning] PHY Address change from %d to %d !!!\n", PHY_ADR_arg, PHY_ADR);
+    }
+	
+	if ( AST1010 ) {
+		Dat_ULONG = (SCU_ach_old >> 12) & 0xf;
+		if (Dat_ULONG) {
+			PRINT(OUT_OBJ "\n[Warning] SCUAC[15:12] == 0x%02lx is not the suggestion value 0.\n", Dat_ULONG);
+			PRINT(OUT_OBJ "          This change at this platform must been proven again by the ASPEED.\n");
+		}
+
+		SCU_48h_default = SCU_48h_AST1010 & 0x01000f00;
+		if ((SCU_48h_old != SCU_48h_default)) {
+			PRINT(OUT_OBJ "\n[Warning] SCU48 == 0x%08lx is not the suggestion value 0x%08lx.\n", SCU_48h_old, SCU_48h_default);
+			PRINT(OUT_OBJ "          This change at this platform must been proven again by the ASPEED.\n");
+		}
+	} 
+	else if ( AST2300 ) {
+		if ( AST2400 ) {
+			Dat_ULONG = (SCU_90h_old >> 8) & 0xf;
+			if (Dat_ULONG) {
+				PRINT(OUT_OBJ "\n[Warning] SCU90[11: 8] == 0x%02lx is not the suggestion value 0.\n", Dat_ULONG);
+				PRINT(OUT_OBJ "          This change at this platform must been proven again by the ASPEED.\n");
+			}
+		} 
+		else {
+			Dat_ULONG = (SCU_90h_old >> 8) & 0xff;
+			if (Dat_ULONG) {
+				PRINT(OUT_OBJ "\n[Warning] SCU90[15: 8] == 0x%02lx is not the suggestion value 0.\n", Dat_ULONG);
+				PRINT(OUT_OBJ "          This change at this platform must been proven again by the ASPEED.\n");
+			}
+		}
+
+		if (Enable_MAC34) SCU_48h_default = SCU_48h_AST2300;
+		else              SCU_48h_default = SCU_48h_AST2300 & 0x0300ffff;
+		    
+		if ((SCU_48h_old != SCU_48h_default)) {
+			PRINT(OUT_OBJ "\n[Warning] SCU48 == 0x%08lx is not the suggestion value 0x%08lx.\n", SCU_48h_old, SCU_48h_default);
+			PRINT(OUT_OBJ "          This change at this platform must been proven again by the ASPEED.\n");
+		}
+	} // End if ( AST1010 )
+
+	if ( ModeSwitch == MODE_NSCI ) {
+		PRINT(OUT_OBJ "\n[Arg] %d %d %d %d %d %ld (%s)\n", GRun_Mode, PackageTolNum, ChannelTolNum, TestMode, IOTimingBund, (ARPNumCnt| (ULONG)PrintNCSIEn), ASTChipName);
+
+		switch (NCSI_Cap_SLT.PCI_DID_VID) {
+			case PCI_DID_VID_Intel_82574L		 : PRINT( OUT_OBJ "[NC]%08lx %08lx: Intel 82574L       \n", NCSI_Cap_SLT.ManufacturerID, NCSI_Cap_SLT.PCI_DID_VID ); break;
+			case PCI_DID_VID_Intel_82575_10d6	 : PRINT( OUT_OBJ "[NC]%08lx %08lx: Intel 82575        \n", NCSI_Cap_SLT.ManufacturerID, NCSI_Cap_SLT.PCI_DID_VID ); break;
+			case PCI_DID_VID_Intel_82575_10a7	 : PRINT( OUT_OBJ "[NC]%08lx %08lx: Intel 82575        \n", NCSI_Cap_SLT.ManufacturerID, NCSI_Cap_SLT.PCI_DID_VID ); break;
+			case PCI_DID_VID_Intel_82575_10a9	 : PRINT( OUT_OBJ "[NC]%08lx %08lx: Intel 82575        \n", NCSI_Cap_SLT.ManufacturerID, NCSI_Cap_SLT.PCI_DID_VID ); break;
+			case PCI_DID_VID_Intel_82576_10c9	 : PRINT( OUT_OBJ "[NC]%08lx %08lx: Intel 82576        \n", NCSI_Cap_SLT.ManufacturerID, NCSI_Cap_SLT.PCI_DID_VID ); break;
+			case PCI_DID_VID_Intel_82576_10e6	 : PRINT( OUT_OBJ "[NC]%08lx %08lx: Intel 82576        \n", NCSI_Cap_SLT.ManufacturerID, NCSI_Cap_SLT.PCI_DID_VID ); break;
+			case PCI_DID_VID_Intel_82576_10e7	 : PRINT( OUT_OBJ "[NC]%08lx %08lx: Intel 82576        \n", NCSI_Cap_SLT.ManufacturerID, NCSI_Cap_SLT.PCI_DID_VID ); break;
+			case PCI_DID_VID_Intel_82576_10e8	 : PRINT( OUT_OBJ "[NC]%08lx %08lx: Intel 82576        \n", NCSI_Cap_SLT.ManufacturerID, NCSI_Cap_SLT.PCI_DID_VID ); break;
+			case PCI_DID_VID_Intel_82576_1518	 : PRINT( OUT_OBJ "[NC]%08lx %08lx: Intel 82576        \n", NCSI_Cap_SLT.ManufacturerID, NCSI_Cap_SLT.PCI_DID_VID ); break;
+			case PCI_DID_VID_Intel_82576_1526	 : PRINT( OUT_OBJ "[NC]%08lx %08lx: Intel 82576        \n", NCSI_Cap_SLT.ManufacturerID, NCSI_Cap_SLT.PCI_DID_VID ); break;
+			case PCI_DID_VID_Intel_82576_150a	 : PRINT( OUT_OBJ "[NC]%08lx %08lx: Intel 82576        \n", NCSI_Cap_SLT.ManufacturerID, NCSI_Cap_SLT.PCI_DID_VID ); break;
+			case PCI_DID_VID_Intel_82576_150d	 : PRINT( OUT_OBJ "[NC]%08lx %08lx: Intel 82576        \n", NCSI_Cap_SLT.ManufacturerID, NCSI_Cap_SLT.PCI_DID_VID ); break;
+			case PCI_DID_VID_Intel_82599_10fb	 : PRINT( OUT_OBJ "[NC]%08lx %08lx: Intel 82599        \n", NCSI_Cap_SLT.ManufacturerID, NCSI_Cap_SLT.PCI_DID_VID ); break;
+			case PCI_DID_VID_Intel_82599_1557	 : PRINT( OUT_OBJ "[NC]%08lx %08lx: Intel 82599        \n", NCSI_Cap_SLT.ManufacturerID, NCSI_Cap_SLT.PCI_DID_VID ); break;
+			case PCI_DID_VID_Intel_I350_1521	 : PRINT( OUT_OBJ "[NC]%08lx %08lx: Intel I350         \n", NCSI_Cap_SLT.ManufacturerID, NCSI_Cap_SLT.PCI_DID_VID ); break;
+			case PCI_DID_VID_Intel_I350_1523	 : PRINT( OUT_OBJ "[NC]%08lx %08lx: Intel I350         \n", NCSI_Cap_SLT.ManufacturerID, NCSI_Cap_SLT.PCI_DID_VID ); break;
+			case PCI_DID_VID_Intel_I210     	 : PRINT( OUT_OBJ "[NC]%08lx %08lx: Intel I210         \n", NCSI_Cap_SLT.ManufacturerID, NCSI_Cap_SLT.PCI_DID_VID ); break;
+			case PCI_DID_VID_Intel_X540	         : PRINT( OUT_OBJ "[NC]%08lx %08lx: Intel X540         \n", NCSI_Cap_SLT.ManufacturerID, NCSI_Cap_SLT.PCI_DID_VID ); break;
+			case PCI_DID_VID_Broadcom_BCM5718	 : PRINT( OUT_OBJ "[NC]%08lx %08lx: Broadcom BCM5718   \n", NCSI_Cap_SLT.ManufacturerID, NCSI_Cap_SLT.PCI_DID_VID ); break;
+			case PCI_DID_VID_Broadcom_BCM5720	 : PRINT( OUT_OBJ "[NC]%08lx %08lx: Broadcom BCM5720   \n", NCSI_Cap_SLT.ManufacturerID, NCSI_Cap_SLT.PCI_DID_VID ); break;
+			case PCI_DID_VID_Broadcom_BCM5725	 : PRINT( OUT_OBJ "[NC]%08lx %08lx: Broadcom BCM5725   \n", NCSI_Cap_SLT.ManufacturerID, NCSI_Cap_SLT.PCI_DID_VID ); break;
+//			case PCI_DID_VID_Broadcom_BCM57810	 : PRINT( OUT_OBJ "[NC]%08x %08x: Broadcom BCM57810  \n", NCSI_Cap_SLT.ManufacturerID, NCSI_Cap_SLT.PCI_DID_VID ); break;
+			case PCI_DID_VID_Mellanox_ConnectX_3 : PRINT( OUT_OBJ "[NC]%08lx %08lx: Mellanox ConnectX-3\n", NCSI_Cap_SLT.ManufacturerID, NCSI_Cap_SLT.PCI_DID_VID ); break;
+			default					:
+				switch (NCSI_Cap_SLT.ManufacturerID) {
+					case ManufacturerID_Intel    : PRINT( OUT_OBJ "[NC]%08lx %08lx: Intel   \n", NCSI_Cap_SLT.ManufacturerID, NCSI_Cap_SLT.PCI_DID_VID ); break;
+					case ManufacturerID_Broadcom : PRINT( OUT_OBJ "[NC]%08lx %08lx: Broadcom\n", NCSI_Cap_SLT.ManufacturerID, NCSI_Cap_SLT.PCI_DID_VID ); break;
+					case ManufacturerID_Mellanox : PRINT( OUT_OBJ "[NC]%08lx %08lx: Mellanox\n", NCSI_Cap_SLT.ManufacturerID, NCSI_Cap_SLT.PCI_DID_VID ); break;
+					default				: PRINT(OUT_OBJ "[NC]%08lx %08lx          \n", NCSI_Cap_SLT.ManufacturerID, NCSI_Cap_SLT.PCI_DID_VID); break;
+				} // End switch (NCSI_Cap_SLT.ManufacturerID)
+		} // End switch (NCSI_Cap_SLT.PCI_DID_VID)
+	}
+	else {
+		if (LOOP_INFINI) PRINT(OUT_OBJ "\n[Arg] %d %d %d # %d %d %d %lx (%s)[%d %d %d]\n" , GRun_Mode, GSpeed, GCtrl,               TestMode, PHY_ADR_arg, IOTimingBund, UserDVal, ASTChipName, Loop_rl[0], Loop_rl[1], Loop_rl[2]);
+		else             PRINT(OUT_OBJ "\n[Arg] %d %d %d %ld %d %d %d %lx (%s)[%d %d %d]\n", GRun_Mode, GSpeed, GCtrl, LOOP_MAX_arg, TestMode, PHY_ADR_arg, IOTimingBund, UserDVal, ASTChipName, Loop_rl[0], Loop_rl[1], Loop_rl[2]);
+		    
+		PRINT(OUT_OBJ "[PHY] Adr:%d ID2:%04lx ID3:%04lx (%s)\n", PHY_ADR, PHY_ID2, PHY_ID3, PHYName);
+	} // End if ( ModeSwitch == MODE_NSCI ) 
+	
+#ifdef SUPPORT_PHY_LAN9303
+	PRINT(OUT_OBJ "[Ver II] %s (for LAN9303 with I2C%d)\n", version_name, LAN9303_I2C_BUSNUM);
+#else
+	PRINT(OUT_OBJ "[Ver II] %s\n", version_name);
+#endif
+} // End void FPri_End (BYTE option)
+
+//------------------------------------------------------------
+void FPri_ErrFlag (BYTE option) {
+    
+    FILE_VAR
+    
+    GET_OBJ( option )
+    
+	if (Err_Flag && Err_Flag_PrintEn) {
+		PRINT(OUT_OBJ "\n\n");
+//fprintf(fp, "Err_Flag: %x\n\n", Err_Flag);
+
+		if ( Err_Flag & Err_PHY_Type                ) PRINT( OUT_OBJ "[Err] Unidentifiable PHY                                     \n" );
+		if ( Err_Flag & Err_MALLOC_FrmSize          ) PRINT( OUT_OBJ "[Err] Malloc fail at frame size buffer                       \n" );
+		if ( Err_Flag & Err_MALLOC_LastWP           ) PRINT( OUT_OBJ "[Err] Malloc fail at last WP buffer                          \n" );
+		if ( Err_Flag & Err_Check_Buf_Data          ) PRINT( OUT_OBJ "[Err] Received data mismatch                                 \n" );
+		if ( Err_Flag & Err_NCSI_Check_TxOwnTimeOut ) PRINT( OUT_OBJ "[Err] Time out of checking Tx owner bit in NCSI packet       \n" );
+		if ( Err_Flag & Err_NCSI_Check_RxOwnTimeOut ) PRINT( OUT_OBJ "[Err] Time out of checking Rx owner bit in NCSI packet       \n" );
+		if ( Err_Flag & Err_NCSI_Check_ARPOwnTimeOut) PRINT( OUT_OBJ "[Err] Time out of checking ARP owner bit in NCSI packet      \n" );
+		if ( Err_Flag & Err_NCSI_No_PHY             ) PRINT( OUT_OBJ "[Err] Can not find NCSI PHY                                  \n" );
+		if ( Err_Flag & Err_NCSI_Channel_Num        ) PRINT( OUT_OBJ "[Err] NCSI Channel Number Mismatch                           \n" );
+		if ( Err_Flag & Err_NCSI_Package_Num        ) PRINT( OUT_OBJ "[Err] NCSI Package Number Mismatch                           \n" );
+		if ( Err_Flag & Err_PHY_TimeOut             ) PRINT( OUT_OBJ "[Err] Time out of read/write/reset PHY register              \n" );
+		if ( Err_Flag & Err_RXBUF_UNAVA             ) PRINT( OUT_OBJ "[Err] MAC00h[2]:Receiving buffer unavailable                 \n" );
+		if ( Err_Flag & Err_RPKT_LOST               ) PRINT( OUT_OBJ "[Err] MAC00h[3]:Received packet lost due to RX FIFO full     \n" );
+		if ( Err_Flag & Err_NPTXBUF_UNAVA           ) PRINT( OUT_OBJ "[Err] MAC00h[6]:Normal priority transmit buffer unavailable  \n" );
+		if ( Err_Flag & Err_TPKT_LOST               ) PRINT( OUT_OBJ "[Err] MAC00h[7]:Packets transmitted to Ethernet lost         \n" );
+		if ( Err_Flag & Err_DMABufNum               ) PRINT( OUT_OBJ "[Err] DMA Buffer is not enough                               \n" );
+		if ( Err_Flag & Err_IOMargin                ) PRINT( OUT_OBJ "[Err] IO timing margin is not enough                         \n" );
+		    
+		if ( Err_Flag & Err_MHCLK_Ratio             ) {
+			if ( AST1010 ) {
+				PRINT(OUT_OBJ "[Err] Error setting of MAC AHB bus clock (SCU08[13:12])      \n");
+				Dat_ULONG = (SCU_08h_old >> 12) & 0x3;
+				PRINT(OUT_OBJ "      SCU08[13:12] == 0x%01lx is not the suggestion value 0.\n", Dat_ULONG);
+			} 
+			else {
+				PRINT(OUT_OBJ "[Err] Error setting of MAC AHB bus clock (SCU08[18:16])      \n");
+				Dat_ULONG = (SCU_08h_old >> 16) & 0x7;
+				
+				if (MAC1_1GEn | MAC2_1GEn) {
+					PRINT(OUT_OBJ "      SCU08[18:16] == 0x%01lx is not the suggestion value 2.\n", Dat_ULONG);
+				} 
+				else {
+					PRINT(OUT_OBJ "      SCU08[18:16] == 0x%01lx is not the suggestion value 4.\n", Dat_ULONG);
+				}
+			} // end if ( AST1010 )
+		} // End if ( Err_Flag & Err_MHCLK_Ratio             )
+
+		if (Err_Flag & Err_IOMarginOUF             ) {
+			PRINT(OUT_OBJ "[Err] IO timing testing range out of boundary\n");
+			if (Enable_RMII) {
+#ifdef Enable_Old_Style
+				PRINT(OUT_OBJ "      (%d,%d): 1x%d [%d]x[%d:%d]\n",        IOdly_out_reg_idx, IOdly_in_reg_idx, IOTimingBund, IOdly_out_reg_idx, IOdly_in_reg_idx - (IOTimingBund>>1), IOdly_in_reg_idx + (IOTimingBund>>1));
+#else
+				PRINT(OUT_OBJ "      (%d,%d): %dx1 [%d:%d]x[%d]\n",        IOdly_in_reg_idx, IOdly_out_reg_idx, IOTimingBund, IOdly_in_reg_idx - (IOTimingBund>>1), IOdly_in_reg_idx + (IOTimingBund>>1), IOdly_out_reg_idx);
+#endif
+			} else {
+#ifdef Enable_Old_Style
+				PRINT(OUT_OBJ "      (%d,%d): %dx%d [%d:%d]x[%d:%d]\n", IOdly_out_reg_idx, IOdly_in_reg_idx, IOTimingBund, IOTimingBund, IOdly_out_reg_idx - (IOTimingBund>>1), IOdly_out_reg_idx + (IOTimingBund>>1), IOdly_in_reg_idx - (IOTimingBund>>1), IOdly_in_reg_idx + (IOTimingBund>>1));
+#else
+				PRINT(OUT_OBJ "      (%d,%d): %dx%d [%d:%d]x[%d:%d]\n", IOdly_in_reg_idx, IOdly_out_reg_idx, IOTimingBund, IOTimingBund, IOdly_in_reg_idx - (IOTimingBund>>1), IOdly_in_reg_idx + (IOTimingBund>>1), IOdly_out_reg_idx - (IOTimingBund>>1), IOdly_out_reg_idx + (IOTimingBund>>1));
+#endif
+			}
+		} // End if (Err_Flag & Err_IOMarginOUF             )
+		
+		if (Err_Flag & Err_Check_Des               ) {
+			PRINT(OUT_OBJ "[Err] Descriptor error\n");
+			if ( Check_Des_Val & Check_Des_TxOwnTimeOut ) PRINT( OUT_OBJ "[Des] Time out of checking Tx owner bit\n" );
+			if ( Check_Des_Val & Check_Des_RxOwnTimeOut ) PRINT( OUT_OBJ "[Des] Time out of checking Rx owner bit\n" );
+			if ( Check_Des_Val & Check_Des_RxErr        ) PRINT( OUT_OBJ "[Des] Input signal RxErr               \n" );
+			if ( Check_Des_Val & Check_Des_OddNibble    ) PRINT( OUT_OBJ "[Des] Nibble bit happen                \n" );
+			if ( Check_Des_Val & Check_Des_CRC          ) PRINT( OUT_OBJ "[Des] CRC error of frame               \n" );
+			if ( Check_Des_Val & Check_Des_RxFIFOFull   ) PRINT( OUT_OBJ "[Des] Rx FIFO full                     \n" );
+			if ( Check_Des_Val & Check_Des_FrameLen     ) PRINT( OUT_OBJ "[Des] Frame length mismatch            \n" );
+		} // End if (Err_Flag & Err_Check_Des               )
+		
+		if (Err_Flag & Err_MACMode                ) {
+			PRINT(OUT_OBJ "[Err] MAC interface mode mismatch\n");
+			if ( AST1010 ) {
+			} 
+			else if (AST2300) {
+				switch (MAC_Mode) {
+					case 0 : PRINT( OUT_OBJ "      SCU70h[7:6] == 0: [MAC#1] RMII   [MAC#2] RMII \n" ); break;
+					case 1 : PRINT( OUT_OBJ "      SCU70h[7:6] == 1: [MAC#1] RGMII  [MAC#2] RMII \n" ); break;
+					case 2 : PRINT( OUT_OBJ "      SCU70h[7:6] == 2: [MAC#1] RMII   [MAC#2] RGMII\n" ); break;
+					case 3 : PRINT( OUT_OBJ "      SCU70h[7:6] == 3: [MAC#1] RGMII  [MAC#2] RGMII\n" ); break;
+				}
+			} 
+			else {
+                switch (MAC_Mode) {
+                	case 0 : PRINT( OUT_OBJ "      SCU70h[8:6] == 000: [MAC#1] GMII               \n" ); break;
+                	case 1 : PRINT( OUT_OBJ "      SCU70h[8:6] == 001: [MAC#1] MII    [MAC#2] MII \n" ); break;
+                	case 2 : PRINT( OUT_OBJ "      SCU70h[8:6] == 010: [MAC#1] RMII   [MAC#2] MII \n" ); break;
+                	case 3 : PRINT( OUT_OBJ "      SCU70h[8:6] == 011: [MAC#1] MII                \n" ); break;
+                	case 4 : PRINT( OUT_OBJ "      SCU70h[8:6] == 100: [MAC#1] RMII               \n" ); break;
+                	case 5 : PRINT( OUT_OBJ "      SCU70h[8:6] == 101: Reserved                   \n" ); break;
+                	case 6 : PRINT( OUT_OBJ "      SCU70h[8:6] == 110: [MAC#1] RMII   [MAC#2] RMII\n" ); break;
+                	case 7 : PRINT( OUT_OBJ "      SCU70h[8:6] == 111: Disable MAC                \n" ); break;
+                }
+			} // End if ( AST1010 )
+		} // End if (Err_Flag & Err_MACMode                )
+
+		if ( ModeSwitch == MODE_NSCI ) {
+			if (Err_Flag & Err_NCSI_LinkFail           ) {
+				PRINT(OUT_OBJ "[Err] NCSI packet retry number over flows when find channel\n");
+				
+				if (NCSI_LinkFail_Val & NCSI_LinkFail_Get_Version_ID         ) PRINT(OUT_OBJ "[NCSI] Time out when Get Version ID         \n");
+				if (NCSI_LinkFail_Val & NCSI_LinkFail_Get_Capabilities       ) PRINT(OUT_OBJ "[NCSI] Time out when Get Capabilities       \n");
+				if (NCSI_LinkFail_Val & NCSI_LinkFail_Select_Active_Package  ) PRINT(OUT_OBJ "[NCSI] Time out when Select Active Package  \n");
+				if (NCSI_LinkFail_Val & NCSI_LinkFail_Enable_Set_MAC_Address ) PRINT(OUT_OBJ "[NCSI] Time out when Enable Set MAC Address \n");
+				if (NCSI_LinkFail_Val & NCSI_LinkFail_Enable_Broadcast_Filter) PRINT(OUT_OBJ "[NCSI] Time out when Enable Broadcast Filter\n");
+				if (NCSI_LinkFail_Val & NCSI_LinkFail_Enable_Network_TX      ) PRINT(OUT_OBJ "[NCSI] Time out when Enable Network TX      \n");
+				if (NCSI_LinkFail_Val & NCSI_LinkFail_Enable_Channel         ) PRINT(OUT_OBJ "[NCSI] Time out when Enable Channel         \n");
+				if (NCSI_LinkFail_Val & NCSI_LinkFail_Disable_Network_TX     ) PRINT(OUT_OBJ "[NCSI] Time out when Disable Network TX     \n");
+				if (NCSI_LinkFail_Val & NCSI_LinkFail_Disable_Channel        ) PRINT(OUT_OBJ "[NCSI] Time out when Disable Channel        \n");
+			}
+			
+			if (Err_Flag & Err_NCSI_Channel_Num       ) PRINT(OUT_OBJ "[NCSI] Channel number expected: %d, real: %d\n", ChannelTolNum, number_chl);
+			if (Err_Flag & Err_NCSI_Package_Num       ) PRINT(OUT_OBJ "[NCSI] Peckage number expected: %d, real: %d\n", PackageTolNum, number_pak);
+		} // End if ( ModeSwitch == MODE_NSCI )
+	} // End if (Err_Flag && Err_Flag_PrintEn)
+} // End void FPri_ErrFlag (BYTE option)
+
+//------------------------------------------------------------
+void Finish_Close (void) {
+
+	if (SCU_oldvld) 
+	    recov_scu();
+
+#ifdef SLT_DOS
+	if (fp_io && IOTiming) 
+	    fclose(fp_io);
+	    
+	if (fp_log) 
+	    fclose(fp_log);
+#endif    
+} // End void Finish_Close (void)
+
+//------------------------------------------------------------
+char Finish_Check (int value) {
+    ULONG temp;
+    CHAR  i = 0;
+    
+#ifdef Disable_VGA
+	if (VGAModeVld) {
+		outp(0x3d4, 0x17);
+		outp(0x3d5, VGAMode);
+	}
+#endif
+	#ifdef  DbgPrn_FuncHeader
+	    printf ("Finish_Check\n"); 
+	    Debug_delay();
+    #endif
+
+	if ( FRAME_LEN ) 
+	    free(FRAME_LEN);
+	    
+	if ( wp_lst   ) 
+	    free(wp_lst   );
+
+	Err_Flag = Err_Flag | value;
+	
+	if ( DbgPrn_ErrFlg ) 
+	    printf ("\nErr_Flag: [%08lx]\n", Err_Flag);
+
+	if ( !BurstEnable ) 
+	    FPri_ErrFlag( FP_LOG );
+	    
+	if ( IOTiming    ) 
+	    FPri_ErrFlag( FP_IO );
+	    
+	FPri_ErrFlag( STD_OUT );
+
+	if ( !BurstEnable ) 
+	    FPri_End( FP_LOG );
+	    
+	if ( IOTiming   ) 
+	    FPri_End( FP_IO );
+	    
+	FPri_End( STD_OUT );
+	
+
+	if ( !BurstEnable ) FPri_RegValue( FP_LOG );
+	if ( IOTiming     ) FPri_RegValue( FP_IO  );
+
+	Finish_Close();
+
+    // 20140325
+    temp = ReadSOC_DD( 0x1e6e2040 );
+    if ( ModeSwitch == MODE_NSCI ) 
+    {
+        if ( SelectMAC == 0 )
+            i = 17;
+        else
+            i = 16;
+    }
+    else
+    {
+        if ( SelectMAC == 0 )
+            i = 19;
+        else
+            i = 18;
+    }
+    WriteSOC_DD( 0x1e6e2040, (temp | (1 << i)) );
+    
+    
+	if ( Err_Flag ) 
+    {
+        // Fail
+	    return( 1 );
+    }
+	else
+    {
+        // Pass
+	    return( 0 );
+    }
+} // End char Finish_Check (int value)
+
+//------------------------------------------------------------
+int FindErr (int value) {
+	Err_Flag = Err_Flag | value;
+	
+	if ( DbgPrn_ErrFlg ) 
+	    printf ("\nErr_Flag: [%08lx]\n", Err_Flag);
+
+	return(1);
+}
+
+//------------------------------------------------------------
+int FindErr_Des (int value) {
+	Check_Des_Val = Check_Des_Val | value;
+	Err_Flag      = Err_Flag | Err_Check_Des;
+	if ( DbgPrn_ErrFlg ) 
+	    printf ("\nErr_Flag: [%08lx] Check_Des_Val: [%08lx]\n", Err_Flag, Check_Des_Val);
+
+	return(1);
+}
+
+//------------------------------------------------------------
+// Get and Check status of Interrupt
+//------------------------------------------------------------
+int check_int ( char *type ) {
+	#ifdef  DbgPrn_FuncHeader
+	    printf ("check_int  : %d\n", Loop); 
+	    Debug_delay();
+    #endif
+
+	Dat_ULONG = ReadSOC_DD( H_MAC_BASE + 0x00 );//Interrupt Status
+#ifdef SLT_DOS	
+#ifdef CheckRxbufUNAVA
+	if ( Dat_ULONG & 0x00000004 ) {
+		fprintf(fp_log, "[%sIntStatus] Receiving buffer unavailable               : %08lx [loop:%d]\n", type, Dat_ULONG, Loop);
+		FindErr( Err_RXBUF_UNAVA );
+	}
+#endif
+
+#ifdef CheckRPktLost
+	if ( Dat_ULONG & 0x00000008 ) {
+		fprintf(fp_log, "[%sIntStatus] Received packet lost due to RX FIFO full   : %08lx [loop:%d]\n", type, Dat_ULONG, Loop);
+		FindErr( Err_RPKT_LOST );
+	}
+#endif
+
+#ifdef CheckNPTxbufUNAVA
+	if ( Dat_ULONG & 0x00000040 ) {
+		fprintf(fp_log, "[%sIntStatus] Normal priority transmit buffer unavailable: %08lx [loop:%d]\n", type, Dat_ULONG, Loop);
+		FindErr( Err_NPTXBUF_UNAVA );
+	}
+#endif
+
+#ifdef CheckTPktLost
+	if ( Dat_ULONG & 0x00000080 ) {
+		fprintf(fp_log, "[%sIntStatus] Packets transmitted to Ethernet lost       : %08lx [loop:%d]\n", type, Dat_ULONG, Loop);
+		FindErr( Err_TPKT_LOST );
+	}
+#endif
+#endif
+	if (Err_Flag) 
+	    return(1);
+	else          
+	    return(0);
+} // End int check_int (char *type)
+
+
+//------------------------------------------------------------
+// Buffer
+//------------------------------------------------------------
+void setup_framesize (void) {
+    int	i;
+    
+	#ifdef  DbgPrn_FuncHeader
+	    printf ("setup_framesize\n"); 
+	    Debug_delay();
+    #endif
+	    
+	//------------------------------------------------------------
+	// Fill Frame Size out descriptor area
+	//------------------------------------------------------------
+    #ifdef SLT_UBOOT
+	if (0)
+    #else
+	if ( ENABLE_RAND_SIZE )
+    #endif
+    {
+		for (i = 0; i < DES_NUMBER; i++) {
+			if ( FRAME_Rand_Simple ) {
+				switch(rand() % 5) {
+					case 0 : FRAME_LEN[i] = 0x4e ; break;
+					case 1 : FRAME_LEN[i] = 0x4ba; break;
+					default: FRAME_LEN[i] = 0x5ea; break;
+				}
+			} 
+			else {
+				FRAME_LEN_Cur = rand() % (MAX_FRAME_RAND_SIZE + 1);
+			
+				if (FRAME_LEN_Cur < MIN_FRAME_RAND_SIZE) 
+				    FRAME_LEN_Cur = MIN_FRAME_RAND_SIZE;
+
+				FRAME_LEN[i] = FRAME_LEN_Cur;
+			}
+#ifdef SLT_DOS			
+			if (DbgPrn_FRAME_LEN) 
+			    fprintf(fp_log, "[setup_framesize] FRAME_LEN_Cur:%08lx[Des:%d][loop:%d]\n", FRAME_LEN[i], i, Loop);
+#endif
+		}
+	} 
+	else {
+		for (i = 0; i < DES_NUMBER; i++) {
+            #ifdef SelectSimpleLength
+			if (i % FRAME_SELH_PERD) 
+			    FRAME_LEN[i] = FRAME_LENH;
+			else                          
+			    FRAME_LEN[i] = FRAME_LENL;
+            #else
+			if ( BurstEnable ) {
+				if (IEEETesting) {
+					FRAME_LEN[i] = 1514;
+				} 
+				else {
+                    #ifdef ENABLE_ARP_2_WOL
+					FRAME_LEN[i] = 164;
+                    #else
+					FRAME_LEN[i] = 60;
+                    #endif
+				}
+			} 
+			else {
+                #ifdef SelectLengthInc
+//				FRAME_LEN[i] = (i%1455)+60;
+				FRAME_LEN[i] = 1514-( i % 1455 );
+                #else
+				if (i % FRAME_SELH_PERD) 
+				    FRAME_LEN[i] = FRAME_LENH;
+				else                          
+				    FRAME_LEN[i] = FRAME_LENL;
+                #endif
+			} // End if (BurstEnable)
+            #endif
+/*
+			switch(i % 20) {
+				case 0 : FRAME_LEN[i] = FRAME_LENH; break;
+				case 1 : FRAME_LEN[i] = FRAME_LENH; break;
+				case 2 : FRAME_LEN[i] = FRAME_LENH; break;
+				default: FRAME_LEN[i] = FRAME_LENL; break;
+			}
+*/
+#ifdef SLT_DOS
+			if (DbgPrn_FRAME_LEN) 
+			    fprintf(fp_log, "[setup_framesize] FRAME_LEN_Cur:%08lx[Des:%d][loop:%d]\n", FRAME_LEN[i], i, Loop);
+#endif
+		} // End for (i = 0; i < DES_NUMBER; i++)
+	} // End if ( ENABLE_RAND_SIZE )
+
+    // Calculate average of frame size
+	Avg_frame_len = 0;
+	
+	for ( i = 0; i < DES_NUMBER; i++ ) {
+		Avg_frame_len += FRAME_LEN[i];
+	}
+	
+	Avg_frame_len = Avg_frame_len / (double)DES_NUMBER;
+
+	//------------------------------------------------------------
+	// Write Plane
+	//------------------------------------------------------------
+	switch( ZeroCopy_OFFSET & 0x3 ) {
+		case 0: wp_fir = 0xffffffff; break;
+		case 1: wp_fir = 0xffffff00; break;
+		case 2: wp_fir = 0xffff0000; break;
+		case 3: wp_fir = 0xff000000; break;
+	}
+	
+	for ( i = 0; i < DES_NUMBER; i++ ) {
+		switch( ( ZeroCopy_OFFSET + FRAME_LEN[i] - 1 ) & 0x3 ) {
+			case 0: wp_lst[i] = 0x000000ff; break;
+			case 1: wp_lst[i] = 0x0000ffff; break;
+			case 2: wp_lst[i] = 0x00ffffff; break;
+			case 3: wp_lst[i] = 0xffffffff; break;
+		}
+	} // End for ( i = 0; i < DES_NUMBER; i++ )
+} // End void setup_framesize (void)
+
+//------------------------------------------------------------
+void setup_arp (void) {
+    int i;
+    for (i = 0; i < 16; i++ )
+        ARP_data[i] = ARP_org_data[i];
+    
+	ARP_data[1] = 0x0000ffff | ( SA[0] << 16 )
+	                         | ( SA[1] << 24 );
+	                                         
+	ARP_data[2] =              ( SA[2]       )
+	                         | ( SA[3] <<  8 )
+	                         | ( SA[4] << 16 )
+	                         | ( SA[5] << 24 );
+	            
+	ARP_data[5] = 0x00000100 | ( SA[0] << 16 )
+	                         | ( SA[1] << 24 );
+	            
+	ARP_data[6] =              ( SA[2]       )
+	                         | ( SA[3] <<  8 )
+	                         | ( SA[4] << 16 )
+	                         | ( SA[5] << 24 );
+} // End void setup_arp (void)
+
+//------------------------------------------------------------
+void setup_buf (void) {
+    int     i;
+    int	    j;
+    ULONG	adr;
+    ULONG	adr_srt;
+    ULONG	adr_end;
+    ULONG	len;
+    #ifdef SelectSimpleDA
+        int     cnt;
+        ULONG   Current_framelen;
+    #endif
+    
+    #ifdef ENABLE_ARP_2_WOL
+    int	    DA[3];
+
+	DA[0] =  ( ( SelectWOLDA_DatH >>  8 ) & 0x00ff ) |
+	         ( ( SelectWOLDA_DatH <<  8 ) & 0xff00 );
+	         
+	DA[1] =  ( ( SelectWOLDA_DatL >> 24 ) & 0x00ff ) |
+	         ( ( SelectWOLDA_DatL >>  8 ) & 0xff00 );
+	         
+	DA[2] =  ( ( SelectWOLDA_DatL >>  8 ) & 0x00ff ) |
+	         ( ( SelectWOLDA_DatL <<  8 ) & 0xff00 );
+    #endif
+    
+	#ifdef  DbgPrn_FuncHeader
+	    printf ("setup_buf  : %d\n", Loop); 
+	    Debug_delay();
+    #endif
+
+    // It need be multiple of 4
+	adr_srt = GET_DMA_BASE_SETUP & 0xfffffffc;
+	
+	for (j = 0; j < DES_NUMBER; j++) {
+		if ( DbgPrn_BufAdr ) 
+		    printf("[loop:%4d][des:%4d][setup_buf  ] %08lx\n", Loop, j, adr_srt);
+		    
+		if ( BurstEnable ) {
+			if ( IEEETesting ) {
+                #ifdef ENABLE_DASA
+				WriteSOC_DD( adr_srt    , 0xffffffff  );
+				WriteSOC_DD( adr_srt + 4, ARP_data[1] );
+				WriteSOC_DD( adr_srt + 8, ARP_data[2] );
+				
+				for (adr = (adr_srt + 12); adr < (adr_srt + DMA_PakSize); adr += 4 )
+                #else
+				for (adr = adr_srt; adr < (adr_srt + DMA_PakSize); adr += 4 )
+                #endif
+                {
+					switch( TestMode ) {
+						case 1: gdata = 0xffffffff;              break;
+						case 2: gdata = 0x55555555;              break;
+						case 3: gdata = rand() | (rand() << 16); break;
+						case 5: gdata = UserDVal;                break;
+					}
+					WriteSOC_DD(adr, gdata);
+				} // End for()
+			} 
+			else {
+				for (i = 0; i < 16; i++) {
+					WriteSOC_DD( adr_srt + ( i << 2 ), ARP_data[i] );
+				}                
+                
+                #ifdef ENABLE_ARP_2_WOL          
+				for (i = 16; i < 40; i += 3) {
+					WriteSOC_DD( adr_srt + ( i << 2 ),     ( DA[1] << 16 ) |  DA[0] );
+					WriteSOC_DD( adr_srt + ( i << 2 ) + 4, ( DA[0] << 16 ) |  DA[2] );
+					WriteSOC_DD( adr_srt + ( i << 2 ) + 8, ( DA[2] << 16 ) |  DA[1] );
+				}
+                #endif
+			} // End if ( IEEETesting ) 
+		} 
+		else {
+		    // --------------------------------------------
+            #ifdef SelectSimpleData
+                #ifdef SimpleData_Fix
+			    switch( j % SimpleData_FixNum ) {
+			    	case  0 : gdata = SimpleData_FixVal00; break;
+			    	case  1 : gdata = SimpleData_FixVal01; break;
+			    	case  2 : gdata = SimpleData_FixVal02; break;
+			    	case  3 : gdata = SimpleData_FixVal03; break;
+			    	case  4 : gdata = SimpleData_FixVal04; break;
+			    	case  5 : gdata = SimpleData_FixVal05; break;
+			    	case  6 : gdata = SimpleData_FixVal06; break;
+			    	case  7 : gdata = SimpleData_FixVal07; break;
+			    	case  8 : gdata = SimpleData_FixVal08; break;
+			    	case  9 : gdata = SimpleData_FixVal09; break;
+			    	case 10 : gdata = SimpleData_FixVal10; break;
+			    	default : gdata = SimpleData_FixVal11; break;
+			    }
+                #else
+			    gdata   = 0x11111111 * ((j + SEED_START) % 256);
+                #endif
+ 			
+ 			adr_end = adr_srt + DMA_PakSize;
+			for ( adr = adr_srt; adr < adr_end; adr += 4 ) {
+				WriteSOC_DD( adr, gdata );
+			}		  
+            // --------------------------------------------			
+			#elif SelectSimpleDA
+
+			gdata   = DATA_SEED(j + SEED_START);
+			Current_framelen = FRAME_LEN[j];
+			
+			if ( DbgPrn_FRAME_LEN ) 
+			    fprintf(fp_log, "[setup_buf      ] Current_framelen:%08lx[Des:%d][loop:%d]\n", Current_framelen, j, Loop);
+			
+			cnt     = 0;
+ 			len     = ( ( ( Current_framelen - 14 ) & 0xff ) << 8) | 
+ 			            ( ( Current_framelen - 14 ) >> 8 );
+
+ 			adr_end = adr_srt + DMA_PakSize;
+			for ( adr = adr_srt; adr < adr_end; adr += 4 ) {
+				cnt++;
+				if      (cnt == 1 ) WriteSOC_DD( adr, SelectSimpleDA_Dat0 );
+				else if (cnt == 2 ) WriteSOC_DD( adr, SelectSimpleDA_Dat1 );
+				else if (cnt == 3 ) WriteSOC_DD( adr, SelectSimpleDA_Dat2 );
+				else if (cnt == 4 ) WriteSOC_DD( adr, len | (len << 16)   );
+				else				
+				    WriteSOC_DD( adr, gdata );      
+				              
+				gdata += DATA_IncVal;
+			}			
+            // --------------------------------------------			
+			#else
+
+			gdata   = DATA_SEED(j + SEED_START);
+ 			adr_end = adr_srt + DMA_PakSize;
+			for ( adr = adr_srt; adr < adr_end; adr += 4 ) {			
+				WriteSOC_DD( adr, gdata );
+                
+				gdata += DATA_IncVal;
+			}
+
+			#endif
+			
+		} // End if ( BurstEnable )
+
+		adr_srt += DMA_PakSize;
+	} // End for (j = 0; j < DES_NUMBER; j++)
+} // End void setup_buf (void)
+
+//------------------------------------------------------------
+// Check data of one packet
+//------------------------------------------------------------
+char check_Data (ULONG desadr, LONG number) {
+	int	    index;
+	int     cnt;
+    ULONG	rdata;  
+    ULONG	wp_lst_cur;  
+    ULONG	adr_las;
+    ULONG	adr;
+    ULONG	adr_srt;
+    ULONG	adr_end;
+    ULONG	len;
+    #ifdef SelectSimpleDA
+        ULONG   gdata_bak;
+    #endif
+    
+	#ifdef  DbgPrn_FuncHeader
+	    printf ("check_Data : %d\n", Loop); 
+	    Debug_delay();
+    #endif
+    //printf("[Des:%d][loop:%d]Desadr:%08x\n", number, Loop, desadr);
+
+	wp_lst_cur    = wp_lst[number];
+	FRAME_LEN_Cur = FRAME_LEN[number];
+#ifdef SLT_DOS	
+	if ( DbgPrn_FRAME_LEN ) 
+	    fprintf(fp_log, "[check_Data     ] FRAME_LEN_Cur:%08lx[Des:%d][loop:%d]\n", FRAME_LEN_Cur, number, Loop);
+#endif	    
+	adr_srt = ReadSOC_DD(desadr) & 0xfffffffc;
+	adr_end = adr_srt + PktByteSize;
+	
+    #ifdef SelectSimpleData
+        #ifdef SimpleData_Fix
+	switch( number % SimpleData_FixNum ) {
+		case  0 : gdata = SimpleData_FixVal00; break;
+		case  1 : gdata = SimpleData_FixVal01; break;
+		case  2 : gdata = SimpleData_FixVal02; break;
+		case  3 : gdata = SimpleData_FixVal03; break;
+		case  4 : gdata = SimpleData_FixVal04; break;
+		case  5 : gdata = SimpleData_FixVal05; break;
+		case  6 : gdata = SimpleData_FixVal06; break;
+		case  7 : gdata = SimpleData_FixVal07; break;
+		case  8 : gdata = SimpleData_FixVal08; break;
+		case  9 : gdata = SimpleData_FixVal09; break;
+		case 10 : gdata = SimpleData_FixVal10; break;
+		default : gdata = SimpleData_FixVal11; break;
+	}
+        #else
+	gdata   = 0x11111111 * ((number + SEED_START) % 256);
+        #endif
+    #else
+	gdata   = DATA_SEED(number + SEED_START);
+    #endif
+
+	wp      = wp_fir;
+	adr_las = adr_end - 4;
+
+	cnt     = 0;
+	len     = (((FRAME_LEN_Cur-14) & 0xff) << 8) | ((FRAME_LEN_Cur-14) >> 8);
+#ifdef SLT_DOS
+	if (DbgPrn_Bufdat) 
+	    fprintf(fp_log, " Inf:%08lx ~ %08lx(%08lx) %08lx [Des:%d][loop:%d]\n", adr_srt, adr_end, adr_las, gdata, number, Loop);
+#endif	    
+	for (adr = adr_srt; adr < adr_end; adr+=4) {
+
+        #ifdef SelectSimpleDA
+		cnt++;
+		if      ( cnt == 1 ) { gdata_bak = gdata; gdata = SelectSimpleDA_Dat0; }
+		else if ( cnt == 2 ) { gdata_bak = gdata; gdata = SelectSimpleDA_Dat1; }
+		else if ( cnt == 3 ) { gdata_bak = gdata; gdata = SelectSimpleDA_Dat2; }
+		else if ( cnt == 4 ) { gdata_bak = gdata; gdata = len | (len << 16);   }
+        #endif
+		rdata = ReadSOC_DD(adr);
+		if (adr == adr_las) 
+		    wp = wp & wp_lst_cur;
+		    
+		if ( (rdata & wp) != (gdata & wp) ) {
+#ifdef SLT_DOS
+            fprintf(fp_log, "\nError: Adr:%08lx[%3d] (%08lx) (%08lx:%08lx) [Des:%d][loop:%d]\n", adr, (adr - adr_srt) / 4, rdata, gdata, wp, number, Loop);
+#endif
+			for (index = 0; index < 6; index++) {
+				rdata = ReadSOC_DD(adr);
+#ifdef SLT_DOS                
+				fprintf(fp_log, "Rep  : Adr:%08lx      (%08lx) (%08lx:%08lx) [Des:%d][loop:%d]\n", adr, rdata, gdata, wp, number, Loop);
+#endif                
+            }
+
+			if ( DbgPrn_DumpMACCnt ) 
+			    dump_mac_ROreg();
+			    
+			return( FindErr( Err_Check_Buf_Data ) );
+		} // End if ( (rdata & wp) != (gdata & wp) )
+#ifdef SLT_DOS		
+		if ( DbgPrn_BufdatDetail ) 
+		    fprintf(fp_log, " Adr:%08lx[%3d] (%08lx) (%08lx:%08lx) [Des:%d][loop:%d]\n", adr, (adr - adr_srt) / 4, rdata, gdata, wp, number, Loop);
+#endif		    
+        #ifdef SelectSimpleDA
+		if ( cnt <= 4 ) 
+		    gdata = gdata_bak;
+        #endif
+
+        #ifdef SelectSimpleData
+        #else
+		gdata += DATA_IncVal;
+        #endif
+		
+		wp     = 0xffffffff;
+	}
+	return(0);
+} // End char check_Data (ULONG desadr, LONG number)
+
+//------------------------------------------------------------
+char check_buf (int loopcnt) {
+    int	    count;
+    ULONG	desadr;
+    
+	#ifdef  DbgPrn_FuncHeader
+	    printf ("check_buf  : %d\n", Loop); 
+	    Debug_delay();
+    #endif
+
+	for ( count = DES_NUMBER - 1; count >= 0; count-- ) {
+		desadr = H_RDES_BASE + ( 16 * count ) + 12;
+        //printf("%d:%08x\n", count, desadr);
+		if (check_Data(desadr, count)) {
+			check_int ("");
+			
+			return(1);
+		}
+	}
+	if ( check_int ("") )
+	    return(1);
+
+	return(0);
+} // End char check_buf (int loopcnt)
+
+//------------------------------------------------------------
+// Descriptor
+//------------------------------------------------------------
+void setup_txdes (ULONG desadr, ULONG bufbase) {
+    ULONG	bufadr;
+    ULONG	desval;
+    int     count;
+    
+	#ifdef  DbgPrn_FuncHeader
+	    printf ("setup_txdes: %d\n", Loop); 
+	    Debug_delay();
+    #endif
+
+	bufadr    = bufbase + ZeroCopy_OFFSET;
+	
+	if (TxDataEnable) {
+		for (count = 0; count < DES_NUMBER; count++) {
+			FRAME_LEN_Cur = FRAME_LEN[count];
+			desval        = TDES_IniVal;
+            #ifdef SLT_DOS	
+			if (DbgPrn_FRAME_LEN) 
+			    fprintf(fp_log, "[setup_txdes    ] FRAME_LEN_Cur:%08lx[Des:%d][loop:%d]\n", FRAME_LEN_Cur, count, Loop);
+            #endif
+			if (DbgPrn_BufAdr) 
+			    printf("[loop:%4d][des:%4d][setup_txdes] %08lx\n", Loop, count, bufadr);
+			    
+			WriteSOC_DD( desadr + 0x04, 0      );
+			WriteSOC_DD( desadr + 0x08, 0      );
+			WriteSOC_DD( desadr + 0x0C, (bufadr + CPU_BUS_ADDR_SDRAM_OFFSET) ); // 20130730
+			if ( count == ( DES_NUMBER - 1 ) )
+			    WriteSOC_DD( desadr       , desval | EOR_IniVal);
+			else
+			    WriteSOC_DD( desadr       , desval );
+
+			bufadr += DMA_PakSize;
+			desadr += 16;
+		}
+	} 
+	else {
+		WriteSOC_DD( desadr     , 0);
+	}
+} // End void setup_txdes (ULONG desadr, ULONG bufbase)
+
+//------------------------------------------------------------
+void setup_rxdes (ULONG desadr, ULONG bufbase) {
+    ULONG	bufadr;
+    ULONG	desval;    
+    int     count;
+    
+	#ifdef  DbgPrn_FuncHeader
+	    printf ("setup_rxdes: %d\n", Loop); 
+	    Debug_delay();
+    #endif
+
+	bufadr = bufbase+ZeroCopy_OFFSET;
+	desval = RDES_IniVal;
+	
+	if ( RxDataEnable ) {
+		for (count = 0; count < DES_NUMBER; count++) {
+			if (DbgPrn_BufAdr) 
+			    printf("[loop:%4d][des:%4d][setup_rxdes] %08lx\n", Loop, count, bufadr);
+			WriteSOC_DD( desadr + 0x04, 0      );
+			WriteSOC_DD( desadr + 0x08, 0      );
+			WriteSOC_DD( desadr + 0x0C, ( bufadr + CPU_BUS_ADDR_SDRAM_OFFSET) ); // 20130730
+            if ( count == ( DES_NUMBER - 1 ) )
+                WriteSOC_DD( desadr       , desval | EOR_IniVal   );
+            else
+			    WriteSOC_DD( desadr       , desval );
+
+			desadr += 16;
+			bufadr += DMA_PakSize;
+		}
+	} 
+	else {
+		WriteSOC_DD( desadr     , 0x80000000   );
+	} // End if ( RxDataEnable )
+} // End void setup_rxdes (ULONG desadr, ULONG bufbase)
+
+//------------------------------------------------------------
+// First setting TX and RX information
+//------------------------------------------------------------
+void setup_des (ULONG bufnum) {
+
+	if ( DbgPrn_BufAdr ) {
+	    printf ("setup_rxdes: %ld\n", bufnum); 
+	    Debug_delay();
+	}
+
+    setup_txdes( H_TDES_BASE, GET_DMA_BASE_SETUP       );
+    setup_rxdes( H_RDES_BASE, GET_DMA_BASE(0)          );
+    
+} // End void setup_des (ULONG bufnum)
+
+//------------------------------------------------------------
+// Move buffer point of TX and RX descriptor to next DMA buffer
+//------------------------------------------------------------
+void setup_des_loop (ULONG bufnum) {
+    int	    count;
+    ULONG	H_rx_desadr;
+    ULONG	H_tx_desadr;
+    ULONG	H_tx_bufadr;
+    ULONG	H_rx_bufadr;
+
+	if ( DbgPrn_BufAdr ) {
+	    printf ("setup_rxdes_loop: %ld\n", bufnum); 
+	    Debug_delay();
+	}
+	
+	if (RxDataEnable) {
+		H_rx_bufadr = GET_DMA_BASE( bufnum + 1 ) + ZeroCopy_OFFSET;
+		H_rx_desadr = H_RDES_BASE;
+//printf (" =====>setup_rxdes_loop: %ld [%lX]\n", bufnum, H_rx_bufadr);
+		for (count = 0; count < DES_NUMBER; count++) {
+			WriteSOC_DD(H_rx_desadr + 0x0C,  (H_rx_bufadr + CPU_BUS_ADDR_SDRAM_OFFSET) ); // 20130730
+			
+			if (count == (DES_NUMBER - 1)) {
+				WriteSOC_DD( H_rx_desadr, RDES_IniVal | EOR_IniVal );
+			}                
+			else {           
+				WriteSOC_DD( H_rx_desadr, RDES_IniVal );
+			}
+			H_rx_bufadr += DMA_PakSize;
+			H_rx_desadr += 16;
+		}
+	}
+	
+	if (TxDataEnable) {
+		if (RxDataEnable) {
+			H_tx_bufadr = GET_DMA_BASE( bufnum ) + ZeroCopy_OFFSET;
+		} 
+		else {
+			H_tx_bufadr = GET_DMA_BASE( 0      ) + ZeroCopy_OFFSET;
+		}
+		H_tx_desadr = H_TDES_BASE;
+//printf (" =====>setup_Txdes_loop: %ld [%lX]\n", bufnum, H_tx_bufadr); 		
+		for (count = 0; count < DES_NUMBER; count++) {
+			FRAME_LEN_Cur = FRAME_LEN[count];
+			WriteSOC_DD( H_tx_desadr + 0x0C, ( H_tx_bufadr + CPU_BUS_ADDR_SDRAM_OFFSET) ); // 20130730
+			if (count == (DES_NUMBER - 1)) {
+				WriteSOC_DD( H_tx_desadr, TDES_IniVal | EOR_IniVal );
+			} 
+			else {
+				WriteSOC_DD( H_tx_desadr, TDES_IniVal );
+			}
+			H_tx_bufadr += DMA_PakSize;
+			H_tx_desadr += 16;
+		}
+	}
+
+	WriteSOC_DD( H_MAC_BASE + 0x18, 0x00000000 ); // Tx Poll
+	WriteSOC_DD( H_MAC_BASE + 0x1c, 0x00000000 ); // Rx Poll
+} // End void setup_des_loop (ULONG bufnum)
+
+//------------------------------------------------------------
+char check_des_header_Tx (char *type, ULONG adr, LONG desnum) {
+	int    timeout = 0;
+	ULONG  dat;
+	
+	dat = ReadSOC_DD(adr);
+	
+	while ( HWOwnTx(dat) ) {
+	    // we will run again, if transfer has not been completed.
+		if ( RxDataEnable && (++timeout > TIME_OUT_Des) ) {
+            #ifdef SLT_DOS
+            fprintf(fp_log, "[%sTxDesOwn] Address %08lx = %08lx [Des:%d][loop:%d]\n", type, adr, dat, desnum, Loop);
+            #endif			
+			return(FindErr_Des(Check_Des_TxOwnTimeOut));
+		}
+		WriteSOC_DD(H_MAC_BASE + 0x18, 0x00000000);//Tx Poll
+		WriteSOC_DD(H_MAC_BASE + 0x1c, 0x00000000);//Rx Poll
+        
+        #ifdef Delay_ChkTxOwn
+		delay(Delay_ChkTxOwn);
+        #endif
+		dat = ReadSOC_DD(adr);
+	}
+
+	return(0);
+} // End char check_des_header_Tx (char *type, ULONG adr, LONG desnum)
+
+//------------------------------------------------------------
+char check_des_header_Rx (char *type, ULONG adr, LONG desnum) {
+    #ifdef CheckRxOwn
+	int    timeout = 0;
+	ULONG  dat;
+	
+	dat = ReadSOC_DD(adr);
+	
+	while ( HWOwnRx( dat ) ) {
+	    // we will run again, if transfer has not been completed.
+		if (TxDataEnable && (++timeout > TIME_OUT_Des)) {
+            #ifdef SLT_DOS
+            fprintf(fp_log, "[%sRxDesOwn] Address %08lx = %08lx [Des:%d][loop:%d]\n", type, adr, dat, desnum, Loop);
+            #endif
+			return(FindErr_Des(Check_Des_RxOwnTimeOut));
+		}
+
+		WriteSOC_DD(H_MAC_BASE + 0x18, 0x00000000);//Tx Poll
+		WriteSOC_DD(H_MAC_BASE + 0x1c, 0x00000000);//Rx Poll
+        
+        #ifdef Delay_ChkRxOwn
+		delay(Delay_ChkRxOwn);
+        #endif
+		dat = ReadSOC_DD(adr);
+	};
+
+	Dat_ULONG = ReadSOC_DD( adr + 12 );
+
+    #ifdef CheckRxLen
+    #ifdef SLT_DOS
+    if ( DbgPrn_FRAME_LEN ) 
+	    fprintf(fp_log, "[%sRxDes          ] FRAME_LEN_Cur:%08lx[Des:%d][loop:%d]\n", type, (FRAME_LEN_Cur + 4), desnum, Loop);
+    #endif	  
+        
+	if ((dat & 0x3fff) != (FRAME_LEN_Cur + 4)) {
+        #ifdef SLT_DOS
+		fprintf(fp_log, "[%sRxDes] Error Frame Length %08lx:%08lx %08lx(%4d/%4d) [Des:%d][loop:%d]\n",   type, adr, dat, Dat_ULONG, (dat & 0x3fff), (FRAME_LEN_Cur + 4), desnum, Loop);
+        #endif
+		FindErr_Des(Check_Des_FrameLen);
+	}
+    #endif // End CheckRxLen
+
+    #ifdef CheckRxErr
+	if (dat & 0x00040000) {
+        #ifdef SLT_DOS
+		fprintf(fp_log, "[%sRxDes] Error RxErr        %08lx:%08lx %08lx            [Des:%d][loop:%d]\n", type, adr, dat, Dat_ULONG, desnum, Loop);
+        #endif
+        FindErr_Des(Check_Des_RxErr);
+	}
+    #endif // End CheckRxErr
+
+    #ifdef CheckOddNibble
+	if (dat & 0x00400000) {
+        #ifdef SLT_DOS
+		fprintf(fp_log, "[%sRxDes] Odd Nibble         %08lx:%08lx %08lx            [Des:%d][loop:%d]\n", type, adr, dat, Dat_ULONG, desnum, Loop);
+        #endif
+		FindErr_Des(Check_Des_OddNibble);
+	}
+    #endif // End CheckOddNibble
+
+    #ifdef CheckCRC
+	if (dat & 0x00080000) {
+        #ifdef SLT_DOS
+		fprintf(fp_log, "[%sRxDes] Error CRC          %08lx:%08lx %08lx            [Des:%d][loop:%d]\n", type, adr, dat, Dat_ULONG, desnum, Loop);
+        #endif
+		FindErr_Des(Check_Des_CRC);
+	}
+    #endif // End CheckCRC
+
+    #ifdef CheckRxFIFOFull
+	if (dat & 0x00800000) {
+		#ifdef SLT_DOS
+        fprintf(fp_log, "[%sRxDes] Error Rx FIFO Full %08lx:%08lx %08lx            [Des:%d][loop:%d]\n", type, adr, dat, Dat_ULONG, desnum, Loop);
+        #endif
+		FindErr_Des(Check_Des_RxFIFOFull);
+	}
+    #endif // End CheckRxFIFOFull
+    
+    //	if (check_int ("")) {return(1);}
+    #endif // End CheckRxOwn
+
+	if (Err_Flag) 
+	    return(1);
+	else          
+	    return(0);
+} // End char check_des_header_Rx (char *type, ULONG adr, LONG desnum)
+
+//------------------------------------------------------------
+char check_des (ULONG bufnum, int checkpoint) {
+    int     desnum;    
+    ULONG	H_rx_desadr;
+    ULONG	H_tx_desadr;
+    ULONG	H_tx_bufadr;
+    ULONG	H_rx_bufadr;
+    
+    #ifdef Delay_DesGap
+    ULONG	dly_cnt = 0;
+    ULONG	dly_max = Delay_CntMaxIncVal;
+    #endif
+    
+	#ifdef  DbgPrn_FuncHeader
+	    printf ("check_des  : %d(%d)\n", Loop, checkpoint); 
+	    Debug_delay();
+    #endif
+    
+	// Fire the engine to send and recvice
+	WriteSOC_DD( H_MAC_BASE + 0x18, 0x00000000 );//Tx Poll
+	WriteSOC_DD( H_MAC_BASE + 0x1c, 0x00000000 );//Rx Poll
+	
+    #ifdef SelectSimpleDes
+    #else
+    if ( IEEETesting == 1 ) {
+        // IEEE test mode, there is the same data in every lan packet
+        H_tx_bufadr = GET_DMA_BASE_SETUP;
+        H_rx_bufadr = GET_DMA_BASE(0);
+    }
+    else {
+	    H_rx_bufadr = GET_DMA_BASE( bufnum + 1 ) + ZeroCopy_OFFSET;
+	    
+	    if (RxDataEnable) {
+	    	H_tx_bufadr = GET_DMA_BASE(bufnum  ) + ZeroCopy_OFFSET;
+	    } 
+	    else {
+	    	H_tx_bufadr = GET_DMA_BASE( 0      ) + ZeroCopy_OFFSET;
+	    }
+	}
+    #endif
+
+	H_rx_desadr = H_RDES_BASE;
+	H_tx_desadr = H_TDES_BASE;
+
+    #ifdef Delay_DES
+	delay(Delay_DES);
+    #endif
+	
+	for (desnum = 0; desnum < DES_NUMBER; desnum++) {
+		if ( DbgPrn_BufAdr ) 
+		    printf( "[loop:%4d][des:%4d][check_des  ] %08lx %08lx [%08lx] [%08lx]\n", Loop, desnum, ( H_tx_desadr ), ( H_rx_desadr ), ReadSOC_DD( H_tx_desadr + 12 ), ReadSOC_DD( H_rx_desadr + 12 ) );
+
+		//[Delay]--------------------
+        #ifdef Delay_DesGap
+		if ( dly_cnt++ > 3 ) {
+			switch ( rand() % 12 ) {
+				case 1 : dly_max = 00000; break;
+				case 3 : dly_max = 20000; break;
+				case 5 : dly_max = 40000; break;
+				case 7 : dly_max = 60000; break;
+				defaule: dly_max = 70000; break;
+			}
+			
+			dly_max += ( rand() % 4 ) * 14321;
+
+			while (dly_cnt < dly_max) {
+			    dly_cnt++;
+			}
+			
+			dly_cnt = 0;
+		} 
+		else {
+//			timeout = 0;
+//			while (timeout < 50000) {timeout++;};
+		}
+        #endif // End Delay_DesGap
+        
+		//[Check Owner Bit]--------------------
+		FRAME_LEN_Cur = FRAME_LEN[desnum];
+#ifdef SLT_DOS		
+		if ( DbgPrn_FRAME_LEN ) 
+		    fprintf(fp_log, "[check_des      ] FRAME_LEN_Cur:%08lx[Des:%d][loop:%d]%d\n", FRAME_LEN_Cur, desnum, Loop, checkpoint);
+#endif		    
+//		if (BurstEnable) {
+//			if (check_des_header_Tx("", H_tx_desadr, desnum)) {CheckDesFail_DesNum = desnum; return(1);}
+//		} else {
+//			if (check_des_header_Rx("", H_rx_desadr, desnum)) {CheckDesFail_DesNum = desnum; return(1);}
+//			if (check_des_header_Tx("", H_tx_desadr, desnum)) {CheckDesFail_DesNum = desnum; return(1);}
+//		}
+        
+        // Check the description of Tx and Rx
+		if ( RxDataEnable && check_des_header_Rx("", H_rx_desadr, desnum) ) {
+		    CheckDesFail_DesNum = desnum; 
+
+		    return(1);
+		}
+		if ( TxDataEnable && check_des_header_Tx("", H_tx_desadr, desnum) ) {
+		    CheckDesFail_DesNum = desnum; 
+
+		    return(1);
+		}
+//		else {
+//			printf(" %d                        \r", desnum);
+//		}
+
+        #ifdef SelectSimpleDes
+        #else
+		if ( !checkpoint ) {
+		    // Setting buffer address to description of Tx and Rx on next stage
+		    
+//			if (!BurstEnable) {
+//				WriteSOC_DD( H_rx_desadr + 0x0C, (H_rx_bufadr + CPU_BUS_ADDR_SDRAM_OFFSET) );
+//				WriteSOC_DD( H_tx_desadr + 0x0C, (H_tx_bufadr + CPU_BUS_ADDR_SDRAM_OFFSET) );
+//			}
+//
+//			if ( desnum == (DES_NUMBER - 1) ) {
+//				WriteSOC_DD( H_rx_desadr, RDES_IniVal | EOR_IniVal );
+//				WriteSOC_DD( H_tx_desadr, TDES_IniVal | EOR_IniVal );
+//			} 
+//          else {         
+//				WriteSOC_DD( H_rx_desadr, RDES_IniVal );
+//				WriteSOC_DD( H_tx_desadr, TDES_IniVal );
+//			}
+//			WriteSOC_DD( H_MAC_BASE+0x18, 0x00000000 ); //Tx Poll
+//			WriteSOC_DD( H_MAC_BASE+0x1c, 0x00000000 ); //Rx Poll
+
+			if ( RxDataEnable ) {
+				WriteSOC_DD( H_rx_desadr + 0x0C, (H_rx_bufadr + CPU_BUS_ADDR_SDRAM_OFFSET) ); // 20130730
+				
+				if ( desnum == (DES_NUMBER - 1) ) {
+					WriteSOC_DD( H_rx_desadr, RDES_IniVal | EOR_IniVal );
+				} else {         
+					WriteSOC_DD( H_rx_desadr, RDES_IniVal );
+				}
+			}
+			if ( TxDataEnable ) {
+				WriteSOC_DD( H_tx_desadr + 0x0C, (H_tx_bufadr + CPU_BUS_ADDR_SDRAM_OFFSET) ); // 20130730
+				if ( desnum == (DES_NUMBER - 1) ) {
+					WriteSOC_DD( H_tx_desadr, TDES_IniVal | EOR_IniVal );
+				}                
+				else {           
+					WriteSOC_DD( H_tx_desadr, TDES_IniVal );
+				}
+			}
+			WriteSOC_DD( H_MAC_BASE + 0x18, 0x00000000 ); //Tx Poll
+			WriteSOC_DD( H_MAC_BASE + 0x1c, 0x00000000 ); //Rx Poll
+		}
+		H_rx_bufadr += DMA_PakSize;
+		H_tx_bufadr += DMA_PakSize;
+        #endif // End SelectSimpleDes
+		
+		H_rx_desadr += 16;
+		H_tx_desadr += 16;
+	} // End for (desnum = 0; desnum < DES_NUMBER; desnum++)
+	
+	return(0);
+} // End char check_des (ULONG bufnum, int checkpoint)
+//#endif
+
+//------------------------------------------------------------
+// Print
+//------------------------------------------------------------
+void PrintMode (void) {
+	if (Enable_MAC34) printf ("run_mode[dec]    | 0->MAC1 1->MAC2 2->MAC3 3->MAC4\n");
+	else              printf ("run_mode[dec]    | 0->MAC1 1->MAC2\n");
+}
+
+//------------------------------------------------------------
+void PrintSpeed (void) {
+	printf ("speed[dec]       | 0->1G   1->100M 2->10M  3->all speed (default:%3d)\n", DEF_SPEED);
+}
+
+//------------------------------------------------------------
+void PrintCtrl (void) {
+	    printf ("ctrl[dec]        | bit0~2: Reserved\n");
+	    printf ("(default:%3d)    | bit3  : 1->Enable PHY init     0->Disable PHY init\n", GCtrl);
+	    printf ("                 | bit4  : 1->Enable PHY int-loop 0->Disable PHY int-loop\n");
+	    printf ("                 | bit5  : 1->Ignore PHY ID       0->Check PHY ID\n");
+	if (AST2400) {
+		printf ("                 | bit6  : 1->Enable MAC int-loop 0->Disable MAC int-loop\n");
+	}
+}
+
+//------------------------------------------------------------
+void PrintLoop (void) {
+	printf ("loop_max[dec]    | 1G  : 20 will run 1 sec (default:%3d)\n", DEF_LOOP_MAX * 20);
+	printf ("                 | 100M:  2 will run 1 sec (default:%3d)\n", DEF_LOOP_MAX * 2);
+	printf ("                 | 10M :  1 will run 1 sec (default:%3d)\n", DEF_LOOP_MAX);
+}
+
+//------------------------------------------------------------
+void PrintTest (void) {
+	if ( ModeSwitch == MODE_NSCI ) {
+		printf ("test_mode[dec]   | 0: NCSI configuration with    Disable_Channel request\n");
+		printf ("(default:%3d)    | 1: NCSI configuration without Disable_Channel request\n", DEF_TESTMODE);
+	}
+	else {
+		printf ("test_mode[dec]   | 0: Tx/Rx frame checking\n");
+		printf ("(default:%3d)    | 1: Tx output 0xff frame\n", DEF_TESTMODE);
+		printf ("                 | 2: Tx output 0x55 frame\n");
+		printf ("                 | 3: Tx output random frame\n");
+		printf ("                 | 4: Tx output ARP frame\n");
+		printf ("                 | 5: Tx output user defined value frame (default:0x%8x)\n", DEF_USER_DEF_PACKET_VAL);
+	} // End if ( ModeSwitch == MODE_NSCI )
+	
+	if (AST2300) {
+		printf ("                 | 6: IO timing testing\n");
+		printf ("                 | 7: IO timing/strength testing\n");
+	}
+}
+
+//------------------------------------------------------------
+void PrintPHYAdr (void) {
+	printf ("phy_adr[dec]     | 0~31: PHY Address (default:%d)\n", DEF_PHY_ADR);
+}
+
+//------------------------------------------------------------
+void PrintIOTimingBund (void) {
+	printf ("IO margin[dec]   | 0/1/3/5 (default:%d)\n", DEF_IOTIMINGBUND);
+}
+
+//------------------------------------------------------------
+void PrintPakNUm (void) {
+	printf ("package_num[dec] | 1~ 8: Total Number of NCSI Package (default:%d)\n", DEF_PACKAGE2NUM);
+}
+
+//------------------------------------------------------------
+void PrintChlNUm (void) {
+	printf ("channel_num[dec] | 1~32: Total Number of NCSI Channel (default:%d)\n", DEF_CHANNEL2NUM);
+}
+
+//------------------------------------------------------------
+
+void Print_Header (BYTE option) {
+    
+    FILE_VAR
+    
+    GET_OBJ( option )
+    
+	if      (GSpeed_sel[0]) PRINT(OUT_OBJ " 1G   ");
+	else if (GSpeed_sel[1]) PRINT(OUT_OBJ " 100M ");
+	else                    PRINT(OUT_OBJ " 10M  ");
+	    
+	switch (TestMode) {
+		case 0 : PRINT(OUT_OBJ "Tx/Rx frame checking       \n"          ); break;
+		case 1 : PRINT(OUT_OBJ "Tx output 0xff frame       \n"          ); break;
+		case 2 : PRINT(OUT_OBJ "Tx output 0x55 frame       \n"          ); break;
+		case 3 : PRINT(OUT_OBJ "Tx output random frame     \n"          ); break;
+		case 4 : PRINT(OUT_OBJ "Tx output ARP frame        \n"          ); break;
+		case 5 : PRINT(OUT_OBJ "Tx output 0x%08lx frame     \n", UserDVal); break;
+		case 6 : PRINT(OUT_OBJ "IO delay testing           \n"          ); break;
+		case 7 : PRINT(OUT_OBJ "IO delay testing(Strength) \n"          ); break;
+		case 8 : PRINT(OUT_OBJ "Tx frame                   \n"          ); break;
+		case 9 : PRINT(OUT_OBJ "Rx frame checking          \n"          ); break;
+	}
+}
+
+//------------------------------------------------------------
+void PrintIO_Header (BYTE option) {
+        
+    FILE_VAR
+    
+    GET_OBJ( option )
+    
+	if ( IOStrength ) {
+		if      (GSpeed_sel[0]) PRINT(OUT_OBJ "[Strength %ld][1G  ]========================================\n", IOStr_i);
+		else if (GSpeed_sel[1]) PRINT(OUT_OBJ "[Strength %ld][100M]========================================\n", IOStr_i);
+		else                    PRINT(OUT_OBJ "[Strength %ld][10M ]========================================\n", IOStr_i);
+	} else {
+		if      (GSpeed_sel[0]) PRINT(OUT_OBJ "[1G  ]========================================\n");
+		else if (GSpeed_sel[1]) PRINT(OUT_OBJ "[100M]========================================\n");
+		else                    PRINT(OUT_OBJ "[10M ]========================================\n");
+	}
+
+#ifdef Enable_Old_Style
+	if (Enable_RMII) PRINT(OUT_OBJ "Tx:SCU48[   %2d]=   ", IOdly_out_shf);
+	else             PRINT(OUT_OBJ "Tx:SCU48[%2d:%2d]=   ", IOdly_out_shf+3, IOdly_out_shf);
+	    
+	for (IOdly_j = IOdly_out_str; IOdly_j <= IOdly_out_end; IOdly_j+=IOdly_incval) {
+		IOdly_out = valary[IOdly_j];
+		PRINT(OUT_OBJ "%2x", IOdly_out);
+	}
+
+	PRINT(OUT_OBJ "\n                   ");
+	for (IOdly_j = IOdly_out_str; IOdly_j <= IOdly_out_end; IOdly_j+=IOdly_incval) {
+		if (IOdly_out_reg_idx == IOdly_j) PRINT(OUT_OBJ " |");
+		else                              PRINT(OUT_OBJ "  ");
+	}
+#else
+	PRINT(OUT_OBJ "Rx:SCU48[%2d:%2d]=   ", IOdly_in_shf+3, IOdly_in_shf);
+	
+	for (IOdly_i = IOdly_in_str; IOdly_i <= IOdly_in_end; IOdly_i+=IOdly_incval) {
+		IOdly_in = valary[IOdly_i];
+		PRINT(OUT_OBJ "%2x", IOdly_in);
+	}
+
+	PRINT(OUT_OBJ "\n                   ");
+	for (IOdly_i = IOdly_in_str; IOdly_i <= IOdly_in_end; IOdly_i+=IOdly_incval) {
+		if (IOdly_in_reg_idx == IOdly_i) PRINT(OUT_OBJ " |");
+		else                             PRINT(OUT_OBJ "  ");
+	}
+#endif
+
+	PRINT(OUT_OBJ "\n");
+} // End void PrintIO_Header (BYTE option)
+
+//------------------------------------------------------------
+void PrintIO_LineS (BYTE option) {
+            
+    FILE_VAR
+    
+    GET_OBJ( option )
+    
+    
+#ifdef Enable_Old_Style
+	if (IOdly_in_reg == IOdly_in) {
+		PRINT(OUT_OBJ "Rx:SCU48[%2d:%2d]=%01x:-", IOdly_in_shf+3, IOdly_in_shf, IOdly_in);
+	} 
+	else {
+		PRINT(OUT_OBJ "Rx:SCU48[%2d:%2d]=%01x: ", IOdly_in_shf+3, IOdly_in_shf, IOdly_in);
+	}
+#else
+	if (Enable_RMII) {
+		if (IOdly_out_reg == IOdly_out) {
+			PRINT(OUT_OBJ "Tx:SCU48[   %2d]=%01x:-", IOdly_out_shf, IOdly_out);
+		} 
+		else {
+			PRINT(OUT_OBJ "Tx:SCU48[   %2d]=%01x: ", IOdly_out_shf, IOdly_out);
+		}
+	} else {
+		if (IOdly_out_reg == IOdly_out) {
+			PRINT(OUT_OBJ "Tx:SCU48[%2d:%2d]=%01x:-", IOdly_out_shf+3, IOdly_out_shf, IOdly_out);
+		} 
+		else {
+			PRINT(OUT_OBJ "Tx:SCU48[%2d:%2d]=%01x: ", IOdly_out_shf+3, IOdly_out_shf, IOdly_out);
+		}
+	}
+#endif
+} // void PrintIO_LineS (BYTE option)
+
+//------------------------------------------------------------
+void PrintIO_Line (BYTE option) {
+            
+    FILE_VAR
+    
+    GET_OBJ( option )
+    
+	if ( ( IOdly_in_reg == IOdly_in ) && ( IOdly_out_reg == IOdly_out ) ) {
+		if (dlymap[IOdly_i][IOdly_j]) PRINT(OUT_OBJ " X");
+		else                          PRINT(OUT_OBJ " O");
+	} 
+	else {
+		if (dlymap[IOdly_i][IOdly_j]) PRINT(OUT_OBJ " x");
+		else                          PRINT(OUT_OBJ " o");
+	}
+} // End void PrintIO_Line (BYTE option)
+
+//------------------------------------------------------------
+void PrintIO_Line_LOG (void) {
+#ifndef SLT_UBOOT      
+#ifdef Enable_Old_Style
+	if (Enable_RMII) fprintf(fp_log, "\nTx:SCU48[   %2d]=%2x, ", IOdly_out_shf, IOdly_out);
+	else             fprintf(fp_log, "\nTx:SCU48[%2d:%2d]=%2x, ", IOdly_out_shf+3, IOdly_out_shf, IOdly_out);
+
+	fprintf(fp_log, "Rx:SCU48[%2d:%2d]=%01x: ", IOdly_in_shf+3, IOdly_in_shf, IOdly_in);
+
+	if (dlymap[IOdly_i][IOdly_j]) fprintf(fp_log, " X\n");
+	else                          fprintf(fp_log, " O\n");
+#else
+	fprintf(fp_log, "\nRx:SCU48[%2d:%2d]=%2x, ", IOdly_in_shf+3, IOdly_in_shf, IOdly_in);
+
+	if (Enable_RMII) fprintf(fp_log, "Tx:SCU48[   %2d]=%01x: ", IOdly_out_shf, IOdly_out);
+	else             fprintf(fp_log, "Tx:SCU48[%2d:%2d]=%01x: ", IOdly_out_shf+3, IOdly_out_shf, IOdly_out);
+
+	if (dlymap[IOdly_i][IOdly_j]) fprintf(fp_log, " X\n");
+	else                          fprintf(fp_log, " O\n");
+#endif
+#endif    
+}
+
+//------------------------------------------------------------
+// main
+//------------------------------------------------------------
+void Calculate_LOOP_CheckNum (void) {
+    
+#define ONE_MBYTE    1048576
+
+  #ifdef CheckDataEveryTime
+	LOOP_CheckNum   = 1;
+  #else
+	if (IOTiming || IOTimingBund || (GSpeed == SET_1G_100M_10MBPS)) {
+		LOOP_CheckNum = LOOP_MAX;
+	} 
+	else {
+		switch ( GSpeed ) {
+			case SET_1GBPS    : CheckBuf_MBSize =  MOVE_DATA_MB_SEC      ; break; // 1G
+			case SET_100MBPS  : CheckBuf_MBSize = (MOVE_DATA_MB_SEC >> 3); break; // 100M ~ 1G / 8
+			case SET_10MBPS   : CheckBuf_MBSize = (MOVE_DATA_MB_SEC >> 6); break; // 10M  ~ 1G / 64
+		}
+		LOOP_CheckNum = ( CheckBuf_MBSize / ( ((DES_NUMBER * DMA_PakSize) / ONE_MBYTE ) + 1) );
+	}
+  #endif
+}
+
+//------------------------------------------------------------
+void TestingSetup (void) {
+	#ifdef  DbgPrn_FuncHeader
+	    printf ("TestingSetup\n"); 
+	    Debug_delay();
+    #endif
+
+  #ifdef SLT_UBOOT
+  #else
+    #ifdef Rand_Sed
+	srand((unsigned) Rand_Sed);
+    #else
+	srand((unsigned) timestart);
+    #endif
+  #endif              
+  
+    //[Disable VGA]--------------------
+    #ifdef Disable_VGA
+	if ( LOOP_INFINI & ~(BurstEnable || IOTiming) ) {
+		VGAModeVld = 1;
+		outp(0x3d4, 0x17);
+		VGAMode = inp(0x3d5);
+		outp(0x3d4, 0x17);
+		outp(0x3d5, 0);
+    }
+    #endif
+    
+    //[Setup]--------------------
+	setup_framesize();
+	setup_buf();
+}
+
+//------------------------------------------------------------
+// Return 1 ==> fail
+// Return 0 ==> PASS
+//------------------------------------------------------------
+char TestingLoop (ULONG loop_checknum) {
+    char	checkprd;
+    char	looplast;
+    char	checken;
+    
+    #ifdef SLT_UBOOT
+    #else
+        clock_t	timeold;
+    #endif
+
+	#ifdef  DbgPrn_FuncHeader
+	    printf ("TestingLoop: %d\n", Loop); 
+	    Debug_delay();
+    #endif
+	
+	if ( DbgPrn_DumpMACCnt ) 
+	    dump_mac_ROreg();
+
+	//[Setup]--------------------
+	Loop     = 0;
+	checkprd = 0;
+	checken  = 0;
+	looplast = 0;
+
+	setup_des( 0 );
+
+    #ifdef SLT_UBOOT
+    #else
+	timeold = clock();
+    #endif
+
+	while ( (Loop < LOOP_MAX) || LOOP_INFINI ) {
+		looplast = !LOOP_INFINI && (Loop == LOOP_MAX - 1);
+        
+        #ifdef CheckRxBuf
+		if (!BurstEnable) {
+			checkprd = ((Loop % loop_checknum) == (loop_checknum - 1));
+		}
+		checken = looplast | checkprd;
+        #endif
+    
+		if ( DataDelay & ( Loop == 0 ) ) {
+			printf ("Press any key to start...\n");
+			GET_CAHR();
+		}
+		
+#ifdef  DbgPrn_FuncHeader
+        if ( DbgPrn_BufAdr ) {
+            printf ("for start ======> %d/%d(%d) looplast:%d checkprd:%d checken:%d\n", Loop, LOOP_MAX, LOOP_INFINI, looplast, checkprd, checken); 
+            Debug_delay();
+        }
+#endif
+        
+		//[Check DES]--------------------
+		if ( check_des(Loop, checken) ) {
+		    //descriptor error
+            #ifdef CheckRxBuf
+			DES_NUMBER = CheckDesFail_DesNum + 1;
+			if ( checkprd ) {
+				check_buf(loop_checknum);
+			} 
+			else {
+				check_buf((LOOP_MAX % loop_checknum));
+			}
+			DES_NUMBER = DES_NUMBER_Org;
+            #endif
+
+			if (DbgPrn_DumpMACCnt) 
+			    dump_mac_ROreg();
+			    
+			return(1);
+		}
+
+		//[Check Buf]--------------------
+		if ( RxDataEnable && checken ) {
+            #ifdef SLT_UBOOT
+            #else
+            timeused = (clock() - timeold) / (double) CLK_TCK;
+            #endif
+			
+			if ( checkprd ) {
+                #ifdef SLT_DOS
+                #else
+                  #ifdef SLT_UBOOT
+                  #else
+                printf("[run loop:%3d] BandWidth: %7.2f Mbps, %6.2f sec\n", loop_checknum, ((double)loop_checknum * (double)DES_NUMBER * Avg_frame_len * 8.0) / ((double)timeused * 1000000.0), timeused);
+                fprintf(fp_log, "[run loop:%3d] BandWidth: %7.2f Mbps, %6.2f sec\n", loop_checknum, ((double)loop_checknum * (double)DES_NUMBER * Avg_frame_len * 8.0) / ((double)timeused * 1000000.0), timeused);
+                  #endif
+                #endif
+                
+                #ifdef CheckRxBuf
+                if ( check_buf( loop_checknum ) ) 
+                    return(1);
+                #endif
+			} 
+			else {
+                #ifdef SLT_DOS
+                #else
+                  #ifdef SLT_UBOOT
+                  #else
+                printf("[run loop:%3d] BandWidth: %7.2f Mbps, %6.2f sec\n", (LOOP_MAX % loop_checknum), ((double)(LOOP_MAX % loop_checknum) * (double)DES_NUMBER * Avg_frame_len * 8.0) / ((double)timeused * 1000000.0), timeused);
+                fprintf(fp_log, "[run loop:%3d] BandWidth: %7.2f Mbps, %6.2f sec\n", (LOOP_MAX % loop_checknum), ((double)(LOOP_MAX % loop_checknum) * (double)DES_NUMBER * Avg_frame_len * 8.0) / ((double)timeused * 1000000.0), timeused);
+                  #endif
+                #endif
+                
+                #ifdef CheckRxBuf
+                if ( check_buf( ( LOOP_MAX % loop_checknum ) ) ) 
+                    return(1);                
+                #endif
+			} // End if ( checkprd )
+            
+            #ifdef SelectSimpleDes
+            #else
+            if ( !looplast ) 
+                setup_des_loop( Loop );
+            #endif
+
+            #ifdef SLT_DOS
+            #else
+              #ifdef SLT_UBOOT
+              #else
+        	timeold = clock();
+              #endif
+            #endif
+
+		} // End if ( RxDataEnable && checken )
+		
+        #ifdef SelectSimpleDes
+		if ( !looplast ) 
+		    setup_des_loop( Loop );
+        #endif
+        
+		if ( LOOP_INFINI ) {
+			    printf("===============> Loop: %d  \r", Loop);
+		} 
+		else if (TestMode == 0) {
+			if (!(DbgPrn_BufAdr || IOTimingBund)) 
+			    printf(" %d                        \r", Loop);
+//			switch (Loop % 4) {
+//				case 0x00: printf("| %d                        \r", Loop); break;
+//				case 0x01: printf("/ %d                        \r", Loop); break;
+//				case 0x02: printf("- %d                        \r", Loop); break;
+//				default  : printf("\ %d                        \r", Loop); break;
+//			}
+		}
+
+        if ( DbgPrn_BufAdr ) {
+            printf ("for end   ======> %d/%d(%d)\n", Loop, LOOP_MAX, LOOP_INFINI); 
+            Debug_delay();
+        }
+
+		Loop++;
+	}  // End while ((Loop < LOOP_MAX) || LOOP_INFINI)
+	
+	Loop_rl[GSpeed_idx] = Loop;
+	
+	return(0);
+} // End char TestingLoop (ULONG loop_checknum)
+
+
diff --git a/arch/arm/cpu/arm926ejs/aspeed/Makefile b/arch/arm/cpu/arm926ejs/aspeed/Makefile
new file mode 100644
index 0000000..378745e
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/aspeed/Makefile
@@ -0,0 +1,53 @@
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(SOC).a
+
+COBJS	= timer.o
+COBJS	+= reset.o
+COBJS	+= mactest.o
+COBJS	+= DRAM_SPI.o
+COBJS	+= IO.o
+COBJS	+= LIB.o
+COBJS	+= MAC.o
+COBJS	+= NCSI.o
+COBJS	+= PCI_SPI.o
+COBJS	+= PHY.o
+COBJS	+= SPIM.o
+COBJS	+= STDUBOOT.o
+COBJS	+= PLLTESTU.o
+COBJS	+= TRAPTEST.o
+COBJS	+= STRESS.o
+
+SRCS	:= $(START:.o=.S) $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS) $(SOBJS))
+START	:= $(addprefix $(obj),$(START))
+
+all:	$(obj).depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/arch/arm/cpu/arm926ejs/aspeed/NCSI.H b/arch/arm/cpu/arm926ejs/aspeed/NCSI.H
new file mode 100644
index 0000000..a0e448b
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/aspeed/NCSI.H
@@ -0,0 +1,189 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef NCSI_H
+#define NCSI_H
+
+#include "TYPEDEF.H"
+
+//---------------------------------------------------------
+// Define
+//---------------------------------------------------------
+#define MAX_PACKAGE_NUM                         8      // 1 ~ 8
+#define MAX_CHANNEL_NUM                         4      // 1 ~ 32
+//#define Enable_NCSI_LOOP_INFINI             //[off]
+
+//---------------------------------------------------------
+// Function
+//---------------------------------------------------------
+#define SENT_RETRY_COUNT                      1
+#define NCSI_RxDESNum                         50
+
+//#define NCSI_Skip_Phase1_DeSelectPackage
+//#define NCSI_Skip_DeSelectPackage
+//#define NCSI_Skip_DiSChannel
+//#define NCSI_EnableDelay_DeSelectPackage
+//#define NCSI_EnableDelay_GetLinkStatus
+//#define NCSI_EnableDelay_EachPackage
+//#define Print_Version_ID
+//#define Print_PackageName
+
+//---------------------------------------------------------
+// PCI DID/VID & Manufacturer ID
+//---------------------------------------------------------
+#define ManufacturerID_Intel                  0x00000157     //343
+#define ManufacturerID_Broadcom               0x0000113d     //4413
+#define ManufacturerID_Mellanox               0x000002c9     //713
+
+//PCI VID: [163c]intel
+//PCI VID: [8086]Intel Corporation
+//PCI VID: [8087]Intel
+//PCI VID: [14e4]Broadcom Corporation
+//PCI VID: [15b3]Mellanox
+#define PCI_DID_VID_Intel_82574L              0x10d38086     // IntelR 82574L Gigabit Ethernet Controller
+#define PCI_DID_VID_Intel_82575_10d6          0x10d68086     // 82566 DM-2-gigabyte
+#define PCI_DID_VID_Intel_82575_10a7          0x10a78086     // 82575EB Gigabit Network Connection
+#define PCI_DID_VID_Intel_82575_10a9          0x10a98086     // 82575EB Gigabit Network Connection
+#define PCI_DID_VID_Intel_82576_10c9          0x10c98086     //*82576 Gigabit ET Dual Port Server Adapter
+#define PCI_DID_VID_Intel_82576_10e6          0x10e68086     // 82576 Gigabit Network Connection
+#define PCI_DID_VID_Intel_82576_10e7          0x10e78086     // 82576 Gigabit Network Connection
+#define PCI_DID_VID_Intel_82576_10e8          0x10e88086     // E64750-xxx Intel Gigabit ET Quad Port Server Adapter
+#define PCI_DID_VID_Intel_82576_1518          0x15188086     // 82576NS SerDes Gigabit Network Connectio
+#define PCI_DID_VID_Intel_82576_1526          0x15268086     // Intel Gigabit ET2 Quad Port Server Adapter
+#define PCI_DID_VID_Intel_82576_150a          0x150a8086     // 82576NS Gigabit Ethernet Controller
+#define PCI_DID_VID_Intel_82576_150d          0x150d8086     // 82576 Gigabit Backplane Connection
+#define PCI_DID_VID_Intel_82599_10fb          0x10fb8086     // 10 Gb Ethernet controller
+#define PCI_DID_VID_Intel_82599_1557          0x15578086     //
+#define PCI_DID_VID_Intel_I350_1521           0x15218086     //
+#define PCI_DID_VID_Intel_I350_1523           0x15238086     //
+#define PCI_DID_VID_Intel_I210                0x15338086     //
+#define PCI_DID_VID_Intel_X540                0x15288086     //
+#define PCI_DID_VID_Broadcom_BCM5718          0x165614e4     //
+#define PCI_DID_VID_Broadcom_BCM5720          0x165f14e4     //
+#define PCI_DID_VID_Broadcom_BCM5725          0x164314e4     //
+#define PCI_DID_VID_Mellanox_ConnectX_3       0x100315b3     //*
+
+//---------------------------------------------------------
+// Delay (ms)
+//---------------------------------------------------------
+#define Delay_EachPackage                     1000
+#define Delay_DeSelectPackage                 50
+#define Delay_GetLinkStatus                   50
+
+//---------------------------------------------------------
+// NCSI Parameter
+//---------------------------------------------------------
+//Command and Response Type
+#define CLEAR_INITIAL_STATE                   0x00           //M
+#define SELECT_PACKAGE                        0x01           //M
+#define DESELECT_PACKAGE                      0x02           //M
+#define ENABLE_CHANNEL                        0x03           //M
+#define DISABLE_CHANNEL                       0x04           //M
+#define RESET_CHANNEL                         0x05           //M
+#define ENABLE_CHANNEL_NETWORK_TX             0x06           //M
+#define DISABLE_CHANNEL_NETWORK_TX            0x07           //M
+#define AEN_ENABLE                            0x08
+#define SET_LINK                              0x09           //M
+#define GET_LINK_STATUS                       0x0A           //M
+#define SET_VLAN_FILTER                       0x0B           //M
+#define ENABLE_VLAN                           0x0C           //M
+#define DISABLE_VLAN                          0x0D           //M
+#define SET_MAC_ADDRESS                       0x0E           //M
+#define ENABLE_BROADCAST_FILTERING            0x10           //M
+#define DISABLE_BROADCAST_FILTERING           0x11           //M
+#define ENABLE_GLOBAL_MULTICAST_FILTERING     0x12
+#define DISABLE_GLOBAL_MULTICAST_FILTERING    0x13
+#define SET_NCSI_FLOW_CONTROL                 0x14
+#define GET_VERSION_ID                        0x15           //M
+#define GET_CAPABILITIES                      0x16           //M
+#define GET_PARAMETERS                        0x17           //M
+#define GET_CONTROLLER_PACKET_STATISTICS      0x18
+#define GET_NCSI_STATISTICS                   0x19
+#define GET_NCSI_PASS_THROUGH_STATISTICS      0x1A
+
+//Standard Response Code
+#define COMMAND_COMPLETED                     0x00
+#define COMMAND_FAILED                        0x01
+#define COMMAND_UNAVAILABLE                   0x02
+#define COMMAND_UNSUPPORTED                   0x03
+
+//Standard Reason Code
+#define NO_ERROR                              0x0000
+#define INTERFACE_INITIALIZATION_REQUIRED     0x0001
+#define PARAMETER_IS_INVALID                  0x0002
+#define CHANNEL_NOT_READY                     0x0003
+#define PACKAGE_NOT_READY                     0x0004
+#define INVALID_PAYLOAD_LENGTH                0x0005
+#define UNKNOWN_COMMAND_TYPE                  0x7FFF
+
+//SET_MAC_ADDRESS
+#define UNICAST                               ( 0x00 << 5 )
+#define MULTICAST                             ( 0x01 << 5 )
+#define DISABLE_MAC_ADDRESS_FILTER            0x00
+#define ENABLE_MAC_ADDRESS_FILTER             0x01
+
+//GET_LINK_STATUS
+#define LINK_DOWN                             0
+#define LINK_UP                               1
+
+#define NCSI_RxDMA_PakSize                    2048
+#define NCSI_RxDMA_BASE                       (DMA_BASE+0x00100000)
+
+//---------------------------------------------------------
+// Variable
+//---------------------------------------------------------
+//NC-SI Command Packet
+typedef struct {
+//Ethernet Header
+    unsigned char  DA[6];                    // Destination Address
+    unsigned char  SA[6];                    // Source Address
+    unsigned short EtherType;                // DMTF NC-SI, it should be 0x88F8
+//NC-SI Control Packet
+    unsigned char  MC_ID;                    // Management Controller should set this field to 0x00
+    unsigned char  Header_Revision;          // For NC-SI 1.0 spec, this field has to set 0x01
+    unsigned char  Reserved_1;               // Reserved has to set to 0x00
+    unsigned char  IID;                      // Instance ID
+    unsigned char  Command;
+    unsigned char  Channel_ID;
+    unsigned short Payload_Length;           // Payload Length = 12 bits, 4 bits are reserved
+    unsigned long  Reserved_2;
+    unsigned long  Reserved_3;
+
+    unsigned short  Reserved_4;
+    unsigned short  Reserved_5;
+    unsigned short  Response_Code;
+    unsigned short  Reason_Code;
+    unsigned char   Payload_Data[64];
+}  NCSI_Command_Packet;
+
+//NC-SI Response Packet
+typedef struct {
+    unsigned char  DA[6];
+    unsigned char  SA[6];
+    unsigned short EtherType;                //DMTF NC-SI
+//NC-SI Control Packet
+    unsigned char  MC_ID;                    //Management Controller should set this field to 0x00
+    unsigned char  Header_Revision;          //For NC-SI 1.0 spec, this field has to set 0x01
+    unsigned char  Reserved_1;               //Reserved has to set to 0x00
+    unsigned char  IID;                      //Instance ID
+    unsigned char  Command;
+    unsigned char  Channel_ID;
+    unsigned short Payload_Length;           //Payload Length = 12 bits, 4 bits are reserved
+    unsigned short  Reserved_2;
+    unsigned short  Reserved_3;
+    unsigned short  Reserved_4;
+    unsigned short  Reserved_5;
+
+    unsigned short  Response_Code;
+    unsigned short  Reason_Code;
+    unsigned char   Payload_Data[64];
+}  NCSI_Response_Packet;
+
+#endif // NCSI_H
diff --git a/arch/arm/cpu/arm926ejs/aspeed/NCSI.c b/arch/arm/cpu/arm926ejs/aspeed/NCSI.c
new file mode 100644
index 0000000..7de06c3
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/aspeed/NCSI.c
@@ -0,0 +1,934 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#define NCSI_C
+static const char ThisFile[] = "NCSI.c";
+
+#include "SWFUNC.H"
+
+#ifdef SLT_UBOOT
+  #include <common.h>
+  #include <command.h>
+  #include <COMMINF.H>
+  #include <NCSI.H>
+  #include <IO.H>
+#endif
+#ifdef SLT_DOS
+  #include <stdio.h>
+  #include <stdlib.h>
+  #include <conio.h>
+  #include <string.h>
+  #include "COMMINF.H"
+  #include "NCSI.H"
+  #include "IO.H"
+#endif
+
+NCSI_Command_Packet     NCSI_Request_SLT;
+NCSI_Response_Packet    NCSI_Respond_SLT;
+int             InstanceID;
+int             NCSI_RxTimeOutScale;
+ULONG           NCSI_RxDesBase;
+ULONG           NCSI_TxDWBUF[512];
+ULONG           NCSI_RxDWBUF[512];
+char            NCSI_CommandStr[512];
+unsigned char   *NCSI_TxByteBUF;
+unsigned char   *NCSI_RxByteBUF;
+unsigned char   NCSI_Payload_Data[16];
+unsigned long   Payload_Checksum_NCSI = 0x00000000;
+ULONG           select_flag[MAX_PACKAGE_NUM];
+
+ULONG DWSwap_SLT (ULONG in) {
+	return( ((in & 0xff000000) >> 24)
+	      | ((in & 0x00ff0000) >>  8)
+	      | ((in & 0x0000ff00) <<  8)
+	      | ((in & 0x000000ff) << 24)
+	      );
+}
+USHORT WDSwap_SLT (USHORT in) {
+	return( ((in & 0xff00) >>  8)
+	      | ((in & 0x00ff) <<  8)
+	      );
+}
+
+//------------------------------------------------------------
+int FindErr_NCSI (int value) {
+	NCSI_LinkFail_Val = NCSI_LinkFail_Val | value;
+	Err_Flag          = Err_Flag | Err_NCSI_LinkFail;
+	if ( DbgPrn_ErrFlg ) 
+	    printf ("\nErr_Flag: [%08lx] NCSI_LinkFail_Val: [%08lx]\n", Err_Flag, NCSI_LinkFail_Val);
+
+	return(1);
+}
+
+//------------------------------------------------------------
+// PHY IC(NC-SI)
+//------------------------------------------------------------
+void ncsi_respdump ( NCSI_Response_Packet *in ) {
+    printf ("DA             : %02x %02x %02x %02x %02x %02x\n", in->DA[5], in->DA[4], in->DA[3], in->DA[2], in->DA[1], in->DA[0]);
+    printf ("SA             : %02x %02x %02x %02x %02x %02x\n", in->SA[5], in->SA[4], in->SA[3], in->SA[2], in->SA[1], in->SA[0]);
+    printf ("EtherType      : %04x\n", in->EtherType       );//DMTF NC-SI
+    printf ("MC_ID          : %02x\n", in->MC_ID           );//Management Controller should set this field to 0x00
+    printf ("Header_Revision: %02x\n", in->Header_Revision );//For NC-SI 1.0 spec, this field has to set 0x01
+//  printf ("Reserved_1     : %02x\n", in->Reserved_1      ); //Reserved has to set to 0x00
+    printf ("IID            : %02x\n", in->IID             );//Instance ID
+    printf ("Command        : %02x\n", in->Command         );
+    printf ("Channel_ID     : %02x\n", in->Channel_ID      );
+    printf ("Payload_Length : %04x\n", in->Payload_Length  );//Payload Length = 12 bits, 4 bits are reserved
+//  printf ("Reserved_2     : %04x\n", in->Reserved_2      );
+//  printf ("Reserved_3     : %04x\n", in->Reserved_3      );
+//  printf ("Reserved_4     : %04x\n", in->Reserved_4      );
+//  printf ("Reserved_5     : %04x\n", in->Reserved_5      );
+    printf ("Response_Code  : %04x\n", in->Response_Code   );
+    printf ("Reason_Code    : %04x\n", in->Reason_Code     );
+    printf ("Payload_Data   : %02x%02x%02x%02x\n", in->Payload_Data[ 3], in->Payload_Data[ 2], in->Payload_Data[ 1], in->Payload_Data[ 0]);
+//  printf ("Payload_Data   : %02x%02x%02x%02x\n", in->Payload_Data[ 7], in->Payload_Data[ 6], in->Payload_Data[ 5], in->Payload_Data[ 4]);
+//  printf ("Payload_Data   : %02x%02x%02x%02x\n", in->Payload_Data[11], in->Payload_Data[10], in->Payload_Data[ 9], in->Payload_Data[ 8]);
+//  printf ("Payload_Data   : %02x%02x%02x%02x\n", in->Payload_Data[15], in->Payload_Data[14], in->Payload_Data[13], in->Payload_Data[12]);
+//  printf ("Payload_Data   : %02x%02x%02x%02x\n", in->Payload_Data[19], in->Payload_Data[18], in->Payload_Data[17], in->Payload_Data[16]);
+//  printf ("Payload_Data   : %02x%02x%02x%02x\n", in->Payload_Data[23], in->Payload_Data[22], in->Payload_Data[21], in->Payload_Data[20]);
+}
+
+//------------------------------------------------------------
+void NCSI_Struct_Initialize_SLT (void) {
+    int i;
+
+    ULONG    NCSI_RxDatBase;
+
+    InstanceID = 0;
+    NCSI_RxTimeOutScale = 1;
+
+    for (i = 0; i < 6; i++) {
+        NCSI_Request_SLT.DA[i] = 0xFF;
+    }
+
+    for (i = 0; i < 6; i++) {
+//      NCSI_Request.SA[i] = i<<2;
+        NCSI_Request_SLT.SA[i] = SA[i];
+    }
+
+    NCSI_Request_SLT.EtherType       = WDSwap_SLT(0x88F8); // EtherType = 0x88F8 (DMTF NC-SI) page 50, table 8, NC-SI spec. version 1.0.0
+    NCSI_Request_SLT.MC_ID           = 0;
+    NCSI_Request_SLT.Header_Revision = 0x01;
+    NCSI_Request_SLT.Reserved_1      = 0;
+    NCSI_Request_SLT.Reserved_2      = 0;
+    NCSI_Request_SLT.Reserved_3      = 0;
+
+    NCSI_TxByteBUF = (unsigned char *) &NCSI_TxDWBUF[0];
+    NCSI_RxByteBUF = (unsigned char *) &NCSI_RxDWBUF[0];
+
+    NCSI_RxDesBase = H_RDES_BASE;
+    NCSI_RxDatBase = NCSI_RxDMA_BASE;
+    
+    for (i = 0; i < NCSI_RxDESNum - 1; i++) {
+        WriteSOC_DD( ( NCSI_RxDesBase +  0 ), 0x00000000     );
+        WriteSOC_DD( ( NCSI_RxDesBase +  4 ), 0x00000000     );
+        WriteSOC_DD( ( NCSI_RxDesBase +  8 ), 0x00000000     );
+        WriteSOC_DD( ( NCSI_RxDesBase + 0x0C ), (NCSI_RxDatBase + CPU_BUS_ADDR_SDRAM_OFFSET) ); // 20130730
+        NCSI_RxDesBase += 16;
+        NCSI_RxDatBase += NCSI_RxDMA_PakSize;
+    }
+    WriteSOC_DD( ( NCSI_RxDesBase +  0 ), EOR_IniVal     );
+    WriteSOC_DD( ( NCSI_RxDesBase +  4 ), 0x00000000     );
+    WriteSOC_DD( ( NCSI_RxDesBase +  8 ), 0x00000000     );
+    WriteSOC_DD( ( NCSI_RxDesBase + 0x0C ), (NCSI_RxDatBase + CPU_BUS_ADDR_SDRAM_OFFSET) ); // 20130730
+
+    NCSI_RxDesBase = H_RDES_BASE;
+}
+
+//------------------------------------------------------------
+void Calculate_Checksum_NCSI (unsigned char *buffer_base, int Length) {
+    ULONG	CheckSum = 0;   
+    ULONG	Data;
+    ULONG	Data1;
+    int     i;
+    
+    // Calculate checksum is from byte 14 of ethernet Haeder and Control packet header
+    // Page 50, NC-SI spec. ver. 1.0.0 form DMTF
+    for (i = 14; i < Length; i += 2 ) {
+        Data      = buffer_base[i];
+        Data1     = buffer_base[i + 1];
+        CheckSum += ((Data << 8) + Data1);
+    }
+    Payload_Checksum_NCSI = DWSwap_SLT(~(CheckSum) + 1); //2's complement
+}
+
+//------------------------------------------------------------
+// return 0: it is PASS
+// return 1: it is FAIL
+//------------------------------------------------------------
+char NCSI_Rx_SLT (unsigned char command) {
+    
+#define NCSI_RX_RETRY_TIME  2    
+    int     timeout = 0;
+    int	    bytesize;
+    int	    dwsize;
+    int     i;
+    int     retry   = 0;
+    char    ret     = 1;
+
+    ULONG   NCSI_RxDatBase;
+    ULONG   NCSI_RxDesDat;
+    ULONG   NCSI_RxData;
+
+    
+    do {
+        WriteSOC_DD( ( H_MAC_BASE + 0x1C ), 0x00000000 );//Rx Poll
+        
+        do {
+            NCSI_RxDesDat = ReadSOC_DD(NCSI_RxDesBase);
+            if ( ++timeout > TIME_OUT_NCSI * NCSI_RxTimeOutScale ) {
+                #ifdef SLT_DOS
+                fprintf(fp_log, "[Cmd:%02X][NCSI-RxDesOwn] %08lX \n", command, NCSI_RxDesDat );
+                #endif
+                return( FindErr(Err_NCSI_Check_RxOwnTimeOut) );
+            }
+        } while( HWOwnRx(NCSI_RxDesDat) );
+        
+        #ifdef CheckRxErr
+        if (NCSI_RxDesDat & 0x00040000) {
+            #ifdef SLT_DOS
+            fprintf(fp_log, "[RxDes] Error RxErr        %08lx\n", NCSI_RxDesDat);
+            #endif
+            FindErr_Des(Check_Des_RxErr);
+        }
+        #endif
+        
+        #ifdef CheckOddNibble
+        if (NCSI_RxDesDat & 0x00400000) {
+            #ifdef SLT_DOS
+            fprintf(fp_log, "[RxDes] Odd Nibble         %08lx\n", NCSI_RxDesDat);
+            #endif
+            FindErr_Des(Check_Des_OddNibble);
+        }
+        #endif
+        
+        #ifdef CheckCRC
+        if (NCSI_RxDesDat & 0x00080000) {
+            #ifdef SLT_DOS
+            fprintf(fp_log, "[RxDes] Error CRC          %08lx\n", NCSI_RxDesDat);
+            #endif
+            FindErr_Des(Check_Des_CRC);
+        }
+        #endif
+        
+        #ifdef CheckRxFIFOFull
+        if (NCSI_RxDesDat & 0x00800000) {
+            #ifdef SLT_DOS
+            fprintf(fp_log, "[RxDes] Error Rx FIFO Full %08lx\n", NCSI_RxDesDat);
+            #endif
+            FindErr_Des(Check_Des_RxFIFOFull);
+        }
+        #endif
+        
+        // Get point of RX DMA buffer
+        NCSI_RxDatBase = ReadSOC_DD( NCSI_RxDesBase + 0x0C );
+        NCSI_RxData    = ReadSOC_DD( NCSI_RxDatBase + 0x0C );
+        
+        if ( HWEOR( NCSI_RxDesDat ) ) {
+            // it is last the descriptor in the receive Ring
+            WriteSOC_DD( NCSI_RxDesBase     , EOR_IniVal    );
+            NCSI_RxDesBase  = H_RDES_BASE;
+        } 
+        else {
+            WriteSOC_DD( NCSI_RxDesBase     , 0x00000000    );
+            NCSI_RxDesBase += 16;
+        }
+        
+        // Get RX valid data in offset 00h of RXDS#0
+        bytesize  = (NCSI_RxDesDat & 0x3fff);
+        
+        // Fill up to multiple of 4
+        if ( ( bytesize % 4 ) != 0 )
+            dwsize = ( bytesize >> 2 ) + 1;
+        else
+            dwsize = bytesize >> 2;
+        
+        #ifdef SLT_DOS
+        if ( PrintNCSIEn ) 
+            fprintf(fp_log ,"[Rx] %d bytes(%xh)\n", bytesize, bytesize);
+        #endif
+        
+        for (i = 0; i < dwsize; i++) {
+            NCSI_RxDWBUF[i] = ReadSOC_DD(NCSI_RxDatBase + ( i << 2 ));
+            if ( PrintNCSIEn ) {
+                if ( i == ( dwsize - 1 ) ) {
+                    switch (bytesize % 4) {
+                        case 0  : NCSI_RxDWBUF[i] = NCSI_RxDWBUF[i] & 0xffffffff; break;
+                        case 3  : NCSI_RxDWBUF[i] = NCSI_RxDWBUF[i] & 0xffffff  ; break;
+                        case 2  : NCSI_RxDWBUF[i] = NCSI_RxDWBUF[i] & 0xffff    ; break;
+                        case 1  : NCSI_RxDWBUF[i] = NCSI_RxDWBUF[i] & 0xff      ; break;
+                    }
+                    #ifdef SLT_DOS
+                    switch (bytesize % 4) {
+                        case 0  : fprintf(fp_log ,"[Rx%02d]%08lx %08lx\n",             i, NCSI_RxDWBUF[i], DWSwap_SLT(NCSI_RxDWBUF[i])       ); break;
+                        case 3  : fprintf(fp_log ,"[Rx%02d]--%06lx %06lx--\n",         i, NCSI_RxDWBUF[i], DWSwap_SLT(NCSI_RxDWBUF[i]) >>  8 ); break;
+                        case 2  : fprintf(fp_log ,"[Rx%02d]----%04lx %04lx----\n",     i, NCSI_RxDWBUF[i], DWSwap_SLT(NCSI_RxDWBUF[i]) >> 16 ); break;
+                        case 1  : fprintf(fp_log ,"[Rx%02d]------%02lx %02lx------\n", i, NCSI_RxDWBUF[i], DWSwap_SLT(NCSI_RxDWBUF[i]) >> 24 ); break;
+                        default : fprintf(fp_log ,"[Rx%02d]error", i); break;
+                    }
+                    #endif
+                } 
+                else {
+                    #ifdef SLT_DOS
+                    fprintf(fp_log ,"[Rx%02d]%08lx %08lx\n", i, NCSI_RxDWBUF[i], DWSwap_SLT(NCSI_RxDWBUF[i]));
+                    #endif
+                }
+            }
+        } // End for (i = 0; i < dwsize; i++)
+        
+        // EtherType field of the response packet should be 0x88F8 
+        if ((NCSI_RxData & 0xffff) == 0xf888) {
+            memcpy (&NCSI_Respond_SLT, NCSI_RxByteBUF, bytesize);
+            
+            #ifdef SLT_DOS
+            if ( PrintNCSIEn ) 
+                fprintf(fp_log ,"[Rx IID:%2d]\n", NCSI_Respond_SLT.IID);
+            #endif
+            
+            NCSI_Respond_SLT.EtherType      = WDSwap_SLT( NCSI_Respond_SLT.EtherType      );
+            NCSI_Respond_SLT.Payload_Length = WDSwap_SLT( NCSI_Respond_SLT.Payload_Length );
+            NCSI_Respond_SLT.Response_Code  = WDSwap_SLT( NCSI_Respond_SLT.Response_Code  );
+            NCSI_Respond_SLT.Reason_Code    = WDSwap_SLT( NCSI_Respond_SLT.Reason_Code    );
+            
+            ret = 0;
+            break;
+        } 
+        else {
+            #ifdef SLT_DOS
+            if ( PrintNCSIEn ) 
+                fprintf(fp_log, "[Skip] Not NCSI Response: %08lx\n", NCSI_RxData);
+            #endif
+                
+            retry++;
+        }
+    } while ( retry < NCSI_RX_RETRY_TIME );
+
+    return( ret );
+} // End char NCSI_Rx_SLT (void)
+
+//------------------------------------------------------------
+char NCSI_Tx (void) {
+    int	   bytesize;
+    int	   dwsize;
+    int    i;
+    int    timeout = 0;
+    ULONG  NCSI_TxDesDat;
+    
+    // Header of NC-SI command format is 34 bytes. page 58, NC-SI spec. ver 1.0.0 from DMTF
+    // The minimum size of a NC-SI package is 64 bytes.
+    bytesize = 34 + WDSwap_SLT(NCSI_Request_SLT.Payload_Length);
+    if ( bytesize < 64 ) {
+        memset (NCSI_TxByteBUF + bytesize, 0, 60 - bytesize);
+        bytesize = 64;
+    }
+    
+    // Fill up to multiple of 4
+//    dwsize = (bytesize + 3) >> 2;
+    if ( ( bytesize % 4 ) != 0 )
+        dwsize = ( bytesize >> 2 ) + 1;
+    else
+        dwsize = bytesize >> 2;
+    
+    #ifdef SLT_DOS
+    if ( PrintNCSIEn ) 
+        fprintf(fp_log ,"[Tx IID:%2d] %d bytes(%xh)\n", NCSI_Request_SLT.IID, bytesize, bytesize);
+    #endif
+    
+    // Copy data to DMA buffer
+    for (i = 0; i < dwsize; i++) {
+        WriteSOC_DD( DMA_BASE + (i << 2), NCSI_TxDWBUF[i] );
+        if ( PrintNCSIEn ) {
+            if (i == (dwsize - 1)) {
+                switch (bytesize % 4) {
+                    case 0  : NCSI_TxDWBUF[i] = NCSI_TxDWBUF[i] & 0xffffffff; break;
+                    case 3  : NCSI_TxDWBUF[i] = NCSI_TxDWBUF[i] & 0x00ffffff; break;
+                    case 2  : NCSI_TxDWBUF[i] = NCSI_TxDWBUF[i] & 0x0000ffff; break;
+                    case 1  : NCSI_TxDWBUF[i] = NCSI_TxDWBUF[i] & 0x000000ff; break;
+                }
+                #ifdef SLT_DOS
+                switch (bytesize % 4) {
+                    case 0  : fprintf(fp_log ,"[Tx%02d]%08x %08x\n",             i, NCSI_TxDWBUF[i], DWSwap_SLT( NCSI_TxDWBUF[i])       ); break;
+                    case 3  : fprintf(fp_log ,"[Tx%02d]--%06x %06x--\n",         i, NCSI_TxDWBUF[i], DWSwap_SLT( NCSI_TxDWBUF[i]) >>  8 ); break;
+                    case 2  : fprintf(fp_log ,"[Tx%02d]----%04x %04x----\n",     i, NCSI_TxDWBUF[i], DWSwap_SLT( NCSI_TxDWBUF[i]) >> 16 ); break;
+                    case 1  : fprintf(fp_log ,"[Tx%02d]------%02x %02x------\n", i, NCSI_TxDWBUF[i], DWSwap_SLT( NCSI_TxDWBUF[i]) >> 24 ); break;
+                    default : fprintf(fp_log ,"[Tx%02d]error", i); break;
+                }
+                #endif
+            } 
+            else {
+                #ifdef SLT_DOS
+                fprintf( fp_log , "[Tx%02d]%08x %08x\n", i, NCSI_TxDWBUF[i], DWSwap_SLT(NCSI_TxDWBUF[i]) );
+                #endif
+            }
+        }
+    } // End for (i = 0; i < dwsize; i++)
+    
+    // Setting one TX descriptor
+    WriteSOC_DD( H_TDES_BASE + 0x04, 0                     );
+    WriteSOC_DD( H_TDES_BASE + 0x08, 0                     );
+    WriteSOC_DD( H_TDES_BASE + 0x0C, (DMA_BASE + CPU_BUS_ADDR_SDRAM_OFFSET)  ); // 20130730
+    WriteSOC_DD( H_TDES_BASE       , 0xf0008000 + bytesize );
+    // Fire             
+    WriteSOC_DD( H_MAC_BASE  + 0x18, 0x00000000            );//Tx Poll
+
+    do {
+        NCSI_TxDesDat = ReadSOC_DD(H_TDES_BASE);
+        if ( ++timeout > TIME_OUT_NCSI ) {
+            #ifdef SLT_DOS
+            fprintf(fp_log, "[NCSI-TxDesOwn] %08lx\n", NCSI_TxDesDat);
+            #endif
+            
+            return(FindErr(Err_NCSI_Check_TxOwnTimeOut));
+        }
+    } while ( HWOwnTx(NCSI_TxDesDat) );
+    
+    return(0);
+} // End char NCSI_Tx (void)
+
+//------------------------------------------------------------
+char NCSI_ARP (void) {
+    int    i;
+    int    timeout = 0;
+    ULONG  NCSI_TxDesDat;
+    
+    if ( ARPNumCnt ) {
+        #ifdef SLT_DOS
+        if ( PrintNCSIEn ) 
+            fprintf(fp_log ,"[ARP] 60 bytes x%d\n", ARPNumCnt);
+        #endif
+        
+        for (i = 0; i < 15; i++) {
+            #ifdef SLT_DOS
+            if ( PrintNCSIEn ) 
+                fprintf(fp_log ,"[Tx%02d] %08x %08x\n", i, ARP_data[i], DWSwap_SLT(ARP_data[i]));
+            #endif
+            WriteSOC_DD( DMA_BASE + ( i << 2 ), ARP_data[i] );
+        }
+        WriteSOC_DD( H_TDES_BASE + 0x04, 0               );
+        WriteSOC_DD( H_TDES_BASE + 0x08, 0               );
+        WriteSOC_DD( H_TDES_BASE + 0x0C, (DMA_BASE + CPU_BUS_ADDR_SDRAM_OFFSET)  ); // 20130730
+        WriteSOC_DD( H_TDES_BASE       , 0xf0008000 + 60 );
+
+        for (i = 0; i < ARPNumCnt; i++) {
+            WriteSOC_DD( H_TDES_BASE      , 0xf0008000 + 60);
+
+            WriteSOC_DD( H_MAC_BASE + 0x18, 0x00000000      );//Tx Poll
+
+            timeout = 0;
+            do {
+                NCSI_TxDesDat = ReadSOC_DD(H_TDES_BASE);
+                
+                if (++timeout > TIME_OUT_NCSI) {
+                    #ifdef SLT_DOS
+                    fprintf(fp_log, "[ARP-TxDesOwn] %08lx\n", NCSI_TxDesDat);
+                    #endif
+                    
+                    return(FindErr(Err_NCSI_Check_ARPOwnTimeOut));
+                }
+            } while (HWOwnTx(NCSI_TxDesDat));
+        }
+    }
+    return(0);
+} // End char NCSI_ARP (void)
+
+//------------------------------------------------------------
+void WrRequest (unsigned char command, unsigned char id, unsigned short length) {
+
+    NCSI_Request_SLT.IID            = InstanceID;
+    NCSI_Request_SLT.Command        = command;
+    NCSI_Request_SLT.Channel_ID     = id;
+    NCSI_Request_SLT.Payload_Length = WDSwap_SLT(length);
+
+    memcpy ( NCSI_TxByteBUF               , &NCSI_Request_SLT    , 30    );
+    memcpy ((NCSI_TxByteBUF + 30         ), &NCSI_Payload_Data    , length);
+    Calculate_Checksum_NCSI(NCSI_TxByteBUF, 30 + length);
+    memcpy ((NCSI_TxByteBUF + 30 + length), &Payload_Checksum_NCSI, 4     );
+}
+
+//------------------------------------------------------------
+void NCSI_PrintCommandStr (unsigned char command, unsigned iid) {
+    switch (command & 0x80) {
+        case 0x80   : sprintf(NCSI_CommandStr, "IID:%3d [%02x][Respond]", iid, command); break;
+        default     : sprintf(NCSI_CommandStr, "IID:%3d [%02x][Request]", iid, command); break;
+    }
+    switch (command & 0x7f) {
+        case 0x00   : sprintf(NCSI_CommandStr, "%s[CLEAR_INITIAL_STATE                ]", NCSI_CommandStr); break;
+        case 0x01   : sprintf(NCSI_CommandStr, "%s[SELECT_PACKAGE                     ]", NCSI_CommandStr); break;
+        case 0x02   : sprintf(NCSI_CommandStr, "%s[DESELECT_PACKAGE                   ]", NCSI_CommandStr); break;
+        case 0x03   : sprintf(NCSI_CommandStr, "%s[ENABLE_CHANNEL                     ]", NCSI_CommandStr); break;
+        case 0x04   : sprintf(NCSI_CommandStr, "%s[DISABLE_CHANNEL                    ]", NCSI_CommandStr); break;
+        case 0x05   : sprintf(NCSI_CommandStr, "%s[RESET_CHANNEL                      ]", NCSI_CommandStr); break;
+        case 0x06   : sprintf(NCSI_CommandStr, "%s[ENABLE_CHANNEL_NETWORK_TX          ]", NCSI_CommandStr); break;
+        case 0x07   : sprintf(NCSI_CommandStr, "%s[DISABLE_CHANNEL_NETWORK_TX         ]", NCSI_CommandStr); break;
+        case 0x08   : sprintf(NCSI_CommandStr, "%s[AEN_ENABLE                         ]", NCSI_CommandStr); break;
+        case 0x09   : sprintf(NCSI_CommandStr, "%s[SET_LINK                           ]", NCSI_CommandStr); break;
+        case 0x0A   : sprintf(NCSI_CommandStr, "%s[GET_LINK_STATUS                    ]", NCSI_CommandStr); break;
+        case 0x0B   : sprintf(NCSI_CommandStr, "%s[SET_VLAN_FILTER                    ]", NCSI_CommandStr); break;
+        case 0x0C   : sprintf(NCSI_CommandStr, "%s[ENABLE_VLAN                        ]", NCSI_CommandStr); break;
+        case 0x0D   : sprintf(NCSI_CommandStr, "%s[DISABLE_VLAN                       ]", NCSI_CommandStr); break;
+        case 0x0E   : sprintf(NCSI_CommandStr, "%s[SET_MAC_ADDRESS                    ]", NCSI_CommandStr); break;
+        case 0x10   : sprintf(NCSI_CommandStr, "%s[ENABLE_BROADCAST_FILTERING         ]", NCSI_CommandStr); break;
+        case 0x11   : sprintf(NCSI_CommandStr, "%s[DISABLE_BROADCAST_FILTERING        ]", NCSI_CommandStr); break;
+        case 0x12   : sprintf(NCSI_CommandStr, "%s[ENABLE_GLOBAL_MULTICAST_FILTERING  ]", NCSI_CommandStr); break;
+        case 0x13   : sprintf(NCSI_CommandStr, "%s[DISABLE_GLOBAL_MULTICAST_FILTERING ]", NCSI_CommandStr); break;
+        case 0x14   : sprintf(NCSI_CommandStr, "%s[SET_NCSI_FLOW_CONTROL              ]", NCSI_CommandStr); break;
+        case 0x15   : sprintf(NCSI_CommandStr, "%s[GET_VERSION_ID                     ]", NCSI_CommandStr); break;
+        case 0x16   : sprintf(NCSI_CommandStr, "%s[GET_CAPABILITIES                   ]", NCSI_CommandStr); break;
+        case 0x17   : sprintf(NCSI_CommandStr, "%s[GET_PARAMETERS                     ]", NCSI_CommandStr); break;
+        case 0x18   : sprintf(NCSI_CommandStr, "%s[GET_CONTROLLER_PACKET_STATISTICS   ]", NCSI_CommandStr); break;
+        case 0x19   : sprintf(NCSI_CommandStr, "%s[GET_NCSI_STATISTICS                ]", NCSI_CommandStr); break;
+        case 0x1A   : sprintf(NCSI_CommandStr, "%s[GET_NCSI_PASS_THROUGH_STATISTICS   ]", NCSI_CommandStr); break;
+        case 0x50   : sprintf(NCSI_CommandStr, "%s[OEM_COMMAND                        ]", NCSI_CommandStr); break;
+        default     : sprintf(NCSI_CommandStr, "%s Not Support Command", NCSI_CommandStr); break ;
+    }
+} // End void NCSI_PrintCommandStr (unsigned char command, unsigned iid)
+
+//------------------------------------------------------------
+void NCSI_PrintCommandType (unsigned char command, unsigned iid) {
+    NCSI_PrintCommandStr(command, iid);
+    printf ("%s\n", NCSI_CommandStr);
+}
+
+//------------------------------------------------------------
+void NCSI_PrintCommandType2File (unsigned char command, unsigned iid) {
+    NCSI_PrintCommandStr(command, iid);
+    #ifdef SLT_DOS
+    fprintf(fp_log, "%s\n", NCSI_CommandStr);
+    #endif
+}
+
+//------------------------------------------------------------
+char NCSI_SentWaitPacket (unsigned char command, unsigned char id, unsigned short length) {
+    int     Retry = 0;
+    char    ret;
+    
+    do {
+        InstanceID++;
+        WrRequest(command, id, length);
+
+        ret = NCSI_Tx();        if ( ret != 0 ) 
+        {
+            // printf("======> NCSI_Tx return code = %X\n", ret );                  
+            return(1);
+        }            
+#ifdef Print_PackageName
+        NCSI_PrintCommandType(command, InstanceID);
+#endif
+
+#ifdef NCSI_EnableDelay_EachPackage
+        delay(Delay_EachPackage);
+#endif
+        if ( NCSI_Rx_SLT( command ) ) 
+            return(2);
+        
+        #ifdef SLT_DOS
+        if ( PrintNCSIEn ) 
+            fprintf(fp_log, "[Request] ETyp:%04x MC_ID:%02x HeadVer:%02x IID:%02x Comm:%02x ChlID:%02x PayLen:%04x\n", WDSwap_SLT(NCSI_Request_SLT.EtherType), 
+                                                                                                                       NCSI_Request_SLT.MC_ID, 
+                                                                                                                       NCSI_Request_SLT.Header_Revision, 
+                                                                                                                       NCSI_Request_SLT.IID, 
+                                                                                                                       NCSI_Request_SLT.Command, 
+                                                                                                                       NCSI_Request_SLT.Channel_ID, 
+                                                                                                                       WDSwap_SLT(NCSI_Request_SLT.Payload_Length) );
+        if ( PrintNCSIEn ) 
+            fprintf(fp_log, "[Respond] ETyp:%04x MC_ID:%02x HeadVer:%02x IID:%02x Comm:%02x ChlID:%02x PayLen:%04x ResCd:%02x ReaCd:%02x\n",        
+                                                                                                                       NCSI_Respond_SLT.EtherType, 
+                                                                                                                       NCSI_Respond_SLT.MC_ID, 
+                                                                                                                       NCSI_Respond_SLT.Header_Revision, 
+                                                                                                                       NCSI_Respond_SLT.IID, 
+                                                                                                                       NCSI_Respond_SLT.Command, 
+                                                                                                                       NCSI_Respond_SLT.Channel_ID,        
+                                                                                                                       NCSI_Respond_SLT.Payload_Length, 
+                                                                                                                       NCSI_Respond_SLT.Response_Code, 
+                                                                                                                       NCSI_Respond_SLT.Reason_Code);
+        #endif
+        
+        if ( (NCSI_Respond_SLT.IID           != InstanceID)       || 
+             (NCSI_Respond_SLT.Command       != (command | 0x80)) || 
+             (NCSI_Respond_SLT.Response_Code != COMMAND_COMPLETED)  ) {
+            #ifdef SLT_DOS
+            if ( PrintNCSIEn ) 
+                fprintf(fp_log, "Retry: Command = %x, Response_Code = %x\n", NCSI_Request_SLT.Command, NCSI_Respond_SLT.Response_Code);
+
+            #endif
+            Retry++;
+        } 
+        else {
+            if ( PrintNCSIEn ) 
+                NCSI_PrintCommandType2File(command, InstanceID);
+
+            return(0);
+        }
+    } while (Retry <= SENT_RETRY_COUNT);
+
+    return( 3 );
+} // End char NCSI_SentWaitPacket (unsigned char command, unsigned char id, unsigned short length)
+
+//------------------------------------------------------------
+char Clear_Initial_State_SLT (int Channel_ID) {//Command:0x00
+    return(NCSI_SentWaitPacket(CLEAR_INITIAL_STATE, (NCSI_Cap_SLT.Package_ID << 5) + Channel_ID, 0));//Internal Channel ID = 0
+}
+
+//------------------------------------------------------------
+char Select_Package_SLT (int Package_ID) {//Command:0x01
+    memset ((void *)NCSI_Payload_Data, 0, 4);
+    NCSI_Payload_Data[3] = 1; //Arbitration Disable
+
+    return(NCSI_SentWaitPacket(SELECT_PACKAGE, (Package_ID << 5) + 0x1F, 4));//Internal Channel ID = 0x1F, 0x1F means all channel
+}
+
+//------------------------------------------------------------
+void Select_Active_Package_SLT (void) {//Command:0x01
+    memset ((void *)NCSI_Payload_Data, 0, 4);
+    NCSI_Payload_Data[3] = 1; //Arbitration Disable
+
+    if (NCSI_SentWaitPacket(SELECT_PACKAGE, (NCSI_Cap_SLT.Package_ID << 5) + 0x1F, 4)) {//Internal Channel ID = 0x1F
+        FindErr_NCSI(NCSI_LinkFail_Select_Active_Package);
+    }
+}
+
+//------------------------------------------------------------
+void DeSelect_Package_SLT (int Package_ID) {//Command:0x02
+    NCSI_SentWaitPacket(DESELECT_PACKAGE, (Package_ID << 5) + 0x1F, 0);//Internal Channel ID = 0x1F, 0x1F means all channel
+
+#ifdef NCSI_EnableDelay_DeSelectPackage
+    delay(Delay_DeSelectPackage);
+#endif
+}
+
+//------------------------------------------------------------
+void Enable_Channel_SLT (void) {//Command:0x03
+    if ( NCSI_SentWaitPacket(ENABLE_CHANNEL, (NCSI_Cap_SLT.Package_ID << 5) + NCSI_Cap_SLT.Channel_ID, 0) ) {
+        FindErr_NCSI(NCSI_LinkFail_Enable_Channel);
+    }
+}
+
+//------------------------------------------------------------
+void Disable_Channel_SLT (void) {//Command:0x04
+    memset ((void *)NCSI_Payload_Data, 0, 4);
+    NCSI_Payload_Data[3] = 0x1; //ALD
+
+    if (NCSI_SentWaitPacket(DISABLE_CHANNEL, (NCSI_Cap_SLT.Package_ID << 5) + NCSI_Cap_SLT.Channel_ID, 4)) {
+        FindErr_NCSI(NCSI_LinkFail_Disable_Channel);
+    }
+}
+void Enable_Network_TX_SLT (void) {//Command:0x06
+    if ( NCSI_SentWaitPacket(ENABLE_CHANNEL_NETWORK_TX, (NCSI_Cap_SLT.Package_ID << 5) + NCSI_Cap_SLT.Channel_ID, 0) ) {
+        FindErr_NCSI(NCSI_LinkFail_Enable_Network_TX);
+    }
+}
+
+//------------------------------------------------------------
+void Disable_Network_TX_SLT (void) {//Command:0x07
+    if ( NCSI_SentWaitPacket(DISABLE_CHANNEL_NETWORK_TX, (NCSI_Cap_SLT.Package_ID << 5) + NCSI_Cap_SLT.Channel_ID, 0) ) {
+        FindErr_NCSI(NCSI_LinkFail_Disable_Network_TX);
+    }
+}
+
+//------------------------------------------------------------
+void Set_Link_SLT (void) {//Command:0x09
+    memset ((void *)NCSI_Payload_Data, 0, 8);
+    NCSI_Payload_Data[2] = 0x02; //full duplex
+//  NCSI_Payload_Data[3] = 0x04; //100M, auto-disable
+    NCSI_Payload_Data[3] = 0x05; //100M, auto-enable
+
+    NCSI_SentWaitPacket(SET_LINK, (NCSI_Cap_SLT.Package_ID << 5) + NCSI_Cap_SLT.Channel_ID, 8);
+}
+
+//------------------------------------------------------------
+char Get_Link_Status_SLT (void) {//Command:0x0a
+    
+    if (NCSI_SentWaitPacket(GET_LINK_STATUS, (NCSI_Cap_SLT.Package_ID << 5) + NCSI_Cap_SLT.Channel_ID, 0)) {
+        return(0);
+    } 
+    else {
+        if (NCSI_Respond_SLT.Payload_Data[3] & 0x20) {
+            if (NCSI_Respond_SLT.Payload_Data[3] & 0x40) {
+                if (NCSI_Respond_SLT.Payload_Data[3] & 0x01) 
+                    return(1); //Link Up or Not
+                else                                     
+                    return(0);
+            } else
+                return(0); //Auto Negotiate did not finish
+        } else {
+            if (NCSI_Respond_SLT.Payload_Data[3] & 0x01) 
+                return(1); //Link Up or Not
+            else                                     
+                return(0);
+        }
+    }
+} // End char Get_Link_Status_SLT (void)
+
+//------------------------------------------------------------
+void Enable_Set_MAC_Address_SLT (void) {//Command:0x0e
+    int i;
+    
+    for ( i = 0; i < 6; i++ ) {
+        NCSI_Payload_Data[i] = NCSI_Request_SLT.SA[i];
+    }
+    NCSI_Payload_Data[6] = 1; //MAC Address Num = 1 --> address filter 1, fixed in sample code
+    NCSI_Payload_Data[7] = UNICAST + 0 + ENABLE_MAC_ADDRESS_FILTER; //AT + Reserved + E
+
+    if ( NCSI_SentWaitPacket(SET_MAC_ADDRESS, (NCSI_Cap_SLT.Package_ID << 5) + NCSI_Cap_SLT.Channel_ID, 8) ) {
+        FindErr_NCSI(NCSI_LinkFail_Enable_Set_MAC_Address);
+    }
+}
+
+//------------------------------------------------------------
+void Enable_Broadcast_Filter_SLT (void) {//Command:0x10
+    memset ((void *)NCSI_Payload_Data, 0, 4);
+    NCSI_Payload_Data[3] = 0xF; //ARP, DHCP, NetBIOS
+
+    if (NCSI_SentWaitPacket(ENABLE_BROADCAST_FILTERING, (NCSI_Cap_SLT.Package_ID << 5) + NCSI_Cap_SLT.Channel_ID, 4) ) {
+        FindErr_NCSI(NCSI_LinkFail_Enable_Broadcast_Filter);
+    }
+}
+
+//------------------------------------------------------------
+void Get_Version_ID_SLT (void) {//Command:0x15
+    
+    if (NCSI_SentWaitPacket(GET_VERSION_ID, (NCSI_Cap_SLT.Package_ID << 5) + NCSI_Cap_SLT.Channel_ID, 0) ) {
+        FindErr_NCSI(NCSI_LinkFail_Get_Version_ID);
+    } 
+    else {
+#ifdef Print_Version_ID
+        printf ("NCSI Version        : %02x %02x %02x %02x\n", NCSI_Respond_SLT.Payload_Data[ 0], NCSI_Respond_SLT.Payload_Data[ 1], NCSI_Respond_SLT.Payload_Data[ 2], NCSI_Respond_SLT.Payload_Data[ 3]);
+        printf ("NCSI Version        : %02x %02x %02x %02x\n", NCSI_Respond_SLT.Payload_Data[ 4], NCSI_Respond_SLT.Payload_Data[ 5], NCSI_Respond_SLT.Payload_Data[ 6], NCSI_Respond_SLT.Payload_Data[ 7]);
+        printf ("Firmware Name String: %02x %02x %02x %02x\n", NCSI_Respond_SLT.Payload_Data[ 8], NCSI_Respond_SLT.Payload_Data[ 9], NCSI_Respond_SLT.Payload_Data[10], NCSI_Respond_SLT.Payload_Data[11]);
+        printf ("Firmware Name String: %02x %02x %02x %02x\n", NCSI_Respond_SLT.Payload_Data[12], NCSI_Respond_SLT.Payload_Data[13], NCSI_Respond_SLT.Payload_Data[14], NCSI_Respond_SLT.Payload_Data[15]);
+        printf ("Firmware Name String: %02x %02x %02x %02x\n", NCSI_Respond_SLT.Payload_Data[16], NCSI_Respond_SLT.Payload_Data[17], NCSI_Respond_SLT.Payload_Data[18], NCSI_Respond_SLT.Payload_Data[19]);
+        printf ("Firmware Version    : %02x %02x %02x %02x\n", NCSI_Respond_SLT.Payload_Data[20], NCSI_Respond_SLT.Payload_Data[21], NCSI_Respond_SLT.Payload_Data[22], NCSI_Respond_SLT.Payload_Data[23]);
+        printf ("PCI DID/VID         : %02x %02x/%02x %02x\n", NCSI_Respond_SLT.Payload_Data[24], NCSI_Respond_SLT.Payload_Data[25], NCSI_Respond_SLT.Payload_Data[26], NCSI_Respond_SLT.Payload_Data[27]);
+        printf ("PCI SSID/SVID       : %02x %02x/%02x %02x\n", NCSI_Respond_SLT.Payload_Data[28], NCSI_Respond_SLT.Payload_Data[29], NCSI_Respond_SLT.Payload_Data[30], NCSI_Respond_SLT.Payload_Data[31]);
+        printf ("Manufacturer ID     : %02x %02x %02x %02x\n", NCSI_Respond_SLT.Payload_Data[32], NCSI_Respond_SLT.Payload_Data[33], NCSI_Respond_SLT.Payload_Data[34], NCSI_Respond_SLT.Payload_Data[35]);
+        printf ("Checksum            : %02x %02x %02x %02x\n", NCSI_Respond_SLT.Payload_Data[36], NCSI_Respond_SLT.Payload_Data[37], NCSI_Respond_SLT.Payload_Data[38], NCSI_Respond_SLT.Payload_Data[39]);
+#endif
+        NCSI_Cap_SLT.PCI_DID_VID    = (NCSI_Respond_SLT.Payload_Data[24]<<24)
+                                | (NCSI_Respond_SLT.Payload_Data[25]<<16)
+                                | (NCSI_Respond_SLT.Payload_Data[26]<< 8)
+                                | (NCSI_Respond_SLT.Payload_Data[27]    );
+        NCSI_Cap_SLT.ManufacturerID = (NCSI_Respond_SLT.Payload_Data[32]<<24)
+                                | (NCSI_Respond_SLT.Payload_Data[33]<<16)
+                                | (NCSI_Respond_SLT.Payload_Data[34]<< 8)
+                                | (NCSI_Respond_SLT.Payload_Data[35]    );
+    }
+} // End void Get_Version_ID_SLT (void)
+
+//------------------------------------------------------------
+void Get_Capabilities_SLT (void) {//Command:0x16
+    
+    if (NCSI_SentWaitPacket(GET_CAPABILITIES, (NCSI_Cap_SLT.Package_ID << 5) + NCSI_Cap_SLT.Channel_ID, 0)) {
+        FindErr_NCSI(NCSI_LinkFail_Get_Capabilities);
+    } 
+    else {
+        NCSI_Cap_SLT.Capabilities_Flags                   = NCSI_Respond_SLT.Payload_Data[0];
+        NCSI_Cap_SLT.Broadcast_Packet_Filter_Capabilities = NCSI_Respond_SLT.Payload_Data[1];
+        NCSI_Cap_SLT.Multicast_Packet_Filter_Capabilities = NCSI_Respond_SLT.Payload_Data[2];
+        NCSI_Cap_SLT.Buffering_Capabilities               = NCSI_Respond_SLT.Payload_Data[3];
+        NCSI_Cap_SLT.AEN_Control_Support                  = NCSI_Respond_SLT.Payload_Data[4];
+    }
+}
+
+//------------------------------------------------------------
+void Get_Controller_Packet_Statistics (void) {//Command:0x18
+
+    NCSI_SentWaitPacket(GET_CONTROLLER_PACKET_STATISTICS, (NCSI_Cap_SLT.Package_ID << 5) + NCSI_Cap_SLT.Channel_ID, 0);
+}
+
+//------------------------------------------------------------
+char phy_ncsi (void) {
+    ULONG   Channel_Found = 0;
+    ULONG   Package_Found = 0;
+    ULONG   Re_Send;
+    ULONG   Err_Flag_bak;
+    ULONG   pkg_idx;
+    ULONG   chl_idx;
+    ULONG   Link_Status;
+    ULONG   NCSI_LinkFail_Val_bak;
+
+    number_chl    = 0;
+    number_pak    = 0;
+    
+    NCSI_LinkFail_Val = 0;
+    #ifdef SLT_DOS
+		fprintf(fp_log, "\n\n======> Start:\n" );
+    #endif
+    NCSI_Struct_Initialize_SLT();
+
+    #ifdef NCSI_Skip_Phase1_DeSelectPackage
+    #else
+    
+    //NCSI Start
+    //Disable Channel then DeSelect Package
+    for (pkg_idx = 0; pkg_idx < MAX_PACKAGE_NUM; pkg_idx++) {
+        // Ignore error flag in the NCSI command
+        Err_Flag_bak          = Err_Flag;
+        NCSI_LinkFail_Val_bak = NCSI_LinkFail_Val;
+        select_flag[pkg_idx]  = Select_Package_SLT (pkg_idx); // Command:0x01
+        Err_Flag              = Err_Flag_bak;
+        NCSI_LinkFail_Val     = NCSI_LinkFail_Val_bak;
+        
+        if ( select_flag[pkg_idx] == 0 ) {
+            NCSI_Cap_SLT.Package_ID = pkg_idx;
+
+            for ( chl_idx = 0; chl_idx < MAX_CHANNEL_NUM; chl_idx++ ) {
+                NCSI_Cap_SLT.Channel_ID = chl_idx;
+                // Ignore error flag in the NCSI command
+                Err_Flag_bak          = Err_Flag;
+                NCSI_LinkFail_Val_bak = NCSI_LinkFail_Val;
+                Disable_Channel_SLT();    // Command: 0x04
+                Err_Flag              = Err_Flag_bak;
+                NCSI_LinkFail_Val     = NCSI_LinkFail_Val_bak;
+            }
+            #ifdef NCSI_Skip_DeSelectPackage
+            #else
+            DeSelect_Package_SLT (pkg_idx); // Command:0x02
+            #endif
+        } // End if ( select_flag[pkg_idx] == 0 )
+    } // End for (pkg_idx = 0; pkg_idx < MAX_PACKAGE_NUM; pkg_idx++)
+    #endif
+
+    //Select Package
+    for (pkg_idx = 0; pkg_idx < MAX_PACKAGE_NUM; pkg_idx++) {
+        #ifdef NCSI_Skip_Phase1_DeSelectPackage
+        // Ignore error flag in the NCSI command
+        Err_Flag_bak          = Err_Flag;
+        NCSI_LinkFail_Val_bak = NCSI_LinkFail_Val;
+        select_flag[pkg_idx]  = Select_Package_SLT (pkg_idx);//Command:0x01
+        Err_Flag              = Err_Flag_bak;
+        NCSI_LinkFail_Val     = NCSI_LinkFail_Val_bak;
+        #endif
+
+        if (select_flag[pkg_idx] == 0) {
+            //NCSI_RxTimeOutScale = 1000;
+            NCSI_RxTimeOutScale = 10;
+            number_pak++;
+            Package_Found       = 1;
+            NCSI_Cap_SLT.Package_ID = pkg_idx;
+
+            if ( !(IOTiming||IOTimingBund) ) 
+                printf ("====Find Package ID: %d\n", NCSI_Cap_SLT.Package_ID);
+            #ifdef SLT_DOS
+            fprintf(fp_log, "====Find Package ID: %d\n", NCSI_Cap_SLT.Package_ID);
+            #endif
+            
+            #ifdef NCSI_Skip_Phase1_DeSelectPackage
+            #else
+            Select_Package_SLT (pkg_idx);//Command:0x01
+            #endif
+            
+            // Scan all channel in the package
+            for ( chl_idx = 0; chl_idx < MAX_CHANNEL_NUM; chl_idx++ ) {
+                // backup error flag
+                Err_Flag_bak          = Err_Flag;
+                NCSI_LinkFail_Val_bak = NCSI_LinkFail_Val;
+                if (Clear_Initial_State_SLT(chl_idx) == 0) { //Command:0x00
+                    number_chl++;
+                    Channel_Found       = 1;
+                    NCSI_Cap_SLT.Channel_ID = chl_idx;
+
+                    if ( !(IOTiming || IOTimingBund) ) 
+                        printf ("--------Find Channel ID: %d\n", NCSI_Cap_SLT.Channel_ID);
+                        
+                    #ifdef SLT_DOS
+                    fprintf(fp_log, "--------Find Channel ID: %d\n", NCSI_Cap_SLT.Channel_ID);
+                    #endif
+                    // Get Version and Capabilities
+                    Get_Version_ID_SLT();          //Command:0x15
+                    Get_Capabilities_SLT();        //Command:0x16
+                    Select_Active_Package_SLT();   //Command:0x01
+                    Enable_Set_MAC_Address_SLT();  //Command:0x0e
+                    Enable_Broadcast_Filter_SLT(); //Command:0x10
+
+                    // Enable TX
+                    Enable_Network_TX_SLT();       //Command:0x06
+
+                    // Enable Channel
+                    Enable_Channel_SLT();          //Command:0x03
+                    
+                    // Get Link Status
+                    Re_Send = 0;
+                    do {
+                        #ifdef NCSI_EnableDelay_GetLinkStatus
+                        if ( Re_Send >= 2 ) 
+                            delay(Delay_GetLinkStatus);
+                        #endif
+                        
+                        Link_Status = Get_Link_Status_SLT();//Command:0x0a
+                        
+                        if ( Link_Status == LINK_UP ) {
+                            if (!(IOTiming||IOTimingBund)) 
+                                printf ("        This Channel is LINK_UP\n");
+                            
+                            #ifdef SLT_DOS
+                            fprintf(fp_log, "        This Channel is LINK_UP\n");
+                            #endif
+                            
+                            NCSI_ARP ();
+                            
+                            break;
+                        } 
+                        else if ( Link_Status == LINK_DOWN ) {
+                            if ( Re_Send >= 2 ) {   
+                                if ( !(IOTiming || IOTimingBund) ) 
+                                    printf ("        This Channel is LINK_DOWN\n");
+	                    	    
+                                #ifdef SLT_DOS
+                                fprintf(fp_log, "        This Channel is LINK_DOWN\n");
+                                #endif
+                                
+	                    	    break;
+	                    	}
+                        } // End if ( Link_Status == LINK_UP )
+                    } while ( Re_Send++ <= 2 );
+
+                    #ifdef NCSI_Skip_DiSChannel
+                    #else
+                    if ( NCSI_DiSChannel ) {
+                        // Disable TX
+                        Disable_Network_TX_SLT(); //Command:0x07
+                        // Disable Channel
+                        Disable_Channel_SLT();    //Command:0x04
+                    }
+                    #endif
+                } 
+                else {
+                    Err_Flag          = Err_Flag_bak;
+                    NCSI_LinkFail_Val = NCSI_LinkFail_Val_bak;
+                }
+            } // End for ( chl_idx = 0; chl_idx < MAX_CHANNEL_NUM; chl_idx++ )
+            
+            #ifdef NCSI_Skip_DeSelectPackage
+            #else
+            DeSelect_Package_SLT (pkg_idx);//Command:0x02
+            #endif
+            NCSI_RxTimeOutScale = 1;
+        } 
+        else {
+            if (!(IOTiming||IOTimingBund)) {
+                printf ("====Absence of Package ID: %ld\n", pkg_idx);
+                #ifdef SLT_DOS
+                fprintf(fp_log, "====Absence of Package ID: %ld\n", pkg_idx);
+                #endif
+            }
+        } // End if (select_flag[pkg_idx] == 0)
+    } // End for (pkg_idx = 0; pkg_idx < MAX_PACKAGE_NUM; pkg_idx++)
+
+    if ( !Package_Found              ) FindErr( Err_NCSI_No_PHY      );
+    if ( ChannelTolNum != number_chl ) FindErr( Err_NCSI_Channel_Num );
+    if ( PackageTolNum != number_pak ) FindErr( Err_NCSI_Package_Num );
+//  if ( !Channel_Found) FindErr();
+
+    if ( Err_Flag ) 
+        return(1);
+    else          
+        return(0);
+}
+
diff --git a/arch/arm/cpu/arm926ejs/aspeed/PCI_SPI.c b/arch/arm/cpu/arm926ejs/aspeed/PCI_SPI.c
new file mode 100644
index 0000000..77aac47
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/aspeed/PCI_SPI.c
@@ -0,0 +1,83 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#define PCI_SPI_C
+static const char ThisFile[] = "PCI_SPI.c";
+
+#include "SWFUNC.H"
+
+#ifdef SLT_UBOOT
+  #include <common.h>
+  #include <command.h>
+#endif
+#ifdef SLT_DOS
+  #include <stdio.h>
+  #include <stdlib.h>
+  #include <conio.h>
+  #include <string.h>
+  #include <dos.h>
+#endif
+
+#include "DEF_SPI.H"
+#include "LIB.H"
+#include "TYPEDEF.H"
+
+#ifdef SPI_BUS
+ULONG  GetPCIInfo (DEVICE_PCI_INFO  *VGAPCIInfo)
+{
+    ULONG ulPCIBaseAddress, MMIOBaseAddress, LinearAddressBase, busnum, data;
+
+    ulPCIBaseAddress = FindPCIDevice (0x1A03, 0x2000, ACTIVE);
+    busnum = 0;
+    while (ulPCIBaseAddress == 0 && busnum < 256) {
+        ulPCIBaseAddress = FindPCIDevice (0x1A03, 0x2000, busnum);
+        if (ulPCIBaseAddress == 0) {
+            ulPCIBaseAddress = FindPCIDevice (0x1688, 0x2000, busnum);
+        }
+        if (ulPCIBaseAddress == 0) {
+            ulPCIBaseAddress = FindPCIDevice (0x1A03, 0x1160, busnum);
+        }
+        if (ulPCIBaseAddress == 0) {
+            ulPCIBaseAddress = FindPCIDevice (0x1A03, 0x1180, busnum);
+        }
+        busnum++;
+    }
+    printf ("ulPCIBaseAddress = %lx\n", ulPCIBaseAddress);
+    if (ulPCIBaseAddress != 0) {
+        VGAPCIInfo->ulPCIConfigurationBaseAddress = ulPCIBaseAddress;
+        VGAPCIInfo->usVendorID = ReadPCIReg(ulPCIBaseAddress, 0, 0xFFFF);
+        VGAPCIInfo->usDeviceID = ReadPCIReg(ulPCIBaseAddress, 0, 0xFFFF0000) >> 16;
+        LinearAddressBase = ReadPCIReg (ulPCIBaseAddress, 0x10, 0xFFFFFFF0);
+        VGAPCIInfo->ulPhysicalBaseAddress = MapPhysicalToLinear (LinearAddressBase, 64 * 1024 * 1024 + 0x200000);
+        MMIOBaseAddress = ReadPCIReg (ulPCIBaseAddress, 0x14, 0xFFFF0000);
+        VGAPCIInfo->ulMMIOBaseAddress = MapPhysicalToLinear (MMIOBaseAddress, 64 * 1024 * 1024);
+        VGAPCIInfo->usRelocateIO = ReadPCIReg (ulPCIBaseAddress, 0x18, 0x0000FF80);
+        OUTDWPORT(0xcf8, ulPCIBaseAddress + 0x4);
+        data = INDWPORT(0xcfc);
+        OUTDWPORT(0xcfc, data | 0x3);
+        return    TRUE;
+    }
+    else {
+        return    FALSE;
+    }
+} // End ULONG  GetPCIInfo (DEVICE_PCI_INFO  *VGAPCIInfo)
+
+BOOLEAN  GetDevicePCIInfo (VIDEO_ENGINE_INFO *VideoEngineInfo)
+{
+    if (GetPCIInfo (&VideoEngineInfo->VGAPCIInfo) == TRUE) {
+        return    TRUE;
+    }
+    else {
+        printf("Can not find PCI device!\n");
+        exit(0);
+        return    FALSE;
+    }
+} // End
+#endif // End ifdef SPI_BUS
diff --git a/arch/arm/cpu/arm926ejs/aspeed/PHY.H b/arch/arm/cpu/arm926ejs/aspeed/PHY.H
new file mode 100644
index 0000000..81d9470
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/aspeed/PHY.H
@@ -0,0 +1,56 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef PHY_H
+#define PHY_H
+
+//
+// Define
+//
+#define Enable_SearchPHYID             //[ON] (Search vlid PHY ID)
+#define Enable_CheckZeroPHYID          //[ON] (Check PHY ID with value 0)
+
+#ifdef Enable_CheckZeroPHYID
+  #define PHY_IS_VALID( dat )      ( ( (dat & 0xffff) != 0xffff ) && ( ( dat & 0xffff ) != 0x0 ) )
+#else
+  #define PHY_IS_VALID( dat )      ( ( dat & 0xffff) != 0xffff )
+#endif
+
+// Define PHY basic register
+#define PHY_REG_BMCR    0x00 // Basic Mode Control Register
+#define PHY_REG_BMSR    0x01 // Basic Mode Status Register
+#define PHY_REG_ID_1    0x02
+#define PHY_REG_ID_2    0x03
+#define PHY_ANER        0x06 // Auto-negotiation Expansion Register
+#define PHY_GBCR        0x09 // 1000Base-T Control Register
+#define PHY_SR          0x11 // PHY Specific Status Register
+#define PHY_INER        0x12 // Interrupt Enable Register
+
+#define TIME_OUT_PHY_RW           10000
+#define TIME_OUT_PHY_Rst          10000
+
+#define PHYID3_Mask                0xfc00         //0xffc0
+
+/* --- Note for SettingPHY chip ---
+void phy_xxxx (int loop_phy) {
+
+	if ( BurstEnable ) {
+        // IEEE test
+	} 
+	else if (loop_phy) {
+        // Internal loop back
+	} 
+	else {
+        // external loop back
+	}
+}
+----------------------------------- */
+
+#endif // PHY_H
diff --git a/arch/arm/cpu/arm926ejs/aspeed/PHY.c b/arch/arm/cpu/arm926ejs/aspeed/PHY.c
new file mode 100644
index 0000000..6afed9d
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/aspeed/PHY.c
@@ -0,0 +1,1541 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#define PHY_C
+static const char ThisFile[] = "PHY.c";
+
+#include "SWFUNC.H"
+
+#ifdef SLT_UBOOT
+  #include <common.h>
+  #include <command.h>
+  #include <COMMINF.H>
+  #include "STDUBOOT.H"
+#endif
+#ifdef SLT_DOS
+  #include <stdio.h>
+  #include <stdlib.h>
+  #include <conio.h>
+  #include <string.h>
+  #include "COMMINF.H"
+#endif
+  
+#include "PHY.H"                    
+#include "TYPEDEF.H"
+#include "IO.H"
+
+ULONG	PHY_09h;
+ULONG	PHY_18h;
+ULONG	PHY_1fh;
+ULONG	PHY_06hA[7];
+ULONG	PHY_11h;
+ULONG	PHY_12h;
+ULONG	PHY_15h;
+ULONG	PHY_06h;
+char	PHYID[256];
+ULONG	PHY_00h;
+
+//------------------------------------------------------------
+// PHY R/W basic
+//------------------------------------------------------------
+void phy_write (int adr, ULONG data) {
+    int timeout = 0;
+    
+	if (AST2300_NewMDIO) {
+		WriteSOC_DD( MAC_PHYBASE + 0x60, ( data << 16 ) | MAC_PHYWr_New | (PHY_ADR<<5) | (adr & 0x1f));
+
+		while ( ReadSOC_DD( MAC_PHYBASE + 0x60 ) & MAC_PHYBusy_New ) {
+			if ( ++timeout > TIME_OUT_PHY_RW ) {
+				if (!BurstEnable) 
+#ifdef SLT_DOS
+                    fprintf(fp_log, "[PHY-Write] Time out: %08lx\n", ReadSOC_DD( MAC_PHYBASE + 0x60 ) );
+#endif
+                    FindErr( Err_PHY_TimeOut );
+				break;
+			}
+		}
+	} 
+	else {
+		WriteSOC_DD( MAC_PHYBASE + 0x64, data );
+
+		WriteSOC_DD( MAC_PHYBASE + 0x60, MDC_Thres | MAC_PHYWr | (PHY_ADR<<16) | ((adr & 0x1f) << 21));
+
+		while ( ReadSOC_DD( MAC_PHYBASE + 0x60 ) & MAC_PHYWr ) {
+			if ( ++timeout > TIME_OUT_PHY_RW ) {
+#ifdef SLT_DOS
+                if (!BurstEnable) 
+				    fprintf(fp_log, "[PHY-Write] Time out: %08lx\n", ReadSOC_DD( MAC_PHYBASE + 0x60 ) );
+#endif
+                FindErr( Err_PHY_TimeOut );
+				break;
+			}
+		}
+	} // End if (AST2300_NewMDIO)
+
+	if ( DbgPrn_PHYRW ) 
+	    printf ("[Wr ]%02d: %04lx\n", adr, data);
+} // End void phy_write (int adr, ULONG data)
+
+//------------------------------------------------------------
+ULONG phy_read (int adr) {
+    int timeout = 0;
+    
+	if ( AST2300_NewMDIO ) {
+		WriteSOC_DD( MAC_PHYBASE + 0x60, MAC_PHYRd_New | (PHY_ADR << 5) | ( adr & 0x1f ) );
+
+		while ( ReadSOC_DD( MAC_PHYBASE + 0x60 ) & MAC_PHYBusy_New ) {
+			if ( ++timeout > TIME_OUT_PHY_RW ) {
+				if ( !BurstEnable ) 
+#ifdef SLT_DOS
+                    fprintf(fp_log, "[PHY-Read] Time out: %08lx\n", ReadSOC_DD( MAC_PHYBASE + 0x60 ));
+#endif
+                    FindErr( Err_PHY_TimeOut );
+				break;
+			}
+		}
+
+		DELAY(Delay_PHYRd);
+		Dat_ULONG = ReadSOC_DD( MAC_PHYBASE + 0x64 ) & 0xffff;
+	} 
+	else {
+		WriteSOC_DD( MAC_PHYBASE + 0x60, MDC_Thres | MAC_PHYRd | (PHY_ADR << 16) | ((adr & 0x1f) << 21) );
+
+		while ( ReadSOC_DD( MAC_PHYBASE + 0x60 ) & MAC_PHYRd ) {
+			if ( ++timeout > TIME_OUT_PHY_RW ) {
+#ifdef SLT_DOS
+                if ( !BurstEnable ) 
+				    fprintf( fp_log, "[PHY-Read] Time out: %08lx\n", ReadSOC_DD( MAC_PHYBASE + 0x60 ) );
+#endif
+                FindErr( Err_PHY_TimeOut );
+				break;
+			}
+		}
+
+		DELAY( Delay_PHYRd );
+		Dat_ULONG = ReadSOC_DD( MAC_PHYBASE + 0x64 ) >> 16;
+	}
+
+	if ( DbgPrn_PHYRW ) 
+	    printf ("[Rd ]%02d: %04lx\n", adr, Dat_ULONG );
+	    
+	return( Dat_ULONG );
+} // End ULONG phy_read (int adr)
+
+//------------------------------------------------------------
+void phy_Read_Write (int adr, ULONG clr_mask, ULONG set_mask) {
+	if ( DbgPrn_PHYRW ) 
+	    printf ("[RW ]%02d: clr:%04lx: set:%04lx\n", adr, clr_mask, set_mask);
+	phy_write(adr, ((phy_read(adr) & (~clr_mask)) | set_mask));
+}
+
+//------------------------------------------------------------
+void phy_out ( int adr ) {
+	printf ("%02d: %04lx\n", adr, phy_read(adr));
+}
+
+//------------------------------------------------------------
+//void phy_outchg ( int adr ) {
+//    ULONG	PHY_valold = 0;
+//    ULONG	PHY_val;
+//
+//	while (1) {
+//		PHY_val = phy_read(adr);
+//		if (PHY_valold != PHY_val) {
+//			printf ("%02d: %04lx\n", adr, PHY_val);
+//			PHY_valold = PHY_val;
+//		}
+//	}
+//}
+
+//------------------------------------------------------------
+void phy_dump (char *name) {
+	int	index;
+
+	printf ("[%s][%d]----------------\n", name, PHY_ADR);
+	for (index = 0; index < 32; index++) {
+		printf ("%02d: %04lx ", index, phy_read(index));
+		
+		if ((index % 8) == 7) 
+		    printf ("\n");
+	}
+}
+
+//------------------------------------------------------------
+void phy_id (BYTE option) {
+    
+    ULONG	reg_adr;
+    CHAR    PHY_ADR_org;
+    FILE_VAR
+    
+    GET_OBJ( option )
+
+    PHY_ADR_org = PHY_ADR;
+	for (PHY_ADR = 0; PHY_ADR < 32; PHY_ADR++) {
+
+		PRINT(OUT_OBJ "[%02d] ", PHY_ADR);
+
+        for (reg_adr = 2; reg_adr <= 3; reg_adr++)
+			PRINT(OUT_OBJ "%ld:%04lx ", reg_adr, phy_read(reg_adr));
+
+		if ((PHY_ADR % 4) == 3) 
+		    PRINT(OUT_OBJ "\n");
+	}
+	PHY_ADR = PHY_ADR_org;
+}
+
+
+//------------------------------------------------------------
+void phy_delay (int dt) {
+    DELAY( dt );
+}
+
+//------------------------------------------------------------
+// PHY IC
+//------------------------------------------------------------
+void phy_basic_setting (int loop_phy) {
+	phy_Read_Write(0,  0x7140, PHY_00h); //clr set
+	if ( DbgPrn_PHYRW ) 
+	    printf ("[Set]00: %04lx\n", phy_read( PHY_REG_BMCR ));
+}
+
+//------------------------------------------------------------
+void phy_Wait_Reset_Done (void) {
+	int timeout = 0;
+	
+	while (  phy_read( PHY_REG_BMCR ) & 0x8000 ) {
+		if (DbgPrn_PHYRW) 
+		    printf ("00: %04lx\n", phy_read( PHY_REG_BMCR ));
+		    
+		if (++timeout > TIME_OUT_PHY_Rst) {
+#ifdef SLT_DOS
+            if (!BurstEnable) fprintf(fp_log, "[PHY-Reset] Time out: %08lx\n", ReadSOC_DD(MAC_PHYBASE+0x60));
+#endif
+            FindErr(Err_PHY_TimeOut);
+			break;
+		}
+	}//wait Rst Done
+
+	if (DbgPrn_PHYRW) printf ("[Clr]00: %04lx\n", phy_read( PHY_REG_BMCR ));
+	DELAY(Delay_PHYRst);
+}
+
+//------------------------------------------------------------
+void phy_Reset (int loop_phy) {
+	phy_basic_setting(loop_phy);
+
+	phy_Read_Write(0,  0x0000, 0x8000 | PHY_00h);//clr set//Rst PHY
+	phy_Wait_Reset_Done();
+
+	phy_basic_setting(loop_phy);
+	DELAY(Delay_PHYRst);
+}
+
+//------------------------------------------------------------
+void recov_phy_marvell (int loop_phy) {//88E1111
+	if ( BurstEnable ) {
+	} 
+	else if ( loop_phy ) {
+	} 
+	else {
+		if (GSpeed_sel[0]) {
+			phy_write(9, PHY_09h);
+
+			phy_Reset(loop_phy);
+
+			phy_write(29, 0x0007);
+			phy_Read_Write(30, 0x0008, 0x0000);//clr set
+			phy_write(29, 0x0010);
+			phy_Read_Write(30, 0x0002, 0x0000);//clr set
+			phy_write(29, 0x0012);
+			phy_Read_Write(30, 0x0001, 0x0000);//clr set
+
+			phy_write(18, PHY_12h);
+		}
+	}
+}
+
+//------------------------------------------------------------
+void phy_marvell (int loop_phy) {//88E1111
+    int	Retry;
+
+	if ( DbgPrn_PHYName ) 
+	    printf ("--->(%04lx %04lx)[Marvell] %s\n", PHY_ID2, PHY_ID3, PHYName);
+
+	if ( BurstEnable ) {
+		phy_Reset(loop_phy);
+	} 
+	else if ( loop_phy ) {
+		phy_Reset(loop_phy);
+	} 
+	else {
+		if ( GSpeed_sel[0] ) {
+			PHY_09h = phy_read( PHY_GBCR );
+			PHY_12h = phy_read( PHY_INER );
+			phy_write ( 18, 0x0000         );
+			phy_Read_Write(  9, 0x0000, 0x1800 );//clr set
+		}                              
+                                       
+		phy_Reset(loop_phy);           
+                                       
+		if (GSpeed_sel[0]) {           
+			phy_write ( 29, 0x0007         );
+			phy_Read_Write( 30, 0x0000, 0x0008 );//clr set
+			phy_write ( 29, 0x0010         );
+			phy_Read_Write( 30, 0x0000, 0x0002 );//clr set
+			phy_write ( 29, 0x0012         );
+			phy_Read_Write( 30, 0x0000, 0x0001 );//clr set
+		}
+	}
+
+	Retry = 0;
+	do {
+		PHY_11h = phy_read( PHY_SR );
+	} while ( !( ( PHY_11h & 0x0400 ) | loop_phy | ( Retry++ > 20 ) ) );
+}
+
+//------------------------------------------------------------
+void recov_phy_marvell0 (int loop_phy) {//88E1310
+	if (BurstEnable) {
+	} else if (loop_phy) {
+	} else {
+		if (GSpeed_sel[0]) {
+			phy_write(22, 0x0006);
+			phy_Read_Write(16, 0x0020, 0x0000);//clr set
+			phy_write(22, 0x0000);
+		}
+	}
+}
+
+//------------------------------------------------------------
+void phy_marvell0 (int loop_phy) {//88E1310
+    int	Retry;
+    
+	if (DbgPrn_PHYName) 
+	    printf ("--->(%04lx %04lx)[Marvell] %s\n", PHY_ID2, PHY_ID3, PHYName);
+
+	phy_write( 22, 0x0002 );
+
+    PHY_15h = phy_read(21);
+	if (PHY_15h & 0x0030) {
+		printf ("\n\n[Warning] Page2, Register 21, bit 4~5 must be 0 [Reg15_2:%04lx]\n\n", PHY_15h);
+#ifdef SLT_DOS
+        if ( IOTiming    ) 
+		    fprintf (fp_io, "\n\n[Warning] Page2, Register 21, bit 4~5 must be 0 [Reg15_2:%04lx]\n\n", PHY_15h);
+		if ( !BurstEnable) 
+		    fprintf (fp_log, "\n\n[Warning] Page2, Register 21, bit 4~5 must be 0 [Reg15_2:%04lx]\n\n", PHY_15h);
+#endif		    
+//		phy_Read_Write(21, 0x0030, 0x0000);//clr set//[5]Rx Dly, [4]Tx Dly
+        phy_write(21, PHY_15h & 0xffcf); // Set [5]Rx Dly, [4]Tx Dly to 0
+	}
+	phy_write(22, 0x0000);
+
+	if ( BurstEnable ) {
+		phy_Reset(loop_phy);
+	} 
+	else if ( loop_phy ) {
+		phy_write( 22, 0x0002 );
+		
+		if ( GSpeed_sel[0] ) {
+			phy_Read_Write( 21, 0x6040, 0x0040 );//clr set
+		} 
+		else if ( GSpeed_sel[1] ) {
+			phy_Read_Write( 21, 0x6040, 0x2000 );//clr set
+		} 
+		else {
+			phy_Read_Write( 21, 0x6040, 0x0000 );//clr set
+		}
+		phy_write( 22, 0x0000 );
+		phy_Reset( loop_phy );
+	} 
+	else {
+		if ( GSpeed_sel[0] ) {
+			phy_write(  22, 0x0006         );
+			phy_Read_Write( 16, 0x0000, 0x0020 );//clr set
+			phy_write(  22, 0x0000         );
+		}
+
+		phy_Reset(loop_phy);
+	}
+
+	Retry = 0;
+	do {
+		PHY_11h = phy_read( PHY_SR );
+	} while (!((PHY_11h & 0x0400) | loop_phy | (Retry++ > 20)));
+}
+
+//------------------------------------------------------------
+void recov_phy_marvell1 (int loop_phy) {//88E6176
+    CHAR    PHY_ADR_org;
+    
+	PHY_ADR_org = PHY_ADR;
+	for ( PHY_ADR = 16; PHY_ADR <= 22; PHY_ADR++ ) {
+		if ( BurstEnable ) {
+		} 
+		else {
+			phy_write(6, PHY_06hA[PHY_ADR-16]);//06h[5]P5 loopback, 06h[6]P6 loopback
+		}
+	}
+	for ( PHY_ADR = 21; PHY_ADR <= 22; PHY_ADR++ ) {
+		phy_write(1, 0x3); //01h[1:0]00 = 10 Mbps, 01 = 100 Mbps, 10 = 1000 Mbps, 11 = Speed is not forced.
+	}
+	PHY_ADR = PHY_ADR_org;
+}
+
+//------------------------------------------------------------
+void phy_marvell1 (int loop_phy) {//88E6176
+//    ULONG	PHY_01h;
+    CHAR    PHY_ADR_org;
+    
+	if (DbgPrn_PHYName) 
+	    printf ("--->(%04lx %04lx)[Marvell] %s\n", PHY_ID2, PHY_ID3, PHYName);
+
+	//The 88E6176 is switch with 7 Port(P0~P6) and the PHYAdr will be fixed at 0x10~0x16, and only P5/P6 can be connected to the MAC.
+	//Therefor, the 88E6176 only can run the internal loopback.
+	PHY_ADR_org = PHY_ADR;
+	for ( PHY_ADR = 16; PHY_ADR <= 20; PHY_ADR++ ) {
+		if ( BurstEnable ) {
+		} 
+		else {
+			PHY_06hA[PHY_ADR-16] = phy_read( PHY_ANER );
+			phy_write(6, 0x00);//06h[5]P5 loopback, 06h[6]P6 loopback
+		}
+	}
+	
+	for ( PHY_ADR = 21; PHY_ADR <= 22; PHY_ADR++ ) {
+//		PHY_01h = phy_read( PHY_REG_BMSR );
+//		if      (GSpeed_sel[0]) phy_write(1, (PHY_01h & 0xfffc) | 0x2);//[1:0]00 = 10 Mbps, 01 = 100 Mbps, 10 = 1000 Mbps, 11 = Speed is not forced.
+//		else if (GSpeed_sel[1]) phy_write(1, (PHY_01h & 0xfffc) | 0x1);//[1:0]00 = 10 Mbps, 01 = 100 Mbps, 10 = 1000 Mbps, 11 = Speed is not forced.
+//		else                    phy_write(1, (PHY_01h & 0xfffc)      );//[1:0]00 = 10 Mbps, 01 = 100 Mbps, 10 = 1000 Mbps, 11 = Speed is not forced.
+		if      (GSpeed_sel[0]) phy_write(1, 0x2);//01h[1:0]00 = 10 Mbps, 01 = 100 Mbps, 10 = 1000 Mbps, 11 = Speed is not forced.
+		else if (GSpeed_sel[1]) phy_write(1, 0x1);//01h[1:0]00 = 10 Mbps, 01 = 100 Mbps, 10 = 1000 Mbps, 11 = Speed is not forced.
+		else                    phy_write(1, 0x0);//01h[1:0]00 = 10 Mbps, 01 = 100 Mbps, 10 = 1000 Mbps, 11 = Speed is not forced.
+
+		if (BurstEnable) {
+		} 
+		else {
+			PHY_06hA[PHY_ADR-16] = phy_read( PHY_ANER );
+			if (PHY_ADR == 21) phy_write(6, 0x20);//06h[5]P5 loopback, 06h[6]P6 loopback
+			else               phy_write(6, 0x40);//06h[5]P5 loopback, 06h[6]P6 loopback
+		}
+	}
+	PHY_ADR = PHY_ADR_org;
+}
+
+//------------------------------------------------------------
+void recov_phy_marvell2 (int loop_phy) {//88E1512
+	if (BurstEnable) {
+	} 
+	else if (loop_phy) {
+	} 
+	else {
+		if (GSpeed_sel[0]) {
+			phy_write(22, 0x0006);
+			phy_Read_Write(18, 0x0008, 0x0000);//clr set
+			phy_write(22, 0x0000);
+		}
+	}
+}
+
+//------------------------------------------------------------
+void phy_marvell2 (int loop_phy) {//88E1512
+    int	    Retry = 0;
+    ULONG   temp_reg;
+
+	if ( DbgPrn_PHYName ) 
+	    printf ("--->(%04lx %04lx)[Marvell] %s\n", PHY_ID2, PHY_ID3, PHYName);
+
+	phy_write(22, 0x0002);
+	PHY_15h = phy_read(21);
+	
+	if ( PHY_15h & 0x0030 ) {
+		printf ("\n\n[Warning] Page2, Register 21, bit 4~5 must be 0 [Reg15h_2:%04lx]\n\n", PHY_15h);
+#ifdef SLT_DOS
+        if (IOTiming    ) fprintf (fp_io, "\n\n[Warning] Page2, Register 21, bit 4~5 must be 0 [Reg15h_2:%04lx]\n\n", PHY_15h);
+		if (!BurstEnable) fprintf (fp_log, "\n\n[Warning] Page2, Register 21, bit 4~5 must be 0 [Reg15h_2:%04lx]\n\n", PHY_15h);
+#endif
+        //		phy_Read_Write(21, 0x0030, 0x0000);//clr set//[5]Rx Dly, [4]Tx Dly
+//		phy_write(21, PHY_15h & 0xffcf);
+	}
+	phy_write(22, 0x0000);
+
+	if ( BurstEnable ) {
+		phy_Reset(loop_phy);
+	} 
+	else if (loop_phy) {
+	    // Internal loopback funciton only support in copper mode
+	    // switch page 18
+	    phy_write(22, 0x0012);
+	    // Change mode to Copper mode
+	    phy_write(20, 0x8210);
+	    // do software reset
+	    do {
+	        temp_reg = phy_read( 20 );
+	    } while ( ( (temp_reg & 0x8000) == 0x8000 ) & (Retry++ < 20) );
+	    
+	    // switch page 2
+		phy_write(22, 0x0002);
+		if (GSpeed_sel[0]) {
+			phy_Read_Write(21, 0x2040, 0x0040);//clr set
+		} 
+		else if (GSpeed_sel[1]) {
+			phy_Read_Write(21, 0x2040, 0x2000);//clr set
+		} 
+		else {
+			phy_Read_Write(21, 0x2040, 0x0000);//clr set
+		}
+		phy_write(22, 0x0000);
+
+		phy_Reset(loop_phy);
+	} 
+	else {
+		if (GSpeed_sel[0]) {
+			phy_write(22, 0x0006);
+			phy_Read_Write(18, 0x0000, 0x0008);//clr set
+			phy_write(22, 0x0000);
+		}
+
+		phy_Reset(loop_phy);
+	}
+
+	Retry = 0;
+	do {
+		PHY_11h = phy_read( PHY_SR );
+	} while (!((PHY_11h & 0x0400) | loop_phy | (Retry++ > 20)));
+}
+
+//------------------------------------------------------------
+void phy_broadcom (int loop_phy) {//BCM5221
+	if (DbgPrn_PHYName) 
+	    printf ("--->(%04lx %04lx)[Broadcom] %s\n", PHY_ID2, PHY_ID3, PHYName);
+
+	phy_Reset(loop_phy);
+
+	if (IEEETesting) {
+		if (IOTimingBund_arg == 0) {
+			phy_write(25, 0x1f01);//Force MDI  //Measuring from channel A
+		} 
+		else {
+			phy_Read_Write(24, 0x0000, 0x4000);//clr set//Force Link
+//			phy_write( 0, PHY_00h);
+//			phy_write(30, 0x1000);
+		}
+	}
+}
+
+//------------------------------------------------------------
+void recov_phy_broadcom0 (int loop_phy) {//BCM54612
+
+    // Need to do it for AST2400
+    phy_write(0x1C, 0x8C00); // Disable GTXCLK Clock Delay Enable
+    phy_write(0x18, 0xF0E7); // Disable RGMII RXD to RXC Skew            
+
+    if (BurstEnable) {
+	} 
+	else if (loop_phy) {
+		phy_write( 0, PHY_00h);
+	} 
+	else {
+		phy_write(0x00, PHY_00h);
+		phy_write(0x09, PHY_09h);
+		phy_write(0x18, PHY_18h);
+	}
+}
+
+//------------------------------------------------------------
+void phy_broadcom0 (int loop_phy) {//BCM54612
+	if ( DbgPrn_PHYName ) 
+	    printf ("--->(%04lx %04lx)[Broadcom] %s\n", PHY_ID2, PHY_ID3, PHYName);
+
+    // Need to do it for AST2400
+    phy_write(0x1C, 0x8C00); // Disable GTXCLK Clock Delay Enable
+    phy_write(0x18, 0xF0E7); // Disable RGMII RXD to RXC Skew            
+        
+    // Backup org value
+    // read reg 18H, Page 103, BCM54612EB1KMLG_Spec.pdf
+    phy_write(0x18, 0x7007);
+    PHY_18h = phy_read(0x18);
+       
+    PHY_00h = phy_read( PHY_REG_BMCR );
+    PHY_09h = phy_read( PHY_GBCR );   
+    
+	if ( BurstEnable ) {
+		phy_basic_setting(loop_phy);
+	} 
+	else if (loop_phy) {
+		phy_basic_setting(loop_phy);
+   
+    // Enable Internal Loopback mode
+    // Page 58, BCM54612EB1KMLG_Spec.pdf
+    phy_write(0x0, 0x5140);
+		DELAY(Delay_PHYRst);
+    /* Only 1G Test is PASS, 100M and 10M is false @20130619 */     
+
+// Waiting for BCM FAE's response
+//        if (GSpeed_sel[0]) {
+//            // Speed 1G
+//            // Enable Internal Loopback mode
+//            // Page 58, BCM54612EB1KMLG_Spec.pdf
+//            phy_write(0x0, 0x5140);
+//        } 
+//        else if (GSpeed_sel[1]) {
+//            // Speed 100M
+//            // Enable Internal Loopback mode
+//            // Page 58, BCM54612EB1KMLG_Spec.pdf
+//            phy_write(0x0, 0x7100);
+//            phy_write(0x1E, 0x1000);
+//        } 
+//        else if (GSpeed_sel[2]) {
+//            // Speed 10M
+//            // Enable Internal Loopback mode
+//            // Page 58, BCM54612EB1KMLG_Spec.pdf
+//            phy_write(0x0, 0x5100);
+//            phy_write(0x1E, 0x1000);
+//        }
+//            
+//		DELAY(Delay_PHYRst);
+    } 
+	else {
+      
+		if (GSpeed_sel[0]) {
+            // Page 60, BCM54612EB1KMLG_Spec.pdf
+            // need to insert loopback plug
+			phy_write( 9, 0x1800);
+			phy_write( 0, 0x0140);
+            phy_write( 0x18, 0x8400); // Enable Transmit test mode
+		} else if (GSpeed_sel[1]) {
+            // Page 60, BCM54612EB1KMLG_Spec.pdf
+            // need to insert loopback plug
+			phy_write( 0, 0x2100);
+            phy_write( 0x18, 0x8400); // Enable Transmit test mode            
+		} else {
+            // Page 60, BCM54612EB1KMLG_Spec.pdf
+            // need to insert loopback plug
+			phy_write( 0, 0x0100);
+            phy_write( 0x18, 0x8400); // Enable Transmit test mode                               
+		}
+	}
+}
+
+//------------------------------------------------------------
+void phy_realtek (int loop_phy) {//RTL8201N
+	if ( DbgPrn_PHYName ) 
+	    printf ("--->(%04lx %04lx)[Realtek] %s\n", PHY_ID2, PHY_ID3, PHYName);
+
+	phy_Reset(loop_phy);
+}
+
+//------------------------------------------------------------
+//internal loop 100M: Don't support
+//internal loop 10M : no  loopback stub
+void phy_realtek0 (int loop_phy) {//RTL8201E
+	if ( DbgPrn_PHYName ) 
+	    printf ("--->(%04lx %04lx)[Realtek] %s\n", PHY_ID2, PHY_ID3, PHYName);
+
+	phy_Reset(loop_phy);
+
+//	phy_Read_Write(25, 0x2800, 0x0000);//clr set
+//	printf("Enable phy output RMII clock\n");
+	if (IEEETesting) {
+		phy_write(31, 0x0001);
+		if (IOTimingBund_arg == 0) {
+			phy_write(25, 0x1f01);//Force MDI  //Measuring from channel A
+		} 
+		else {
+			phy_write(25, 0x1f00);//Force MDIX //Measuring from channel B
+		}
+		phy_write(31, 0x0000);
+	}
+}
+
+//------------------------------------------------------------
+void recov_phy_realtek1 (int loop_phy) {//RTL8211D
+	if ( BurstEnable ) {
+		if ( IEEETesting ) {
+			if ( GSpeed_sel[0] ) {
+				if (IOTimingBund_arg == 0) {
+					//Test Mode 1
+					phy_write( 31, 0x0002 );
+					phy_write(  2, 0xc203 );
+					phy_write( 31, 0x0000 );
+					phy_write(  9, 0x0000 );
+				} 
+				else {
+					//Test Mode 4
+					phy_write( 31, 0x0000 );
+					phy_write(  9, 0x0000 );
+				}
+
+				phy_write( 31, 0x0000 );
+			} 
+			else if ( GSpeed_sel[1] ) {
+				phy_write( 23, 0x2100 );
+				phy_write( 16, 0x016e );
+			} 
+			else {
+//				phy_write( 31, 0x0006 );
+//				phy_write(  0, 0x5a00 );
+//				phy_write( 31, 0x0000 );
+			}
+		} // End if ( IEEETesting )
+	} 
+	else if (loop_phy) {
+		if ( GSpeed_sel[0] ) {
+			phy_write( 31, 0x0000 ); // new in Rev. 1.6
+			phy_write(  0, 0x1140 ); // new in Rev. 1.6
+			phy_write( 20, 0x8040 ); // new in Rev. 1.6
+		}
+	} 
+	else {
+		if ( GSpeed_sel[0] ) {
+			phy_write( 31, 0x0001 );
+			phy_write(  3, 0xdf41 );
+			phy_write(  2, 0xdf20 );
+			phy_write(  1, 0x0140 );
+			phy_write(  0, 0x00bb );
+			phy_write(  4, 0xb800 );
+			phy_write(  4, 0xb000 );
+                              
+			phy_write( 31, 0x0000 );
+//			phy_write( 26, 0x0020 ); // Rev. 1.2
+			phy_write( 26, 0x0040 ); // new in Rev. 1.6
+			phy_write(  0, 0x1140 );    
+//			phy_write( 21, 0x0006 ); // Rev. 1.2
+			phy_write( 21, 0x1006 ); // new in Rev. 1.6
+			phy_write( 23, 0x2100 ); 
+//		} else if ( GSpeed_sel[1] ) {//option
+//			phy_write( 31, 0x0000 );
+//			phy_write(  9, 0x0200 );
+//			phy_write(  0, 0x1200 );
+//		} else if ( GSpeed_sel[2] ) {//option
+//			phy_write( 31, 0x0000 );
+//			phy_write(  9, 0x0200 );
+//			phy_write(  4, 0x05e1 );
+//			phy_write(  0, 0x1200 );
+		}
+	} // End if ( BurstEnable )
+} // End void recov_phy_realtek1 (int loop_phy)
+
+//------------------------------------------------------------
+//internal loop 1G  : no  loopback stub
+//internal loop 100M: no  loopback stub
+//internal loop 10M : no  loopback stub
+void phy_realtek1 (int loop_phy) {//RTL8211D
+	if ( DbgPrn_PHYName ) 
+	    printf ("--->(%04lx %04lx)[Realtek] %s\n", PHY_ID2, PHY_ID3, PHYName);
+         
+	if ( BurstEnable ) {
+		if ( IEEETesting ) {
+			if ( GSpeed_sel[0] ) {
+				if (IOTimingBund_arg == 0) {
+					//Test Mode 1
+					phy_write( 31, 0x0002 );
+					phy_write(  2, 0xc22b );
+					phy_write( 31, 0x0000 );
+					phy_write(  9, 0x2000 );
+				} 
+				else {
+					//Test Mode 4
+					phy_write( 31, 0x0000 );
+					phy_write(  9, 0x8000 );
+				}
+				phy_write( 31, 0x0000 );
+			} 
+			else if ( GSpeed_sel[1] ) {
+				if ( IOTimingBund_arg == 0 ) {
+					//From Channel A
+					phy_write( 23, 0xa102 );
+					phy_write( 16, 0x01ae );//MDI
+				} 
+				else {
+					//From Channel B
+					phy_Read_Write( 17, 0x0008, 0x0000 ); // clr set
+					phy_write(  23, 0xa102 );         // MDI
+					phy_write(  16, 0x010e );
+				}
+			} else {
+//				if ( IOTimingBund_arg == 0 ) {//Pseudo-random pattern
+//					phy_write( 31, 0x0006 );
+//					phy_write(  0, 0x5a21 );
+//					phy_write( 31, 0x0000 );
+//				} 
+//              else if ( IOTimingBund_arg == 1 ) {//FF pattern
+//					phy_write( 31, 0x0006 );
+//					phy_write(  2, 0x05ee );
+//					phy_write(  0, 0xff21 );
+//					phy_write( 31, 0x0000 );
+//				} else {//00 pattern
+//					phy_write( 31, 0x0006 );
+//					phy_write(  2, 0x05ee );
+//					phy_write(  0, 0x0021 );
+//					phy_write( 31, 0x0000 );
+//				}
+			}
+		} 
+		else {
+			phy_Reset(loop_phy);
+		}
+	} 
+	else if ( loop_phy ) {
+		phy_Reset(loop_phy);
+		
+		if ( GSpeed_sel[0] ) {
+			phy_write(20, 0x0042);//new in Rev. 1.6
+		}
+	} 
+	else {
+		if ( GSpeed_sel[0] ) {
+			phy_write( 31, 0x0001 );
+			phy_write(  3, 0xff41 );
+			phy_write(  2, 0xd720 );
+			phy_write(  1, 0x0140 );
+			phy_write(  0, 0x00bb );
+			phy_write(  4, 0xb800 );
+			phy_write(  4, 0xb000 );
+                              
+			phy_write( 31, 0x0007 );
+			phy_write( 30, 0x0040 );
+			phy_write( 24, 0x0008 );
+                              
+			phy_write( 31, 0x0000 );
+			phy_write(  9, 0x0300 );
+			phy_write( 26, 0x0020 );
+			phy_write(  0, 0x0140 );
+			phy_write( 23, 0xa101 );
+			phy_write( 21, 0x0200 );
+			phy_write( 23, 0xa121 );
+			phy_write( 23, 0xa161 );
+			phy_write(  0, 0x8000 );
+			phy_Wait_Reset_Done();
+			phy_delay(200); // new in Rev. 1.6
+//		} 
+//      else if ( GSpeed_sel[1] ) {//option
+//			phy_write( 31, 0x0000 );
+//			phy_write(  9, 0x0000 );
+//			phy_write(  4, 0x0061 );
+//			phy_write(  0, 0x1200 );
+//			phy_delay(5000);
+//		} 
+//      else if (GSpeed_sel[2]) {//option
+//			phy_write( 31, 0x0000 );
+//			phy_write(  9, 0x0000 );
+//			phy_write(  4, 0x05e1 );
+//			phy_write(  0, 0x1200 );
+//			phy_delay(5000);
+		} 
+		else {
+			phy_Reset(loop_phy);
+		}
+	}
+} // End void phy_realtek1 (int loop_phy)
+
+//------------------------------------------------------------
+void recov_phy_realtek2 (int loop_phy) {//RTL8211E
+	if ( BurstEnable ) {
+		if ( IEEETesting ) {
+			phy_write( 31, 0x0005 );
+			phy_write(  5, 0x8b86 );
+			phy_write(  6, 0xe201 );
+			phy_write( 31, 0x0007 );
+			phy_write( 30, 0x0020 );
+			phy_write( 21, 0x1108 );
+			phy_write( 31, 0x0000 );
+
+			if ( GSpeed_sel[0] ) {
+				phy_write( 31, 0x0000 );
+				phy_write(  9, 0x0000 );
+			} 
+			else if ( GSpeed_sel[1] ) {
+				phy_write( 31, 0x0007 );
+				phy_write( 30, 0x002f );
+				phy_write( 23, 0xd88f );
+				phy_write( 30, 0x002d );
+				phy_write( 24, 0xf050 );
+				phy_write( 31, 0x0000 );
+				phy_write( 16, 0x006e );
+			} 
+			else {
+			}
+		} 
+		else {
+		}
+	} 
+	else if (loop_phy) {
+	} 
+	else {
+		if (GSpeed_sel[0]) {
+			//Rev 1.5  //not stable
+//			phy_write( 31, 0x0000 );
+//			phy_write(  0, 0x8000 );
+//			phy_Wait_Reset_Done();
+//			phy_delay(30);
+//			phy_write( 23, 0x2160 );
+//			phy_write( 31, 0x0007 );
+//			phy_write( 30, 0x0040 );
+//			phy_write( 24, 0x0004 );
+//			phy_write( 24, 0x1a24 );
+//			phy_write( 25, 0xfd00 );
+//			phy_write( 24, 0x0000 );
+//			phy_write( 31, 0x0000 );
+//			phy_write(  0, 0x1140 );
+//			phy_write( 26, 0x0040 );
+//			phy_write( 31, 0x0007 );
+//			phy_write( 30, 0x002f );
+//			phy_write( 23, 0xd88f );
+//			phy_write( 30, 0x0023 );
+//			phy_write( 22, 0x0300 );
+//			phy_write( 31, 0x0000 );
+//			phy_write( 21, 0x1006 );
+//			phy_write( 23, 0x2100 );
+/**/
+			//Rev 1.6
+			phy_write( 31, 0x0000 );
+			phy_write(  0, 0x8000 );
+			phy_Wait_Reset_Done();
+			phy_delay(30);
+			phy_write( 31, 0x0007 );
+			phy_write( 30, 0x0042 );
+			phy_write( 21, 0x0500 );
+			phy_write( 31, 0x0000 );
+			phy_write(  0, 0x1140 );
+			phy_write( 26, 0x0040 );
+			phy_write( 31, 0x0007 );
+			phy_write( 30, 0x002f );
+			phy_write( 23, 0xd88f );
+			phy_write( 30, 0x0023 );
+			phy_write( 22, 0x0300 );
+			phy_write( 31, 0x0000 );
+			phy_write( 21, 0x1006 );
+			phy_write( 23, 0x2100 );
+/**/
+//		} else if (GSpeed_sel[1]) {//option
+//			phy_write( 31, 0x0000 );
+//			phy_write(  9, 0x0200 );
+//			phy_write(  0, 0x1200 );
+//		} else if (GSpeed_sel[2]) {//option
+//			phy_write( 31, 0x0000 );
+//			phy_write(  9, 0x0200 );
+//			phy_write(  4, 0x05e1 );
+//			phy_write(  0, 0x1200 );
+		}
+	}
+} // End void recov_phy_realtek2 (int loop_phy)
+
+//------------------------------------------------------------
+//internal loop 1G  : no  loopback stub
+//internal loop 100M: no  loopback stub
+//internal loop 10M : no  loopback stub
+void phy_realtek2 (int loop_phy) {//RTL8211E
+
+	if ( DbgPrn_PHYName ) 
+	    printf ("--->(%04lx %04lx)[Realtek] %s\n", PHY_ID2, PHY_ID3, PHYName);
+
+	phy_Read_Write( 0,  0x0000, 0x8000 | PHY_00h ); // clr set // Rst PHY
+	phy_Wait_Reset_Done();
+	phy_delay(30);
+
+	if ( BurstEnable ) {
+		if ( IEEETesting ) {
+			phy_write( 31, 0x0005 );
+			phy_write(  5, 0x8b86 );
+			phy_write(  6, 0xe200 );
+			phy_write( 31, 0x0007 );
+			phy_write( 30, 0x0020 );
+			phy_write( 21, 0x0108 );
+			phy_write( 31, 0x0000 );
+
+			if ( GSpeed_sel[0] ) {
+				phy_write( 31, 0x0000 );
+				
+				if ( IOTimingBund_arg == 0 ) {
+					phy_write( 9, 0x2000);//Test Mode 1
+				} 
+				else {
+					phy_write( 9, 0x8000);//Test Mode 4
+				}
+			} 
+			else if ( GSpeed_sel[1] ) {
+				phy_write( 31, 0x0007 );
+				phy_write( 30, 0x002f );
+				phy_write( 23, 0xd818 );
+				phy_write( 30, 0x002d );
+				phy_write( 24, 0xf060 );
+				phy_write( 31, 0x0000 );
+				
+				if ( IOTimingBund_arg == 0 ) {
+					phy_write(16, 0x00ae);//From Channel A
+				} 
+				else {
+					phy_write(16, 0x008e);//From Channel B
+				}
+			} 
+			else {
+			}
+		} 
+		else {
+			phy_basic_setting(loop_phy);
+			phy_delay(30);
+		}
+	} 
+	else if (loop_phy) {
+		phy_basic_setting(loop_phy);
+
+		phy_Read_Write(0,  0x0000, 0x8000 | PHY_00h);//clr set//Rst PHY
+		phy_Wait_Reset_Done();
+		phy_delay(30);
+
+		phy_basic_setting(loop_phy);
+		phy_delay(30);
+	} 
+	else {
+		if ( GSpeed_sel[0] ) {
+			//Rev 1.5  //not stable
+//			phy_write( 23, 0x2160 );
+//			phy_write( 31, 0x0007 );
+//			phy_write( 30, 0x0040 );
+//			phy_write( 24, 0x0004 );
+//			phy_write( 24, 0x1a24 );
+//			phy_write( 25, 0x7d00 );
+//			phy_write( 31, 0x0000 );
+//			phy_write( 23, 0x2100 );
+//			phy_write( 31, 0x0007 );
+//			phy_write( 30, 0x0040 );
+//			phy_write( 24, 0x0000 );
+//			phy_write( 30, 0x0023 );
+//			phy_write( 22, 0x0006 );
+//			phy_write( 31, 0x0000 );
+//			phy_write(  0, 0x0140 );
+//			phy_write( 26, 0x0060 );
+//			phy_write( 31, 0x0007 );
+//			phy_write( 30, 0x002f );
+//			phy_write( 23, 0xd820 );
+//			phy_write( 31, 0x0000 );
+//			phy_write( 21, 0x0206 );
+//			phy_write( 23, 0x2120 );
+//			phy_write( 23, 0x2160 );
+/**/                          
+            //Rev 1.6                     
+			phy_write( 31, 0x0007 );
+			phy_write( 30, 0x0042 );
+			phy_write( 21, 0x2500 );
+			phy_write( 30, 0x0023 );
+			phy_write( 22, 0x0006 );
+			phy_write( 31, 0x0000 );
+			phy_write(  0, 0x0140 );
+			phy_write( 26, 0x0060 );
+			phy_write( 31, 0x0007 );
+			phy_write( 30, 0x002f );
+			phy_write( 23, 0xd820 );
+			phy_write( 31, 0x0000 );
+			phy_write( 21, 0x0206 );
+			phy_write( 23, 0x2120 );
+			phy_write( 23, 0x2160 );
+			phy_delay(300);
+/**/
+//		} 
+//      else if ( GSpeed_sel[1] ) {//option
+//			phy_write( 31, 0x0000 );
+//			phy_write(  9, 0x0000 );
+//			phy_write(  4, 0x0061 );
+//			phy_write(  0, 0x1200 );
+//			phy_delay(5000);
+//		} 
+//      else if ( GSpeed_sel[2] ) {//option
+//			phy_write( 31, 0x0000 );
+//			phy_write(  9, 0x0000 );
+//			phy_write(  4, 0x05e1 );
+//			phy_write(  0, 0x1200 );
+//			phy_delay(5000);
+		} 
+		else {
+			phy_basic_setting(loop_phy);
+			phy_delay(150);
+		}
+	}
+} // End void phy_realtek2 (int loop_phy)
+
+//------------------------------------------------------------
+void recov_phy_realtek3 (int loop_phy) {//RTL8211C
+	if ( BurstEnable ) {
+		if ( IEEETesting ) {
+			if ( GSpeed_sel[0] ) {
+				phy_write(  9, 0x0000 );
+			} 
+			else if ( GSpeed_sel[1] ) {
+				phy_write( 17, PHY_11h );
+				phy_write( 14, 0x0000  );
+				phy_write( 16, 0x00a0  );
+			} 
+			else {
+//				phy_write( 31, 0x0006 );
+//				phy_write(  0, 0x5a00 );
+//				phy_write( 31, 0x0000 );
+			}
+		} 
+		else {
+		}
+	} 
+	else if (loop_phy) {
+		if ( GSpeed_sel[0] ) {
+			phy_write( 11, 0x0000 );
+		}
+		phy_write( 12, 0x1006 );
+	} 
+	else {
+		if ( GSpeed_sel[0] ) {
+			phy_write( 31, 0x0001 );
+			phy_write(  4, 0xb000 );
+			phy_write(  3, 0xff41 );
+			phy_write(  2, 0xdf20 );
+			phy_write(  1, 0x0140 );
+			phy_write(  0, 0x00bb );
+			phy_write(  4, 0xb800 );
+			phy_write(  4, 0xb000 );
+                              
+			phy_write( 31, 0x0000 );
+			phy_write( 25, 0x8c00 );
+			phy_write( 26, 0x0040 );
+			phy_write(  0, 0x1140 );
+			phy_write( 14, 0x0000 );
+			phy_write( 12, 0x1006 );
+			phy_write( 23, 0x2109 );
+		}
+	}
+}
+
+//------------------------------------------------------------
+void phy_realtek3 (int loop_phy) {//RTL8211C
+	if ( DbgPrn_PHYName ) 
+	    printf ("--->(%04lx %04lx)[Realtek] %s\n", PHY_ID2, PHY_ID3, PHYName);
+
+	if ( BurstEnable ) {
+		if ( IEEETesting ) {
+			if ( GSpeed_sel[0] ) {
+				if ( IOTimingBund_arg == 0 ) {   //Test Mode 1
+					phy_write( 9, 0x2000);
+				} 
+				else if (IOTimingBund_arg == 1) {//Test Mode 2
+					phy_write( 9, 0x4000);
+				} 
+				else if (IOTimingBund_arg == 2) {//Test Mode 3
+					phy_write( 9, 0x6000);
+				} 
+				else {                           //Test Mode 4
+					phy_write( 9, 0x8000);
+				}
+			} 
+			else if ( GSpeed_sel[1] ) {
+				PHY_11h = phy_read( PHY_SR );
+				phy_write( 17, PHY_11h & 0xfff7 );
+				phy_write( 14, 0x0660 );
+				
+				if ( IOTimingBund_arg == 0 ) {
+					phy_write( 16, 0x00a0 );//MDI  //From Channel A
+				} 
+				else {
+					phy_write( 16, 0x0080 );//MDIX //From Channel B
+				}
+			} 
+			else {
+//				if (IOTimingBund_arg == 0) {//Pseudo-random pattern
+//					phy_write( 31, 0x0006 );
+//					phy_write(  0, 0x5a21 );
+//					phy_write( 31, 0x0000 );
+//				} 
+//              else if (IOTimingBund_arg == 1) {//FF pattern
+//					phy_write( 31, 0x0006 );
+//					phy_write(  2, 0x05ee );
+//					phy_write(  0, 0xff21 );
+//					phy_write( 31, 0x0000 );
+//				} 
+//              else {//00 pattern
+//					phy_write( 31, 0x0006 );
+//					phy_write(  2, 0x05ee );
+//					phy_write(  0, 0x0021 );
+//					phy_write( 31, 0x0000 );
+//				}
+			}
+		} 
+		else {
+			phy_Reset(loop_phy);
+		}
+	} 
+	else if (loop_phy) {
+		phy_write( 0, 0x9200);
+		phy_Wait_Reset_Done();
+		phy_delay(30);
+
+		phy_write( 17, 0x401c );
+		phy_write( 12, 0x0006 );
+		
+		if ( GSpeed_sel[0] ) {
+			phy_write(11, 0x0002);
+		} 
+		else {
+			phy_basic_setting(loop_phy);
+		}
+	} 
+	else {
+		if (GSpeed_sel[0]) {
+			phy_write( 31, 0x0001 );
+			phy_write(  4, 0xb000 );
+			phy_write(  3, 0xff41 );
+			phy_write(  2, 0xd720 );
+			phy_write(  1, 0x0140 );
+			phy_write(  0, 0x00bb );
+			phy_write(  4, 0xb800 );
+			phy_write(  4, 0xb000 );
+                              
+			phy_write( 31, 0x0000 );
+			phy_write( 25, 0x8400 );
+			phy_write( 26, 0x0020 );
+			phy_write(  0, 0x0140 );
+			phy_write( 14, 0x0210 );
+			phy_write( 12, 0x0200 );
+			phy_write( 23, 0x2109 );
+			phy_write( 23, 0x2139 );
+		} 
+		else {
+			phy_Reset(loop_phy);
+		}
+	}
+} // End void phy_realtek3 (int loop_phy)
+
+//------------------------------------------------------------
+void phy_realtek4 (int loop_phy) {//RTL8201F
+	if ( DbgPrn_PHYName ) 
+	    printf ("--->(%04lx %04lx)[Realtek] %s\n", PHY_ID2, PHY_ID3, PHYName);
+
+	if ( BurstEnable ) {
+		if ( IEEETesting ) {
+			phy_write( 31, 0x0004 );
+			phy_write( 16, 0x4077 );
+			phy_write( 21, 0xc5a0 );
+			phy_write( 31, 0x0000 );
+
+			if ( GSpeed_sel[1] ) {
+				phy_write(  0, 0x8000 ); // Reset PHY
+				phy_write( 24, 0x0310 ); // Disable ALDPS
+				
+				if ( IOTimingBund_arg == 0 ) {
+					phy_write( 28, 0x40c2 ); //Force MDI //From Channel A (RJ45 pair 1, 2)
+				}                        
+				else {                   
+					phy_write( 28, 0x40c0 ); //Force MDIX//From Channel B (RJ45 pair 3, 6)
+				}
+				phy_write( 0, 0x2100);       //Force 100M/Full Duplex)
+			}
+		} else {
+			phy_Reset(loop_phy);
+		}
+	} 
+	else {
+		phy_Reset(loop_phy);
+	}
+}
+
+//------------------------------------------------------------
+void phy_smsc (int loop_phy) {//LAN8700
+	if ( DbgPrn_PHYName ) 
+	    printf ("--->(%04lx %04lx)[SMSC] %s\n", PHY_ID2, PHY_ID3, PHYName);
+
+	phy_Reset(loop_phy);
+}
+
+//------------------------------------------------------------
+void phy_micrel (int loop_phy) {//KSZ8041
+	if ( DbgPrn_PHYName ) 
+	    printf ("--->(%04lx %04lx)[Micrel] %s\n", PHY_ID2, PHY_ID3, PHYName);
+
+	phy_Reset(loop_phy);
+
+//	phy_write(24,  0x0600);
+}
+
+//------------------------------------------------------------
+void phy_micrel0 (int loop_phy) {//KSZ8031/KSZ8051
+	if ( DbgPrn_PHYName ) printf ("--->(%04lx %04lx)[Micrel] %s\n", PHY_ID2, PHY_ID3, PHYName);
+
+	//For KSZ8051RNL only
+	//Reg1Fh[7] = 0(default): 25MHz Mode, XI, XO(pin 9, 8) is 25MHz(crystal/oscilator).
+	//Reg1Fh[7] = 1         : 50MHz Mode, XI(pin 9) is 50MHz(oscilator).
+	PHY_1fh = phy_read(31);
+	if (PHY_1fh & 0x0080) sprintf(PHYName, "%s-50MHz Mode", PHYName);
+	else                  sprintf(PHYName, "%s-25MHz Mode", PHYName);
+
+	if (IEEETesting) {
+		phy_Read_Write( 0,  0x0000, 0x8000 | PHY_00h );//clr set//Rst PHY
+		phy_Wait_Reset_Done();
+
+		phy_Read_Write( 31, 0x0000, 0x2000 );//clr set//1Fh[13] = 1: Disable auto MDI/MDI-X
+		phy_basic_setting(loop_phy);
+		phy_Read_Write( 31, 0x0000, 0x0800 );//clr set//1Fh[11] = 1: Force link pass
+
+//		phy_delay(2500);//2.5 sec
+	} 
+	else {
+		phy_Reset(loop_phy);
+
+		//Reg16h[6] = 1         : RMII B-to-B override
+		//Reg16h[1] = 1(default): RMII override
+		phy_Read_Write( 22, 0x0000, 0x0042 );//clr set
+	}
+
+	if ( PHY_1fh & 0x0080 ) 
+	    phy_Read_Write( 31, 0x0000, 0x0080 );//clr set//Reset PHY will clear Reg1Fh[7]
+}
+
+//------------------------------------------------------------
+void recov_phy_vitesse (int loop_phy) {//VSC8601
+	if ( BurstEnable ) {
+//		if (IEEETesting) {
+//		} else {
+//		}
+	} 
+	else if ( loop_phy ) {
+	} 
+	else {
+		if ( GSpeed_sel[0] ) {
+			phy_write( 24, PHY_18h );
+			phy_write( 18, PHY_12h );
+		}
+	}
+}
+
+//------------------------------------------------------------
+void phy_vitesse (int loop_phy) {//VSC8601
+	if ( DbgPrn_PHYName ) 
+	    printf ("--->(%04lx %04lx)[VITESSE] %s\n", PHY_ID2, PHY_ID3, PHYName);
+
+	if ( BurstEnable ) {
+		if ( IEEETesting ) {
+			phy_Reset(loop_phy);
+		} 
+		else {
+			phy_Reset(loop_phy);
+		}
+	} 
+	else if ( loop_phy ) {
+		phy_Reset(loop_phy);
+	} 
+	else {
+		if ( GSpeed_sel[0] ) {
+			PHY_18h = phy_read( 24 );
+			PHY_12h = phy_read( PHY_INER );
+
+			phy_Reset(loop_phy);
+
+			phy_write( 24, PHY_18h | 0x0001 );
+			phy_write( 18, PHY_12h | 0x0020 );
+		} 
+		else {
+			phy_Reset(loop_phy);
+		}
+	}
+}
+
+//------------------------------------------------------------
+void phy_default (int loop_phy) {
+	if ( DbgPrn_PHYName ) 
+	    printf ("--->(%04lx %04lx)%s\n", PHY_ID2, PHY_ID3, PHYName);
+
+	phy_Reset(loop_phy);
+}
+
+//------------------------------------------------------------
+// PHY Init
+//------------------------------------------------------------
+BOOLEAN find_phyadr (void) {
+    ULONG       PHY_val;
+    BOOLEAN     ret = FALSE;
+    
+	#ifdef  DbgPrn_FuncHeader
+	    printf ("find_phyadr\n"); 
+	    Debug_delay();
+    #endif
+
+	do {
+	    // Check current PHY address by user setting
+	    PHY_val = phy_read( PHY_REG_ID_1 );
+    	if ( PHY_IS_VALID(PHY_val) ) {
+    		ret = TRUE;
+    		break;
+    	}
+    	 
+    	if ( Enable_SkipChkPHY ) {
+    		PHY_val = phy_read( PHY_REG_BMCR );
+    		
+    		if ((PHY_val & 0x8000) & Enable_InitPHY) {
+    		    // PHY is reseting and need to inital PHY
+                #ifndef Enable_SearchPHYID
+    			break;
+                #endif
+    		} 
+    		else {
+    			ret = TRUE;
+                break;    			
+    		}
+    	} 
+    	
+    	#ifdef Enable_SearchPHYID
+    	// Scan PHY address from 0 to 31
+        printf("Search PHY address\n");
+        for ( PHY_ADR = 0; PHY_ADR < 32; PHY_ADR++ ) {
+        	PHY_val = phy_read( PHY_REG_ID_1 );
+        	if ( PHY_IS_VALID(PHY_val) ) {
+        		ret = TRUE;
+        		break;
+        	}
+        }
+        // Don't find PHY address
+        PHY_ADR = PHY_ADR_arg;
+        #endif
+    } while ( 0 );
+
+	if ( ret == TRUE ) {
+		if ( PHY_ADR_arg != PHY_ADR ) {
+
+            if ( !BurstEnable ) 
+			    phy_id( FP_LOG );
+
+            phy_id( STD_OUT );
+		}
+	} 
+	else {
+
+		if ( !BurstEnable ) 
+		    phy_id( FP_LOG );
+
+        phy_id( STD_OUT );
+		FindErr( Err_PHY_Type );
+	}
+	
+	return ret;
+} // End BOOLEAN find_phyadr (void)
+
+//------------------------------------------------------------
+char phy_chk (ULONG id2, ULONG id3, ULONG id3_mask) {
+	if ((PHY_ID2 == id2) && ((PHY_ID3 & id3_mask) == (id3 & id3_mask))) 
+	    return(1);
+	else                                                                
+	    return(0);
+}
+
+//------------------------------------------------------------
+void phy_set00h (int loop_phy) {
+	#ifdef  DbgPrn_FuncHeader
+	    printf ("phy_set00h\n"); 
+	    Debug_delay();
+    #endif
+
+	if (BurstEnable) {
+		if (IEEETesting) {
+			if      (GSpeed_sel[0]) PHY_00h = 0x0140;
+			else if (GSpeed_sel[1]) PHY_00h = 0x2100;
+			else                    PHY_00h = 0x0100;
+		} 
+		else {
+			if      (GSpeed_sel[0]) PHY_00h = 0x1140;
+			else if (GSpeed_sel[1]) PHY_00h = 0x3100;
+			else                    PHY_00h = 0x1100;
+		}
+	} 
+	else if (loop_phy) {
+		if      (GSpeed_sel[0]) PHY_00h = 0x4140;
+		else if (GSpeed_sel[1]) PHY_00h = 0x6100;
+		else                    PHY_00h = 0x4100;
+	} 
+	else {
+		if      (GSpeed_sel[0]) PHY_00h = 0x0140;
+		else if (GSpeed_sel[1]) PHY_00h = 0x2100;
+		else                    PHY_00h = 0x0100;
+	}
+}
+
+//------------------------------------------------------------
+void phy_sel (int loop_phy) {
+	#ifdef  DbgPrn_FuncHeader
+	    printf ("phy_sel\n"); 
+	    Debug_delay();
+    #endif
+
+	PHY_ID2 = phy_read( PHY_REG_ID_1 );
+	PHY_ID3 = phy_read( PHY_REG_ID_2 );
+	phy_set00h(loop_phy);
+
+	if      ((PHY_ID2 == 0xffff) && (PHY_ID3 == 0xffff) && !Enable_SkipChkPHY) {
+	    sprintf(PHYName, "--"); 
+	    FindErr(Err_PHY_Type);
+	}
+#ifdef Enable_CheckZeroPHYID
+	else if ((PHY_ID2 == 0x0000) && (PHY_ID3 == 0x0000) && !Enable_SkipChkPHY) {
+	    sprintf(PHYName, "--"); FindErr(Err_PHY_Type);
+	}
+#endif
+
+	if      (phy_chk(0x0362, 0x5e6a, 0xfff0     )) {sprintf(PHYName, "BCM54612"        ); if (Enable_InitPHY) phy_broadcom0(loop_phy);}//BCM54612         1G/100/10M  RGMII
+	else if (phy_chk(0x0362, 0x5d10, 0xfff0     )) {sprintf(PHYName, "BCM54616S"       ); if (Enable_InitPHY) phy_broadcom0(loop_phy);}//BCM54616A        1G/100/10M  RGMII	    
+	else if (phy_chk(0x0040, 0x61e0, PHYID3_Mask)) {sprintf(PHYName, "BCM5221"         ); if (Enable_InitPHY) phy_broadcom (loop_phy);}//BCM5221             100/10M  MII, RMII
+	else if (phy_chk(0x0141, 0x0dd0, 0xfff0     )) {sprintf(PHYName, "88E1512"         ); if (Enable_InitPHY) phy_marvell2 (loop_phy);}//88E1512          1G/100/10M  RGMII
+	else if (phy_chk(0xff00, 0x1761, 0xffff     )) {sprintf(PHYName, "88E6176(IntLoop)"); if (Enable_InitPHY) phy_marvell1 (loop_phy);}//88E6176          1G/100/10M  2 RGMII Switch
+	else if (phy_chk(0x0141, 0x0e90, 0xfff0     )) {sprintf(PHYName, "88E1310"         ); if (Enable_InitPHY) phy_marvell0 (loop_phy);}//88E1310          1G/100/10M  RGMII
+	else if (phy_chk(0x0141, 0x0cc0, PHYID3_Mask)) {sprintf(PHYName, "88E1111"         ); if (Enable_InitPHY) phy_marvell  (loop_phy);}//88E1111          1G/100/10M  GMII, MII, RGMII
+	else if (phy_chk(0x001c, 0xc816, 0xffff     )) {sprintf(PHYName, "RTL8201F"        ); if (Enable_InitPHY) phy_realtek4 (loop_phy);}//RTL8201F            100/10M  MII, RMII
+	else if (phy_chk(0x001c, 0xc815, 0xfff0     )) {sprintf(PHYName, "RTL8201E"        ); if (Enable_InitPHY) phy_realtek0 (loop_phy);}//RTL8201E            100/10M  MII, RMII(RTL8201E(L)-VC only)
+	else if (phy_chk(0x001c, 0xc912, 0xffff     )) {sprintf(PHYName, "RTL8211C"        ); if (Enable_InitPHY) phy_realtek3 (loop_phy);}//RTL8211C         1G/100/10M  RGMII
+	else if (phy_chk(0x001c, 0xc914, 0xffff     )) {sprintf(PHYName, "RTL8211D"        ); if (Enable_InitPHY) phy_realtek1 (loop_phy);}//RTL8211D         1G/100/10M  GMII(RTL8211DN/RTL8211DG only), MII(RTL8211DN/RTL8211DG only), RGMII
+	else if (phy_chk(0x001c, 0xc915, 0xffff     )) {sprintf(PHYName, "RTL8211E"        ); if (Enable_InitPHY) phy_realtek2 (loop_phy);}//RTL8211E         1G/100/10M  GMII(RTL8211EG only), RGMII
+	else if (phy_chk(0x0000, 0x8201, PHYID3_Mask)) {sprintf(PHYName, "RTL8201N"        ); if (Enable_InitPHY) phy_realtek  (loop_phy);}//RTL8201N            100/10M  MII, RMII
+	else if (phy_chk(0x0007, 0xc0c4, PHYID3_Mask)) {sprintf(PHYName, "LAN8700"         ); if (Enable_InitPHY) phy_smsc     (loop_phy);}//LAN8700             100/10M  MII, RMII
+	else if (phy_chk(0x0022, 0x1555, 0xfff0     )) {sprintf(PHYName, "KSZ8031/KSZ8051" ); if (Enable_InitPHY) phy_micrel0  (loop_phy);}//KSZ8051/KSZ8031     100/10M  RMII
+	else if (phy_chk(0x0022, 0x1560, 0xfff0     )) {sprintf(PHYName, "KSZ8081"         ); if (Enable_InitPHY) phy_micrel0  (loop_phy);}//KSZ8081             100/10M  RMII
+	else if (phy_chk(0x0022, 0x1512, 0xfff0     )) {sprintf(PHYName, "KSZ8041"         ); if (Enable_InitPHY) phy_micrel   (loop_phy);}//KSZ8041             100/10M  RMII
+	else if (phy_chk(0x0007, 0x0421, 0xfff0     )) {sprintf(PHYName, "VSC8601"         ); if (Enable_InitPHY) phy_vitesse  (loop_phy);}//VSC8601          1G/100/10M  RGMII
+	else                                           {sprintf(PHYName, "default"         ); if (Enable_InitPHY) phy_default  (loop_phy);}//
+}
+
+//------------------------------------------------------------
+void recov_phy (int loop_phy) {
+	#ifdef  DbgPrn_FuncHeader
+	    printf ("recov_phy\n"); 
+	    Debug_delay();
+    #endif
+
+	if      (phy_chk(0x0362, 0x5e6a, 0xfff0     )) recov_phy_broadcom0(loop_phy);//BCM54612  1G/100/10M  RGMII
+	else if (phy_chk(0x0362, 0x5d10, 0xfff0     )) recov_phy_broadcom0(loop_phy);//BCM54616A 1G/100/10M  RGMII
+	else if (phy_chk(0x0141, 0x0dd0, 0xfff0     )) recov_phy_marvell2 (loop_phy);//88E1512   1G/100/10M  RGMII
+	else if (phy_chk(0xff00, 0x1761, 0xffff     )) recov_phy_marvell1 (loop_phy);//88E6176   1G/100/10M  2 RGMII Switch
+	else if (phy_chk(0x0141, 0x0e90, 0xfff0     )) recov_phy_marvell0 (loop_phy);//88E1310   1G/100/10M  RGMII
+	else if (phy_chk(0x0141, 0x0cc0, PHYID3_Mask)) recov_phy_marvell  (loop_phy);//88E1111   1G/100/10M  GMII, MII, RGMII
+	else if (phy_chk(0x001c, 0xc914, 0xffff     )) recov_phy_realtek1 (loop_phy);//RTL8211D  1G/100/10M  GMII(RTL8211DN/RTL8211DG only), MII(RTL8211DN/RTL8211DG only), RGMII
+	else if (phy_chk(0x001c, 0xc915, 0xffff     )) recov_phy_realtek2 (loop_phy);//RTL8211E  1G/100/10M  GMII(RTL8211EG only), RGMII
+	else if (phy_chk(0x001c, 0xc912, 0xffff     )) recov_phy_realtek3 (loop_phy);//RTL8211C  1G/100/10M  RGMII
+	else if (phy_chk(0x0007, 0x0421, 0xfff0     )) recov_phy_vitesse  (loop_phy);//VSC8601   1G/100/10M  RGMII
+}
+
+//------------------------------------------------------------
+void init_phy (int loop_phy) {
+	#ifdef  DbgPrn_FuncHeader
+	    printf ("init_phy\n"); 
+	    Debug_delay();
+    #endif
+	
+	sprintf( PHYID, "PHY%d", SelectMAC + 1 );
+
+	if ( DbgPrn_PHYInit ) 
+	    phy_dump( PHYID );
+
+	if ( find_phyadr() == TRUE ) 
+	    phy_sel( loop_phy );
+
+	if ( DbgPrn_PHYInit )
+	    phy_dump( PHYID );
+}
+
+
diff --git a/arch/arm/cpu/arm926ejs/aspeed/PLLTESTU.H b/arch/arm/cpu/arm926ejs/aspeed/PLLTESTU.H
new file mode 100644
index 0000000..6fa96e6
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/aspeed/PLLTESTU.H
@@ -0,0 +1,50 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef PLLTESTU_H
+#define PLLTESTU_H
+
+//PLL Mode Definition
+#define	NAND_PLLMODE		    0x00
+#define	DELAY_PLLMODE		    0x04
+#define	PCI_PLLMODE	            0x08
+#define	DPLL_PLLMODE		    0x2c
+#define	MPLL_PLLMODE		    0x10
+#define	HPLL_PLLMODE		    0x14
+#define	LPC_PLLMODE	            0x18
+#define	VIDEOA_PLLMODE		    0x1c
+#define	D2PLL_PLLMODE		    0x0c
+#define	VIDEOB_PLLMODE		    0x3c
+
+#define	PCI_PLLMODE_AST1160     0x10
+#define	MPLL_PLLMODE_AST1160	0x14
+#define	HPLL_PLLMODE_AST1160	0x14
+#define	DPLL_PLLMODE_AST1160	0x1c
+
+#define	PCI_PLLMODE_AST2300     0x2c
+#define	MPLL_PLLMODE_AST2300	0x10
+#define	HPLL_PLLMODE_AST2300	0x30
+#define	DPLL_PLLMODE_AST2300	0x08
+#define	DEL0_PLLMODE_AST2300	0x00
+
+#define ERR_FATAL		0x00000001
+
+typedef struct _VGAINFO {
+    USHORT usDeviceID;
+    UCHAR  jRevision;           
+    
+    ULONG  ulMCLK;
+    ULONG  ulDRAMBusWidth;    
+    
+    ULONG  ulCPUCLK;
+    ULONG  ulAHBCLK;    
+} _VGAInfo;
+
+#endif // End PLLTESTU_H
diff --git a/arch/arm/cpu/arm926ejs/aspeed/PLLTESTU.c b/arch/arm/cpu/arm926ejs/aspeed/PLLTESTU.c
new file mode 100644
index 0000000..95958b0
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/aspeed/PLLTESTU.c
@@ -0,0 +1,411 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#define PLLTEST_C
+static const char ThisFile[] = "PLLTEST.c";
+
+#include "SWFUNC.H"
+
+#include <COMMINF.H>
+#include <STDUBOOT.H>
+#include <TYPEDEF.H>
+#include <IO.H>
+#include <PLLTESTU.H>
+
+/*
+ * static
+ */
+static UCHAR jVersion[] = "v.0.57.00";
+             
+void print_usage( void )
+{
+    printf(" PLLTest [pll mode] [err rate]\n");
+    printf("      [pll mode] h-pll: ARM CPU Clock PLL\n");
+    printf("                 m-pll: Memory Clock PLL\n");
+    printf("      [err rate] Error Rate: unit %\n");
+    printf("                 default is 1%\n");
+}             
+             
+BOOL CompareToRing(_VGAInfo *VGAInfo, ULONG ulPLLMode, ULONG ulDCLK, ULONG ulErrRate)
+{
+    ULONG ulCounter, ulLowLimit, ulHighLimit;
+    ULONG ulData, ulValue, ulDiv;
+    ULONG ulSCUBase;
+    double del0;
+    ULONG uldel0;
+    
+    if ((VGAInfo->usDeviceID == 0x1160) || (VGAInfo->usDeviceID == 0x1180))
+        ulSCUBase = 0x80fc8200;    
+    else
+        ulSCUBase = 0x1e6e2000;
+
+    //Fixed AST2300 H-PLL can't Get Correct Value in VGA only mode, ycchen@081711
+    if ( (VGAInfo->jRevision >= 0x20) && (ulPLLMode == HPLL_PLLMODE_AST2300) )
+    {
+        WriteSOC_DD(ulSCUBase, 0x1688a8a8);	    
+        ulData = ReadSOC_DD(ulSCUBase + 0x08);            
+        WriteSOC_DD(ulSCUBase + 0x08, ulData & 0xFFFFFF00);	    
+    }
+	    	    
+    ulCounter = (ulDCLK/1000) * 512 / 24000 - 1;
+    ulLowLimit = ulCounter * (100 - ulErrRate) / 100;
+    ulHighLimit = ulCounter * (100 + ulErrRate) / 100;
+
+    DELAY(10);
+    WriteSOC_DD(ulSCUBase, 0x1688a8a8);
+    WriteSOC_DD(ulSCUBase + 0x28, (ulHighLimit << 16) | ulLowLimit);
+    WriteSOC_DD(ulSCUBase + 0x10, ulPLLMode);
+    WriteSOC_DD(ulSCUBase + 0x10, ulPLLMode | 0x03);
+    DELAY(1);
+    do {
+        ulData = ReadSOC_DD(ulSCUBase + 0x10);            
+    } while (!(ulData & 0x40));	
+    ulValue = ReadSOC_DD(ulSCUBase + 0x14);            
+    
+    //Patch for AST1160/1180 DCLK calculate
+    if ( ((VGAInfo->usDeviceID == 0x1160) || (VGAInfo->usDeviceID == 0x1180)) && (ulPLLMode == DPLL_PLLMODE_AST1160) )
+    {
+        ulData = ReadSOC_DD(0x80fc906c);            
+    	ulDiv   = ulData & 0x000c0000;
+    	ulDiv >>= 18;
+    	ulDiv++;
+    	ulValue /= ulDiv;
+    }
+    
+    if ( (VGAInfo->jRevision >= 0x20) && (ulPLLMode == DEL0_PLLMODE_AST2300) )
+    {
+      del0 = (double)(24.0 * (ulValue + 1) / 512.0);
+      del0 = 1000/del0/16/8;
+      uldel0 = (ULONG) (del0 * 1000000);
+      if (uldel0 < ulDCLK)
+      {
+          printf( "[PASS][DEL0] Actual DEL0:%f ns, Max. DEL0:%f ns \n", del0, (double)ulDCLK/1000000);    		      
+          ulData |= 0x80;
+      }    
+      else
+      {
+          printf( "[ERROR][DEL0] Actual DEL0:%f ns, Max. DEL0:%f ns \n", del0, (double)ulDCLK/1000000);    		      	      
+          ulData == 0x00;    
+      }    
+    }	
+    else
+    {
+        printf( "[INFO] PLL Predict Count = %x, Actual Count = %x \n", ulCounter, ulValue);	
+    }
+    
+    WriteSOC_DD(ulSCUBase + 0x10, 0x2C);	//disable ring
+        
+    if (ulData & 0x80)
+        return (TRUE);
+    else
+        return(FALSE);    	
+} /* CompareToRing */	
+
+VOID GetDRAMInfo(_VGAInfo *VGAInfo)
+{
+    ULONG ulData, ulData2;
+    ULONG ulRefPLL, ulDeNumerator, ulNumerator, ulDivider, ulOD;
+
+    if (VGAInfo->jRevision >= 0x10)
+    {
+        WriteSOC_DD(0x1e6e2000, 0x1688A8A8);
+	    
+        //Get DRAM Bus Width
+        ulData  = ReadSOC_DD(0x1e6e0004);        
+        if (ulData & 0x40)
+           VGAInfo->ulDRAMBusWidth = 16;
+        else    
+           VGAInfo->ulDRAMBusWidth = 32;    
+  
+        ulRefPLL = 24000;	            
+        if (VGAInfo->jRevision >= 0x30)	//AST2400
+        {
+            ulData = ReadSOC_DD(0x1e6e2070);
+            if (ulData & 0x00800000)	//D[23] = 1
+                ulRefPLL = 25000;	            
+        }         
+
+        ulData  = ReadSOC_DD(0x1e6e2020);                                
+        ulDeNumerator = ulData & 0x0F;
+        ulNumerator = (ulData & 0x07E0) >> 5;
+        ulOD = (ulData & 0x10) ? 1:2;
+            
+        ulData = (ulData & 0x7000) >> 12;        
+        switch (ulData)
+        {
+            case 0x07:
+                ulDivider = 16;
+                break;
+            case 0x06:
+                ulDivider = 8;
+                break;
+            case 0x05:
+                ulDivider = 4;
+                break;
+            case 0x04:
+                ulDivider = 2;
+                break;        
+            default:
+                ulDivider = 0x01;                         
+        }    
+    
+        VGAInfo->ulMCLK = ulRefPLL * ulOD * (ulNumerator + 2) / ((ulDeNumerator + 1) * ulDivider * 1000);                  	        
+    }    
+} // GetDRAMInfo
+
+VOID GetCLKInfo( _VGAInfo *VGAInfo)
+{
+    ULONG ulData, ulCPUTrap, ulAHBTrap;
+    ULONG ulRefPLL, ulDeNumerator, ulNumerator, ulDivider, ulOD;
+
+    if (VGAInfo->jRevision >= 0x30)
+    {
+        WriteSOC_DD(0x1e6e2000, 0x1688a8a8);
+        ulData = ReadSOC_DD(0x1e6e2024);            
+        if (ulData & 0x40000)		//from H-PLL		
+        {
+            ulRefPLL = 24000;	            
+            ulData = ReadSOC_DD(0x1e6e2070);
+            if (ulData & 0x00800000)	//D[23] = 1
+                ulRefPLL = 25000;	            
+	        
+            ulData = ReadSOC_DD(0x1e6e2024);            
+                
+            ulDeNumerator = ulData & 0x0F;
+            ulNumerator = (ulData & 0x07E0) >> 5;
+            ulOD = (ulData & 0x10) ? 1:2;                    
+            
+            VGAInfo->ulCPUCLK = ulRefPLL * ulOD * (ulNumerator + 2) / ((ulDeNumerator + 1) * 1000);          
+        	
+        }
+        else				//from trapping
+        {        
+             ulRefPLL = 24;	            
+             ulData = ReadSOC_DD(0x1e6e2070);
+             if (ulData & 0x00800000)	//D[23] = 1
+                ulRefPLL = 25; 
+                         
+             ulCPUTrap = ulData & 0x0300;
+             ulCPUTrap >>= 8;
+         
+             switch (ulCPUTrap)
+             {
+                case 0x00:
+                    VGAInfo->ulCPUCLK = ulRefPLL * 16;
+                    break;
+                case 0x01:
+                    VGAInfo->ulCPUCLK = ulRefPLL * 15;
+                    break;
+                case 0x02:
+                    VGAInfo->ulCPUCLK = ulRefPLL * 14;
+                    break;
+                case 0x03:
+                    VGAInfo->ulCPUCLK = ulRefPLL * 17;
+                    break;
+             }	
+         
+        }
+        
+        ulData = ReadSOC_DD(0x1e6e2070);            
+        ulAHBTrap = ulData & 0x0c00;
+        ulAHBTrap >>= 10;        
+        switch (ulAHBTrap)
+        {
+            case 0x00:
+                VGAInfo->ulAHBCLK = VGAInfo->ulCPUCLK;
+                break;	
+            case 0x01:
+                VGAInfo->ulAHBCLK = VGAInfo->ulCPUCLK / 2;
+                break;	        
+            case 0x02:
+                VGAInfo->ulAHBCLK = VGAInfo->ulCPUCLK / 4;
+                break;	        
+            case 0x03:
+                VGAInfo->ulAHBCLK = VGAInfo->ulCPUCLK / 3;
+            break;	
+        }	
+	        
+    } //AST2400	    
+    else if (VGAInfo->jRevision >= 0x20)
+    {
+        WriteSOC_DD(0x1e6e2000, 0x1688a8a8);
+        ulData = ReadSOC_DD(0x1e6e2024);            
+        if (ulData & 0x40000)		//from H-PLL		
+        {
+            ulRefPLL = 24000;
+            
+            ulData = ReadSOC_DD(0x1e6e2024);            
+                
+            ulDeNumerator = ulData & 0x0F;
+            ulNumerator = (ulData & 0x07E0) >> 5;
+            ulOD = (ulData & 0x10) ? 1:2;                    
+            
+            VGAInfo->ulCPUCLK = ulRefPLL * ulOD * (ulNumerator + 2) / ((ulDeNumerator + 1) * 1000);          
+        	
+        }
+        else				//from trapping
+        {        
+             ulData = ReadSOC_DD(0x1e6e2070);            
+             ulCPUTrap = ulData & 0x0300;
+             ulCPUTrap >>= 8;
+         
+             switch (ulCPUTrap)
+             {
+                case 0x00:
+                    VGAInfo->ulCPUCLK = 384;
+                    break;
+                case 0x01:
+                    VGAInfo->ulCPUCLK = 360;
+                    break;
+                case 0x02:
+                    VGAInfo->ulCPUCLK = 336;
+                    break;
+                case 0x03:
+                    VGAInfo->ulCPUCLK = 408;
+                    break;
+             }	
+         
+        }
+        
+        ulData = ReadSOC_DD(0x1e6e2070);            
+        ulAHBTrap = ulData & 0x0c00;
+        ulAHBTrap >>= 10;        
+        switch (ulAHBTrap)
+        {
+            case 0x00:
+                VGAInfo->ulAHBCLK = VGAInfo->ulCPUCLK;
+                break;	
+            case 0x01:
+                VGAInfo->ulAHBCLK = VGAInfo->ulCPUCLK / 2;
+                break;	        
+            case 0x02:
+                VGAInfo->ulAHBCLK = VGAInfo->ulCPUCLK / 4;
+                break;	        
+            case 0x03:
+                VGAInfo->ulAHBCLK = VGAInfo->ulCPUCLK / 3;
+            break;	
+        }	
+	        
+    } //AST2300    
+} // GetCLKInfo
+
+int pll_function(int argc, char *argv[])
+{
+    _VGAInfo *pVGAInfo;
+    ULONG    ulErrRate = 1;
+    ULONG    PLLMode;
+    ULONG    RefClk;
+    CHAR     *stop_at;
+    CHAR     i;
+    
+    printf("**************************************************** \n");       
+    printf("*** ASPEED Graphics PLL Test %s Log       *** \n", jVersion);
+    printf("***                                   for u-boot *** \n");
+    printf("**************************************************** \n"); 
+    printf("\n"); 
+    
+    // Check chip type
+    switch ( ReadSOC_DD( 0x1e6e2000 + 0x7c ) ) {   
+        case 0x02010303 :
+        case 0x02000303 : 
+            printf("The chip is AST2400\n" ); 
+            pVGAInfo->usDeviceID = 0x2400; 
+            pVGAInfo->jRevision  = 0x30;         
+            break;
+            
+        case 0x02010103 :
+        case 0x02000003 : 
+            printf("The chip is AST1400\n" ); 
+            pVGAInfo->usDeviceID = 0x1400; 
+            pVGAInfo->jRevision  = 0x30;   
+            break;
+            
+        case 0x01010303 :
+        case 0x01000003 : 
+            printf("The chip is AST2300\n" ); 
+            pVGAInfo->usDeviceID = 0x2300; 
+            pVGAInfo->jRevision  = 0x20;   
+            break;
+        
+        case 0x01010203 : 
+            printf("The chip is AST1050\n" ); 
+            pVGAInfo->usDeviceID = 0x1050; 
+            pVGAInfo->jRevision  = 0x20;   
+            break;
+                    
+        default     : 
+            printf ("Error Silicon Revision ID(SCU7C) %08lx!!!\n", ReadSOC_DD( 0x1e6e2000 + 0x7c ) ); 
+            return(1);
+    }
+    
+    
+    GetDRAMInfo( pVGAInfo );
+    GetCLKInfo( pVGAInfo );
+
+    if ( ( argc <= 1 ) || ( argc >= 4 ) ){
+        print_usage();
+        return (ERR_FATAL);
+    }
+    else {
+        for ( i = 1; i < argc; i++ ) {
+            switch ( i ) {
+                case 1:
+                    if (!strcmp(argv[i], "m-pll"))
+                    {
+                    	if (pVGAInfo->jRevision >= 0x20)
+                    	    PLLMode = MPLL_PLLMODE_AST2300;
+                    	else
+                    	    PLLMode = MPLL_PLLMODE;
+                    	
+                    	RefClk = pVGAInfo->ulMCLK * 1000000;
+                    	if (pVGAInfo->jRevision >= 0x20)	//dual-edge
+                    	    RefClk /= 2;            	
+                    }
+                    else if (!strcmp(argv[i], "h-pll"))
+                    {
+           	            if (pVGAInfo->jRevision >= 0x20)
+                            PLLMode = HPLL_PLLMODE_AST2300;
+                        else
+                            PLLMode = HPLL_PLLMODE;
+                        
+                        //AST2300 only has HCLK ring test mode, ycchen@040512
+                        RefClk = pVGAInfo->ulCPUCLK * 1000000;	//Other  : H-PLL
+                        if (pVGAInfo->jRevision >= 0x20)	//AST2300: HCLK
+                            RefClk = pVGAInfo->ulAHBCLK * 1000000;
+                    }
+                    else {
+                        print_usage();
+                        return (ERR_FATAL);
+                    }
+                    break;
+                case 2:
+                    ulErrRate = (ULONG) strtoul(argv[i], &stop_at, 10);	                    
+
+                    break;
+                default: 
+                    break;
+            } // End switch()
+        } // End for
+    } 
+    
+    /* Compare ring */
+    if (CompareToRing(pVGAInfo, PLLMode, RefClk, ulErrRate ) == TRUE)
+    {
+	    printf("[PASS] %s PLL Check Pass!! \n", argv[1]);
+        return 0;
+    }
+    else
+    {
+	    printf("[ERROR] %s PLL Check Failed!! \n", argv[1]);	
+        return (ERR_FATAL);
+    }
+}
+
+
diff --git a/arch/arm/cpu/arm926ejs/aspeed/SPIM.c b/arch/arm/cpu/arm926ejs/aspeed/SPIM.c
new file mode 100644
index 0000000..e1bdd07
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/aspeed/SPIM.c
@@ -0,0 +1,63 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#define SPIM_C
+static const char ThisFile[] = "SPIM.c";
+
+#include "SWFUNC.H"
+
+#ifdef SPI_BUS
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <conio.h>
+#include <string.h>
+#include "TYPEDEF.H"
+#include "LIB_SPI.H"
+
+#define SPIM_CMD_WHA     0x01
+#define SPIM_CMD_RD      0x0B
+#define SPIM_CMD_DRD     0xBB
+#define SPIM_CMD_WR      0x02
+#define SPIM_CMD_DWR     0xD2
+#define SPIM_CMD_STA     0x05
+#define SPIM_CMD_ENBYTE  0x06
+#define SPIM_CMD_DISBYTE 0x04
+
+ULONG spim_cs;
+ULONG spim_base;
+ULONG spim_hadr;
+
+void spim_end()
+{
+  ULONG data;
+
+  data = MIndwm((ULONG)mmiobase, 0x1E620010 + (spim_cs << 2));
+  MOutdwm( (ULONG)mmiobase, 0x1E620010 + (spim_cs << 2), data | 0x4);
+  MOutdwm( (ULONG)mmiobase, 0x1E620010 + (spim_cs << 2), data);
+}
+
+//------------------------------------------------------------
+void spim_init(int cs)
+{
+  ULONG data;
+
+  spim_cs = cs;
+  MOutdwm( (ULONG)mmiobase, 0x1E620000, (0x2 << (cs << 1)) | (0x10000 << cs));
+  MOutdwm( (ULONG)mmiobase, 0x1E620010 + (cs << 2), 0x00000007);
+  MOutdwm( (ULONG)mmiobase, 0x1E620010 + (cs << 2), 0x00002003);
+  MOutdwm( (ULONG)mmiobase, 0x1E620004, 0x100 << cs);
+  data = MIndwm((ULONG)mmiobase, 0x1E620030 + (cs << 2));
+  spim_base = 0x20000000 | ((data & 0x007f0000) << 7);
+  MOutwm ( (ULONG)mmiobase, spim_base, SPIM_CMD_WHA);
+  spim_end();
+  spim_hadr = 0;
+}
+#endif // End SPI_BUS
diff --git a/arch/arm/cpu/arm926ejs/aspeed/STDUBOOT.H b/arch/arm/cpu/arm926ejs/aspeed/STDUBOOT.H
new file mode 100644
index 0000000..7fbf590
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/aspeed/STDUBOOT.H
@@ -0,0 +1,18 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef STDUBOOT_H
+#define STDUBOOT_H
+
+unsigned long int strtoul(char *string, char **endPtr, int base);
+int atoi( char s[] );
+int rand(void);
+
+#endif // End STDUBOOT_H
diff --git a/arch/arm/cpu/arm926ejs/aspeed/STDUBOOT.c b/arch/arm/cpu/arm926ejs/aspeed/STDUBOOT.c
new file mode 100644
index 0000000..90e2997
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/aspeed/STDUBOOT.c
@@ -0,0 +1,235 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#define STDUBOOT_C
+static const char ThisFile[] = "STDUBOOT.c";
+
+#include "SWFUNC.H"
+
+#ifdef SLT_UBOOT
+
+int isspace ( char c )
+{
+    if ( ( c == ' ' ) || ( c == 9 ) || ( c == 13 ) )
+        return 1;
+    
+    return 0;
+}
+
+/* 
+ * strtoul.c --
+ *
+ *  Source code for the "strtoul" library procedure.
+ *
+ * Copyright 1988 Regents of the University of California
+ * Permission to use, copy, modify, and distribute this
+ * software and its documentation for any purpose and without
+ * fee is hereby granted, provided that the above copyright
+ * notice appear in all copies.  The University of California
+ * makes no representations about the suitability of this
+ * software for any purpose.  It is provided "as is" without
+ * express or implied warranty.
+ */
+
+//#include <ctype.h>
+
+/*
+ * The table below is used to convert from ASCII digits to a
+ * numerical equivalent.  It maps from '0' through 'z' to integers
+ * (100 for non-digit characters).
+ */
+
+static char cvtIn[] = {
+    0, 1, 2, 3, 4, 5, 6, 7, 8, 9,       /* '0' - '9' */
+    100, 100, 100, 100, 100, 100, 100,      /* punctuation */
+    10, 11, 12, 13, 14, 15, 16, 17, 18, 19, /* 'A' - 'Z' */
+    20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
+    30, 31, 32, 33, 34, 35,
+    100, 100, 100, 100, 100, 100,       /* punctuation */
+    10, 11, 12, 13, 14, 15, 16, 17, 18, 19, /* 'a' - 'z' */
+    20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
+    30, 31, 32, 33, 34, 35};
+
+/*
+ *----------------------------------------------------------------------
+ *
+ * strtoul --
+ *
+ *  Convert an ASCII string into an integer.
+ *
+ * Results:
+ *  The return value is the integer equivalent of string.  If endPtr
+ *  is non-NULL, then *endPtr is filled in with the character
+ *  after the last one that was part of the integer.  If string
+ *  doesn't contain a valid integer value, then zero is returned
+ *  and *endPtr is set to string.
+ *
+ * Side effects:
+ *  None.
+ *
+ *----------------------------------------------------------------------
+ */
+
+unsigned long int
+strtoul(char *string, char **endPtr, int base)
+    /* string;     String of ASCII digits, possibly
+                 * preceded by white space.  For bases
+                 * greater than 10, either lower- or
+                 * upper-case digits may be used.
+                 */
+    /* **endPtr;   Where to store address of terminating
+                 * character, or NULL. */
+    /* base;       Base for conversion.  Must be less
+                 * than 37.  If 0, then the base is chosen
+                 * from the leading characters of string:
+                 * "0x" means hex, "0" means octal, anything
+                 * else means decimal.
+                 */
+{
+    register char *p;
+    register unsigned long int result = 0;
+    register unsigned digit;
+    int anyDigits = 0;
+
+    /*
+     * Skip any leading blanks.
+     */
+
+    p = string;
+    while (isspace(*p)) {
+    p += 1;
+    }
+
+    /*
+     * If no base was provided, pick one from the leading characters
+     * of the string.
+     */
+    
+    if (base == 0)
+    {
+    if (*p == '0') {
+        p += 1;
+        if (*p == 'x') {
+        p += 1;
+        base = 16;
+        } else {
+
+        /*
+         * Must set anyDigits here, otherwise "0" produces a
+         * "no digits" error.
+         */
+
+        anyDigits = 1;
+        base = 8;
+        }
+    }
+    else base = 10;
+    } else if (base == 16) {
+
+    /*
+     * Skip a leading "0x" from hex numbers.
+     */
+
+    if ((p[0] == '0') && (p[1] == 'x')) {
+        p += 2;
+    }
+    }
+
+    /*
+     * Sorry this code is so messy, but speed seems important.  Do
+     * different things for base 8, 10, 16, and other.
+     */
+
+    if (base == 8) {
+    for ( ; ; p += 1) {
+        digit = *p - '0';
+        if (digit > 7) {
+        break;
+        }
+        result = (result << 3) + digit;
+        anyDigits = 1;
+    }
+    } else if (base == 10) {
+    for ( ; ; p += 1) {
+        digit = *p - '0';
+        if (digit > 9) {
+        break;
+        }
+        result = (10*result) + digit;
+        anyDigits = 1;
+    }
+    } else if (base == 16) {
+    for ( ; ; p += 1) {
+        digit = *p - '0';
+        if (digit > ('z' - '0')) {
+        break;
+        }
+        digit = cvtIn[digit];
+        if (digit > 15) {
+        break;
+        }
+        result = (result << 4) + digit;
+        anyDigits = 1;
+    }
+    } else {
+    for ( ; ; p += 1) {
+        digit = *p - '0';
+        if (digit > ('z' - '0')) {
+        break;
+        }
+        digit = cvtIn[digit];
+        if (digit >= base) {
+        break;
+        }
+        result = result*base + digit;
+        anyDigits = 1;
+    }
+    }
+
+    /*
+     * See if there were any digits at all.
+     */
+
+    if (!anyDigits) {
+    p = string;
+    }
+
+    if (endPtr != 0) {
+    *endPtr = p;
+    }
+
+    return result;
+}
+
+// -----------------------------------------------------------------------------
+int atoi( char s[] )
+{
+
+    int i;
+    int ans = 0;
+
+    for( i = 0; s[i] >= '0' && s[i] <= '9'; ++i )
+        ans = ( 10 * ans ) + ( s[i] - '0' );
+
+    return ans;
+} 
+
+// -----------------------------------------------------------------------------
+/* rand:return pseudo-random integer on 0...32767 */
+int rand(void)
+{
+    static unsigned long int next = 1;
+    
+    next = next * 1103515245 + 12345; 
+
+    return (unsigned int) ( next / 65536 ) % 32768;
+}
+
+#endif // End SLT_UBOOT
diff --git a/arch/arm/cpu/arm926ejs/aspeed/STRESS.c b/arch/arm/cpu/arm926ejs/aspeed/STRESS.c
new file mode 100644
index 0000000..dffd64f
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/aspeed/STRESS.c
@@ -0,0 +1,145 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#define STRESS_C
+static const char ThisFile[] = "STRESS.c";
+
+#include "SWFUNC.H"
+#include <COMMINF.H>
+#include <IO.H>
+
+#define TIMEOUT_DRAM              5000000
+
+/* ------------------------------------------------------------------------- */
+int MMCTestBurst(unsigned int datagen)
+{
+  unsigned int data;
+  unsigned int timeout = 0;
+  
+  WriteSOC_DD( 0x1E6E0070, 0x00000000 );
+  WriteSOC_DD( 0x1E6E0070, (0x000000C1 | (datagen << 3)) );
+  
+  do {
+    data = ReadSOC_DD( 0x1E6E0070 ) & 0x3000;
+
+    if( data & 0x2000 )
+      return(0);
+
+    if( ++timeout > TIMEOUT_DRAM ) {
+      printf("Timeout!!\n");
+      WriteSOC_DD( 0x1E6E0070, 0x00000000 );
+      
+      return(0);
+    }
+  } while( !data );
+  WriteSOC_DD( 0x1E6E0070, 0x00000000 );
+  
+  return(1);
+}
+
+/* ------------------------------------------------------------------------- */
+int MMCTestSingle(unsigned int datagen)
+{
+  unsigned int data;
+  unsigned int timeout = 0;
+
+  WriteSOC_DD( 0x1E6E0070, 0x00000000 );
+  WriteSOC_DD( 0x1E6E0070, (0x00000085 | (datagen << 3)) );
+  
+  do {
+    data = ReadSOC_DD( 0x1E6E0070 ) & 0x3000;
+    
+    if( data & 0x2000 )
+      return(0);
+    
+    if( ++timeout > TIMEOUT_DRAM ){
+      printf("Timeout!!\n");
+      WriteSOC_DD( 0x1E6E0070, 0x00000000 );
+      
+      return(0);
+    }
+  } while ( !data );
+  WriteSOC_DD( 0x1E6E0070, 0x00000000 );
+  
+  return(1);
+}
+
+/* ------------------------------------------------------------------------- */
+int MMCTest()
+{
+  unsigned int pattern;
+
+  pattern = ReadSOC_DD( 0x1E6E2078 );
+  printf("Pattern = %08X : ",pattern);
+
+  WriteSOC_DD(0x1E6E0074, (DRAM_MapAdr | 0x7fffff) );
+  WriteSOC_DD(0x1E6E007C, pattern );
+  
+  if(!MMCTestBurst(0))    return(0);
+  if(!MMCTestBurst(1))    return(0);
+  if(!MMCTestBurst(2))    return(0);
+  if(!MMCTestBurst(3))    return(0);
+  if(!MMCTestBurst(4))    return(0);
+  if(!MMCTestBurst(5))    return(0);
+  if(!MMCTestBurst(6))    return(0);
+  if(!MMCTestBurst(7))    return(0);
+  if(!MMCTestSingle(0))   return(0);
+  if(!MMCTestSingle(1))   return(0);
+  if(!MMCTestSingle(2))   return(0);
+  if(!MMCTestSingle(3))   return(0);
+  if(!MMCTestSingle(4))   return(0);
+  if(!MMCTestSingle(5))   return(0);
+  if(!MMCTestSingle(6))   return(0);
+  if(!MMCTestSingle(7))   return(0);
+
+  return(1);
+}
+
+/* ------------------------------------------------------------------------- */
+int dram_stress_function(int argc, char *argv[])
+{
+    unsigned int Pass;
+    unsigned int PassCnt     = 0;
+    unsigned int Testcounter = 0;
+    int          ret = 1;
+    char         *stop_at;
+
+    printf("**************************************************** \n");       
+    printf("*** ASPEED Stress DRAM                           *** \n");
+    printf("***                          20131107 for u-boot *** \n");
+    printf("**************************************************** \n"); 
+    printf("\n"); 
+  
+    if ( argc != 2 ){
+        ret = 0;
+        return ( ret );
+    }
+    else {
+        Testcounter = (unsigned int) strtoul(argv[1], &stop_at, 10);                     
+    }
+
+    WriteSOC_DD(0x1E6E0000, 0xFC600309);   
+
+    while( ( Testcounter > PassCnt ) || ( Testcounter == 0 ) ){
+        if( !MMCTest() ) {
+            printf("FAIL...%d/%d\n", PassCnt, Testcounter);
+            ret = 0;
+      
+            break;
+        }
+        else {
+            PassCnt++;
+            printf("Pass %d/%d\n", PassCnt, Testcounter);
+        }
+     } // End while()
+     
+     return( ret );
+}
+
diff --git a/arch/arm/cpu/arm926ejs/aspeed/SWFUNC.H b/arch/arm/cpu/arm926ejs/aspeed/SWFUNC.H
new file mode 100644
index 0000000..0a03654
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/aspeed/SWFUNC.H
@@ -0,0 +1,137 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef SWFUNC_H
+#define SWFUNC_H
+
+
+//---------------------------------------------------------
+// Program information
+//---------------------------------------------------------
+#define    VER_NAME    "Ver 0.34 version @2014/03/25 0932"
+
+/* == Step 1: ====== Support OS system =================== */
+// LinuxAP
+// #define Windows
+#define SLT_UBOOT
+//#define SLT_DOS
+
+/* == Step 2:======== Support interface ================== */
+/* Choose One */
+//#define SPI_BUS
+//#define USE_LPC
+//#define USE_P2A     // PCI or PCIe bus to AHB bus
+
+/* == Step 3:==========  Support Chip   ================== */
+//#define AST1010_CHIP
+//#define AST3200_IOMAP
+//#define FPGA
+
+#ifdef AST1010_CHIP
+    #ifdef SLT_UBOOT
+        #define AST1010_IOMAP   1
+    #endif
+    #ifdef SLT_DOS
+        #define AST1010_IOMAP   2
+        
+        // AST1010 only has LPC interface 
+        #undef USE_P2A
+        #undef SPI_BUS
+        #define USE_LPC
+    #endif
+#endif   
+
+/* == Step 4:==========   Select PHY    ================== */
+//#define SUPPORT_PHY_LAN9303        // Initial PHY via I2C bus
+#define LAN9303_I2C_BUSNUM      6  // 1-based
+#define LAN9303_I2C_ADR         0x14
+
+/* ====================== Program ======================== */
+// The "PHY_NCSI" option is only for DOS compiler
+#if defined (PHY_NCSI)
+    #ifdef SLT_UBOOT
+        #error Wrong setting......
+    #endif
+#endif
+
+#if defined (PHY_NCSI)
+    #ifdef SUPPORT_PHY_LAN9303
+        #error Wrong setting (Can't support LAN9303)......
+    #endif
+#endif
+
+/* =================  Check setting  ===================== */
+#ifdef SLT_UBOOT
+    #ifdef SLT_DOS
+        #error Can NOT support two OS 
+    #endif
+#endif
+#ifdef SLT_DOS
+    #ifdef SLT_UBOOT
+        #error Can NOT support two OS 
+    #endif
+#endif
+
+#ifdef USE_P2A
+    #ifdef SLT_UBOOT
+        #error Can NOT be set PCI bus in Uboot
+    #endif
+#endif
+#ifdef USE_LPC
+    #ifdef SLT_UBOOT
+        #error Can NOT be set LPC bus in Uboot
+    #endif
+#endif
+#ifdef SPI_BUS
+    #ifdef SLT_UBOOT
+        #error Can NOT be set SPI bus in Uboot 
+    #endif
+#endif
+
+/* ======================== Program flow control ======================== */
+#define RUN_STEP                     5
+// 0: read_scu
+// 1: parameter setup
+// 2: init_scu1,
+// 3: init_scu_macrst
+// 4: Data Initial
+// 5: ALL
+
+/* ====================== Switch print debug message ====================== */
+#define   DbgPrn_Enable_Debug_delay  0
+//#define   DbgPrn_FuncHeader          0 //1
+#define   DbgPrn_ErrFlg              0
+#define   DbgPrn_BufAdr              0 //1
+#define   DbgPrn_Bufdat              0
+#define   DbgPrn_BufdatDetail        0
+#define   DbgPrn_PHYRW               0
+#define   DbgPrn_PHYInit             0
+#define   DbgPrn_PHYName             0
+#define   DbgPrn_DumpMACCnt          0
+#define   DbgPrn_Info                0 //1
+#define   DbgPrn_FRAME_LEN           0
+
+
+/* ============ Enable or Disable Check item of the descriptor ============ */
+#define   CheckRxOwn
+#define   CheckRxErr
+//#define   CheckOddNibble
+#define   CheckCRC
+#define   CheckRxFIFOFull
+#define   CheckRxLen
+//#define   CheckDataEveryTime
+
+//#define   CheckRxbufUNAVA
+#define   CheckRPktLost
+//#define   CheckNPTxbufUNAVA
+#define   CheckTPktLost
+#define   CheckRxBuf
+
+#endif // SWFUNC_H
diff --git a/arch/arm/cpu/arm926ejs/aspeed/TRAPTEST.c b/arch/arm/cpu/arm926ejs/aspeed/TRAPTEST.c
new file mode 100644
index 0000000..72936c0
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/aspeed/TRAPTEST.c
@@ -0,0 +1,151 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#define PLLTEST_C
+static const char ThisFile[] = "PLLTEST.c";
+
+#include "SWFUNC.H"
+
+#include <COMMINF.H>
+#include <TYPEDEF.H>
+#include <IO.H>
+
+#define ASTCHIP_2400    0
+#define ASTCHIP_2300    1
+#define ASTCHIP_1400    2
+#define ASTCHIP_1300    3
+#define ASTCHIP_1050    4
+
+const UCHAR jVersion[] = "v.0.60.06";
+
+typedef struct _TRAPINFO {
+    USHORT  CPU_clk;
+    UCHAR   CPU_AHB_ratio;
+} _TrapInfo;
+
+const _TrapInfo AST_default_trap_setting[] = {
+    // CPU_clk, CPU_AHB_ratio
+    { 384,      2 },            // AST2400 or AST1250 ( ASTCHIP_2400 )
+    { 384,      2 },            // AST2300 ( ASTCHIP_2300 )
+    { 384,   0xFF },            // AST1400 ( ASTCHIP_1400 )
+    { 384,   0xFF },            // AST1300 ( ASTCHIP_1300 )
+    { 384,      2 }             // AST1050 ( ASTCHIP_1050 )
+};
+
+int trap_function(int argc, char *argv[])
+{
+    UCHAR   chiptype;   
+    ULONG   ulData, ulTemp; 
+    UCHAR   status = TRUE;
+    USHORT  val_trap;
+    
+    printf("**************************************************** \n");       
+    printf("*** ASPEED Trap Test %s Log               *** \n", jVersion);
+    printf("***                                   for u-boot *** \n");
+    printf("**************************************************** \n"); 
+    printf("\n"); 
+    
+    // Check chip type
+    switch ( ReadSOC_DD( 0x1e6e2000 + 0x7c ) ) {   
+        case 0x02010303 :
+        case 0x02000303 : 
+            printf("The chip is AST2400 or AST1250\n" ); 
+            chiptype = ASTCHIP_2400; 
+            break;
+            
+        case 0x02010103 :
+        case 0x02000003 : 
+            printf("The chip is AST1400\n" ); 
+            chiptype = ASTCHIP_1400; 
+            break;
+            
+        case 0x01010303 :
+        case 0x01000003 : 
+            printf("The chip is AST2300\n" ); 
+            chiptype = ASTCHIP_2300; 
+            break;
+        
+        case 0x01010203 : 
+            printf("The chip is AST1050\n" ); 
+            chiptype = ASTCHIP_1050; 
+            break;
+            
+        case 0x01010003 : 
+            printf("The chip is AST1300\n" ); 
+            chiptype = ASTCHIP_1300; 
+            break;
+            
+        default     : 
+            printf ("Error Silicon Revision ID(SCU7C) %08lx!!!\n", ReadSOC_DD( 0x1e6e2000 + 0x7c ) ); 
+            return(1);
+    }
+    
+    WriteSOC_DD(0x1e6e2000, 0x1688A8A8);
+    ulData = ReadSOC_DD(0x1e6e2070);
+    
+    // Check CPU clock
+    ulTemp  = ulData;
+    ulTemp &= 0x0300;
+    ulTemp >>= 8;
+    
+    switch (ulTemp)
+    {
+        case 0x00:
+            val_trap = 384;
+            break;
+        case 0x01:
+            val_trap = 360;
+            break;
+        case 0x02:
+            val_trap = 336;
+            break;
+        case 0x03:
+            val_trap = 408;
+            break;
+    }
+    
+    if (AST_default_trap_setting[chiptype].CPU_clk != val_trap)
+    {
+        printf("[ERROR] CPU CLK: Correct is %d; Real is %d \n", AST_default_trap_setting[chiptype].CPU_clk, val_trap);	
+    	status = FALSE;
+    }
+           	
+    // Check cpu_ahb_ratio
+    ulTemp  = ulData;
+    ulTemp &= 0x0c00;
+    ulTemp >>= 10;
+    
+    switch (ulTemp)
+    {
+        case 0x00:
+            val_trap = 1;
+            break;
+        case 0x01:
+            val_trap = 2;
+            break;
+        case 0x02:
+            val_trap = 4;
+            break;
+        case 0x03:
+            val_trap = 3;
+            break;
+    }
+    
+    if (AST_default_trap_setting[chiptype].CPU_AHB_ratio != val_trap)
+    {
+        printf("[ERROR] CPU:AHB: Correct is %x:1; Real is %x:1 \n", AST_default_trap_setting[chiptype].CPU_AHB_ratio, val_trap);	
+    	status = FALSE;
+    }
+    
+    if ( status == TRUE )
+        printf("[PASS] hardware trap for CPU clock and CPU\\AHB ratio.\n");
+    
+    return status;
+}
diff --git a/arch/arm/cpu/arm926ejs/aspeed/TYPEDEF.H b/arch/arm/cpu/arm926ejs/aspeed/TYPEDEF.H
new file mode 100644
index 0000000..3053ad7
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/aspeed/TYPEDEF.H
@@ -0,0 +1,74 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef TYPEDEF_H
+#define TYPEDEF_H
+
+#include "SWFUNC.H"
+
+//
+// Define
+//
+#define   PCI                   1
+#define   PCIE                  2
+#define   AGP                   3
+#define   ACTIVE                4
+
+#if defined(LinuxAP)
+    #ifndef FLONG
+        #define FLONG   unsigned long
+    #endif
+    #ifndef ULONG
+        #define ULONG   unsigned long
+    #endif
+    #ifndef LONG
+        #define LONG    long
+    #endif
+    #ifndef USHORT
+        #define USHORT  unsigned short
+    #endif
+    #ifndef SHORT
+        #define SHORT   short
+    #endif
+    #ifndef UCHAR
+        #define UCHAR   unsigned char
+    #endif
+    #ifndef CHAR
+        #define CHAR    char
+    #endif
+    #ifndef BYTE
+        #define BYTE    unsigned char
+    #endif
+    #ifndef VOID
+        #define VOID    void
+    #endif
+    #ifndef SCHAR
+        #define SCHAR   signed char
+    #endif
+#else	
+/* DOS Program */
+    #define     VOID	  void
+    #define     FLONG     unsigned long
+    #define     ULONG     unsigned long
+    #define     USHORT    unsigned short
+    #define     UCHAR     unsigned char
+    #define     LONG      long
+    #define     SHORT     short
+    #define     CHAR      char
+    #define     BYTE	  UCHAR
+    #define     BOOL	  SHORT
+    #define     BOOLEAN   unsigned short
+    #define     PULONG    ULONG *
+    #define     SCHAR     signed char
+#endif    
+    #define	    TRUE      1
+    #define	    FALSE     0
+    
+#endif // TYPEDEF_H
diff --git a/arch/arm/cpu/arm926ejs/aspeed/mactest.c b/arch/arm/cpu/arm926ejs/aspeed/mactest.c
new file mode 100644
index 0000000..95bd560
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/aspeed/mactest.c
@@ -0,0 +1,1215 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#define MACTEST_C
+static const char ThisFile[] = "MACTEST.c";
+
+#include "SWFUNC.H"
+
+#ifdef SLT_UBOOT
+  #include <common.h>
+  #include <command.h>
+  #include <post.h>
+  #include <malloc.h>
+  #include <net.h>
+  #include <COMMINF.H>
+  #include <STDUBOOT.H>
+  #include <IO.H>
+#else
+  #include <stdlib.h>
+  #include <string.h>
+  #include "LIB.H"
+  #include "COMMINF.H"
+  #include "IO.H"
+#endif
+
+const  BYTE        Val_Array[16]    = {0,1, 2,3, 4,5, 6,7, 8,9, 10,11, 12,13, 14,15}; // AST2300-A1
+const  BYTE        Val_Array_A0[16] = {8,1, 10,3, 12,5, 14,7, 0,9, 2,11, 4,13, 6,15}; // AST2300-A0
+
+#ifdef SLT_UBOOT
+int main_function(int argc, char *argv[])
+#endif
+#ifdef SLT_DOS
+int main(int argc, char *argv[])
+#endif
+{
+    CHAR    MAC2_Valid;
+    CHAR    MAC_1GEn;
+    CHAR    MAC1_RMII;
+    CHAR    Enable_IntLoopPHY;
+    CHAR    Disable_RecovPHY;
+    CHAR    Force1G;
+    CHAR    Force10M;
+    CHAR    Force100M;
+    CHAR    *stop_at;
+    ULONG   IOStr_val;
+    ULONG   IOStr_max;
+    ULONG   IOStr_shf;
+    ULONG   IOdly_val;
+    ULONG   Err_Flag_allapeed;    
+    int     DES_LowNumber;
+    int     index;
+    int     i;
+    int     j;
+    #ifdef Enable_NCSI_LOOP_INFINI
+        BYTE    GSpeed_org[3];
+    #endif
+
+#ifdef SPI_BUS
+    VIDEO_ENGINE_INFO VideoEngineInfo;
+#else
+    // ( USE_P2A | USE_LPC )
+    UCHAR   *ulMMIOLinearBaseAddress;
+#endif
+
+    #ifdef SLT_UBOOT
+    #else
+        time(&timestart);
+    #endif
+
+    // For DOS system
+    #if defined(PHY_NCSI)
+        // For DOS compiler OPEN WATCOM
+        ModeSwitch = MODE_NSCI;
+    #else
+        #ifdef SLT_DOS
+        ModeSwitch = MODE_DEDICATED;
+        #endif
+    #endif
+    
+//------------------------------------------------------------
+// Argument Initial
+//------------------------------------------------------------
+    Err_Flag_allapeed = 0;
+    Err_Flag          = 0;
+    Err_Flag_PrintEn  = 1;
+    Loop_rl[0]        = 0;
+    Loop_rl[1]        = 0;
+    Loop_rl[2]        = 0;
+
+//------------------------------------------------------------
+// Bus Initial
+//------------------------------------------------------------
+#if defined(LinuxAP)
+#else   
+  //DOS system
+  #ifdef SPI_BUS
+  #endif
+  #ifdef USE_LPC
+
+        if ( findlpcport( 0x0d ) == 0) {
+            printf("Failed to find proper LPC port \n");
+            
+            return(1);
+        }
+        open_aspeed_sio_password();
+        enable_aspeed_LDU( 0x0d );
+  #endif
+  #ifdef USE_P2A
+        // PCI bus
+        #ifdef DOS_PMODEW
+        if (CheckDOS()) return 1;
+        #endif
+
+        #ifdef  DbgPrn_FuncHeader
+            printf ("Initial-MMIO\n"); 
+            Debug_delay();
+        #endif
+        ulPCIBaseAddress = FindPCIDevice (0x1A03, 0x2000, ACTIVE);
+        if ( ulPCIBaseAddress == 0 ) 
+            ulPCIBaseAddress = FindPCIDevice (0x1688, 0x2000, ACTIVE);
+        if ( ulPCIBaseAddress == 0 ) 
+            ulPCIBaseAddress = FindPCIDevice (0x1A03, 0x0200, ACTIVE);
+        if ( ulPCIBaseAddress == 0 ) 
+            ulPCIBaseAddress = FindPCIDevice (0x1A03, 0x3000, ACTIVE);
+        if ( ulPCIBaseAddress == 0 ) 
+            ulPCIBaseAddress = FindPCIDevice (0x1A03, 0x2010, ACTIVE);
+        if ( ulPCIBaseAddress == 0 ) { 
+            printf ("Can't find device\n"); 
+            
+            return(1);
+        }
+
+        WritePCIReg (ulPCIBaseAddress, 0x04, 0xFFFFFFFc, 0x3);
+        ulMMIOBaseAddress       = ReadPCIReg (ulPCIBaseAddress, 0x14, 0xFFFF0000);
+        ulMMIOLinearBaseAddress = (UCHAR *)MapPhysicalToLinear (ulMMIOBaseAddress, 64 * 1024 * 1024);
+  #endif // #ifdef USE_P2A
+#endif // End defined(LinuxAP)
+
+#ifdef SPI_BUS
+    GetDevicePCIInfo (&VideoEngineInfo);
+    mmiobase = VideoEngineInfo.VGAPCIInfo.ulMMIOBaseAddress;
+    spim_init(SPI_CS);
+#else    
+    // ( USE_P2A | USE_LPC )
+    mmiobase = ulMMIOLinearBaseAddress;
+#endif
+
+//------------------------------------------------------------
+// Check Chip Feature
+//------------------------------------------------------------
+    read_scu();
+
+    if (RUN_STEP >= 1) {
+        switch (SCU_7ch_old) {
+//          case 0x02000003 : sprintf(ASTChipName, "[ ]AST3200-FPGA"                  ); ASTChipType = 6; AST1100 = 0; break;
+            
+            case 0x03020003 : sprintf(ASTChipName, "[ ]AST1010-A2"                    ); ASTChipType = 5; AST1100 = 0; break;
+            case 0x03010003 : sprintf(ASTChipName, "[ ]AST1010-A1"                    ); ASTChipType = 5; AST1100 = 0; break;
+            case 0x03000003 : sprintf(ASTChipName, "[*]AST1010-A0"                    ); ASTChipType = 5; AST1100 = 0; break;
+            
+            case 0x02010303 : sprintf(ASTChipName, "[*]AST2400-A1"                    ); ASTChipType = 4; AST1100 = 0; break;//AST2400-A1
+            case 0x02000303 : sprintf(ASTChipName, "[ ]AST2400-A0"                    ); ASTChipType = 4; AST1100 = 0; break;//AST2400-A0
+            case 0x02010103 : sprintf(ASTChipName, "[*]AST1400-A1"                    ); ASTChipType = 4; AST1100 = 0; break;//AST1400-A1
+            case 0x02000003 : sprintf(ASTChipName, "[ ]AST1400-A0"                    ); ASTChipType = 4; AST1100 = 0; break;//AST1400-A0
+            
+            case 0x01010303 : sprintf(ASTChipName, "[*]AST2300-A1"                    ); ASTChipType = 3; AST1100 = 0; break;//AST2300-A1
+            case 0x01010203 : sprintf(ASTChipName, "[*]AST1050-A1"                    ); ASTChipType = 3; AST1100 = 0; break;//AST1050-A1
+            case 0x01010003 : sprintf(ASTChipName, "[*]AST1300-A1"                    ); ASTChipType = 3; AST1100 = 0; break;//AST1300-A1
+            case 0x01000003 : sprintf(ASTChipName, "[ ]AST2300-A0"                    ); ASTChipType = 3; AST1100 = 0; break;//AST2300-A0
+//          case 0x01860003 : sprintf(ASTChipName, "[ ]AST2300-FPGA"                  ); ASTChipType = 3; AST1100 = 0; break;
+            
+            case 0x00000102 : sprintf(ASTChipName, "[*]AST2200-A1"                    ); ASTChipType = 2; AST1100 = 0; break;//AST2200-A1/A0
+            
+            case 0x00000302 : sprintf(ASTChipName, "[*]AST2100-A3"                    ); ASTChipType = 1; AST1100 = 0; break;//AST2100-A3/A2
+            case 0x00000301 : sprintf(ASTChipName, "[ ]AST2100-A1"                    ); ASTChipType = 1; AST1100 = 0; break;//AST2100-A1
+            case 0x00000300 : sprintf(ASTChipName, "[ ]AST2100-A0"                    ); ASTChipType = 1; AST1100 = 0; break;//AST2100-A0
+            case 0x00000202 : sprintf(ASTChipName, "[*]AST2050/AST1100-A3, AST2150-A1"); ASTChipType = 1; AST1100 = 1; break;//AST2050/AST1100-A3/A2 AST2150-A1/A0
+            case 0x00000201 : sprintf(ASTChipName, "[ ]AST2050/AST1100-A1"            ); ASTChipType = 1; AST1100 = 1; break;//AST2050/AST1100-A1
+            case 0x00000200 : sprintf(ASTChipName, "[ ]AST2050/AST1100-A0"            ); ASTChipType = 1; AST1100 = 1; break;//AST2050/AST1100-A0
+            
+            default     : 
+                printf ("Error Silicon Revision ID(SCU7C) %08lx!!!\n", SCU_7ch_old); 
+                return(1);
+        } // End switch (SCU_7ch_old)
+        
+        switch (ASTChipType) {
+            case 6  : AST2300 = 1; AST2400 = 1; AST1010 = 0; AST3200 = 1; break;
+            case 5  : AST2300 = 1; AST2400 = 1; AST1010 = 1; AST3200 = 0; break;
+            case 4  : AST2300 = 1; AST2400 = 1; AST1010 = 0; AST3200 = 0; break;
+            case 3  : AST2300 = 1; AST2400 = 0; AST1010 = 0; AST3200 = 0; break;
+            default : AST2300 = 0; AST2400 = 0; AST1010 = 0; AST3200 = 0; break;
+        } // End switch (ASTChipType)
+
+        if (ASTChipType == 3) {
+#ifdef Force_Enable_MAC34
+            WriteSOC_DD( SCU_BASE + 0xf0, 0xAEED0001 ); //enable mac34
+            Enable_MAC34 = 1;
+#else
+            if (SCU_f0h_old & 0x00000001) 
+                Enable_MAC34 = 1;
+            else                          
+                Enable_MAC34 = 0;
+#endif
+        } 
+        else {
+            Enable_MAC34 = 0;
+        } // End if (ASTChipType == 3)
+
+    Setting_scu();
+
+//------------------------------------------------------------
+// Argument Input
+//------------------------------------------------------------
+        // Load default value
+        UserDVal         = DEF_USER_DEF_PACKET_VAL;
+        IOTimingBund_arg = DEF_IOTIMINGBUND;
+        PHY_ADR_arg      = DEF_PHY_ADR;
+        TestMode         = DEF_TESTMODE;
+        LOOP_INFINI      = 0;
+        LOOP_MAX_arg     = 0;
+        GCtrl            = ( DEF_MAC_LOOP_BACK << 6 ) | ( DEF_SKIP_CHECK_PHY << 5 ) | ( DEF_INIT_PHY << 3 );
+        GSpeed           = DEF_SPEED;
+        
+        // Get setting information by user
+        GRun_Mode        = (BYTE)atoi(argv[1]);
+
+        if ( ModeSwitch == MODE_NSCI ) {
+            ARPNumCnt        = DEF_ARPNUMCNT;
+            ChannelTolNum    = DEF_CHANNEL2NUM;
+            PackageTolNum    = DEF_PACKAGE2NUM;
+            GSpeed           = SET_100MBPS;        // In NCSI mode, we set to 100M bps
+        }
+        
+        // Setting user's configuration
+        if (argc > 1) {
+            if ( ModeSwitch == MODE_NSCI )
+                switch (argc) {
+                    case 7: ARPNumCnt        = (ULONG)atoi(argv[6]);
+                    case 6: IOTimingBund_arg = (BYTE)atoi(argv[5]);
+                    case 5: TestMode         = (BYTE)atoi(argv[4]);
+                    case 4: ChannelTolNum    = (BYTE)atoi(argv[3]);
+                    case 3: PackageTolNum    = (BYTE)atoi(argv[2]);
+                    default: break;
+                }
+            else
+                switch (argc) {
+                    case 9: UserDVal         = strtoul (argv[8], &stop_at, 16);
+                    case 8: IOTimingBund_arg = (BYTE)atoi(argv[7]);
+                    case 7: PHY_ADR_arg      = (BYTE)atoi(argv[6]);
+                    case 6: TestMode         = (BYTE)atoi(argv[5]);
+                    case 5: strcpy(LOOP_Str, argv[4]);
+                        if (!strcmp(LOOP_Str, "#")) LOOP_INFINI = 1;
+                        else                        LOOP_MAX_arg = (ULONG)atoi(LOOP_Str);
+                    case 4: GCtrl            = (BYTE)atoi(argv[3]);
+                    case 3: GSpeed           = (BYTE)atoi(argv[2]);
+                    default: break;
+                }
+
+            IOTimingBund = IOTimingBund_arg;
+            PHY_ADR      = PHY_ADR_arg;
+        } 
+        else {
+            // Wrong parameter
+            if ( ModeSwitch == MODE_NSCI ) {
+                if (AST2300) 
+                    printf ("\nNCSITEST.exe  run_mode  <package_num>  <channel_num>  <test_mode>  <IO margin>\n\n");
+                else         
+                    printf ("\nNCSITEST.exe  run_mode  <package_num>  <channel_num>  <test_mode>\n\n");
+                PrintMode ();
+                PrintPakNUm();
+                PrintChlNUm();
+                PrintTest ();
+                if (AST2300) 
+                    PrintIOTimingBund ();
+            } 
+            else {
+                if (AST2300) 
+                    printf ("\nMACTEST.exe  run_mode  <speed>  <ctrl>  <loop_max>  <test_mode>  <phy_adr>  <IO margin>\n\n");
+                else         
+                    printf ("\nMACTEST.exe  run_mode  <speed>  <ctrl>  <loop_max>  <test_mode>  <phy_adr>\n\n");
+                PrintMode ();
+                PrintSpeed ();
+                PrintCtrl ();
+                PrintLoop ();
+                PrintTest ();
+                PrintPHYAdr ();
+                if (AST2300) 
+                    PrintIOTimingBund ();
+            }
+            Finish_Close();
+            
+            return(1);
+        } // End if (argc > 1) 
+
+//------------------------------------------------------------
+// Check Argument
+//------------------------------------------------------------
+        switch ( GRun_Mode ) {
+            case 0:                    printf ("\n[MAC1]\n"); SelectMAC = 0; H_MAC_BASE = MAC_BASE1; break;
+            case 1:                    printf ("\n[MAC2]\n"); SelectMAC = 1; H_MAC_BASE = MAC_BASE2; break;
+            case 2: if (Enable_MAC34) {printf ("\n[MAC3]\n"); SelectMAC = 2; H_MAC_BASE = MAC_BASE3; break;} 
+                    else 
+                        goto Error_MAC_Mode;
+            case 3: if (Enable_MAC34) {printf ("\n[MAC4]\n"); SelectMAC = 3; H_MAC_BASE = MAC_BASE4; break;} 
+                    else 
+                        goto Error_MAC_Mode;
+            default:
+Error_MAC_Mode:     
+                    printf ("Error run_mode!!!\n");
+                    PrintMode ();
+                    
+                    return(1);
+        } // End switch ( GRun_Mode )
+        
+        H_TDES_BASE   = TDES_BASE1;
+        H_RDES_BASE   = RDES_BASE1;
+        MAC_PHYBASE   = H_MAC_BASE;
+        
+        Force1G       = 0;
+        Force10M      = 0;
+        Force100M     = 0;
+        GSpeed_sel[0] = 0;//1G
+        GSpeed_sel[1] = 0;//100M
+        GSpeed_sel[2] = 0;//10M
+        
+        switch ( GSpeed ) {
+            case SET_1GBPS          : Force1G   = 1; GSpeed_sel[0] = 1; break;
+            case SET_100MBPS        : Force100M = 1; GSpeed_sel[1] = 1; break;
+            case SET_10MBPS         : Force10M  = 1; GSpeed_sel[2] = 1; break;
+            case SET_1G_100M_10MBPS :                                   break;
+            default: printf ("Error speed!!!\n");
+                PrintSpeed ();
+                return(1);
+        } // End switch ( GSpeed )
+
+        if ( ModeSwitch == MODE_NSCI ) {
+            Enable_MACLoopback = 0; // For mactest function
+            Enable_SkipChkPHY  = 0; // For mactest function
+            Enable_IntLoopPHY  = 0; // For mactest function
+            Enable_InitPHY     = 0; // For mactest function
+            Disable_RecovPHY   = 0; // For mactest function
+            BurstEnable        = 0; // For mactest function
+
+            PrintNCSIEn = (ARPNumCnt & 0x1);
+            ARPNumCnt   = ARPNumCnt & 0xfffffffe;
+    
+            // Check parameter
+            if ((PackageTolNum < 1) || (PackageTolNum >  8)) { 
+                PrintPakNUm();
+                return(1);
+            }
+//            if ((ChannelTolNum < 0) || (ChannelTolNum > 32)) { 
+            if (ChannelTolNum > 32) { 
+                PrintChlNUm(); 
+                return(1);
+            }
+
+            switch (TestMode) {
+                case 0 :               NCSI_DiSChannel = 1; IOTiming = 0; IOStrength = 0; TxDataEnable = 1; RxDataEnable = 1; break;
+                case 1 :               NCSI_DiSChannel = 0; IOTiming = 0; IOStrength = 0; TxDataEnable = 1; RxDataEnable = 1; break;
+                case 6 : if (AST2300) {NCSI_DiSChannel = 1; IOTiming = 1; IOStrength = 0; TxDataEnable = 1; RxDataEnable = 1; break;} 
+                         else 
+                            goto Error_Test_Mode_NCSI;
+                case 7 : if (AST2300) {NCSI_DiSChannel = 1; IOTiming = 1; IOStrength = 1; TxDataEnable = 1; RxDataEnable = 1; break;} 
+                         else 
+                            goto Error_Test_Mode_NCSI;
+                default:
+                    // Wrong parameter
+Error_Test_Mode_NCSI:       
+                    printf ("Error test_mode!!!\n");
+                    PrintTest ();
+                    return(1);
+            } // End switch (TestMode)
+        }
+        else {
+            if ( GCtrl & 0xffffff83 ) {
+                printf ("Error ctrl!!!\n");
+                PrintCtrl ();
+                return(1);
+            } 
+            else {
+                Enable_MACLoopback = ( GCtrl >> 6 ) & 0x1; // ??
+                Enable_SkipChkPHY  = ( GCtrl >> 5 ) & 0x1; // ??
+                Enable_IntLoopPHY  = ( GCtrl >> 4 ) & 0x1;
+                Enable_InitPHY     = ( GCtrl >> 3 ) & 0x1;
+                Disable_RecovPHY   = ( GCtrl >> 2 ) & 0x1; // ??
+            
+                if (!AST2400 && Enable_MACLoopback) {
+                    printf ("Error ctrl!!!\n");
+                    PrintCtrl ();
+                    return(1);
+                }
+            } // End if ( GCtrl & 0xffffff83 )
+            
+            if (!LOOP_MAX_arg) {
+                switch (GSpeed) {
+                    case SET_1GBPS         : LOOP_MAX_arg  = DEF_LOOP_MAX * 200; break; // 20140325
+                    case SET_100MBPS       : LOOP_MAX_arg  = DEF_LOOP_MAX * 20 ; break; // 20140325
+                    case SET_10MBPS        : LOOP_MAX_arg  = DEF_LOOP_MAX * 10 ; break; // 20140325
+                    case SET_1G_100M_10MBPS: LOOP_MAX_arg  = DEF_LOOP_MAX * 10 ; break; // 20140325
+                }
+            } // End if (!LOOP_MAX_arg)
+            
+            LOOP_MAX = LOOP_MAX_arg * 10; // 20140325
+            Calculate_LOOP_CheckNum();
+
+            switch (TestMode) {
+                case  0 :               BurstEnable = 0; IEEETesting = 0; IOTiming = 0; IOStrength = 0; TxDataEnable = 1; RxDataEnable = 1; DataDelay = 0; break;
+                case  1 :               BurstEnable = 1; IEEETesting = 1; IOTiming = 0; IOStrength = 0; TxDataEnable = 1; RxDataEnable = 0; DataDelay = 0; break;
+                case  2 :               BurstEnable = 1; IEEETesting = 1; IOTiming = 0; IOStrength = 0; TxDataEnable = 1; RxDataEnable = 0; DataDelay = 0; break;
+                case  3 :               BurstEnable = 1; IEEETesting = 1; IOTiming = 0; IOStrength = 0; TxDataEnable = 1; RxDataEnable = 0; DataDelay = 0; break;
+                case  4 :               BurstEnable = 1; IEEETesting = 0; IOTiming = 0; IOStrength = 0; TxDataEnable = 1; RxDataEnable = 0; DataDelay = 0; break; // ??
+                case  5 :               BurstEnable = 1; IEEETesting = 1; IOTiming = 0; IOStrength = 0; TxDataEnable = 1; RxDataEnable = 0; DataDelay = 0; break; // ??
+                case  6 : if (AST2300) {BurstEnable = 0; IEEETesting = 0; IOTiming = 1; IOStrength = 0; TxDataEnable = 1; RxDataEnable = 1; DataDelay = 0; break;} 
+                          else 
+                            goto Error_Test_Mode;
+                case  7 : if (AST2300) {BurstEnable = 0; IEEETesting = 0; IOTiming = 1; IOStrength = 1; TxDataEnable = 1; RxDataEnable = 1; DataDelay = 0; break;} 
+                          else 
+                            goto Error_Test_Mode;
+                case  8 :               BurstEnable = 0; IEEETesting = 0; IOTiming = 0; IOStrength = 0; TxDataEnable = 1; RxDataEnable = 0; DataDelay = 0; break; // ??
+                case  9 :               BurstEnable = 0; IEEETesting = 0; IOTiming = 0; IOStrength = 0; TxDataEnable = 0; RxDataEnable = 1; DataDelay = 0; break; // ??
+                case 10 :               BurstEnable = 0; IEEETesting = 0; IOTiming = 0; IOStrength = 0; TxDataEnable = 1; RxDataEnable = 1; DataDelay = 1; break; // ??
+                default:
+Error_Test_Mode:        
+                    printf ("Error test_mode!!!\n");
+                    PrintTest ();
+                    return(1);
+            } // End switch (TestMode)
+
+            if ( PHY_ADR > 31 ) {
+                printf ("Error phy_adr!!!\n");
+                PrintPHYAdr ();
+                return(1);
+            } // End if (PHY_ADR > 31)
+        } // End if ( ModeSwitch == MODE_NSCI )
+
+        if ( BurstEnable ) {
+            IOTimingBund = 0;
+        } 
+        else {
+            if ( ~DataDelay && AST2300 ) {
+                if ( !( ( (7 >= IOTimingBund) && (IOTimingBund & 0x1) ) || 
+                        ( IOTimingBund == 0 )                              ) ) {
+                    printf ("Error IO margin!!!\n");
+                    PrintIOTimingBund ();
+                    return(1);
+                }
+            } 
+            else {
+                IOTimingBund = 0;
+            } // End if ( ~DataDelay && AST2300 )
+            
+            // Define Output file name
+            if ( ModeSwitch == MODE_NSCI )
+                sprintf(FileNameMain, "%d", SelectMAC+1);
+            else {
+                if (Enable_IntLoopPHY) 
+                    sprintf(FileNameMain, "%dI", SelectMAC+1);
+                else                   
+                    sprintf(FileNameMain, "%dE", SelectMAC+1);
+            }
+        
+            #ifndef SLT_UBOOT
+            if ( IOTiming ) {
+                if ( IOStrength ) 
+                    sprintf(FileName, "MIOD%sS.log", FileNameMain);
+                else            
+                    sprintf(FileName, "MIOD%s.log", FileNameMain);
+
+                fp_log = fopen(FileName,"w");
+        
+                if ( IOStrength ) 
+                    sprintf(FileName, "MIO%sS.log", FileNameMain);
+                else            
+                    sprintf(FileName, "MIO%s.log", FileNameMain);
+
+                fp_io  = fopen(FileName,"w");
+            } 
+            else {
+                sprintf(FileName, "MAC%s.log", FileNameMain);
+
+                fp_log = fopen(FileName,"w");
+            }
+            #endif
+        } // End if (BurstEnable)
+
+//------------------------------------------------------------
+// Check Definition
+//------------------------------------------------------------
+        for (i = 0; i < 16; i++) 
+            valary[i] = Val_Array[i];
+        
+        if ( AST3200 ) {
+            MAC_Mode   = (SCU_70h_old >> 6) & 0x1;
+            MAC1_1GEn  = (MAC_Mode & 0x1) ? 1 : 0;//1:RGMII, 0:RMII
+            MAC2_1GEn  = 0;
+        
+            MAC1_RMII  = !MAC1_1GEn;
+            MAC2_RMII  = 0;
+            MAC2_Valid = 0;
+        } 
+        else if ( AST1010 ) {
+            MAC_Mode   = 0;
+            MAC1_1GEn  = 0;
+            MAC2_1GEn  = 0;
+        
+            MAC1_RMII  = 1;
+            MAC2_RMII  = 0;
+            MAC2_Valid = 0;
+        } 
+        else if ( AST2300 ) {
+            if (SCU_7ch_old == 0x01000003) {
+                //AST2300-A0
+                for (i = 0; i < 16; i++) {
+                    valary[i] = Val_Array_A0[i];
+                }
+            }
+        
+            MAC_Mode   = (SCU_70h_old >> 6) & 0x3;
+            MAC1_1GEn  = (MAC_Mode & 0x1) ? 1 : 0;//1:RGMII, 0:RMII
+            MAC2_1GEn  = (MAC_Mode & 0x2) ? 1 : 0;//1:RGMII, 0:RMII
+        
+            MAC1_RMII  = !MAC1_1GEn;
+            MAC2_RMII  = !MAC2_1GEn;
+            MAC2_Valid = 1;
+        } 
+        else {
+            MAC_Mode   = (SCU_70h_old >> 6) & 0x7;
+            MAC1_1GEn  = (MAC_Mode == 0x0) ? 1 : 0;
+            MAC2_1GEn  = 0;
+        
+            switch ( MAC_Mode ) {
+                case 0 : MAC1_RMII = 0; MAC2_RMII = 0; MAC2_Valid = 0; break; //000: Select GMII(MAC#1) only
+                case 1 : MAC1_RMII = 0; MAC2_RMII = 0; MAC2_Valid = 1; break; //001: Select MII (MAC#1) and MII(MAC#2)
+                case 2 : MAC1_RMII = 1; MAC2_RMII = 0; MAC2_Valid = 1; break; //010: Select RMII(MAC#1) and MII(MAC#2)
+                case 3 : MAC1_RMII = 0; MAC2_RMII = 0; MAC2_Valid = 0; break; //011: Select MII (MAC#1) only
+                case 4 : MAC1_RMII = 1; MAC2_RMII = 0; MAC2_Valid = 0; break; //100: Select RMII(MAC#1) only
+//              case 5 : MAC1_RMII = 0; MAC2_RMII = 0; MAC2_Valid = 0; break; //101: Reserved
+                case 6 : MAC1_RMII = 1; MAC2_RMII = 1; MAC2_Valid = 1; break; //110: Select RMII(MAC#1) and RMII(MAC#2)
+//              case 7 : MAC1_RMII = 0; MAC2_RMII = 0; MAC2_Valid = 0; break; //111: Disable dual MAC
+                default: return(Finish_Check(Err_MACMode));
+            }
+        } // End if ( AST3200 )
+        
+        if ( SelectMAC == 0 ) {
+            Enable_RMII = MAC1_RMII;
+            MAC_1GEn    = MAC1_1GEn;
+        
+            if ( Force1G & !MAC1_1GEn ) {
+                printf ("\nMAC1 don't support 1Gbps !!!\n"); 
+                return( Finish_Check(Err_MACMode) );
+            }
+        } else if (SelectMAC == 1) {
+            Enable_RMII = MAC2_RMII;
+            MAC_1GEn    = MAC2_1GEn;
+        
+            if ( Force1G & !MAC2_1GEn ) {
+                printf ("\nMAC2 don't support 1Gbps !!!\n"); 
+                return(Finish_Check(Err_MACMode));
+            }
+            if ( !MAC2_Valid ) {
+                printf ("\nMAC2 not valid !!!\n"); 
+                return(Finish_Check(Err_MACMode));
+            }
+        } 
+        else {
+            Enable_RMII = 1;
+            MAC_1GEn = 0;
+        
+            if (Force1G) {
+                printf ("\nMAC3/MAC4 don't support 1Gbps !!!\n"); 
+                return(Finish_Check(Err_MACMode));
+            }
+        } // End if ( SelectMAC == 0 )
+
+        if ( ModeSwitch == MODE_NSCI ) {
+            if (!Enable_RMII) {
+                printf ("\nNCSI must be RMII interface !!!\n");
+                return(Finish_Check(Err_MACMode));
+            }
+        }
+
+        if ( GSpeed == SET_1G_100M_10MBPS ) {
+            GSpeed_sel[0] = MAC_1GEn;
+            GSpeed_sel[1] = 1;
+            GSpeed_sel[2] = 1;
+        }
+
+        if ( AST1010 ) {
+            // Check bit 13:12
+            Dat_ULONG = SCU_08h_old & 0x00003000;
+            if (Dat_ULONG != 0x00000000)
+                return(Finish_Check(Err_MHCLK_Ratio));
+        } 
+        else if ( AST2300 ) {
+            Dat_ULONG = (SCU_08h_old >> 16) & 0x7;
+            if (MAC1_1GEn | MAC2_1GEn) {
+                if ( (Dat_ULONG == 0) || (Dat_ULONG > 2) )
+                    return(Finish_Check(Err_MHCLK_Ratio));
+            } 
+            else {
+                if (Dat_ULONG != 4)
+                    return(Finish_Check(Err_MHCLK_Ratio));
+            }
+        } // End if (AST1010)
+
+        //MAC
+        MAC_08h_old = ReadSOC_DD( H_MAC_BASE + 0x08 );
+        MAC_0ch_old = ReadSOC_DD( H_MAC_BASE + 0x0c );
+        MAC_40h_old = ReadSOC_DD( H_MAC_BASE + 0x40 );
+        
+        if (  ((MAC_08h_old == 0x0000) && (MAC_0ch_old == 0x00000000))
+           || ((MAC_08h_old == 0xffff) && (MAC_0ch_old == 0xffffffff))
+//         || (MAC_0ch_old & 0x1)
+//         || (MAC_0ch_old & 0x2)
+           ) 
+        {
+            // Load default for MAC address
+            SA[0] = 0x00;
+            SA[1] = 0x57;
+            SA[2] = 0x89;
+            SA[3] = 0x56;
+            SA[4] = 0x88;
+            SA[5] = 0x38;
+        } 
+        else {
+            SA[0] = (MAC_08h_old >>  8) & 0xff;
+            SA[1] = (MAC_08h_old      ) & 0xff;
+            SA[2] = (MAC_0ch_old >> 24) & 0xff;
+            SA[3] = (MAC_0ch_old >> 16) & 0xff;
+            SA[4] = (MAC_0ch_old >>  8) & 0xff;
+            SA[5] = (MAC_0ch_old      ) & 0xff;
+        }
+        // printf ("%08x %08x: %02x %02x %02x %02x %02x %02x\n", MAC_08h_old, MAC_0ch_old, SA[0], SA[1], SA[2], SA[3], SA[4], SA[5]);        
+
+        if ( AST2300 ) {
+#ifdef Force_Enable_NewMDIO
+            AST2300_NewMDIO = 1;
+            WriteSOC_DD(H_MAC_BASE+0x40, MAC_40h_old | 0x80000000)
+#else
+            AST2300_NewMDIO = (MAC_40h_old & 0x80000000) ? 1 : 0;
+#endif
+        } 
+        else {
+            AST2300_NewMDIO = 0;
+        } // End if (AST2300)
+
+//------------------------------------------------------------
+// Parameter Initial
+//------------------------------------------------------------
+        if ( AST3200 ) {
+            SCU_04h = 0x0c000800; //Reset Engine
+        } 
+        else if (AST1010) {
+            SCU_04h = 0x00000010; //Reset Engine
+        } 
+        else if (AST2300) {
+            SCU_04h = 0x0c001800; //Reset Engine
+        } 
+        else {
+            SCU_04h = 0x00001800; //Reset Engine
+        } // End if ( AST3200 )
+    
+        if ( ModeSwitch == MODE_NSCI )
+            // Set to 100Mbps and Enable RX broabcast packets and CRC_APD and Full duplex
+            MAC_50h = 0x000a0500;
+        else {
+            // RX_ALLADR and CRC_APD and Full duplex
+            MAC_50h = 0x00004500;
+            
+            #ifdef Enable_Runt
+            MAC_50h = MAC_50h | 0x00001000;
+            #endif
+            
+            #ifdef Enable_Jumbo
+            MAC_50h = MAC_50h | 0x00002000;
+            #endif
+        } // End if ( ModeSwitch == MODE_NSCI )
+
+//------------------------------------------------------------
+// Descriptor Number
+//------------------------------------------------------------
+        if ( ModeSwitch == MODE_DEDICATED ) {
+
+            #ifdef Enable_Jumbo
+            DES_LowNumber = 1;
+            #else
+            DES_LowNumber = IOTiming;
+            #endif
+            if ( Enable_SkipChkPHY && ( TestMode == 0 ) ) {
+                DES_NUMBER = 114;//for SMSC's LAN9303 issue
+            } 
+            else {
+                if ( AST1010 | AST3200 ) {
+                    DES_NUMBER = (IOTimingBund) ? 100 : 256;
+                } 
+                else {
+                    switch ( GSpeed ) {
+                        case SET_1GBPS          : DES_NUMBER = (IOTimingBund) ? 10 : (DES_LowNumber) ? 50 : 400; break; // 20140325
+                        case SET_100MBPS        : DES_NUMBER = (IOTimingBund) ? 10 : (DES_LowNumber) ? 50 : 400; break; // 20140325
+                        case SET_10MBPS         : DES_NUMBER = (IOTimingBund) ? 10 : (DES_LowNumber) ? 10 :  80; break; // 20140325
+                        case SET_1G_100M_10MBPS : DES_NUMBER = (IOTimingBund) ? 10 : (DES_LowNumber) ? 10 :  80; break; // 20140325
+                    }
+                } // End if ( Enable_SkipChkPHY && ( TestMode == 0 ) )
+            } 
+
+            #ifdef SelectDesNumber
+            DES_NUMBER = SelectDesNumber;
+            #endif
+            
+            #ifdef USE_LPC
+                DES_NUMBER /= 8;
+            #endif
+        
+            #ifdef ENABLE_ARP_2_WOL
+            if ( TestMode == 4 ) {
+                DES_NUMBER = 1;
+            }
+            #endif
+            
+            DES_NUMBER_Org = DES_NUMBER;
+            
+            if ( DbgPrn_Info ) {
+                printf ("CheckBuf_MBSize : %ld\n", CheckBuf_MBSize);
+                printf ("LOOP_CheckNum   : %ld\n", LOOP_CheckNum);
+                printf ("DES_NUMBER      : %ld\n", DES_NUMBER);
+                printf ("DMA_BufSize     : %ld bytes\n", DMA_BufSize);
+                printf ("DMA_BufNum      : %d\n", DMA_BufNum);
+                printf ("\n");
+            }
+//          if (3 > DMA_BufNum) 
+//                return( Finish_Check(Err_DMABufNum) );
+            
+            if (2 > DMA_BufNum) 
+                return( Finish_Check(Err_DMABufNum) );
+        } // End if ( ModeSwitch == MODE_DEDICATED )
+    } // End if (RUN_STEP >= 1)
+
+//------------------------------------------------------------
+// SCU Initial
+//------------------------------------------------------------
+    if ( RUN_STEP >= 2 ) {
+        init_scu1();
+    }
+    
+    if ( RUN_STEP >= 3 ) {
+        init_scu_macrst();
+    }
+
+//------------------------------------------------------------
+// Data Initial
+//------------------------------------------------------------
+    if (RUN_STEP >= 4) {
+        setup_arp();
+        if ( ModeSwitch ==  MODE_DEDICATED ) {
+
+            FRAME_LEN = (ULONG *)malloc(DES_NUMBER * sizeof( ULONG ));
+            wp_lst    = (ULONG *)malloc(DES_NUMBER * sizeof( ULONG ));
+        
+            if ( !FRAME_LEN ) 
+                return( Finish_Check( Err_MALLOC_FrmSize ) );
+                
+            if ( !wp_lst ) 
+                return( Finish_Check( Err_MALLOC_LastWP ));
+                
+            // Setup data and length
+            TestingSetup();
+        } // End if ( ModeSwitch ==  MODE_DEDICATED )
+        
+        // Get bit (shift) of IO driving strength register
+        if ( IOStrength ) {
+            if (AST1010) {
+                IOStr_max = 1;//0~1
+            } 
+            else if (AST2400) {
+                IOStr_max = 1;//0~1
+                switch (SelectMAC) {
+                    case 0  : IOStr_shf =  9; break;
+                    case 1  : IOStr_shf = 11; break;
+                }
+            } 
+            else {
+                IOStr_max = 3;//0~3
+                switch (SelectMAC) {
+                    case 0  : IOStr_shf =  8; break;
+                    case 1  : IOStr_shf = 10; break;
+                    case 2  : IOStr_shf = 12; break;
+                    case 3  : IOStr_shf = 14; break;
+                }
+            }
+        } 
+        else {
+            IOStr_max = 0;
+            IOStr_shf = 0;
+        } // End if (IOStrength)
+
+        // Get current clock delay value of TX(out) and RX(in) in the SCU48 register
+        // and setting test range
+        if ( Enable_RMII ) {
+            switch (GRun_Mode) {
+                case 0  : IOdly_out_shf = 24; IOdly_in_shf =  8; break;
+                case 1  : IOdly_out_shf = 25; IOdly_in_shf = 12; break;
+                case 2  : IOdly_out_shf = 26; IOdly_in_shf = 16; break;
+                case 3  : IOdly_out_shf = 27; IOdly_in_shf = 20; break;
+            }
+            IOdly_in_reg  = (SCU_48h_old >> IOdly_in_shf ) & 0xf;
+            IOdly_out_reg = (SCU_48h_old >> IOdly_out_shf) & 0x1;
+        } 
+        else {
+            switch (GRun_Mode) {
+                case 0  : IOdly_out_shf =  0; IOdly_in_shf  =  8; break;
+                case 1  : IOdly_out_shf =  4; IOdly_in_shf  = 12; break;
+            }
+            IOdly_in_reg  = (SCU_48h_old >> IOdly_in_shf ) & 0xf;
+            IOdly_out_reg = (SCU_48h_old >> IOdly_out_shf) & 0xf;
+        } // End if ( Enable_RMII )
+        
+        // Find the coordinate in X-Y axis
+        for ( index = 0; index <= 15; index++ ) 
+            if ( IOdly_in_reg == valary[index] ) {
+                IOdly_in_reg_idx = index; 
+                break;
+            }
+        for ( index = 0; index <= 15; index++ ) 
+            if ( IOdly_out_reg == valary[index] ) {
+                IOdly_out_reg_idx = index; 
+                break;
+            }
+        
+        // Get the range for testmargin block
+        if ( IOTiming ) {
+            if ( Enable_RMII ) {
+                IOdly_incval  = 1;
+                IOdly_in_str  = 0;
+                IOdly_in_end  = 15;
+                IOdly_out_str = 0;
+                IOdly_out_end = 1;
+            } 
+            else {
+                IOdly_incval  = 1;
+                IOdly_in_str  = 0;
+                IOdly_in_end  = 15;
+                IOdly_out_str = 0;
+                IOdly_out_end = 15;
+            }
+        } 
+        else if ( IOTimingBund ) {
+            if ( Enable_RMII ) {
+                IOdly_incval  = 1;
+                IOdly_in_str  = IOdly_in_reg_idx  - ( IOTimingBund >> 1 );
+                IOdly_in_end  = IOdly_in_reg_idx  + ( IOTimingBund >> 1 );
+                IOdly_out_str = IOdly_out_reg_idx;
+                IOdly_out_end = IOdly_out_reg_idx;
+            } 
+            else {
+                IOdly_incval  = 1;
+                IOdly_in_str  = IOdly_in_reg_idx  - ( IOTimingBund >> 1 );
+                IOdly_in_end  = IOdly_in_reg_idx  + ( IOTimingBund >> 1 );
+                IOdly_out_str = IOdly_out_reg_idx - ( IOTimingBund >> 1 );
+                IOdly_out_end = IOdly_out_reg_idx + ( IOTimingBund >> 1 );
+            }
+            if ((IOdly_in_str  < 0) || (IOdly_in_end  > 15)) 
+                return( Finish_Check( Err_IOMarginOUF ) );
+                
+            if ((IOdly_out_str < 0) || (IOdly_out_end > 15)) 
+                return( Finish_Check( Err_IOMarginOUF ) );
+
+//          if (IOdly_in_str  <  0) IOdly_in_str  =  0;
+//          if (IOdly_in_end  > 15) IOdly_in_end  = 15;
+//          if (IOdly_out_str <  0) IOdly_out_str =  0;
+//          if (IOdly_out_end > 15) IOdly_out_end = 15;
+        } 
+        else {
+            IOdly_incval  = 1;
+            IOdly_in_str  = 0;
+            IOdly_in_end  = 0;
+            IOdly_out_str = 0;
+            IOdly_out_end = 0;
+        } // End if (IOTiming)
+    } // End if (RUN_STEP >= 4)
+
+//------------------------------------------------------------
+// main
+//------------------------------------------------------------
+    if (RUN_STEP >= 5) {
+        #ifdef  DbgPrn_FuncHeader
+            printf ("GSpeed_sel: %d %d %d\n", GSpeed_sel[0], GSpeed_sel[1], GSpeed_sel[2]); 
+            Debug_delay();
+        #endif
+
+    if ( ModeSwitch == MODE_NSCI ) {
+        #ifdef Enable_NCSI_LOOP_INFINI
+        for ( GSpeed_idx = 0; GSpeed_idx < 3; GSpeed_idx++ ) {
+            GSpeed_org[GSpeed_idx] = GSpeed_sel[GSpeed_idx];
+        }
+NCSI_LOOP_INFINI:;
+        for ( GSpeed_idx = 0; GSpeed_idx < 3; GSpeed_idx++ ) {
+            GSpeed_sel[GSpeed_idx] = GSpeed_org[GSpeed_idx];
+        }
+        #endif
+    } // End if ( ModeSwitch == MODE_NSCI )
+
+        for (GSpeed_idx = 0; GSpeed_idx < 3; GSpeed_idx++) {
+            Err_Flag_PrintEn = 1;
+            if ( GSpeed_sel[GSpeed_idx] ) {
+                // Setting the LAN speed
+                if ( ModeSwitch ==  MODE_DEDICATED ) {
+
+
+                    // Test three speed of LAN, we will modify loop number
+                    if (GSpeed == SET_1G_100M_10MBPS) {
+                        if      (GSpeed_sel[0]) LOOP_MAX = LOOP_MAX_arg;
+                        else if (GSpeed_sel[1]) LOOP_MAX = LOOP_MAX_arg / 10;
+                        else                    LOOP_MAX = LOOP_MAX_arg / 100;
+                            
+                        if ( !LOOP_MAX ) 
+                            LOOP_MAX = 1;
+                        
+                        Calculate_LOOP_CheckNum();
+                    }
+                    
+                    // Setting speed of LAN
+                    if      (GSpeed_sel[0]) MAC_50h_Speed = 0x00000200;
+                    else if (GSpeed_sel[1]) MAC_50h_Speed = 0x00080000;
+                    else                    MAC_50h_Speed = 0x00000000;
+                        
+                    //------------------------------------------------------------
+                    // PHY Initial
+                    //------------------------------------------------------------
+                    if ( AST1100 ) 
+                        init_scu2();
+                        
+                    if ( Enable_InitPHY ) {
+#ifdef SUPPORT_PHY_LAN9303
+                        LAN9303(LAN9303_I2C_BUSNUM, PHY_ADR_arg, GSpeed_idx, Enable_IntLoopPHY | (BurstEnable<<1) | IEEETesting);
+#else
+                        init_phy( Enable_IntLoopPHY );
+#endif
+                        DELAY( Delay_PHYRst * 10 );
+                    } // End if (Enable_InitPHY)
+
+                    if ( AST1100 ) 
+                        init_scu3();
+
+                    if ( Err_Flag ) 
+                        return( Finish_Check( 0 ) );
+                } // End if ( ModeSwitch ==  MODE_DEDICATED )
+
+                //------------------------------------------------------------
+                // Start
+                //------------------------------------------------------------
+                
+                // The loop is for different IO strength
+                for ( IOStr_i = 0; IOStr_i <= IOStr_max; IOStr_i++ ) {
+                    
+                    // Print Header of report to monitor and log file
+                    if ( IOTiming || IOTimingBund ) {
+                        if ( IOStrength ) {
+                            if ( AST1010 ) {
+                                IOStr_val = (SCU_ach_old & 0xfff0ffff) | ((IOStr_i) ? 0xf0000 : 0x0);
+                            } 
+                            else {
+                                IOStr_val = (SCU_90h_old & 0xffff00ff) | (IOStr_i << IOStr_shf);
+                            }
+                            //printf("\nIOStrength_val= %08x, ", IOStr_val);
+                            //printf("SCU90h: %08x ->", ReadSOC_DD(SCU_BASE+0x90));
+                            WriteSOC_DD( SCU_BASE + 0x90, IOStr_val );
+                            //printf(" %08x\n", ReadSOC_DD(SCU_BASE+0x90));
+                            
+                            #ifndef SLT_UBOOT
+                            if      (GSpeed_sel[0]) fprintf(fp_log, "[Strength %d][1G  ]========================================\n", IOStr_i);
+                            else if (GSpeed_sel[1]) fprintf(fp_log, "[Strength %d][100M]========================================\n", IOStr_i);
+                            else                    fprintf(fp_log, "[Strength %d][10M ]========================================\n", IOStr_i);
+                            #endif
+                        } 
+                        else {
+                            #ifndef SLT_UBOOT
+                            if      (GSpeed_sel[0]) fprintf(fp_log, "[1G  ]========================================\n");
+                            else if (GSpeed_sel[1]) fprintf(fp_log, "[100M]========================================\n");
+                            else                    fprintf(fp_log, "[10M ]========================================\n");
+                            #endif
+                        }
+
+                        if ( IOTimingBund ) 
+                            PrintIO_Header(FP_LOG);
+                        if ( IOTiming     ) 
+                            PrintIO_Header(FP_IO);
+
+                        PrintIO_Header(STD_OUT);
+                        
+                    } 
+                    else {
+                        if ( ModeSwitch == MODE_DEDICATED ) {
+
+                            if (!BurstEnable) 
+                                Print_Header(FP_LOG);
+
+                            Print_Header(STD_OUT);
+                        }
+                    } // End if (IOTiming || IOTimingBund)
+                    
+#ifdef Enable_Old_Style
+                    for (IOdly_i = IOdly_in_str; IOdly_i <= IOdly_in_end; IOdly_i+=IOdly_incval) {
+                        IOdly_in  = valary[IOdly_i];
+#else
+                    for (IOdly_j = IOdly_out_str; IOdly_j <= IOdly_out_end; IOdly_j+=IOdly_incval) {
+                        IOdly_out = valary[IOdly_j];
+#endif
+
+                        if (IOTiming || IOTimingBund) {
+#ifdef Enable_Fast_SCU
+  #ifdef Enable_Old_Style
+                            WriteSOC_DD(SCU_BASE + 0x48, SCU_48h_mix | (IOdly_in << IOdly_in_shf));
+  #else
+                            WriteSOC_DD(SCU_BASE + 0x48, SCU_48h_mix | (IOdly_out << IOdly_out_shf));
+  #endif
+#endif
+
+                            if ( IOTimingBund ) 
+                                PrintIO_LineS(FP_LOG);
+                            if ( IOTiming     ) 
+                                PrintIO_LineS(FP_IO);
+
+                            PrintIO_LineS(STD_OUT);
+                        } // End if (IOTiming || IOTimingBund)
+                        
+                        //------------------------------------------------------------
+                        // SCU Initial
+                        //------------------------------------------------------------
+#ifdef Enable_Fast_SCU
+                        init_scu_macrst();
+#endif
+#ifdef Enable_Old_Style
+                        for (IOdly_j = IOdly_out_str; IOdly_j <= IOdly_out_end; IOdly_j+=IOdly_incval) {
+                            IOdly_out = valary[IOdly_j];
+#else
+                        for (IOdly_i = IOdly_in_str; IOdly_i <= IOdly_in_end; IOdly_i+=IOdly_incval) {
+                            IOdly_in  = valary[IOdly_i];
+#endif
+                            if ( IOTiming || IOTimingBund ) {
+                                IOdly_val = (IOdly_in  << IOdly_in_shf) | (IOdly_out << IOdly_out_shf);
+
+//printf("\nIOdly_val= %08x, ", IOdly_val);
+//printf("SCU48h: %08x ->", ReadSOC_DD( SCU_BASE + 0x48 ) );
+                            WriteSOC_DD( SCU_BASE + 0x48, SCU_48h_mix | IOdly_val );
+//printf(" %08x\n", ReadSOC_DD(SCU_BASE+0x48));
+                            } // End if (IOTiming || IOTimingBund)
+                        
+                            //------------------------------------------------------------
+                            // SCU Initial
+                            //------------------------------------------------------------
+#ifdef Enable_Fast_SCU
+#else
+                            init_scu_macrst();
+#endif
+
+                            //------------------------------------------------------------
+                            // MAC Initial
+                            //------------------------------------------------------------
+                            init_mac(H_MAC_BASE, H_TDES_BASE, H_RDES_BASE);
+                            if ( Err_Flag ) 
+                                return( Finish_Check(0) );
+
+                            // Testing 
+                            if ( ModeSwitch == MODE_NSCI )
+                                dlymap[IOdly_i][IOdly_j] = phy_ncsi();
+                            else
+                                dlymap[IOdly_i][IOdly_j] = TestingLoop(LOOP_CheckNum);
+                            
+                            
+                            // Display to Log file and monitor
+                            if ( IOTiming || IOTimingBund ) {
+
+                                if ( IOTimingBund ) 
+                                    PrintIO_Line(FP_LOG);
+                                    
+                                if ( IOTiming     ) 
+                                    PrintIO_Line(FP_IO);
+
+                                PrintIO_Line(STD_OUT);
+
+                                // Find the range of current setting 
+                                if ( ( IOdly_in_reg == IOdly_in ) && ( IOdly_out_reg == IOdly_out ) ) {
+                                    IOdly_i_min = IOdly_i - ( IOTimingBund >> 1 );
+                                    IOdly_i_max = IOdly_i + ( IOTimingBund >> 1 );
+                                
+                                    if ( Enable_RMII ) {
+                                        IOdly_j_min = IOdly_j;
+                                        IOdly_j_max = IOdly_j;
+                                    } 
+                                    else {
+                                        IOdly_j_min = IOdly_j - (IOTimingBund >> 1 );
+                                        IOdly_j_max = IOdly_j + (IOTimingBund >> 1 );
+                                    }
+                                }
+                                
+                                PrintIO_Line_LOG();
+                                FPri_ErrFlag(FP_LOG);
+
+//                              Err_Flag_allapeed = Err_Flag_allapeed | Err_Flag;
+                                Err_Flag = 0;
+                            }
+                        }// End for (IOdly_j = IOdly_out_str; IOdly_j <= IOdly_out_end; IOdly_j+=IOdly_incval)
+#ifndef SLT_UBOOT                        
+                        if ( IOTiming || IOTimingBund ) {
+                            if ( IOTimingBund ) 
+                                fprintf(fp_log, "\n");
+                            if (IOTiming    ) 
+                                fprintf(fp_io, "\n");
+                        }
+#endif
+                        printf("\n");
+                    } // End for (IOdly_j = IOdly_out_str; IOdly_j <= IOdly_out_end; IOdly_j+=IOdly_incval)
+                    
+                    //------------------------------------------------------------
+                    // End
+                    //------------------------------------------------------------
+
+                    if ( IOTiming || IOTimingBund ) {
+                        if ( ( IOdly_i_min < 0 ) || ( IOdly_i_max > 15 ) ) 
+                            FindErr(Err_IOMarginOUF);
+                        if ( ( IOdly_j_min < 0 ) || ( IOdly_j_max > 15 ) ) 
+                            FindErr(Err_IOMarginOUF);
+
+                        if ( IOdly_i_min <  0 ) IOdly_i_min =  0;
+                        if ( IOdly_i_max > 15 ) IOdly_i_max = 15;
+                        if ( IOdly_j_min <  0 ) IOdly_j_min =  0;
+                        if ( IOdly_j_max > 15 ) IOdly_j_max = 15;
+
+#ifdef Enable_Old_Style
+                        for (IOdly_i = IOdly_i_min; IOdly_i <= IOdly_i_max; IOdly_i++)
+                            for (IOdly_j = IOdly_j_min; IOdly_j <= IOdly_j_max; IOdly_j++)
+#else
+                        for (IOdly_j = IOdly_j_min; IOdly_j <= IOdly_j_max; IOdly_j++)
+                            for (IOdly_i = IOdly_i_min; IOdly_i <= IOdly_i_max; IOdly_i++)
+#endif
+                            {             
+                                if ( dlymap[IOdly_i][IOdly_j] ) {
+#ifdef SLT_DOS                   
+                                    if ( IOTiming ) {
+#ifdef Enable_Old_Style
+                                        for (i = IOdly_i_min; i <= IOdly_i_max; i++)
+#else
+                                        for (j = IOdly_j_min; j <= IOdly_j_max; j++)
+#endif
+                                        {
+#ifdef Enable_Old_Style
+                                            for (j = IOdly_j_min; j <= IOdly_j_max; j++)
+#else
+                                            for (i = IOdly_i_min; i <= IOdly_i_max; i++)
+#endif
+                                            {    
+                                                if (dlymap[i][j]) fprintf(fp_io, "x ");
+                                                else              fprintf(fp_io, "o ");
+                                            }
+                                            fprintf(fp_io, "\n");
+                                        }
+                                    } // End if ( IOTiming )
+#endif // End SLT_DOS  
+                                    FindErr(Err_IOMargin);
+                                    goto Find_Err_IOMargin;
+                                } // End if ( dlymap[IOdly_i][IOdly_j] )
+                            }
+                    } // End if ( IOTiming || IOTimingBund )
+
+Find_Err_IOMargin:;
+                    if ( !BurstEnable ) 
+                        FPri_ErrFlag(FP_LOG);
+                    if ( IOTiming ) 
+                        FPri_ErrFlag(FP_IO);
+
+                    FPri_ErrFlag(STD_OUT);
+                    
+                    Err_Flag_allapeed = Err_Flag_allapeed | Err_Flag;
+                    Err_Flag = 0;
+                } // End for (IOStr_i = 0; IOStr_i <= IOStr_max; IOStr_i++)
+                
+                if ( ModeSwitch == MODE_DEDICATED ) {
+                    if ( Enable_InitPHY & !Disable_RecovPHY ) 
+                        recov_phy(Enable_IntLoopPHY);
+                }
+                    
+                GSpeed_sel[GSpeed_idx] = 0;
+            } // End if (GSpeed_sel[GSpeed_idx])
+            
+            Err_Flag_PrintEn = 0;
+        } // End for (GSpeed_idx = 0; GSpeed_idx < 3; GSpeed_idx++)
+        
+        Err_Flag = Err_Flag_allapeed;
+
+        if ( ModeSwitch == MODE_NSCI ) {
+            #ifdef Enable_NCSI_LOOP_INFINI
+            if (Err_Flag == 0) {
+                if (fp_log) {
+                    fclose(fp_log);
+                    fp_log = fopen(FileName,"w");
+                }
+                goto NCSI_LOOP_INFINI;
+            }
+            #endif
+        }
+        
+    } // End if (RUN_STEP >= 5)
+
+    return(Finish_Check(0));
+   
+}
+
diff --git a/arch/arm/cpu/arm926ejs/aspeed/reset.c b/arch/arm/cpu/arm926ejs/aspeed/reset.c
new file mode 100644
index 0000000..e0a57f9
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/aspeed/reset.c
@@ -0,0 +1,24 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#include <common.h>
+#include <asm/io.h>
+
+#define AST_WDT_BASE 0x1e785000
+void reset_cpu(ulong addr)
+{
+	__raw_writel(0x10 , AST_WDT_BASE+0x04);
+	__raw_writel(0x4755, AST_WDT_BASE+0x08);
+	__raw_writel(0x3, AST_WDT_BASE+0x0c);
+
+	while (1)
+	/*nothing*/;
+}
diff --git a/arch/arm/cpu/arm926ejs/aspeed/timer.c b/arch/arm/cpu/arm926ejs/aspeed/timer.c
new file mode 100644
index 0000000..4bba5c5
--- /dev/null
+++ b/arch/arm/cpu/arm926ejs/aspeed/timer.c
@@ -0,0 +1,153 @@
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <arm926ejs.h>
+
+#define TIMER_LOAD_VAL 0xffffffff
+
+/* macro to read the 32 bit timer */
+#define READ_TIMER (*(volatile ulong *)(CONFIG_SYS_TIMERBASE+0))
+
+static ulong timestamp;
+static ulong lastdec;
+
+int timer_init (void)
+{
+	*(volatile ulong *)(CONFIG_SYS_TIMERBASE + 4)    = TIMER_LOAD_VAL;
+	*(volatile ulong *)(CONFIG_SYS_TIMERBASE + 0x30) = 0x3;		/* enable timer1 */
+
+	/* init the timestamp and lastdec value */
+	reset_timer_masked();
+
+	return 0;
+}
+
+/*
+ * timer without interrupts
+ */
+
+void reset_timer (void)
+{
+	reset_timer_masked ();
+}
+
+ulong get_timer (ulong base)
+{
+	return get_timer_masked () - base;
+}
+
+void set_timer (ulong t)
+{
+	timestamp = t;
+}
+
+/* delay x useconds AND perserve advance timstamp value */
+void udelay (unsigned long usec)
+{
+	ulong tmo, tmp;
+
+	if(usec >= 1000){		/* if "big" number, spread normalization to seconds */
+		tmo = usec / 1000;	/* start to normalize for usec to ticks per sec */
+		tmo *= CONFIG_SYS_HZ;		/* find number of "ticks" to wait to achieve target */
+		tmo /= 1000;		/* finish normalize. */
+	}else{				/* else small number, don't kill it prior to HZ multiply */
+		tmo = usec * CONFIG_SYS_HZ;
+		tmo /= (1000*1000);
+	}
+
+	tmp = get_timer (0);		/* get current timestamp */
+	if( (tmo + tmp + 1) < tmp )	/* if setting this fordward will roll time stamp */
+		reset_timer_masked ();	/* reset "advancing" timestamp to 0, set lastdec value */
+	else
+		tmo += tmp;		/* else, set advancing stamp wake up time */
+
+	while (get_timer_masked () < tmo)/* loop till event */
+		/*NOP*/;
+}
+
+void reset_timer_masked (void)
+{
+	/* reset time */
+	lastdec = READ_TIMER;  /* capure current decrementer value time */
+	timestamp = 0;	       /* start "advancing" time stamp from 0 */
+}
+
+ulong get_timer_masked (void)
+{
+	ulong now = READ_TIMER;		/* current tick value */
+
+	if (lastdec >= now) {		/* normal mode (non roll) */
+		/* normal mode */
+		timestamp += lastdec - now; /* move stamp fordward with absoulte diff ticks */
+	} else {			/* we have overflow of the count down timer */
+		/* nts = ts + ld + (TLV - now)
+		 * ts=old stamp, ld=time that passed before passing through -1
+		 * (TLV-now) amount of time after passing though -1
+		 * nts = new "advancing time stamp"...it could also roll and cause problems.
+		 */
+		timestamp += lastdec + TIMER_LOAD_VAL - now;
+	}
+	lastdec = now;
+
+	return timestamp;
+}
+
+/* waits specified delay value and resets timestamp */
+void udelay_masked (unsigned long usec)
+{
+	ulong tmo;
+	ulong endtime;
+	signed long diff;
+
+	if (usec >= 1000) {		/* if "big" number, spread normalization to seconds */
+		tmo = usec / 1000;	/* start to normalize for usec to ticks per sec */
+		tmo *= CONFIG_SYS_HZ;		/* find number of "ticks" to wait to achieve target */
+		tmo /= 1000;		/* finish normalize. */
+	} else {			/* else small number, don't kill it prior to HZ multiply */
+		tmo = usec * CONFIG_SYS_HZ;
+		tmo /= (1000*1000);
+	}
+
+	endtime = get_timer_masked () + tmo;
+
+	do {
+		ulong now = get_timer_masked ();
+		diff = endtime - now;
+	} while (diff >= 0);
+}
+
+/*
+ * This function is derived from PowerPC code (read timebase as long long).
+ * On ARM it just returns the timer value.
+ */
+unsigned long long get_ticks(void)
+{
+	return get_timer(0);
+}
+
+/*
+ * This function is derived from PowerPC code (timebase clock frequency).
+ * On ARM it returns the number of timer ticks per second.
+ */
+ulong get_tbclk (void)
+{
+	ulong tbclk;
+
+	tbclk = CONFIG_SYS_HZ;
+	return tbclk;
+}
diff --git a/arch/arm/include/asm/arch-aspeed/aspeed_i2c.h b/arch/arm/include/asm/arch-aspeed/aspeed_i2c.h
new file mode 100644
index 0000000..5419fca
--- /dev/null
+++ b/arch/arm/include/asm/arch-aspeed/aspeed_i2c.h
@@ -0,0 +1,69 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#if	defined(CONFIG_AST1300)
+#define  SCU_BASE       CONFIG_SCUREG_BASE
+#define  I2C_BASE       CONFIG_I2CREG_BASE
+#define  I2C_CHANNEL    CONFIG_I2C_CHANNEL
+#else
+#define  SCU_BASE       0x1E6E2000
+#define  I2C_BASE       0x1E78A000
+/* Cause U-boot i2c command limitation, it can't assign channel number. Our EEPROM is at channel 3 now*/
+/* AST2200's EEPROM is at channel 4 */
+#if defined(CONFIG_AST2200) || defined(CONFIG_AST2300) || defined(CONFIG_AST2400)
+#define  I2C_CHANNEL    4
+#else
+#define  I2C_CHANNEL    3
+#endif
+#endif
+
+/* Fix timing for EEPROM 100Khz*/
+#define  AC_TIMING      0x77743335
+#define  ALL_CLEAR      0xFFFFFFFF
+#define  MASTER_ENABLE  0x01
+#define  SLAVE_ENABLE   0x02
+#define  LOOP_COUNT     0x100000
+#define  SCU_RESET_CONTROL    0x04
+#define  SCU_MULTIFUNCTION_PIN_CTL5_REG    0x90
+
+/* I2C Register */
+#define  I2C_FUNCTION_CONTROL_REGISTER    (I2C_BASE + I2C_CHANNEL * 0x40 + 0x00)
+#define  I2C_AC_TIMING_REGISTER_1         (I2C_BASE + I2C_CHANNEL * 0x40 + 0x04)
+#define  I2C_AC_TIMING_REGISTER_2         (I2C_BASE + I2C_CHANNEL * 0x40 + 0x08)
+#define  I2C_INTERRUPT_CONTROL_REGISTER   (I2C_BASE + I2C_CHANNEL * 0x40 + 0x0c)
+#define  I2C_INTERRUPT_STATUS_REGISTER    (I2C_BASE + I2C_CHANNEL * 0x40 + 0x10)
+#define  I2C_COMMAND_REGISTER             (I2C_BASE + I2C_CHANNEL * 0x40 + 0x14)
+#define  I2C_DEVICE_ADDRESS_REGISTER      (I2C_BASE + I2C_CHANNEL * 0x40 + 0x18)
+#define  I2C_BUFFER_CONTROL_REGISTER      (I2C_BASE + I2C_CHANNEL * 0x40 + 0x1c)
+#define  I2C_BYTE_BUFFER_REGISTER         (I2C_BASE + I2C_CHANNEL * 0x40 + 0x20)
+#define  I2C_DMA_CONTROL_REGISTER         (I2C_BASE + I2C_CHANNEL * 0x40 + 0x24)
+#define  I2C_DMA_STATUS_REGISTER          (I2C_BASE + I2C_CHANNEL * 0x40 + 0x28)
+
+/* Command Bit */
+#define  MASTER_START_COMMAND    (1 << 0)
+#define  MASTER_TX_COMMAND       (1 << 1)
+#define  MASTER_RX_COMMAND       (1 << 3)
+#define  RX_COMMAND_LIST         (1 << 4)
+#define  MASTER_STOP_COMMAND     (1 << 5)
+
+/* Interrupt Status Bit */
+#define  TX_ACK        (1 << 0)
+#define  TX_NACK       (1 << 1)
+#define  RX_DONE       (1 << 2)
+#define  STOP_DONE     (1 << 4)
+
+/* Macros to access registers */
+#define outb(v,p) *(volatile u8 *) (p) = v
+#define outw(v,p) *(volatile u16 *) (p) = v
+#define outl(v,p) *(volatile u32 *) (p) = v
+
+#define inb(p)	*(volatile u8 *) (p)
+#define inw(p)	*(volatile u16 *) (p)
+#define inl(p)	*(volatile u32 *) (p)
diff --git a/arch/arm/include/asm/mach-types.h b/arch/arm/include/asm/mach-types.h
index 440b041..48fcf2b 100644
--- a/arch/arm/include/asm/mach-types.h
+++ b/arch/arm/include/asm/mach-types.h
@@ -175,6 +175,16 @@ extern unsigned int __machine_arch_type;
 #define MACH_TYPE_PALMTX               885
 #define MACH_TYPE_S3C2413              887
 #define MACH_TYPE_WG302V2              890
+#define MACH_TYPE_AST1100              903
+#define MACH_TYPE_AST2000              900
+#define MACH_TYPE_AST2100              902
+#define MACH_TYPE_AST2150              907
+#define MACH_TYPE_AST2200              906
+#define MACH_TYPE_AST2300_FPGA_1       901
+#define MACH_TYPE_AST2300_FPGA_2       901
+#define MACH_TYPE_AST2300              901
+#define MACH_TYPE_AST3100              901
+#define MACH_TYPE_ASPEED               8888
 #define MACH_TYPE_OMAP_2430SDP         900
 #define MACH_TYPE_DAVINCI_EVM          901
 #define MACH_TYPE_PALMZ72              904
@@ -840,7 +850,6 @@ extern unsigned int __machine_arch_type;
 #define MACH_TYPE_NV1000               3218
 #define MACH_TYPE_NUC950TS             3219
 #define MACH_TYPE_NOKIA_RM680          3220
-#define MACH_TYPE_AST2200              3221
 #define MACH_TYPE_LEAD                 3222
 #define MACH_TYPE_UNINO1               3223
 #define MACH_TYPE_GREECO               3224
@@ -3063,6 +3072,126 @@ extern unsigned int __machine_arch_type;
 # define machine_is_wg302v2()	(0)
 #endif
 
+#ifdef CONFIG_MACH_AST1100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AST1100
+# endif
+# define machine_is_ast1100()	(machine_arch_type == MACH_TYPE_AST1100)
+#else
+# define machine_is_ast1100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AST2000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AST2000
+# endif
+# define machine_is_ast2000()	(machine_arch_type == MACH_TYPE_AST2000)
+#else
+# define machine_is_ast2000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AST2100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AST2100
+# endif
+# define machine_is_ast2100()	(machine_arch_type == MACH_TYPE_AST2100)
+#else
+# define machine_is_ast2100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AST2150
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AST2150
+# endif
+# define machine_is_ast2150()	(machine_arch_type == MACH_TYPE_AST2150)
+#else
+# define machine_is_ast2150()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AST2200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AST2200
+# endif
+# define machine_is_ast2200()	(machine_arch_type == MACH_TYPE_AST2200)
+#else
+# define machine_is_ast2200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AST2300_FPGA_1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AST2300_FPGA_1
+# endif
+# define machine_is_ast2300_fpga_1()	(machine_arch_type == MACH_TYPE_AST2300_FPGA_1)
+#else
+# define machine_is_ast2300_fpga_1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AST2300_FPGA_2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AST2300_FPGA_2
+# endif
+# define machine_is_ast2300_fpga_2()	(machine_arch_type == MACH_TYPE_AST2300_FPGA_2)
+#else
+# define machine_is_ast2300_fpga_2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AST3100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AST3100
+# endif
+# define machine_is_ast3100()	(machine_arch_type == MACH_TYPE_AST3100)
+#else
+# define machine_is_ast3100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASPEED
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASPEED
+# endif
+# define machine_is_aspeed()	(machine_arch_type == MACH_TYPE_ASPEED)
+#else
+# define machine_is_aspeed()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AST2300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AST2300
+# endif
+# define machine_is_ast2300()	(machine_arch_type == MACH_TYPE_AST2300)
+#else
+# define machine_is_ast2300()	(0)
+#endif
+
 #ifdef CONFIG_MACH_OMAP_2430SDP
 # ifdef machine_arch_type
 #  undef machine_arch_type
@@ -11043,18 +11172,6 @@ extern unsigned int __machine_arch_type;
 # define machine_is_nokia_rm680()	(0)
 #endif
 
-#ifdef CONFIG_MACH_AST2200
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_AST2200
-# endif
-# define machine_is_ast2200()	(machine_arch_type == MACH_TYPE_AST2200)
-#else
-# define machine_is_ast2200()	(0)
-#endif
-
 #ifdef CONFIG_MACH_LEAD
 # ifdef machine_arch_type
 #  undef machine_arch_type
diff --git a/board/aspeed/ast2300/Makefile b/board/aspeed/ast2300/Makefile
new file mode 100644
index 0000000..d5300e6
--- /dev/null
+++ b/board/aspeed/ast2300/Makefile
@@ -0,0 +1,42 @@
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	= ast2300.o flash.o flash_spi.o pci.o crc32.o slt.o regtest.o vfun.o vhace.o crt.o videotest.o mactest.o hactest.o mictest.o
+
+ifdef CONFIG_FPGA_ASPEED
+SOBJS   := platform_fpga.o
+else
+SOBJS   := platform.o
+endif
+
+SRCS    := $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS    := $(addprefix $(obj),$(COBJS))
+SOBJS   := $(addprefix $(obj),$(SOBJS))
+
+$(LIB): $(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/aspeed/ast2300/aes.c b/board/aspeed/ast2300/aes.c
new file mode 100755
index 0000000..f30ab99
--- /dev/null
+++ b/board/aspeed/ast2300/aes.c
@@ -0,0 +1,573 @@
+/*
+ *  AES implementation
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* uncomment the following line to run the test suite */
+
+/* #define TEST */
+
+/* uncomment the following line to use pre-computed tables */
+/* otherwise the tables will be generated at the first run */
+
+#define FIXED_TABLES
+
+#ifndef FIXED_TABLES
+
+/* forward S-box & tables */
+
+uint32 FSb[256];
+uint32 FT0[256]; 
+uint32 FT1[256]; 
+uint32 FT2[256]; 
+uint32 FT3[256]; 
+
+/* reverse S-box & tables */
+
+uint32 RSb[256];
+uint32 RT0[256];
+uint32 RT1[256];
+uint32 RT2[256];
+uint32 RT3[256];
+
+/* round constants */
+
+uint32 RCON[10];
+
+/* tables generation flag */
+
+int do_init = 1;
+
+/* tables generation routine */
+
+#define ROTR8(x) ( ( ( x << 24 ) & 0xFFFFFFFF ) | \
+                   ( ( x & 0xFFFFFFFF ) >>  8 ) )
+
+#define XTIME(x) ( ( x <<  1 ) ^ ( ( x & 0x80 ) ? 0x1B : 0x00 ) )
+#define MUL(x,y) ( ( x &&  y ) ? pow[(log[x] + log[y]) % 255] : 0 )
+
+void aes_gen_tables( void )
+{
+    int i;
+    uint8 x, y;
+    uint8 pow[256];
+    uint8 log[256];
+
+    /* compute pow and log tables over GF(2^8) */
+
+    for( i = 0, x = 1; i < 256; i++, x ^= XTIME( x ) )
+    {
+        pow[i] = x;
+        log[x] = i;
+    }
+
+    /* calculate the round constants */
+
+    for( i = 0, x = 1; i < 10; i++, x = XTIME( x ) )
+    {
+        RCON[i] = (uint32) x << 24;
+    }
+
+    /* generate the forward and reverse S-boxes */
+
+    FSb[0x00] = 0x63;
+    RSb[0x63] = 0x00;
+
+    for( i = 1; i < 256; i++ )
+    {
+        x = pow[255 - log[i]];
+
+        y = x;  y = ( y << 1 ) | ( y >> 7 );
+        x ^= y; y = ( y << 1 ) | ( y >> 7 );
+        x ^= y; y = ( y << 1 ) | ( y >> 7 );
+        x ^= y; y = ( y << 1 ) | ( y >> 7 );
+        x ^= y ^ 0x63;
+
+        FSb[i] = x;
+        RSb[x] = i;
+    }
+
+    /* generate the forward and reverse tables */
+
+    for( i = 0; i < 256; i++ )
+    {
+        x = (unsigned char) FSb[i]; y = XTIME( x );
+
+        FT0[i] =   (uint32) ( x ^ y ) ^
+                 ( (uint32) x <<  8 ) ^
+                 ( (uint32) x << 16 ) ^
+                 ( (uint32) y << 24 );
+
+        FT0[i] &= 0xFFFFFFFF;
+
+        FT1[i] = ROTR8( FT0[i] );
+        FT2[i] = ROTR8( FT1[i] );
+        FT3[i] = ROTR8( FT2[i] );
+
+        y = (unsigned char) RSb[i];
+
+        RT0[i] = ( (uint32) MUL( 0x0B, y )       ) ^
+                 ( (uint32) MUL( 0x0D, y ) <<  8 ) ^
+                 ( (uint32) MUL( 0x09, y ) << 16 ) ^
+                 ( (uint32) MUL( 0x0E, y ) << 24 );
+
+        RT0[i] &= 0xFFFFFFFF;
+
+        RT1[i] = ROTR8( RT0[i] );
+        RT2[i] = ROTR8( RT1[i] );
+        RT3[i] = ROTR8( RT2[i] );
+    }
+}
+
+#else
+
+/* forward S-box */
+
+static const uint32 FSb[256] =
+{
+    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5,
+    0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
+    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0,
+    0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
+    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC,
+    0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
+    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A,
+    0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
+    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0,
+    0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
+    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B,
+    0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
+    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85,
+    0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
+    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5,
+    0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
+    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17,
+    0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
+    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88,
+    0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
+    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C,
+    0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
+    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9,
+    0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
+    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6,
+    0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
+    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E,
+    0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
+    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94,
+    0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
+    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68,
+    0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
+};
+
+/* forward tables */
+
+#define FT \
+\
+    V(C6,63,63,A5), V(F8,7C,7C,84), V(EE,77,77,99), V(F6,7B,7B,8D), \
+    V(FF,F2,F2,0D), V(D6,6B,6B,BD), V(DE,6F,6F,B1), V(91,C5,C5,54), \
+    V(60,30,30,50), V(02,01,01,03), V(CE,67,67,A9), V(56,2B,2B,7D), \
+    V(E7,FE,FE,19), V(B5,D7,D7,62), V(4D,AB,AB,E6), V(EC,76,76,9A), \
+    V(8F,CA,CA,45), V(1F,82,82,9D), V(89,C9,C9,40), V(FA,7D,7D,87), \
+    V(EF,FA,FA,15), V(B2,59,59,EB), V(8E,47,47,C9), V(FB,F0,F0,0B), \
+    V(41,AD,AD,EC), V(B3,D4,D4,67), V(5F,A2,A2,FD), V(45,AF,AF,EA), \
+    V(23,9C,9C,BF), V(53,A4,A4,F7), V(E4,72,72,96), V(9B,C0,C0,5B), \
+    V(75,B7,B7,C2), V(E1,FD,FD,1C), V(3D,93,93,AE), V(4C,26,26,6A), \
+    V(6C,36,36,5A), V(7E,3F,3F,41), V(F5,F7,F7,02), V(83,CC,CC,4F), \
+    V(68,34,34,5C), V(51,A5,A5,F4), V(D1,E5,E5,34), V(F9,F1,F1,08), \
+    V(E2,71,71,93), V(AB,D8,D8,73), V(62,31,31,53), V(2A,15,15,3F), \
+    V(08,04,04,0C), V(95,C7,C7,52), V(46,23,23,65), V(9D,C3,C3,5E), \
+    V(30,18,18,28), V(37,96,96,A1), V(0A,05,05,0F), V(2F,9A,9A,B5), \
+    V(0E,07,07,09), V(24,12,12,36), V(1B,80,80,9B), V(DF,E2,E2,3D), \
+    V(CD,EB,EB,26), V(4E,27,27,69), V(7F,B2,B2,CD), V(EA,75,75,9F), \
+    V(12,09,09,1B), V(1D,83,83,9E), V(58,2C,2C,74), V(34,1A,1A,2E), \
+    V(36,1B,1B,2D), V(DC,6E,6E,B2), V(B4,5A,5A,EE), V(5B,A0,A0,FB), \
+    V(A4,52,52,F6), V(76,3B,3B,4D), V(B7,D6,D6,61), V(7D,B3,B3,CE), \
+    V(52,29,29,7B), V(DD,E3,E3,3E), V(5E,2F,2F,71), V(13,84,84,97), \
+    V(A6,53,53,F5), V(B9,D1,D1,68), V(00,00,00,00), V(C1,ED,ED,2C), \
+    V(40,20,20,60), V(E3,FC,FC,1F), V(79,B1,B1,C8), V(B6,5B,5B,ED), \
+    V(D4,6A,6A,BE), V(8D,CB,CB,46), V(67,BE,BE,D9), V(72,39,39,4B), \
+    V(94,4A,4A,DE), V(98,4C,4C,D4), V(B0,58,58,E8), V(85,CF,CF,4A), \
+    V(BB,D0,D0,6B), V(C5,EF,EF,2A), V(4F,AA,AA,E5), V(ED,FB,FB,16), \
+    V(86,43,43,C5), V(9A,4D,4D,D7), V(66,33,33,55), V(11,85,85,94), \
+    V(8A,45,45,CF), V(E9,F9,F9,10), V(04,02,02,06), V(FE,7F,7F,81), \
+    V(A0,50,50,F0), V(78,3C,3C,44), V(25,9F,9F,BA), V(4B,A8,A8,E3), \
+    V(A2,51,51,F3), V(5D,A3,A3,FE), V(80,40,40,C0), V(05,8F,8F,8A), \
+    V(3F,92,92,AD), V(21,9D,9D,BC), V(70,38,38,48), V(F1,F5,F5,04), \
+    V(63,BC,BC,DF), V(77,B6,B6,C1), V(AF,DA,DA,75), V(42,21,21,63), \
+    V(20,10,10,30), V(E5,FF,FF,1A), V(FD,F3,F3,0E), V(BF,D2,D2,6D), \
+    V(81,CD,CD,4C), V(18,0C,0C,14), V(26,13,13,35), V(C3,EC,EC,2F), \
+    V(BE,5F,5F,E1), V(35,97,97,A2), V(88,44,44,CC), V(2E,17,17,39), \
+    V(93,C4,C4,57), V(55,A7,A7,F2), V(FC,7E,7E,82), V(7A,3D,3D,47), \
+    V(C8,64,64,AC), V(BA,5D,5D,E7), V(32,19,19,2B), V(E6,73,73,95), \
+    V(C0,60,60,A0), V(19,81,81,98), V(9E,4F,4F,D1), V(A3,DC,DC,7F), \
+    V(44,22,22,66), V(54,2A,2A,7E), V(3B,90,90,AB), V(0B,88,88,83), \
+    V(8C,46,46,CA), V(C7,EE,EE,29), V(6B,B8,B8,D3), V(28,14,14,3C), \
+    V(A7,DE,DE,79), V(BC,5E,5E,E2), V(16,0B,0B,1D), V(AD,DB,DB,76), \
+    V(DB,E0,E0,3B), V(64,32,32,56), V(74,3A,3A,4E), V(14,0A,0A,1E), \
+    V(92,49,49,DB), V(0C,06,06,0A), V(48,24,24,6C), V(B8,5C,5C,E4), \
+    V(9F,C2,C2,5D), V(BD,D3,D3,6E), V(43,AC,AC,EF), V(C4,62,62,A6), \
+    V(39,91,91,A8), V(31,95,95,A4), V(D3,E4,E4,37), V(F2,79,79,8B), \
+    V(D5,E7,E7,32), V(8B,C8,C8,43), V(6E,37,37,59), V(DA,6D,6D,B7), \
+    V(01,8D,8D,8C), V(B1,D5,D5,64), V(9C,4E,4E,D2), V(49,A9,A9,E0), \
+    V(D8,6C,6C,B4), V(AC,56,56,FA), V(F3,F4,F4,07), V(CF,EA,EA,25), \
+    V(CA,65,65,AF), V(F4,7A,7A,8E), V(47,AE,AE,E9), V(10,08,08,18), \
+    V(6F,BA,BA,D5), V(F0,78,78,88), V(4A,25,25,6F), V(5C,2E,2E,72), \
+    V(38,1C,1C,24), V(57,A6,A6,F1), V(73,B4,B4,C7), V(97,C6,C6,51), \
+    V(CB,E8,E8,23), V(A1,DD,DD,7C), V(E8,74,74,9C), V(3E,1F,1F,21), \
+    V(96,4B,4B,DD), V(61,BD,BD,DC), V(0D,8B,8B,86), V(0F,8A,8A,85), \
+    V(E0,70,70,90), V(7C,3E,3E,42), V(71,B5,B5,C4), V(CC,66,66,AA), \
+    V(90,48,48,D8), V(06,03,03,05), V(F7,F6,F6,01), V(1C,0E,0E,12), \
+    V(C2,61,61,A3), V(6A,35,35,5F), V(AE,57,57,F9), V(69,B9,B9,D0), \
+    V(17,86,86,91), V(99,C1,C1,58), V(3A,1D,1D,27), V(27,9E,9E,B9), \
+    V(D9,E1,E1,38), V(EB,F8,F8,13), V(2B,98,98,B3), V(22,11,11,33), \
+    V(D2,69,69,BB), V(A9,D9,D9,70), V(07,8E,8E,89), V(33,94,94,A7), \
+    V(2D,9B,9B,B6), V(3C,1E,1E,22), V(15,87,87,92), V(C9,E9,E9,20), \
+    V(87,CE,CE,49), V(AA,55,55,FF), V(50,28,28,78), V(A5,DF,DF,7A), \
+    V(03,8C,8C,8F), V(59,A1,A1,F8), V(09,89,89,80), V(1A,0D,0D,17), \
+    V(65,BF,BF,DA), V(D7,E6,E6,31), V(84,42,42,C6), V(D0,68,68,B8), \
+    V(82,41,41,C3), V(29,99,99,B0), V(5A,2D,2D,77), V(1E,0F,0F,11), \
+    V(7B,B0,B0,CB), V(A8,54,54,FC), V(6D,BB,BB,D6), V(2C,16,16,3A)
+
+#define V(a,b,c,d) 0x##a##b##c##d
+static const uint32 FT0[256] = { FT };
+#undef V
+
+#define V(a,b,c,d) 0x##d##a##b##c
+static const uint32 FT1[256] = { FT };
+#undef V
+
+#define V(a,b,c,d) 0x##c##d##a##b
+static const uint32 FT2[256] = { FT };
+#undef V
+
+#define V(a,b,c,d) 0x##b##c##d##a
+static const uint32 FT3[256] = { FT };
+#undef V
+
+#undef FT
+
+/* reverse S-box */
+
+static const uint32 RSb[256] =
+{
+    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38,
+    0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
+    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87,
+    0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
+    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D,
+    0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
+    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2,
+    0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
+    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16,
+    0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
+    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA,
+    0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
+    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A,
+    0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
+    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02,
+    0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
+    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA,
+    0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
+    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85,
+    0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
+    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89,
+    0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
+    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20,
+    0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
+    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31,
+    0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
+    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D,
+    0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
+    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0,
+    0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
+    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26,
+    0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
+};
+
+/* reverse tables */
+
+#define RT \
+\
+    V(51,F4,A7,50), V(7E,41,65,53), V(1A,17,A4,C3), V(3A,27,5E,96), \
+    V(3B,AB,6B,CB), V(1F,9D,45,F1), V(AC,FA,58,AB), V(4B,E3,03,93), \
+    V(20,30,FA,55), V(AD,76,6D,F6), V(88,CC,76,91), V(F5,02,4C,25), \
+    V(4F,E5,D7,FC), V(C5,2A,CB,D7), V(26,35,44,80), V(B5,62,A3,8F), \
+    V(DE,B1,5A,49), V(25,BA,1B,67), V(45,EA,0E,98), V(5D,FE,C0,E1), \
+    V(C3,2F,75,02), V(81,4C,F0,12), V(8D,46,97,A3), V(6B,D3,F9,C6), \
+    V(03,8F,5F,E7), V(15,92,9C,95), V(BF,6D,7A,EB), V(95,52,59,DA), \
+    V(D4,BE,83,2D), V(58,74,21,D3), V(49,E0,69,29), V(8E,C9,C8,44), \
+    V(75,C2,89,6A), V(F4,8E,79,78), V(99,58,3E,6B), V(27,B9,71,DD), \
+    V(BE,E1,4F,B6), V(F0,88,AD,17), V(C9,20,AC,66), V(7D,CE,3A,B4), \
+    V(63,DF,4A,18), V(E5,1A,31,82), V(97,51,33,60), V(62,53,7F,45), \
+    V(B1,64,77,E0), V(BB,6B,AE,84), V(FE,81,A0,1C), V(F9,08,2B,94), \
+    V(70,48,68,58), V(8F,45,FD,19), V(94,DE,6C,87), V(52,7B,F8,B7), \
+    V(AB,73,D3,23), V(72,4B,02,E2), V(E3,1F,8F,57), V(66,55,AB,2A), \
+    V(B2,EB,28,07), V(2F,B5,C2,03), V(86,C5,7B,9A), V(D3,37,08,A5), \
+    V(30,28,87,F2), V(23,BF,A5,B2), V(02,03,6A,BA), V(ED,16,82,5C), \
+    V(8A,CF,1C,2B), V(A7,79,B4,92), V(F3,07,F2,F0), V(4E,69,E2,A1), \
+    V(65,DA,F4,CD), V(06,05,BE,D5), V(D1,34,62,1F), V(C4,A6,FE,8A), \
+    V(34,2E,53,9D), V(A2,F3,55,A0), V(05,8A,E1,32), V(A4,F6,EB,75), \
+    V(0B,83,EC,39), V(40,60,EF,AA), V(5E,71,9F,06), V(BD,6E,10,51), \
+    V(3E,21,8A,F9), V(96,DD,06,3D), V(DD,3E,05,AE), V(4D,E6,BD,46), \
+    V(91,54,8D,B5), V(71,C4,5D,05), V(04,06,D4,6F), V(60,50,15,FF), \
+    V(19,98,FB,24), V(D6,BD,E9,97), V(89,40,43,CC), V(67,D9,9E,77), \
+    V(B0,E8,42,BD), V(07,89,8B,88), V(E7,19,5B,38), V(79,C8,EE,DB), \
+    V(A1,7C,0A,47), V(7C,42,0F,E9), V(F8,84,1E,C9), V(00,00,00,00), \
+    V(09,80,86,83), V(32,2B,ED,48), V(1E,11,70,AC), V(6C,5A,72,4E), \
+    V(FD,0E,FF,FB), V(0F,85,38,56), V(3D,AE,D5,1E), V(36,2D,39,27), \
+    V(0A,0F,D9,64), V(68,5C,A6,21), V(9B,5B,54,D1), V(24,36,2E,3A), \
+    V(0C,0A,67,B1), V(93,57,E7,0F), V(B4,EE,96,D2), V(1B,9B,91,9E), \
+    V(80,C0,C5,4F), V(61,DC,20,A2), V(5A,77,4B,69), V(1C,12,1A,16), \
+    V(E2,93,BA,0A), V(C0,A0,2A,E5), V(3C,22,E0,43), V(12,1B,17,1D), \
+    V(0E,09,0D,0B), V(F2,8B,C7,AD), V(2D,B6,A8,B9), V(14,1E,A9,C8), \
+    V(57,F1,19,85), V(AF,75,07,4C), V(EE,99,DD,BB), V(A3,7F,60,FD), \
+    V(F7,01,26,9F), V(5C,72,F5,BC), V(44,66,3B,C5), V(5B,FB,7E,34), \
+    V(8B,43,29,76), V(CB,23,C6,DC), V(B6,ED,FC,68), V(B8,E4,F1,63), \
+    V(D7,31,DC,CA), V(42,63,85,10), V(13,97,22,40), V(84,C6,11,20), \
+    V(85,4A,24,7D), V(D2,BB,3D,F8), V(AE,F9,32,11), V(C7,29,A1,6D), \
+    V(1D,9E,2F,4B), V(DC,B2,30,F3), V(0D,86,52,EC), V(77,C1,E3,D0), \
+    V(2B,B3,16,6C), V(A9,70,B9,99), V(11,94,48,FA), V(47,E9,64,22), \
+    V(A8,FC,8C,C4), V(A0,F0,3F,1A), V(56,7D,2C,D8), V(22,33,90,EF), \
+    V(87,49,4E,C7), V(D9,38,D1,C1), V(8C,CA,A2,FE), V(98,D4,0B,36), \
+    V(A6,F5,81,CF), V(A5,7A,DE,28), V(DA,B7,8E,26), V(3F,AD,BF,A4), \
+    V(2C,3A,9D,E4), V(50,78,92,0D), V(6A,5F,CC,9B), V(54,7E,46,62), \
+    V(F6,8D,13,C2), V(90,D8,B8,E8), V(2E,39,F7,5E), V(82,C3,AF,F5), \
+    V(9F,5D,80,BE), V(69,D0,93,7C), V(6F,D5,2D,A9), V(CF,25,12,B3), \
+    V(C8,AC,99,3B), V(10,18,7D,A7), V(E8,9C,63,6E), V(DB,3B,BB,7B), \
+    V(CD,26,78,09), V(6E,59,18,F4), V(EC,9A,B7,01), V(83,4F,9A,A8), \
+    V(E6,95,6E,65), V(AA,FF,E6,7E), V(21,BC,CF,08), V(EF,15,E8,E6), \
+    V(BA,E7,9B,D9), V(4A,6F,36,CE), V(EA,9F,09,D4), V(29,B0,7C,D6), \
+    V(31,A4,B2,AF), V(2A,3F,23,31), V(C6,A5,94,30), V(35,A2,66,C0), \
+    V(74,4E,BC,37), V(FC,82,CA,A6), V(E0,90,D0,B0), V(33,A7,D8,15), \
+    V(F1,04,98,4A), V(41,EC,DA,F7), V(7F,CD,50,0E), V(17,91,F6,2F), \
+    V(76,4D,D6,8D), V(43,EF,B0,4D), V(CC,AA,4D,54), V(E4,96,04,DF), \
+    V(9E,D1,B5,E3), V(4C,6A,88,1B), V(C1,2C,1F,B8), V(46,65,51,7F), \
+    V(9D,5E,EA,04), V(01,8C,35,5D), V(FA,87,74,73), V(FB,0B,41,2E), \
+    V(B3,67,1D,5A), V(92,DB,D2,52), V(E9,10,56,33), V(6D,D6,47,13), \
+    V(9A,D7,61,8C), V(37,A1,0C,7A), V(59,F8,14,8E), V(EB,13,3C,89), \
+    V(CE,A9,27,EE), V(B7,61,C9,35), V(E1,1C,E5,ED), V(7A,47,B1,3C), \
+    V(9C,D2,DF,59), V(55,F2,73,3F), V(18,14,CE,79), V(73,C7,37,BF), \
+    V(53,F7,CD,EA), V(5F,FD,AA,5B), V(DF,3D,6F,14), V(78,44,DB,86), \
+    V(CA,AF,F3,81), V(B9,68,C4,3E), V(38,24,34,2C), V(C2,A3,40,5F), \
+    V(16,1D,C3,72), V(BC,E2,25,0C), V(28,3C,49,8B), V(FF,0D,95,41), \
+    V(39,A8,01,71), V(08,0C,B3,DE), V(D8,B4,E4,9C), V(64,56,C1,90), \
+    V(7B,CB,84,61), V(D5,32,B6,70), V(48,6C,5C,74), V(D0,B8,57,42)
+
+#define V(a,b,c,d) 0x##a##b##c##d
+static const uint32 RT0[256] = { RT };
+#undef V
+
+#define V(a,b,c,d) 0x##d##a##b##c
+static const uint32 RT1[256] = { RT };
+#undef V
+
+#define V(a,b,c,d) 0x##c##d##a##b
+static const uint32 RT2[256] = { RT };
+#undef V
+
+#define V(a,b,c,d) 0x##b##c##d##a
+static const uint32 RT3[256] = { RT };
+#undef V
+
+#undef RT
+
+/* round constants */
+
+static const uint32 RCON[10] =
+{
+    0x01000000, 0x02000000, 0x04000000, 0x08000000,
+    0x10000000, 0x20000000, 0x40000000, 0x80000000,
+    0x1B000000, 0x36000000
+};
+
+int do_init = 0;
+
+void aes_gen_tables( void )
+{
+}
+
+#endif
+
+/* platform-independant 32-bit integer manipulation macros */
+
+#define GET_UINT32_aes(n,b,i)                       \
+{                                               \
+    (n) = ( (uint32) (b)[(i)    ] << 24 )       \
+        | ( (uint32) (b)[(i) + 1] << 16 )       \
+        | ( (uint32) (b)[(i) + 2] <<  8 )       \
+        | ( (uint32) (b)[(i) + 3]       );      \
+}
+
+#define PUT_UINT32_aes(n,b,i)                       \
+{                                               \
+    (b)[(i)    ] = (uint8) ( (n) >> 24 );       \
+    (b)[(i) + 1] = (uint8) ( (n) >> 16 );       \
+    (b)[(i) + 2] = (uint8) ( (n) >>  8 );       \
+    (b)[(i) + 3] = (uint8) ( (n)       );       \
+}
+
+/* decryption key schedule tables */
+
+int KT_init = 1;
+
+uint32 KT0[256];
+uint32 KT1[256];
+uint32 KT2[256];
+uint32 KT3[256];
+
+/* AES key scheduling routine */
+int aes_set_key( aes_context *ctx, uint8 *key, int nbits )
+{
+    int i;
+    uint32 *RK, *SK;
+
+    if( do_init )
+    {
+        aes_gen_tables();
+
+        do_init = 0;
+    }
+
+    switch( nbits )
+    {
+        case 128: ctx->nr = 10; break;
+        case 192: ctx->nr = 12; break;
+        case 256: ctx->nr = 14; break;
+        default : return( 1 );
+    }
+
+    RK = ctx->erk;
+
+    for( i = 0; i < (nbits >> 5); i++ )
+    {
+        GET_UINT32_aes( RK[i], key, i * 4 );
+    }
+
+    /* setup encryption round keys */
+
+    switch( nbits )
+    {
+    case 128:
+
+        for( i = 0; i < 10; i++, RK += 4 )
+        {
+            RK[4]  = RK[0] ^ RCON[i] ^
+                        ( FSb[ (uint8) ( RK[3] >> 16 ) ] << 24 ) ^
+                        ( FSb[ (uint8) ( RK[3] >>  8 ) ] << 16 ) ^
+                        ( FSb[ (uint8) ( RK[3]       ) ] <<  8 ) ^
+                        ( FSb[ (uint8) ( RK[3] >> 24 ) ]       );
+
+            RK[5]  = RK[1] ^ RK[4];
+            RK[6]  = RK[2] ^ RK[5];
+            RK[7]  = RK[3] ^ RK[6];
+        }
+        break;
+
+    case 192:
+
+        for( i = 0; i < 8; i++, RK += 6 )
+        {
+            RK[6]  = RK[0] ^ RCON[i] ^
+                        ( FSb[ (uint8) ( RK[5] >> 16 ) ] << 24 ) ^
+                        ( FSb[ (uint8) ( RK[5] >>  8 ) ] << 16 ) ^
+                        ( FSb[ (uint8) ( RK[5]       ) ] <<  8 ) ^
+                        ( FSb[ (uint8) ( RK[5] >> 24 ) ]       );
+
+            RK[7]  = RK[1] ^ RK[6];
+            RK[8]  = RK[2] ^ RK[7];
+            RK[9]  = RK[3] ^ RK[8];
+            RK[10] = RK[4] ^ RK[9];
+            RK[11] = RK[5] ^ RK[10];
+        }
+        break;
+
+    case 256:
+
+        for( i = 0; i < 7; i++, RK += 8 )
+        {
+            RK[8]  = RK[0] ^ RCON[i] ^
+                        ( FSb[ (uint8) ( RK[7] >> 16 ) ] << 24 ) ^
+                        ( FSb[ (uint8) ( RK[7] >>  8 ) ] << 16 ) ^
+                        ( FSb[ (uint8) ( RK[7]       ) ] <<  8 ) ^
+                        ( FSb[ (uint8) ( RK[7] >> 24 ) ]       );
+
+            RK[9]  = RK[1] ^ RK[8];
+            RK[10] = RK[2] ^ RK[9];
+            RK[11] = RK[3] ^ RK[10];
+
+            RK[12] = RK[4] ^
+                        ( FSb[ (uint8) ( RK[11] >> 24 ) ] << 24 ) ^
+                        ( FSb[ (uint8) ( RK[11] >> 16 ) ] << 16 ) ^
+                        ( FSb[ (uint8) ( RK[11] >>  8 ) ] <<  8 ) ^
+                        ( FSb[ (uint8) ( RK[11]       ) ]       );
+
+            RK[13] = RK[5] ^ RK[12];
+            RK[14] = RK[6] ^ RK[13];
+            RK[15] = RK[7] ^ RK[14];
+        }
+        break;
+    }
+
+    /* setup decryption round keys */
+
+    if( KT_init )
+    {
+        for( i = 0; i < 256; i++ )
+        {
+            KT0[i] = RT0[ FSb[i] ];
+            KT1[i] = RT1[ FSb[i] ];
+            KT2[i] = RT2[ FSb[i] ];
+            KT3[i] = RT3[ FSb[i] ];
+        }
+
+        KT_init = 0;
+    }
+
+    SK = ctx->drk;
+
+    *SK++ = *RK++;
+    *SK++ = *RK++;
+    *SK++ = *RK++;
+    *SK++ = *RK++;
+
+    for( i = 1; i < ctx->nr; i++ )
+    {
+        RK -= 8;
+
+        *SK++ = KT0[ (uint8) ( *RK >> 24 ) ] ^
+                KT1[ (uint8) ( *RK >> 16 ) ] ^
+                KT2[ (uint8) ( *RK >>  8 ) ] ^
+                KT3[ (uint8) ( *RK       ) ]; RK++;
+
+        *SK++ = KT0[ (uint8) ( *RK >> 24 ) ] ^
+                KT1[ (uint8) ( *RK >> 16 ) ] ^
+                KT2[ (uint8) ( *RK >>  8 ) ] ^
+                KT3[ (uint8) ( *RK       ) ]; RK++;
+
+        *SK++ = KT0[ (uint8) ( *RK >> 24 ) ] ^
+                KT1[ (uint8) ( *RK >> 16 ) ] ^
+                KT2[ (uint8) ( *RK >>  8 ) ] ^
+                KT3[ (uint8) ( *RK       ) ]; RK++;
+
+        *SK++ = KT0[ (uint8) ( *RK >> 24 ) ] ^
+                KT1[ (uint8) ( *RK >> 16 ) ] ^
+                KT2[ (uint8) ( *RK >>  8 ) ] ^
+                KT3[ (uint8) ( *RK       ) ]; RK++;
+    }
+
+    RK -= 8;
+
+    *SK++ = *RK++;
+    *SK++ = *RK++;
+    *SK++ = *RK++;
+    *SK++ = *RK++;
+
+    return( 0 );
+}
diff --git a/board/aspeed/ast2300/ast2300.c b/board/aspeed/ast2300/ast2300.c
new file mode 100644
index 0000000..b317786
--- /dev/null
+++ b/board/aspeed/ast2300/ast2300.c
@@ -0,0 +1,171 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <pci.h>
+
+int board_init (void)
+{
+    DECLARE_GLOBAL_DATA_PTR;
+    unsigned char data;
+    unsigned long reg;
+
+    /* AHB Controller */
+    *((volatile ulong*) 0x1E600000)  = 0xAEED1A03;	/* unlock AHB controller */ 
+    *((volatile ulong*) 0x1E60008C) |= 0x01;		/* map DRAM to 0x00000000 */
+#ifdef CONFIG_PCI
+    *((volatile ulong*) 0x1E60008C) |= 0x30;		/* map PCI */
+#endif
+
+    /* Flash Controller */
+#ifdef	CONFIG_FLASH_AST2300
+    *((volatile ulong*) 0x1e620000) |= 0x800f0000;	/* enable Flash Write */     
+#else
+    *((volatile ulong*) 0x16000000) |= 0x00001c00;	/* enable Flash Write */ 
+#endif    
+
+    /* SCU */
+    *((volatile ulong*) 0x1e6e2000) = 0x1688A8A8;	/* unlock SCU */
+    reg = *((volatile ulong*) 0x1e6e2008);		
+    reg &= 0x1c0fffff;                                  
+    reg |= 0x61800000;						/* PCLK  = HPLL/8 */				
+#ifdef CONFIG_AST1070	
+	reg |= 0x300000;					/* LHCLK = HPLL/8 */
+	reg |= 0x80000;					/* LPC Host Clock */
+#endif	
+    *((volatile ulong*) 0x1e6e2008) = reg;     
+    reg = *((volatile ulong*) 0x1e6e200c);		/* enable 2D Clk */
+    *((volatile ulong*) 0x1e6e200c) &= 0xFFFFFFFD;
+/* enable wide screen. If your video driver does not support wide screen, don't
+enable this bit 0x1e6e2040 D[0]*/
+    reg = *((volatile ulong*) 0x1e6e2040);
+    *((volatile ulong*) 0x1e6e2040) |= 0x01;
+#ifdef CONFIG_AST1070                                                                          
+/*set VPPL1 */
+
+    *((volatile ulong*) 0x1e6e201c) = 0x6420;
+
+// set d2-pll & enable d2-pll D[21:20], D[4]
+    reg = *((volatile ulong*) 0x1e6e202c);
+    reg &= 0xffcfffef;
+    reg |= 0x00200010;
+    *((volatile ulong*) 0x1e6e202c) = reg;
+
+// set OSCCLK = VPLL1
+    *((volatile ulong*) 0x1e6e2010) = 0x8;
+
+// enable OSCCLK
+    reg = *((volatile ulong*) 0x1e6e202c);
+    reg &= 0xfffffffd;
+    reg |= 0x00000002;
+    *((volatile ulong*) 0x1e6e202c) = reg;
+
+// enable AST1050's LPC master
+    reg = *((volatile ulong*) 0x1e7890a0);
+    *((volatile ulong*) 0x1e7890a0) |= 0x11;
+#endif
+    /* arch number */
+    gd->bd->bi_arch_number = MACH_TYPE_ASPEED;
+                                                                                                                             
+    /* adress of boot parameters */
+    gd->bd->bi_boot_params = 0x40000100;
+                                                                                                                             
+    return 0;
+}
+
+int dram_init (void)
+{
+    DECLARE_GLOBAL_DATA_PTR;
+                                                                                                                             
+    gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+    gd->bd->bi_dram[0].size  = PHYS_SDRAM_1_SIZE;
+                                                                                                                 
+    return 0;
+}
+
+/*
+SCU7C: Silicon Revision ID Register
+D[31:24]: Chip ID
+0: AST2050/AST2100/AST2150/AST2200/AST3000
+1: AST2300
+
+D[23:16] Silicon revision ID for AST2300 generation and later
+0: A0
+1: A1
+2: A2
+.
+.
+.
+FPGA revision starts from 0x80
+
+
+D[11:8] Bounding option
+
+D[7:0] Silicon revision ID for AST2050/AST2100 generation (for software compatible)
+0: A0
+1: A1
+2: A2
+3: A3
+.
+.
+FPGA revision starts from 0x08, 8~10 means A0, 11+ means A1, AST2300 should be assigned to 3
+*/
+int misc_init_r(void)
+{
+    unsigned int reg1, revision, chip_id;
+
+    /* Show H/W Version */
+    reg1 = (unsigned int) (*((ulong*) 0x1e6e207c));
+    chip_id = (reg1 & 0xff000000) >> 24;
+    revision = (reg1 & 0xff0000) >> 16;
+
+    puts ("H/W:   ");
+    if (chip_id == 1) {
+    	if (revision >= 0x80) {
+    		printf("AST2300 series FPGA Rev. %02x \n", revision);
+    	}
+    	else {
+    		printf("AST2300 series chip Rev. %02x \n", revision);
+    	}
+    }
+    else if (chip_id == 0) {
+	printf("AST2050/AST2150 series chip\n");
+    }
+
+#ifdef CONFIG_AST1070
+	puts ("C/C:   ");
+	revision = (unsigned int) (*((ulong*) 0x60002034));
+	printf("AST1070 ID [%08x] \n", revision);
+#endif
+
+#ifdef	CONFIG_PCI	
+    pci_init ();
+#endif
+
+    if (getenv ("verify") == NULL) {
+	setenv ("verify", "n");
+    }
+    if (getenv ("eeprom") == NULL) {
+	setenv ("eeprom", "y");
+    }
+}
+
+#ifdef	CONFIG_PCI
+static struct pci_controller hose;
+
+extern void aspeed_init_pci (struct pci_controller *hose);
+
+void pci_init_board(void)
+{
+    aspeed_init_pci(&hose);
+}
+#endif
diff --git a/board/aspeed/ast2300/config.mk b/board/aspeed/ast2300/config.mk
new file mode 100755
index 0000000..24ca09b
--- /dev/null
+++ b/board/aspeed/ast2300/config.mk
@@ -0,0 +1,18 @@
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+# ROM version
+#TEXT_BASE = 0xBFC00000
+
+# RAM version
+TEXT_BASE = 0x40500000
+#TEXT_BASE = 0x00000000
+#TEXT_BASE = 0x00400000
diff --git a/board/aspeed/ast2300/crc32.c b/board/aspeed/ast2300/crc32.c
new file mode 100755
index 0000000..cc8d2ac
--- /dev/null
+++ b/board/aspeed/ast2300/crc32.c
@@ -0,0 +1,127 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <common.h>
+#include <asm/processor.h>
+#include <asm/byteorder.h>
+#include <environment.h>
+
+#ifdef CONFIG_2SPIFLASH
+
+extern flash_info_t flash_info[CFG_MAX_FLASH_BANKS];
+
+/* ========================================================================
+ * Table of CRC-32's of all single-byte values (made by make_aspeed_crc_table)
+ */
+unsigned long aspeed_crc_table[256] = {
+  0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
+  0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
+  0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
+  0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
+  0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
+  0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
+  0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
+  0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
+  0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
+  0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
+  0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
+  0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
+  0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
+  0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
+  0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
+  0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
+  0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
+  0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
+  0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
+  0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
+  0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
+  0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
+  0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
+  0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
+  0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
+  0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
+  0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
+  0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
+  0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
+  0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
+  0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
+  0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
+  0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
+  0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
+  0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
+  0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
+  0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
+  0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
+  0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
+  0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
+  0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
+  0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
+  0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
+  0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
+  0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
+  0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
+  0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
+  0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
+  0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
+  0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
+  0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
+  0x2d02ef8dL
+};
+
+/* ========================================================================= */
+#define ASPEED_DO1(buf)  crc = aspeed_crc_table[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);
+#define ASPEED_DO2(buf)  ASPEED_DO1(buf); ASPEED_DO1(buf);
+#define ASPEED_DO4(buf)  ASPEED_DO2(buf); ASPEED_DO2(buf);
+#define ASPEED_DO8(buf)  ASPEED_DO4(buf); ASPEED_DO4(buf);
+
+/* ========================================================================= */
+unsigned long spi2_crc32(crc, buf, len)
+    unsigned long crc;
+    unsigned char *buf;
+    unsigned long len;
+{
+
+    size_t len1, len2;
+    char *s;
+
+    len1 = len2 = 0;
+    if ( (ulong)(buf) <= (flash_info[0].start[0] + flash_info[0].size) )
+        len1 = (flash_info[0].start[0] + flash_info[0].size) - (ulong)(buf);
+    
+    len1 = (len < len1) ? len:len1;
+    len2 = (len < len1) ? 0: (len - len1);
+
+    crc = crc ^ 0xffffffffL;
+    while (len1 >= 8)
+    {
+      ASPEED_DO8(buf);
+      len1 -= 8;
+    }
+    if (len1) do {
+      ASPEED_DO1(buf);
+    } while (--len1);
+    
+    //s = (char *) flash_info[1].start[0];
+    s= (char *) flash_make_addr (&flash_info[1], 0, 0);
+    while (len2 >= 8)
+    {
+      ASPEED_DO8(s);
+      len2 -= 8;
+    }
+    if (len2) do {
+      ASPEED_DO1(s);
+    } while (--len2);   
+
+    return crc ^ 0xffffffffL;
+    
+}
+
+#endif /* CONFIG_2SPIFLASH */
+
diff --git a/board/aspeed/ast2300/crt.c b/board/aspeed/ast2300/crt.c
new file mode 100755
index 0000000..b67f669
--- /dev/null
+++ b/board/aspeed/ast2300/crt.c
@@ -0,0 +1,322 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <common.h>
+#include <command.h>
+
+#include "type.h"
+#include "vesa.h"
+#include "vdef.h"
+#include "vfun.h"
+#include "vreg.h"
+#include "crt.h"
+
+ULONG AST3000DCLKTableV [] = {
+    0x00046515,     /* 00: VCLK25_175 */  
+    0x00047255,     /* 01: VCLK28_322 */
+    0x0004682a,     /* 02: VCLK31_5         */
+    0x0004672a,     /* 03: VCLK36          */
+    0x00046c50,     /* 04: VCLK40           */
+    0x00046842,     /* 05: VCLK49_5         */
+    0x00006c32,     /* 06: VCLK50           */
+    0x00006a2f,     /* 07: VCLK56_25        */
+    0x00006c41,     /* 08: VCLK65  */
+    0x00006832,     /* 09: VCLK75         */
+    0x0000672e,     /* 0A: VCLK78_75        */
+    0x0000683f,     /* 0B: VCLK94_5         */
+    0x00004824,     /* 0C: VCLK108          */
+	0x00004723,		/* 0D: VCLK119			*/
+    0x0000482d,     /* 0E: VCLK135          */
+	0x00004B37,		/* 0F: VCLK146_25		*/
+    0x0000472e,     /* 10: VCLK157_5        */
+    0x00004836,     /* 11: VCLK162          */
+
+};
+
+BOOL CheckDAC(int nCRTIndex)
+{
+	BYTE	btValue;	
+	BOOL	bValue;
+
+	BYTE btDeviceSelect;
+
+	switch (nCRTIndex)
+	{
+	case CRT_1:
+		btDeviceSelect = DEVICE_ADDRESS_CH7301_CRT1;
+		break;
+	case CRT_2:
+		btDeviceSelect = DEVICE_ADDRESS_CH7301_CRT2;
+		break;
+	default:
+		printf("CRTIndex is not 1 or 2");
+		return FALSE;
+		break;
+	}
+
+	//Enable all DAC's and set register 21h[0] = '0'
+	//DVIP and DVIL disable for DAC
+	SetI2CRegClient(0, DEVICE_SELECT_CH7301, btDeviceSelect, CH7301_PM_REG, 0x00);
+
+	btValue = GetI2CRegClient(0, DEVICE_SELECT_CH7301, btDeviceSelect, CH7301_DC_REG);
+	btValue = btValue & 0xFE;
+	SetI2CRegClient(0, DEVICE_SELECT_CH7301, btDeviceSelect, CH7301_DC_REG, btValue);
+
+	//Set SENSE bit to 1
+	btValue = GetI2CRegClient(0, DEVICE_SELECT_CH7301, btDeviceSelect, CH7301_CD_REG);
+	btValue = btValue | 0x01;
+	SetI2CRegClient(0, DEVICE_SELECT_CH7301, btDeviceSelect, CH7301_CD_REG, btValue);
+
+	//Reset SENSE bit to 0
+	btValue = GetI2CRegClient(0, DEVICE_SELECT_CH7301, btDeviceSelect, CH7301_CD_REG);
+	btValue = btValue & 0xFE;
+	SetI2CRegClient(0, DEVICE_SELECT_CH7301, btDeviceSelect, CH7301_CD_REG, btValue);
+
+	bValue = (GetI2CRegClient(0, DEVICE_SELECT_CH7301, btDeviceSelect, CH7301_CD_REG) & CD_DACT) ? TRUE : FALSE;
+
+	return bValue;
+}
+
+VOID  SetCH7301C(ULONG	MMIOBase,
+				 int	nCRTIndex,
+                 int	inFreqRange,
+				 int	inOperating)
+{
+	BYTE btDeviceSelect;
+	BYTE btValue;
+
+//#ifdef EVB_CLIENT
+	//output RGB doesn't need to set CH7301
+	//if (1 == inOperating)
+	//	return;
+//#endif
+
+	switch (nCRTIndex)
+	{
+	case CRT_1:
+		btDeviceSelect = 0xEA;
+
+		break;
+	case CRT_2:
+		btDeviceSelect = 0xEC;
+
+		break;
+	default:
+		printf("CRTIndex is not 1 or 2");
+		return;
+		break;
+	}
+
+	if (inFreqRange <= VCLK65)
+	{
+	  printf("ch7301: low f \n");
+		SetI2CRegClient(MMIOBase, 0x3, btDeviceSelect, 0x33, 0x08);
+		SetI2CRegClient(MMIOBase, 0x3, btDeviceSelect, 0x34, 0x16);
+		SetI2CRegClient(MMIOBase, 0x3, btDeviceSelect, 0x36, 0x60);
+	}
+	else
+	{
+		SetI2CRegClient(MMIOBase, 0x3, btDeviceSelect, 0x33, 0x06);
+		SetI2CRegClient(MMIOBase, 0x3, btDeviceSelect, 0x34, 0x26);
+		SetI2CRegClient(MMIOBase, 0x3, btDeviceSelect, 0x36, 0xA0);
+	}
+
+	switch (inOperating)
+	{
+	case 0:
+		//DVI is normal function
+		 SetI2CRegClient(MMIOBase, 0x3, btDeviceSelect, 0x49, 0xC0);
+		 SetI2CRegClient(MMIOBase, 0x3, btDeviceSelect, 0x1D, 0x47);
+		break;
+	case 1:
+		//RGB
+		SetI2CRegClient(MMIOBase, 0x3, btDeviceSelect, 0x48, 0x18);
+		SetI2CRegClient(MMIOBase, 0x3, btDeviceSelect, 0x49, 0x0);
+		SetI2CRegClient(MMIOBase, 0x3, btDeviceSelect, 0x56, 0x0);
+		SetI2CRegClient(MMIOBase, 0x3, btDeviceSelect, 0x21, 0x9);
+		SetI2CRegClient(MMIOBase, 0x3, btDeviceSelect, 0x1D, 0x48);
+		SetI2CRegClient(MMIOBase, 0x3, btDeviceSelect, 0x1C, 0x00);
+		break;
+	default:
+		break;
+	};
+}
+
+void SetASTModeTiming (ULONG MMIOBase, int nCRTIndex, BYTE ModeIndex, BYTE ColorDepth)
+{
+    ULONG    temp, RetraceStart, RetraceEnd, DisplayOffset, TerminalCount, bpp;
+
+//  Access CRT Engine
+	//  SetPolarity
+    WriteMemoryLongWithMASKClient(SCU_BASE, CRT1_CONTROL_REG + nCRTIndex*0x60, ((vModeTable[ModeIndex].HorPolarity << HOR_SYNC_SELECT_BIT) | (vModeTable[ModeIndex].VerPolarity << VER_SYNC_SELECT_BIT)), (HOR_SYNC_SELECT_MASK|VER_SYNC_SELECT_MASK));
+
+#if CONFIG_AST3000
+	WriteMemoryLongClient(SCU_BASE, CRT1_CONTROL2_REG + nCRTIndex*0x60, 0xc0);
+#else
+    //2100 is single edge
+	WriteMemoryLongClient(SCU_BASE, CRT1_CONTROL2_REG + nCRTIndex*0x60, 0x80);
+#endif    
+	//  Horizontal Timing
+	temp = 0;
+    temp = ((vModeTable[ModeIndex].HorizontalActive - 1) << HOR_ENABLE_END_BIT) | ((vModeTable[ModeIndex].HorizontalTotal - 1) << HOR_TOTAL_BIT);
+    WriteMemoryLongClient(SCU_BASE, CRT1_HOR_TOTAL_END_REG  + nCRTIndex*0x60, temp);
+
+    RetraceStart = vModeTable[ModeIndex].HorizontalTotal - vModeTable[ModeIndex].HBackPorch - vModeTable[ModeIndex].HSyncTime - vModeTable[ModeIndex].HLeftBorder - 1;
+    RetraceEnd = (RetraceStart + vModeTable[ModeIndex].HSyncTime);
+	temp = 0;
+    temp = (RetraceEnd << HOR_RETRACE_END_BIT) | (RetraceStart << HOR_RETRACE_START_BIT);
+    WriteMemoryLongClient(SCU_BASE, CRT1_HOR_RETRACE_REG  + nCRTIndex*0x60, temp);
+
+	//  Vertical Timing
+	temp = 0;
+    temp = ((vModeTable[ModeIndex].VerticalActive - 1) << VER_ENABLE_END_BIT) | ((vModeTable[ModeIndex].VerticalTotal - 1) << VER_TOTAL_BIT);
+    WriteMemoryLongClient(SCU_BASE, CRT1_VER_TOTAL_END_REG  + nCRTIndex*0x60, temp);
+
+	temp = 0;
+    RetraceStart = vModeTable[ModeIndex].VerticalTotal - vModeTable[ModeIndex].VBackPorch - vModeTable[ModeIndex].VSyncTime - vModeTable[ModeIndex].VTopBorder - 1;
+    RetraceEnd = (RetraceStart + vModeTable[ModeIndex].VSyncTime);
+    temp = (RetraceEnd << VER_RETRACE_END_BIT) | (RetraceStart << VER_RETRACE_START_BIT);
+    WriteMemoryLongClient(SCU_BASE, CRT1_VER_RETRACE_REG  + nCRTIndex*0x60, temp);
+
+	//  Set CRT Display Offset and Terminal Count
+    if (ColorDepth == RGB_565) {
+        bpp = 16;
+    }
+    else {
+        bpp = 32;
+    }
+
+    DisplayOffset = vModeTable[ModeIndex].HorizontalActive * bpp / 8;
+    TerminalCount = vModeTable[ModeIndex].HorizontalActive * bpp / 64;
+    if (ColorDepth == YUV_444) {
+        TerminalCount = TerminalCount * 3 / 4;
+    }
+    if (((vModeTable[ModeIndex].HorizontalActive * bpp) % 64) != 0) {
+        TerminalCount++;
+    }
+
+    WriteMemoryLongClient(SCU_BASE, CRT1_DISPLAY_OFFSET + nCRTIndex*0x60, ((TerminalCount << TERMINAL_COUNT_BIT) | DisplayOffset));
+
+	//  Set Color Format
+    WriteMemoryLongWithMASKClient(SCU_BASE, CRT1_CONTROL_REG + nCRTIndex*0x60, (ColorDepth << FORMAT_SELECT_BIT), FORMAT_SELECT_MASK);
+
+	//  Set Threshold
+	temp = 0;
+    temp = (CRT_HIGH_THRESHOLD_VALUE << THRES_HIGHT_BIT) | (CRT_LOW_THRESHOLD_VALUE << THRES_LOW_BIT);
+    WriteMemoryLongClient(SCU_BASE, CRT1_THRESHOLD_REG + nCRTIndex*0x60, temp);
+
+	WriteMemoryLongClient(SCU_BASE, CRT1_VIDEO_PLL_REG + nCRTIndex*0x60, AST3000DCLKTableV[vModeTable[ModeIndex].PixelClock]);
+}
+
+void SetASTCenter1024ModeTiming (ULONG MMIOBase, int nCRTIndex, BYTE ModeIndex, BYTE ColorDepth)
+{
+    ULONG    temp, RetraceStart, RetraceEnd, DisplayOffset, TerminalCount, bpp;
+
+	//  Access CRT Engine
+	//  SetPolarity
+    WriteMemoryLongWithMASKClient(SCU_BASE, CRT1_CONTROL_REG + nCRTIndex*0x60, (HOR_NEGATIVE << HOR_SYNC_SELECT_BIT) | (VER_NEGATIVE << VER_SYNC_SELECT_BIT), HOR_SYNC_SELECT_MASK|VER_SYNC_SELECT_MASK);
+
+	WriteMemoryLongClient(SCU_BASE, CRT1_CONTROL2_REG + nCRTIndex*0x60, 0xC0);
+
+	//  Horizontal Timing
+	temp = 0;
+    temp = ((vModeTable[ModeIndex].HorizontalActive - 1) << HOR_ENABLE_END_BIT) | ((vModeTable[10].HorizontalTotal - 1) << HOR_TOTAL_BIT);
+    WriteMemoryLongClient(SCU_BASE, CRT1_HOR_TOTAL_END_REG + nCRTIndex*0x60, temp);
+
+    RetraceStart = vModeTable[10].HorizontalTotal - vModeTable[10].HBackPorch - vModeTable[10].HSyncTime - vModeTable[10].HLeftBorder - 1;
+    RetraceStart = RetraceStart - (vModeTable[10].HorizontalActive - vModeTable[ModeIndex].HorizontalActive) / 2 - 1;
+    RetraceEnd = (RetraceStart + vModeTable[10].HSyncTime);
+	temp = 0;
+    temp = (RetraceEnd << HOR_RETRACE_END_BIT) | (RetraceStart << HOR_RETRACE_START_BIT);
+    WriteMemoryLongClient(SCU_BASE, CRT1_HOR_RETRACE_REG + nCRTIndex*0x60, temp);
+
+	//  Vertical Timing
+	temp = 0;
+    temp = ((vModeTable[ModeIndex].VerticalActive - 1) << VER_ENABLE_END_BIT) | ((vModeTable[10].VerticalTotal - 1) << VER_TOTAL_BIT);
+    WriteMemoryLongClient(SCU_BASE, CRT1_VER_TOTAL_END_REG + nCRTIndex*0x60, temp);
+
+    RetraceStart = vModeTable[10].VerticalTotal - vModeTable[10].VBackPorch - vModeTable[10].VSyncTime - vModeTable[10].VTopBorder - 1;
+    RetraceStart = RetraceStart - (vModeTable[10].VerticalActive - vModeTable[ModeIndex].VerticalActive) / 2 - 1;
+    RetraceEnd = (RetraceStart + vModeTable[10].VSyncTime);
+    temp = (RetraceEnd << VER_RETRACE_END_BIT) | (RetraceStart << VER_RETRACE_START_BIT);
+    WriteMemoryLongClient(SCU_BASE, CRT1_VER_RETRACE_REG + nCRTIndex*0x60, temp);
+
+	//  Set CRT Display Offset and Terminal Count
+    if (ColorDepth == RGB_565) {
+        bpp = 16;
+    }
+    else {
+        bpp = 32;
+    }
+    DisplayOffset = vModeTable[ModeIndex].HorizontalActive * bpp / 8;
+    TerminalCount = vModeTable[ModeIndex].HorizontalActive * bpp / 64;
+    if (ColorDepth == YUV_444) {
+        TerminalCount = TerminalCount * 3 / 4;
+    }
+    if (((vModeTable[ModeIndex].HorizontalActive * bpp) % 64) != 0) {
+        TerminalCount++;
+    }
+
+    WriteMemoryLongClient(SCU_BASE, CRT1_DISPLAY_OFFSET + nCRTIndex*0x60, (TerminalCount << TERMINAL_COUNT_BIT) | DisplayOffset);
+
+	//  Set Color Format
+    WriteMemoryLongWithMASKClient(SCU_BASE, CRT1_CONTROL_REG + nCRTIndex*0x60, (ColorDepth << FORMAT_SELECT_BIT), FORMAT_SELECT_MASK);
+
+	//  Set Threshold
+	temp = 0;
+    temp = (CRT_HIGH_THRESHOLD_VALUE << THRES_HIGHT_BIT) | (CRT_LOW_THRESHOLD_VALUE << THRES_LOW_BIT);
+    WriteMemoryLongClient(SCU_BASE, CRT1_THRESHOLD_REG + nCRTIndex*0x60, temp);
+    
+	// Set DCLK
+	WriteMemoryLongClient(SCU_BASE, CRT1_VIDEO_PLL_REG + nCRTIndex*0x60, AST3000DCLKTableV[vModeTable[ModeIndex].PixelClock]);
+
+}
+
+BOOL  ASTSetModeV (ULONG MMIOBase, int nCRTIndex, ULONG VGABaseAddr, USHORT Horizontal, USHORT Vertical, BYTE ColorFormat, BYTE CenterMode)
+{
+    BYTE    i, ModeIndex;
+    BOOL	bDAC;	
+    ULONG   ulTemp;
+
+    //  Access CRT Engine
+    //Enable CRT1 graph
+    WriteMemoryLongWithMASKClient(SCU_BASE, CRT1_CONTROL_REG + 0x60*nCRTIndex, GRAPH_DISPLAY_ON, GRAPH_DISPLAY_MASK);
+    
+    //  Set CRT Display Start Address
+    WriteMemoryLongWithMASKClient(SCU_BASE, CRT1_DISPLAY_ADDRESS + 0x60*nCRTIndex, VGABaseAddr, DISPLAY_ADDRESS_MASK);
+
+    for (i = 0; i < Mode60HZCount; i++) {
+        if ((vModeTable[i].HorizontalActive == Horizontal) && (vModeTable[i].VerticalActive == Vertical)) {
+
+	    ModeIndex = i;
+
+            if (CenterMode != 1) {
+                SetASTModeTiming(MMIOBase, nCRTIndex, i, ColorFormat);
+            }
+            else {
+                SetASTCenter1024ModeTiming (MMIOBase, nCRTIndex, i, ColorFormat);
+            }
+
+            //use internal video out sigal and don't need use 7301
+            /*
+			bDAC = CheckDAC(nCRTIndex);
+            
+			SetCH7301C(0,
+				nCRTIndex,
+				vModeTable[ModeIndex].PixelClock,
+				bDAC);		//For RGB
+			*/	
+			return TRUE;
+        }
+    }
+
+    return FALSE;
+}
+
diff --git a/board/aspeed/ast2300/crt.h b/board/aspeed/ast2300/crt.h
new file mode 100755
index 0000000..e7483be
--- /dev/null
+++ b/board/aspeed/ast2300/crt.h
@@ -0,0 +1,121 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef _CRT_H_
+#define _CRT_H_
+
+#ifdef Watcom
+#define		CRT_REMAP_OFFSET	0x10000
+#else
+#define		CRT_REMAP_OFFSET	0x0
+#endif
+
+/********************************************************/
+/*    CRT register                                      */
+/********************************************************/
+#define		CRT_BASE_OFFSET						0x6000+CRT_REMAP_OFFSET
+
+#define		CRT1_CONTROL_REG					0x00 + CRT_BASE_OFFSET
+	#define		GRAPH_DISPLAY_BIT				0
+	#define     GRAPH_DISPLAY_MASK				(1<<0)
+		#define		GRAPH_DISPLAY_ON			1
+		#define		GRAPH_DISPLAY_OFF			0
+    #define     FORMAT_SELECT_BIT               8
+    #define     FORMAT_SELECT_MASK              (3<<8)   
+	#define		HOR_SYNC_SELECT_BIT				16
+    #define		HOR_SYNC_SELECT_MASK			(1<<16)	
+		#define		HOR_NEGATIVE				1
+		#define		HOR_POSITIVE				0
+	#define		VER_SYNC_SELECT_BIT				17
+    #define		VER_SYNC_SELECT_MASK			(1<<17)	
+		#define		VER_NEGATIVE				1
+		#define		VER_POSITIVE				0
+
+#define		CRT1_CONTROL2_REG					0x04 + CRT_BASE_OFFSET
+        
+#define     CRT1_VIDEO_PLL_REG                  0x0C + CRT_BASE_OFFSET
+    #define     POST_DIV_BIT                    18
+    #define     POST_DIV_MASK                   3<<18
+        #define     DIV_1_1                     0
+        //#define     DIV_1_2                     1
+        #define     DIV_1_2                     2
+        #define     DIV_1_4                     3
+        
+#define     CRT1_HOR_TOTAL_END_REG              0x10 + CRT_BASE_OFFSET
+    #define     HOR_TOTAL_BIT                   0
+    #define     HOR_ENABLE_END_BIT              16
+
+#define     CRT1_HOR_RETRACE_REG                0x14 + CRT_BASE_OFFSET
+    #define     HOR_RETRACE_START_BIT           0
+    #define     HOR_RETRACE_END_BIT             16
+
+#define     CRT1_VER_TOTAL_END_REG              0x18 + CRT_BASE_OFFSET
+    #define     VER_TOTAL_BIT                   0
+    #define     VER_ENABLE_END_BIT              16
+
+#define     CRT1_VER_RETRACE_REG                0x1C + CRT_BASE_OFFSET
+    #define     VER_RETRACE_START_BIT           0
+    #define     VER_RETRACE_END_BIT             16
+
+#define     CRT1_DISPLAY_ADDRESS				0x20 + CRT_BASE_OFFSET
+	#define		DISPLAY_ADDRESS_MASK			0x0FFFFFFF
+
+#define     CRT1_DISPLAY_OFFSET                 0x24 + CRT_BASE_OFFSET
+    #define     DISPLAY_OFFSET_ALIGN            7 /* 8 byte alignment*/
+    #define     TERMINAL_COUNT_BIT              16    
+
+#define     CRT1_THRESHOLD_REG                  0x28 + CRT_BASE_OFFSET
+    #define     THRES_LOW_BIT                   0
+    #define     THRES_HIGHT_BIT                 8
+
+#define    CURSOR_POSITION                  0x30 + OFFSET
+#define    CURSOR_OFFSET                    0x34 + OFFSET
+#define    CURSOR_PATTERN                   0x38 + OFFSET
+#define    OSD_HORIZONTAL                   0x40 + OFFSET
+#define    OSD_VERTICAL                     0x44 + OFFSET
+#define    OSD_PATTERN                      0x48 + OFFSET
+#define    OSD_OFFSET                       0x4C + OFFSET
+#define    OSD_THRESHOLD                    0x50 + OFFSET
+
+//Ch7301c
+#define		DEVICE_ADDRESS_CH7301_CRT1	0xEA
+#define		DEVICE_ADDRESS_CH7301_CRT2	0xEC
+
+
+#define		DEVICE_SELECT_CH7301		0x3
+
+/* CH7301 Register Definition */
+#define     CH7301_CD_REG				0x20
+	#define     CD_DACT					0x0E
+	#define		CD_DVIT					1 << 5
+#define     CH7301_DC_REG				0x21
+#define     CH7301_PM_REG				0x49
+
+BOOL CheckHotPlug(int nCRTIndex);
+BOOL CheckDAC(int nCRTIndex);
+
+BOOL  ASTSetModeV (ULONG MMIOBase, 
+                int nCRTIndex, 
+                ULONG VGABaseAddr, 
+                USHORT Horizontal, 
+                USHORT Vertical, 
+                BYTE ColorFormat, 
+                BYTE CenterMode);
+                
+BOOL  SelCRTClock(ULONG MMIOBase,
+				  int	nCRTIndex,
+				  USHORT Horizontal, 
+				  USHORT Vertical);
+
+void DisableCRT(ULONG MMIOBase, int nCRTIndex);
+void ClearCRTWithBlack(ULONG ulCRTAddr, int iWidth, int iHeight);
+
+#endif /* _CRT_H_ */
+
diff --git a/board/aspeed/ast2300/flash.c b/board/aspeed/ast2300/flash.c
new file mode 100755
index 0000000..d611d0d
--- /dev/null
+++ b/board/aspeed/ast2300/flash.c
@@ -0,0 +1,1651 @@
+/*
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * History
+ * 01/20/2004 - combined variants of original driver.
+ * 01/22/2004 - Write performance enhancements for parallel chips (Tolunay)
+ * 01/23/2004 - Support for x8/x16 chips (Rune Raknerud)
+ * 01/27/2004 - Little endian support Ed Okerson
+ *
+ * Tested Architectures
+ * Port Width  Chip Width    # of banks	   Flash Chip  Board
+ * 32	       16	     1		   28F128J3    seranoa/eagle
+ * 64	       16	     1		   28F128J3    seranoa/falcon
+ */
+// (Sun) This CFI driver is written for fixed-width flash chips.
+// It was not designed for flexible 8-bit/16-bit chips, which are the norm.
+// When those chips are connected to a bus in 8-bit mode, the address wires
+// right-shifted by 1.
+//FIXME: Fix the driver to auto-detect "16-bit flash wired in 8-bit mode".
+// Left-shift CFI offsets by 1 bit instead of doubling the #define values.
+
+/* The DEBUG define must be before common to enable debugging */
+// (Sun) Changed to DEBUG_FLASH because flash debug()s are too numerous.
+// #define DEBUG
+
+#include <common.h>
+#include <asm/processor.h>
+#include <asm/byteorder.h>
+#include <environment.h>
+#ifdef	CONFIG_SYS_FLASH_CFI
+
+/*
+ * This file implements a Common Flash Interface (CFI) driver for U-Boot.
+ * The width of the port and the width of the chips are determined at initialization.
+ * These widths are used to calculate the address for access CFI data structures.
+ * It has been tested on an Intel Strataflash implementation and AMD 29F016D.
+ *
+ * References
+ * JEDEC Standard JESD68 - Common Flash Interface (CFI)
+ * JEDEC Standard JEP137-A Common Flash Interface (CFI) ID Codes
+ * Intel Application Note 646 Common Flash Interface (CFI) and Command Sets
+ * Intel 290667-008 3 Volt Intel StrataFlash Memory datasheet
+ *
+ * TODO
+ *
+ * Use Primary Extended Query table (PRI) and Alternate Algorithm Query
+ * Table (ALT) to determine if protection is available
+ *
+ * Add support for other command sets Use the PRI and ALT to determine command set
+ * Verify erase and program timeouts.
+ */
+
+#ifndef CONFIG_FLASH_BANKS_LIST
+#define CONFIG_FLASH_BANKS_LIST { CONFIG_SYS_FLASH_BASE }
+#endif
+
+#define FLASH_CMD_CFI			0x98
+#define FLASH_CMD_READ_ID		0x90
+#define FLASH_CMD_RESET			0xff
+#define FLASH_CMD_BLOCK_ERASE		0x20
+#define FLASH_CMD_ERASE_CONFIRM		0xD0
+#define FLASH_CMD_WRITE			0x40
+#define FLASH_CMD_PROTECT		0x60
+#define FLASH_CMD_PROTECT_SET		0x01
+#define FLASH_CMD_PROTECT_CLEAR		0xD0
+#define FLASH_CMD_CLEAR_STATUS		0x50
+#define FLASH_CMD_WRITE_TO_BUFFER	0xE8
+#define FLASH_CMD_WRITE_BUFFER_CONFIRM	0xD0
+
+#define FLASH_STATUS_DONE		0x80
+#define FLASH_STATUS_ESS		0x40
+#define FLASH_STATUS_ECLBS		0x20
+#define FLASH_STATUS_PSLBS		0x10
+#define FLASH_STATUS_VPENS		0x08
+#define FLASH_STATUS_PSS		0x04
+#define FLASH_STATUS_DPS		0x02
+#define FLASH_STATUS_R			0x01
+#define FLASH_STATUS_PROTECT		0x01
+
+#define AMD_CMD_RESET			0xF0
+#define AMD_CMD_WRITE			0xA0
+#define AMD_CMD_ERASE_START		0x80
+#define AMD_CMD_ERASE_SECTOR		0x30
+#define AMD_CMD_UNLOCK_START		0xAA
+#define AMD_CMD_UNLOCK_ACK		0x55
+#define AMD_CMD_WRITE_TO_BUFFER		0x25
+#define AMD_CMD_BUFFER_TO_FLASH		0x29
+
+#define AMD_STATUS_TOGGLE		0x40
+#define AMD_STATUS_ERROR		0x20
+//FIXME: These 3 were also changed for 8-bit/16-bit flash chips.
+#define AMD_ADDR_ERASE_START		(0xAAA/info->portwidth)
+#define AMD_ADDR_START			(0xAAA/info->portwidth)
+#define AMD_ADDR_ACK			(0x555/info->portwidth)
+
+//FIXME: Fix the driver to auto-detect "16-bit flash wired in 8-bit mode".
+// Left-shift CFI offsets by 1 bit instead of doubling the #define values.
+#define FLASH_OFFSET_CFI		(0xAA/info->portwidth)
+#define FLASH_OFFSET_CFI_RESP		(0x20/info->portwidth)
+#define FLASH_OFFSET_CFI_RESP1		(0x22/info->portwidth)
+#define FLASH_OFFSET_CFI_RESP2		(0x24/info->portwidth)
+#define FLASH_OFFSET_PRIMARY_VENDOR	(0x26/info->portwidth)
+#define FLASH_OFFSET_WTOUT		(0x3E/info->portwidth)
+#define FLASH_OFFSET_WBTOUT		(0x40/info->portwidth)
+#define FLASH_OFFSET_ETOUT		(0x42/info->portwidth)
+#define FLASH_OFFSET_CETOUT		(0x44/info->portwidth)
+#define FLASH_OFFSET_WMAX_TOUT		(0x46/info->portwidth)
+#define FLASH_OFFSET_WBMAX_TOUT		(0x48/info->portwidth)
+#define FLASH_OFFSET_EMAX_TOUT		(0x4A/info->portwidth)
+#define FLASH_OFFSET_CEMAX_TOUT		(0x4C/info->portwidth)
+#define FLASH_OFFSET_SIZE		(0x4E/info->portwidth)
+#define FLASH_OFFSET_INTERFACE		(0x50/info->portwidth)
+#define FLASH_OFFSET_BUFFER_SIZE	(0x54/info->portwidth)
+#define FLASH_OFFSET_NUM_ERASE_REGIONS	(0x58/info->portwidth)
+#define FLASH_OFFSET_ERASE_REGIONS	(0x5A/info->portwidth)
+#define FLASH_OFFSET_PROTECT		(0x02/info->portwidth)
+#define FLASH_OFFSET_USER_PROTECTION	(0x85/info->portwidth)
+#define FLASH_OFFSET_INTEL_PROTECTION	(0x81/info->portwidth)
+
+#define MAX_NUM_ERASE_REGIONS		4
+
+#define FLASH_MAN_CFI			0x01000000
+
+#define CFI_CMDSET_NONE		    0
+#define CFI_CMDSET_INTEL_EXTENDED   1
+#define CFI_CMDSET_AMD_STANDARD	    2
+#define CFI_CMDSET_INTEL_STANDARD   3
+#define CFI_CMDSET_AMD_EXTENDED	    4
+#define CFI_CMDSET_MITSU_STANDARD   256
+#define CFI_CMDSET_MITSU_EXTENDED   257
+#define CFI_CMDSET_SST		    258
+
+
+#ifdef CONFIG_SYS_FLASH_CFI_AMD_RESET /* needed for STM_ID_29W320DB on UC100 */
+# undef  FLASH_CMD_RESET
+# define FLASH_CMD_RESET                AMD_CMD_RESET /* use AMD-Reset instead */
+#endif
+
+
+typedef union {
+	unsigned char c;
+	unsigned short w;
+	unsigned long l;
+	unsigned long long ll;
+} cfiword_t;
+
+typedef union {
+	volatile unsigned char *cp;
+	volatile unsigned short *wp;
+	volatile unsigned long *lp;
+	volatile unsigned long long *llp;
+} cfiptr_t;
+
+/* use CFG_MAX_FLASH_BANKS_DETECT if defined */
+#ifdef CONFIG_SYS_MAX_FLASH_BANKS_DETECT
+static ulong bank_base[CONFIG_SYS_MAX_FLASH_BANKS_DETECT] = CONFIG_FLASH_BANKS_LIST;
+flash_info_t flash_info[CFG_MAX_FLASH_BANKS_DETECT];	/* FLASH chips info */
+#else
+static ulong bank_base[CONFIG_SYS_MAX_FLASH_BANKS] = CONFIG_FLASH_BANKS_LIST;
+flash_info_t flash_info[CONFIG_SYS_MAX_FLASH_BANKS];		/* FLASH chips info */
+#endif
+
+
+/*-----------------------------------------------------------------------
+ * Functions
+ */
+static void flash_add_byte (flash_info_t * info, cfiword_t * cword, uchar c);
+static void flash_make_cmd (flash_info_t * info, uchar cmd, void *cmdbuf);
+static void flash_write_cmd (flash_info_t * info, flash_sect_t sect, uint offset, uchar cmd);
+static void flash_write_cmd_nodbg (flash_info_t * info, flash_sect_t sect, uint offset, uchar cmd);
+static void flash_write_cmd_int (flash_info_t * info, flash_sect_t sect, uint offset, uchar cmd, int noDebug);
+static void flash_unlock_seq (flash_info_t * info, flash_sect_t sect);
+static int flash_isequal (flash_info_t * info, flash_sect_t sect, uint offset, uchar cmd);
+static int flash_isset (flash_info_t * info, flash_sect_t sect, uint offset, uchar cmd);
+static int flash_toggle (flash_info_t * info, flash_sect_t sect, uint offset, uchar cmd);
+static int flash_detect_cfi (flash_info_t * info);
+ulong flash_get_size (ulong base, int banknum);
+static int flash_write_cfiword (flash_info_t * info, ulong dest, cfiword_t cword);
+static int flash_full_status_check (flash_info_t * info, flash_sect_t sector,
+				    ulong tout, char *prompt);
+static void write_buffer_abort_reset(flash_info_t * info, flash_sect_t sector);				    
+#if defined(CFG_ENV_IS_IN_FLASH) || defined(CFG_ENV_ADDR_REDUND) || (CFG_MONITOR_BASE >= CFG_FLASH_BASE)
+static flash_info_t *flash_get_info(ulong base);
+#endif
+#ifdef CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+static int flash_write_cfibuffer (flash_info_t * info, ulong dest, uchar * cp, int len);
+static int flash_write_cfibuffer_amd (flash_info_t * info, ulong dest, uchar * cp, int len);
+#endif
+
+/*-----------------------------------------------------------------------
+ * create an address based on the offset and the port width
+ */
+inline uchar *flash_make_addr (flash_info_t * info, flash_sect_t sect, uint offset)
+{
+	return ((uchar *) (info->start[sect] + (offset * info->portwidth)));
+}
+
+/*-----------------------------------------------------------------------
+ * Debug support
+ */
+#ifdef DEBUG_FLASH
+static void print_longlong (char *str, unsigned long long data)
+{
+	int i;
+	char *cp;
+
+	cp = (unsigned char *) &data;
+	for (i = 0; i < 8; i++)
+		sprintf (&str[i * 2], "%2.2x", *cp++);
+}
+#endif
+
+#if defined(DEBUG_FLASH)
+static void flash_printqry (flash_info_t * info, flash_sect_t sect)
+{
+	cfiptr_t cptr;
+	int x, y;
+
+	for (x = 0; x < 0x40; x += 16U / info->portwidth) {
+		cptr.cp =
+			flash_make_addr (info, sect,
+					 x + FLASH_OFFSET_CFI_RESP);
+		debug ("%p : ", cptr.cp);
+		for (y = 0; y < 16; y++) {
+			debug ("%2.2x ", cptr.cp[y]);
+		}
+		debug (" ");
+		for (y = 0; y < 16; y++) {
+			if (cptr.cp[y] >= 0x20 && cptr.cp[y] <= 0x7e) {
+				debug ("%c", cptr.cp[y]);
+			} else {
+				debug (".");
+			}
+		}
+		debug ("\n");
+	}
+}
+#endif
+
+/*-----------------------------------------------------------------------
+ * read a character at a port width address
+ */
+inline uchar flash_read_uchar (flash_info_t * info, uint offset)
+{
+	uchar *cp;
+
+	cp = flash_make_addr (info, 0, offset);
+#if defined(__LITTLE_ENDIAN)
+	return (cp[0]);
+#else
+	return (cp[info->portwidth - 1]);
+#endif
+}
+
+/*-----------------------------------------------------------------------
+ * read a short word by swapping for ppc format.
+ */
+#if 0
+static ushort flash_read_ushort (flash_info_t * info, flash_sect_t sect, uint offset)
+{
+	uchar *addr;
+	ushort retval;
+
+#ifdef DEBUG_FLASH
+	int x;
+#endif
+	addr = flash_make_addr (info, sect, offset);
+
+#ifdef DEBUG_FLASH
+	debug ("ushort addr is at %p info->portwidth = %d\n", addr,
+	       info->portwidth);
+	for (x = 0; x < 2 * info->portwidth; x++) {
+		debug ("addr[%x] = 0x%x\n", x, addr[x]);
+	}
+#endif
+#if defined(__LITTLE_ENDIAN)
+	if (info->interface == FLASH_CFI_X8X16) {
+	    retval = (addr[0] | (addr[2] << 8));
+	} else {
+	    retval = (addr[0] | (addr[(info->portwidth)] << 8));
+	}
+#else
+	retval = ((addr[(2 * info->portwidth) - 1] << 8) |
+		  addr[info->portwidth - 1]);
+#endif
+
+	debug ("retval = 0x%x\n", retval);
+	return retval;
+}
+#endif
+
+/*-----------------------------------------------------------------------
+ * read a long word by picking the least significant byte of each maximum
+ * port size word. Swap for ppc format.
+ */
+static ulong flash_read_long (flash_info_t * info, flash_sect_t sect, uint offset)
+{
+	uchar *addr;
+	ulong retval;
+#ifdef DEBUG_FLASH
+	int x;
+#endif
+#if 0
+	switch (info->interface) {
+	case FLASH_CFI_X8:
+	case FLASH_CFI_X16:
+	    break;
+	case FLASH_CFI_X8X16:
+	    offset <<= 1;
+	}
+#endif	
+	// flash_make_addr() multiplies offset by info->portwidth.
+	addr = flash_make_addr (info, sect, offset);
+
+#ifdef DEBUG_FLASH
+	debug ("long addr is at %p info->portwidth = %d\n", addr,
+	       info->portwidth);
+	for (x = 0; x < 4 * info->portwidth; x++) {
+		debug ("addr[%x] = 0x%x\n", x, addr[x]);
+	}
+#endif
+#if defined(__LITTLE_ENDIAN)
+	if (info->interface == FLASH_CFI_X8X16) {
+	    retval = (addr[0] | (addr[2] << 8) | (addr[4] << 16) | (addr[6] << 24));
+	} else {
+	    retval = (addr[0] | (addr[(info->portwidth)] << 8) |
+		      (addr[(2 * info->portwidth)] << 16) |
+		      (addr[(3 * info->portwidth)] << 24));
+	}
+#else
+	//FIXME: This undocumented code appears to match broken bus wiring.
+	retval = (addr[(2 * info->portwidth) - 1] << 24) |
+		(addr[(info->portwidth) - 1] << 16) |
+		(addr[(4 * info->portwidth) - 1] << 8) |
+		addr[(3 * info->portwidth) - 1];
+#endif
+	return retval;
+}
+
+/*-----------------------------------------------------------------------
+ */
+unsigned long flash_init (void)
+{
+	unsigned long size = 0;
+	int i;
+
+	/* Init: no FLASHes known */
+	for (i = 0; i < CONFIG_SYS_MAX_FLASH_BANKS; ++i) {
+		flash_info[i].flash_id = FLASH_UNKNOWN;
+		size += flash_info[i].size = flash_get_size (bank_base[i], i);
+		if (flash_info[i].flash_id == FLASH_UNKNOWN) {
+#ifndef CFG_FLASH_QUIET_TEST
+			printf ("## Unknown FLASH on Bank %d - Size = 0x%08lx = %ld MB\n",
+				i, flash_info[i].size, flash_info[i].size << 20);
+#endif /* CFG_FLASH_QUIET_TEST */
+		}
+	}
+
+	/* Monitor protection ON by default */
+#if (CONFIG_MONITOR_BASE >= CONFIG_SYS_FLASH_BASE)
+	flash_protect (FLAG_PROTECT_SET,
+		       CONFIG_MONITOR_BASE,
+		       CONFIG_MONITOR_BASE + monitor_flash_len  - 1,
+		       flash_get_info(CONFIG_MONITOR_BASE));
+#endif
+
+	/* Environment protection ON by default */
+#ifdef CONFIG_ENV_IS_IN_FLASH
+	flash_protect (FLAG_PROTECT_SET,
+		       CONFIG_ENV_ADDR,
+		       CONFIG_ENV_ADDR + CONFIG_ENV_SECT_SIZE - 1,
+		       flash_get_info(CONFIG_ENV_ADDR));
+#endif
+
+	/* Redundant environment protection ON by default */
+#ifdef CONFIG_ENV_ADDR_REDUND
+	flash_protect (FLAG_PROTECT_SET,
+		       CONFIG_ENV_ADDR_REDUND,
+		       CONFIG_ENV_ADDR_REDUND + CONFIG_ENV_SIZE_REDUND - 1,
+		       flash_get_info(CONFIG_ENV_ADDR_REDUND));
+#endif
+	return (size);
+}
+
+/*-----------------------------------------------------------------------
+ */
+#if defined(CONFIG_ENV_IS_IN_FLASH) || defined(CONFIG_ENV_ADDR_REDUND) || (CONFIG_MONITOR_BASE >= CONFIG_SYS_FLASH_BASE)
+static flash_info_t *flash_get_info(ulong base)
+{
+	int i;
+	flash_info_t * info = 0;
+
+	for (i = 0; i < CONFIG_SYS_MAX_FLASH_BANKS; i ++) {
+		info = & flash_info[i];
+		if (info->size && info->start[0] <= base &&
+		    base <= info->start[0] + info->size - 1)
+			break;
+	}
+
+	return i == CONFIG_SYS_MAX_FLASH_BANKS ? 0 : info;
+}
+#endif
+
+/*-----------------------------------------------------------------------
+ */
+int flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+	int rcode = 0;
+	int prot;
+	flash_sect_t sect;
+        uchar ch;
+	uchar *addr;
+  
+	if (info->flash_id != FLASH_MAN_CFI) {
+		puts ("Can't erase unknown flash type - aborted\n");
+		return 1;
+	}
+	if ((s_first < 0) || (s_first > s_last)) {
+		puts ("- no sectors to erase\n");
+		return 1;
+	}
+
+	prot = 0;
+	for (sect = s_first; sect <= s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+	if (prot) {
+		printf ("- Warning: %d protected sectors will not be erased!\n", prot);
+	} else {
+		putc ('\n');
+	}
+
+
+	for (sect = s_first; sect <= s_last; sect++) {
+		if (info->protect[sect] == 0) { /* not protected */
+			switch (info->vendor) {
+			case CFI_CMDSET_INTEL_STANDARD:
+			case CFI_CMDSET_INTEL_EXTENDED:
+				flash_write_cmd (info, sect, 0, FLASH_CMD_CLEAR_STATUS);
+				flash_write_cmd (info, sect, 0, FLASH_CMD_BLOCK_ERASE);
+				flash_write_cmd (info, sect, 0, FLASH_CMD_ERASE_CONFIRM);
+				break;
+			case CFI_CMDSET_AMD_STANDARD:
+			case CFI_CMDSET_AMD_EXTENDED:
+				flash_unlock_seq (info, sect);
+				flash_write_cmd (info, sect, AMD_ADDR_ERASE_START,
+							AMD_CMD_ERASE_START);
+				flash_unlock_seq (info, sect);
+				flash_write_cmd (info, sect, 0, AMD_CMD_ERASE_SECTOR);
+				
+				/* toggle */
+	                        addr = flash_make_addr (info, sect, 0);				
+				do {
+				    ch = *(volatile uchar *)(addr);
+                                } while ( ((ch & 0x80) == 0) || (ch != 0xFF) );
+				break;
+			default:
+				debug ("Unkown flash vendor %d\n",
+				       info->vendor);
+				break;
+			}
+
+			if (flash_full_status_check
+			    (info, sect, info->erase_blk_tout, "erase")) {
+				rcode = 1;
+			} else
+				putc ('.');
+		}
+	}
+	puts (" done\n");
+	return rcode;
+}
+
+/*-----------------------------------------------------------------------
+ */
+void flash_print_info (flash_info_t * info)
+{
+	int i;
+
+	if (info->flash_id != FLASH_MAN_CFI) {
+		puts ("missing or unknown FLASH type\n");
+		return;
+	}
+
+	printf ("CFI conformant FLASH (%d x %d)",
+		(info->portwidth << 3), (info->chipwidth << 3));
+	printf ("  Size: %ld MB in %d Sectors\n",
+		info->size >> 20, info->sector_count);
+	printf (" Erase timeout %ld ms, write timeout %ld ms, buffer write timeout %ld ms, buffer size %d\n",
+		info->erase_blk_tout,
+		info->write_tout,
+		info->buffer_write_tout,
+		info->buffer_size);
+
+	puts ("  Sector Start Addresses:");
+	for (i = 0; i < info->sector_count; ++i) {
+#ifdef CFG_FLASH_EMPTY_INFO
+		int k;
+		int size;
+		int erased;
+		volatile unsigned long *flash;
+
+		/*
+		 * Check if whole sector is erased
+		 */
+		if (i != (info->sector_count - 1))
+			size = info->start[i + 1] - info->start[i];
+		else
+			size = info->start[0] + info->size - info->start[i];
+		erased = 1;
+		flash = (volatile unsigned long *) info->start[i];
+		size = size >> 2;	/* divide by 4 for longword access */
+		for (k = 0; k < size; k++) {
+			if (*flash++ != 0xffffffff) {
+				erased = 0;
+				break;
+			}
+		}
+
+		if ((i % 5) == 0)
+			printf ("\n");
+		/* print empty and read-only info */
+		printf (" %08lX%s%s",
+			info->start[i],
+			erased ? " E" : "  ",
+			info->protect[i] ? "RO " : "   ");
+#else	/* ! CFG_FLASH_EMPTY_INFO */
+		if ((i % 5) == 0)
+			printf ("\n   ");
+		printf (" %08lX%s",
+			info->start[i], info->protect[i] ? " (RO)" : "     ");
+#endif
+	}
+	putc ('\n');
+	return;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash, returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ */
+int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+	ulong wp;
+	ulong cp;
+	int aln;
+	cfiword_t cword;
+	int i, rc;
+
+#ifdef CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+	unsigned char pat[] = {'|', '-', '/', '\\'};
+       	int patcnt = 0;
+	int buffered_size;
+#endif
+	/* get lower aligned address */
+	/* get lower aligned address */
+	wp = (addr & ~(info->portwidth - 1));
+
+	/* handle unaligned start */
+	if ((aln = addr - wp) != 0) {
+		cword.l = 0;
+		cp = wp;
+		for (i = 0; i < aln; ++i, ++cp)
+			flash_add_byte (info, &cword, (*(uchar *) cp));
+
+		for (; (i < info->portwidth) && (cnt > 0); i++) {
+			flash_add_byte (info, &cword, *src++);
+			cnt--;
+			cp++;
+		}
+		for (; (cnt == 0) && (i < info->portwidth); ++i, ++cp)
+			flash_add_byte (info, &cword, (*(uchar *) cp));
+		if ((rc = flash_write_cfiword (info, wp, cword)) != 0)
+			return rc;
+		wp = cp;
+	}
+
+	/* handle the aligned part */
+#ifdef CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+	buffered_size = (info->portwidth / info->chipwidth);
+	buffered_size *= info->buffer_size;
+	while (cnt >= info->portwidth) {
+		/* Show processing */
+		if ((++patcnt % 256) == 0)
+		    printf("%c\b", pat[(patcnt / 256) & 0x03]);
+
+		i = buffered_size > cnt ? cnt : buffered_size;
+		if ((rc = flash_write_cfibuffer (info, wp, src, i)) != ERR_OK)
+			return rc;
+		i -= i & (info->portwidth - 1);
+		wp += i;
+		src += i;
+		cnt -= i;
+	}
+#else
+	while (cnt >= info->portwidth) {
+		cword.l = 0;
+		for (i = 0; i < info->portwidth; i++) {
+			flash_add_byte (info, &cword, *src++);
+		}
+		if ((rc = flash_write_cfiword (info, wp, cword)) != 0)
+			return rc;
+		wp += info->portwidth;
+		cnt -= info->portwidth;
+	}
+#endif /* CONFIG_SYS_FLASH_USE_BUFFER_WRITE */
+	if (cnt == 0) {
+		return (0);
+	}
+
+	/*
+	 * handle unaligned tail bytes
+	 */
+	cword.l = 0;
+	for (i = 0, cp = wp; (i < info->portwidth) && (cnt > 0); ++i, ++cp) {
+		flash_add_byte (info, &cword, *src++);
+		--cnt;
+	}
+	for (; i < info->portwidth; ++i, ++cp) {
+		flash_add_byte (info, &cword, (*(uchar *) cp));
+	}
+
+	return flash_write_cfiword (info, wp, cword);
+}
+
+/*-----------------------------------------------------------------------
+ */
+#ifdef CFG_FLASH_PROTECTION
+
+int flash_real_protect (flash_info_t * info, long sector, int prot)
+{
+	int retcode = 0;
+
+	flash_write_cmd (info, sector, 0, FLASH_CMD_CLEAR_STATUS);
+	flash_write_cmd (info, sector, 0, FLASH_CMD_PROTECT);
+	if (prot)
+		flash_write_cmd (info, sector, 0, FLASH_CMD_PROTECT_SET);
+	else
+		flash_write_cmd (info, sector, 0, FLASH_CMD_PROTECT_CLEAR);
+
+	if ((retcode =
+	     flash_full_status_check (info, sector, info->erase_blk_tout,
+				      prot ? "protect" : "unprotect")) == 0) {
+
+		info->protect[sector] = prot;
+		/* Intel's unprotect unprotects all locking */
+		if (prot == 0) {
+			flash_sect_t i;
+
+			for (i = 0; i < info->sector_count; i++) {
+				if (info->protect[i])
+					flash_real_protect (info, i, 1);
+			}
+		}
+	}
+	return retcode;
+}
+
+/*-----------------------------------------------------------------------
+ * flash_read_user_serial - read the OneTimeProgramming cells
+ */
+void flash_read_user_serial (flash_info_t * info, void *buffer, int offset,
+			     int len)
+{
+	uchar *src;
+	uchar *dst;
+
+	dst = buffer;
+	src = flash_make_addr (info, 0, FLASH_OFFSET_USER_PROTECTION);
+	flash_write_cmd (info, 0, 0, FLASH_CMD_READ_ID);
+	memcpy (dst, src + offset, len);
+	flash_write_cmd (info, 0, 0, info->cmd_reset);
+}
+
+/*
+ * flash_read_factory_serial - read the device Id from the protection area
+ */
+void flash_read_factory_serial (flash_info_t * info, void *buffer, int offset,
+				int len)
+{
+	uchar *src;
+
+	src = flash_make_addr (info, 0, FLASH_OFFSET_INTEL_PROTECTION);
+	flash_write_cmd (info, 0, 0, FLASH_CMD_READ_ID);
+	memcpy (buffer, src + offset, len);
+	flash_write_cmd (info, 0, 0, info->cmd_reset);
+}
+
+#endif /* CFG_FLASH_PROTECTION */
+
+/*
+ * flash_is_busy - check to see if the flash is busy
+ * This routine checks the status of the chip and returns true if the chip is busy
+ */
+static int flash_is_busy (flash_info_t * info, flash_sect_t sect)
+{
+	int retval;
+
+	switch (info->vendor) {
+	case CFI_CMDSET_INTEL_STANDARD:
+	case CFI_CMDSET_INTEL_EXTENDED:
+		retval = !flash_isset (info, sect, 0, FLASH_STATUS_DONE);
+		break;
+	case CFI_CMDSET_AMD_STANDARD:
+	case CFI_CMDSET_AMD_EXTENDED:
+		retval = flash_toggle (info, sect, 0, AMD_STATUS_TOGGLE);
+		break;
+	default:
+		retval = 0;
+	}
+#ifdef DEBUG_FLASH
+	if (retval)
+	    debug ("flash_is_busy: %d\n", retval);
+#endif
+	return retval;
+}
+
+/*-----------------------------------------------------------------------
+ *  wait for XSR.7 to be set. Time out with an error if it does not.
+ *  This routine does not set the flash to read-array mode.
+ */
+static int flash_status_check (flash_info_t * info, flash_sect_t sector,
+			       ulong tout, char *prompt)
+{
+	ulong start, now;
+
+	/* Wait for command completion */
+	// (Sun) Fix order of checking time so it works when the CPU is very
+	// slow, e.g., single-stepping or emulation.
+	start = get_timer (0);
+	while (now = get_timer(start),
+	       flash_is_busy (info, sector))
+	{
+		if (now > info->erase_blk_tout) {
+			printf ("Flash %s timeout at address %lx data %lx\n",
+				prompt, info->start[sector],
+				flash_read_long (info, sector, 0));
+			flash_write_cmd (info, sector, 0, info->cmd_reset);
+			return ERR_TIMOUT;
+		}
+	}
+	return ERR_OK;
+}
+
+/*-----------------------------------------------------------------------
+ * Wait for XSR.7 to be set, if it times out print an error, otherwise do a full status check.
+ * This routine sets the flash to read-array mode.
+ */
+static int flash_full_status_check (flash_info_t * info, flash_sect_t sector,
+				    ulong tout, char *prompt)
+{
+	int retcode;
+
+	retcode = flash_status_check (info, sector, tout, prompt);
+	switch (info->vendor) {
+	case CFI_CMDSET_INTEL_EXTENDED:
+	case CFI_CMDSET_INTEL_STANDARD:
+		if ((retcode != ERR_OK)
+		    && !flash_isequal (info, sector, 0, FLASH_STATUS_DONE)) {
+			retcode = ERR_INVAL;
+			printf ("Flash %s error at address %lx\n", prompt,
+				info->start[sector]);
+			if (flash_isset (info, sector, 0, FLASH_STATUS_ECLBS | FLASH_STATUS_PSLBS)) {
+				puts ("Command Sequence Error.\n");
+			} else if (flash_isset (info, sector, 0, FLASH_STATUS_ECLBS)) {
+				puts ("Block Erase Error.\n");
+				retcode = ERR_NOT_ERASED;
+			} else if (flash_isset (info, sector, 0, FLASH_STATUS_PSLBS)) {
+				puts ("Locking Error\n");
+			}
+			if (flash_isset (info, sector, 0, FLASH_STATUS_DPS)) {
+				puts ("Block locked.\n");
+				retcode = ERR_PROTECTED;
+			}
+			if (flash_isset (info, sector, 0, FLASH_STATUS_VPENS))
+				puts ("Vpp Low Error.\n");
+		}
+		flash_write_cmd (info, sector, 0, info->cmd_reset);
+		break;
+	default:
+		break;
+	}
+	return retcode;
+}
+
+static void write_buffer_abort_reset(flash_info_t * info, flash_sect_t sector)
+{
+     flash_write_cmd (info, sector, 0xaaa, 0xaa);
+     flash_write_cmd (info, sector, 0x555, 0x55);
+     flash_write_cmd (info, sector, 0xaaa, 0xf0);    	
+}	
+
+/*-----------------------------------------------------------------------
+ */
+static void flash_add_byte (flash_info_t * info, cfiword_t * cword, uchar c)
+{
+#if defined(__LITTLE_ENDIAN)
+	unsigned short	w;
+	unsigned int	l;
+	unsigned long long ll;
+#endif
+
+	switch (info->portwidth) {
+	case FLASH_CFI_8BIT:
+		cword->c = c;
+		break;
+	case FLASH_CFI_16BIT:
+#if defined(__LITTLE_ENDIAN)
+		w = c;
+		w <<= 8;
+		cword->w = (cword->w >> 8) | w;
+#else
+		cword->w = (cword->w << 8) | c;
+#endif
+		break;
+	case FLASH_CFI_32BIT:
+#if defined(__LITTLE_ENDIAN)
+		l = c;
+		l <<= 24;
+		cword->l = (cword->l >> 8) | l;
+#else
+		cword->l = (cword->l << 8) | c;
+#endif
+		break;
+	case FLASH_CFI_64BIT:
+#if defined(__LITTLE_ENDIAN)
+		ll = c;
+		ll <<= 56;
+		cword->ll = (cword->ll >> 8) | ll;
+#else
+		cword->ll = (cword->ll << 8) | c;
+#endif
+		break;
+	}
+}
+
+
+/*-----------------------------------------------------------------------
+ * make a proper sized command based on the port and chip widths
+ */
+static void flash_make_cmd (flash_info_t * info, uchar cmd, void *cmdbuf)
+{
+	int i;
+	uchar *cp = (uchar *) cmdbuf;
+
+#if defined(__LITTLE_ENDIAN)
+	for (i = info->portwidth; i > 0; i--)
+#else
+	for (i = 1; i <= info->portwidth; i++)
+#endif
+		*cp++ = (i & (info->chipwidth - 1)) ? '\0' : cmd;
+}
+
+/*
+ * Write a proper sized command to the correct address
+ */
+static void
+flash_write_cmd (flash_info_t * info, flash_sect_t sect, uint offset,
+		 uchar cmd)
+{
+#ifdef DEBUG_FLASH
+    const int noDebug = 0;
+#else
+    const int noDebug = 1;
+#endif
+    return flash_write_cmd_int(info, sect, offset, cmd, noDebug);
+}
+static void
+flash_write_cmd_nodbg (flash_info_t * info, flash_sect_t sect, uint offset,
+		       uchar cmd)
+{
+    return flash_write_cmd_int(info, sect, offset, cmd, 1);
+}
+
+static void
+flash_write_cmd_int (flash_info_t * info, flash_sect_t sect, uint offset,
+		     uchar cmd, int noDebug)
+{
+
+	volatile cfiptr_t addr;
+	cfiword_t cword;
+
+	addr.cp = flash_make_addr (info, sect, offset);
+	flash_make_cmd (info, cmd, &cword);
+	switch (info->portwidth) {
+	case FLASH_CFI_8BIT:
+		if (noDebug == 0)
+		debug ("fwc addr %p cmd %x %x 8bit x %d bit\n", addr.cp, cmd,
+		       cword.c, info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
+		*addr.cp = cword.c;
+		break;
+	case FLASH_CFI_16BIT:
+		if (noDebug == 0)
+		debug ("fwc addr %p cmd %x %4.4x 16bit x %d bit\n", addr.wp,
+		       cmd, cword.w,
+		       info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
+		*addr.wp = cword.w;
+		break;
+	case FLASH_CFI_32BIT:
+		if (noDebug == 0)
+		debug ("fwc addr %p cmd %x %8.8lx 32bit x %d bit\n", addr.lp,
+		       cmd, cword.l,
+		       info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
+		*addr.lp = cword.l;
+		break;
+	case FLASH_CFI_64BIT:
+#ifdef DEBUG_FLASH
+		if (noDebug == 0)
+		{
+			char str[20];
+
+			print_longlong (str, cword.ll);
+
+			debug ("fwrite addr %p cmd %x %s 64 bit x %d bit\n",
+			       addr.llp, cmd, str,
+			       info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
+		}
+#endif
+		*addr.llp = cword.ll;
+		break;
+	}
+}
+
+static void flash_unlock_seq (flash_info_t * info, flash_sect_t sect)
+{
+	flash_write_cmd_nodbg (info, sect, AMD_ADDR_START, AMD_CMD_UNLOCK_START);
+	flash_write_cmd_nodbg (info, sect, AMD_ADDR_ACK, AMD_CMD_UNLOCK_ACK);
+}
+
+/*-----------------------------------------------------------------------
+ */
+static int flash_isequal (flash_info_t * info, flash_sect_t sect, uint offset, uchar cmd)
+{
+	cfiptr_t cptr;
+	cfiword_t cword;
+	int retval;
+#ifdef DEBUG_FLASH
+	const int dbg = 1;
+#else
+	const int dbg = 0;
+#endif
+	cptr.cp = flash_make_addr (info, sect, offset);
+	flash_make_cmd (info, cmd, &cword);
+
+	if (dbg)
+	    debug ("is= cmd %x(%c) addr %p ", cmd, cmd, cptr.cp);
+	switch (info->portwidth) {
+	case FLASH_CFI_8BIT:
+		if (dbg)
+		    debug ("is= %x %x\n", cptr.cp[0], cword.c);
+		retval = (cptr.cp[0] == cword.c);
+		break;
+	case FLASH_CFI_16BIT:
+		if (dbg)
+		    debug ("is= %4.4x %4.4x\n", cptr.wp[0], cword.w);
+		retval = (cptr.wp[0] == cword.w);
+		break;
+	case FLASH_CFI_32BIT:
+		if (dbg)
+		    debug ("is= %8.8lx %8.8lx\n", cptr.lp[0], cword.l);
+		retval = (cptr.lp[0] == cword.l);
+		break;
+	case FLASH_CFI_64BIT:
+#ifdef DEBUG_FLASH
+		{
+			char str1[20];
+			char str2[20];
+
+			print_longlong (str1, cptr.llp[0]);
+			print_longlong (str2, cword.ll);
+			debug ("is= %s %s\n", str1, str2);
+		}
+#endif
+		retval = (cptr.llp[0] == cword.ll);
+		break;
+	default:
+		retval = 0;
+		break;
+	}
+	return retval;
+}
+
+/*-----------------------------------------------------------------------
+ */
+static int flash_isset (flash_info_t * info, flash_sect_t sect, uint offset, uchar cmd)
+{
+	cfiptr_t cptr;
+	cfiword_t cword;
+	int retval;
+
+	cptr.cp = flash_make_addr (info, sect, offset);
+	flash_make_cmd (info, cmd, &cword);
+	switch (info->portwidth) {
+	case FLASH_CFI_8BIT:
+		retval = ((cptr.cp[0] & cword.c) == cword.c);
+		break;
+	case FLASH_CFI_16BIT:
+		retval = ((cptr.wp[0] & cword.w) == cword.w);
+		break;
+	case FLASH_CFI_32BIT:
+		retval = ((cptr.lp[0] & cword.l) == cword.l);
+		break;
+	case FLASH_CFI_64BIT:
+		retval = ((cptr.llp[0] & cword.ll) == cword.ll);
+		break;
+	default:
+		retval = 0;
+		break;
+	}
+	return retval;
+}
+
+/*-----------------------------------------------------------------------
+ */
+static int flash_toggle (flash_info_t * info, flash_sect_t sect, uint offset, uchar cmd)
+{
+	cfiptr_t cptr;
+	cfiword_t cword;
+	int retval;
+
+	cptr.cp = flash_make_addr (info, sect, offset);
+	flash_make_cmd (info, cmd, &cword);
+	switch (info->portwidth) {
+	case FLASH_CFI_8BIT:
+		retval = ((cptr.cp[0] & cword.c) != (cptr.cp[0] & cword.c));
+		break;
+	case FLASH_CFI_16BIT:
+		retval = ((cptr.wp[0] & cword.w) != (cptr.wp[0] & cword.w));
+		break;
+	case FLASH_CFI_32BIT:
+		retval = ((cptr.lp[0] & cword.l) != (cptr.lp[0] & cword.l));
+		break;
+	case FLASH_CFI_64BIT:
+		retval = ((cptr.llp[0] & cword.ll) !=
+			  (cptr.llp[0] & cword.ll));
+		break;
+	default:
+		retval = 0;
+		break;
+	}
+	return retval;
+}
+
+/*-----------------------------------------------------------------------
+ * detect if flash is compatible with the Common Flash Interface (CFI)
+ * http://www.jedec.org/download/search/jesd68.pdf
+ *
+*/
+static int flash_detect_cfi (flash_info_t * info)
+{
+        ulong data;
+        	
+	debug ("flash_detect_cfi()... ");
+
+#if     defined(CONFIG_FLASH_AST2300)
+        data = *(ulong *)(0x1e6e2070);		/* hardware traping */
+        if (data & 0x10)			/* D[4]: 0/1 (8/16) */
+            info->portwidth = FLASH_CFI_16BIT;
+        else
+            info->portwidth = FLASH_CFI_8BIT;            
+#else
+        info->portwidth = FLASH_CFI_8BIT;
+#endif
+
+	{     	
+		for (info->chipwidth = FLASH_CFI_BY8;
+		     info->chipwidth <= info->portwidth;
+		     info->chipwidth <<= 1) {
+			flash_write_cmd (info, 0, 0, FLASH_CMD_RESET);
+			flash_write_cmd (info, 0, FLASH_OFFSET_CFI, FLASH_CMD_CFI);
+			if (flash_isequal (info, 0, FLASH_OFFSET_CFI_RESP, 'Q')
+			    //FIXME: Next 3 lines were changed for 8-bit/16-bit flash chips.
+			    && flash_isequal (info, 0, FLASH_OFFSET_CFI_RESP1, 'R')
+			    && flash_isequal (info, 0, FLASH_OFFSET_CFI_RESP2, 'Y')) {
+				info->interface = flash_read_uchar (info, FLASH_OFFSET_INTERFACE);
+				debug ("device interface is %d\n",
+				       info->interface);
+				debug ("found port %d chip %d ",
+				       info->portwidth, info->chipwidth);
+				debug ("port %d bits chip %d bits\n",
+				       info->portwidth << CFI_FLASH_SHIFT_WIDTH,
+				       info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
+				return 1;
+			}
+		}
+	}
+	debug ("not found\n");
+	return 0;
+}
+
+/*
+ * The following code cannot be run from FLASH!
+ *
+ */
+ulong flash_get_size (ulong base, int banknum)
+{
+	flash_info_t *info = &flash_info[banknum];
+	int i, j;
+	flash_sect_t sect_cnt;
+	unsigned long sector;
+	unsigned long tmp;
+	int size_ratio;
+	uchar num_erase_regions;
+	int erase_region_size;
+	int erase_region_count;
+
+	info->start[0] = base;
+
+	if (flash_detect_cfi (info)) {
+		info->vendor = flash_read_uchar (info, FLASH_OFFSET_PRIMARY_VENDOR);
+#if defined(DEBUG_FLASH)
+		flash_printqry (info, 0);
+#endif
+		switch (info->vendor) {
+		case CFI_CMDSET_INTEL_STANDARD:
+		case CFI_CMDSET_INTEL_EXTENDED:
+		default:
+			info->cmd_reset = FLASH_CMD_RESET;
+			break;
+		case CFI_CMDSET_AMD_STANDARD:
+		case CFI_CMDSET_AMD_EXTENDED:
+			info->cmd_reset = AMD_CMD_RESET;
+			break;
+		}
+
+		debugX(2, "manufacturer is %d\n", info->vendor);
+		size_ratio = info->portwidth / info->chipwidth;
+		/* if the chip is x8/x16 reduce the ratio by half */
+#if 0
+		if ((info->interface == FLASH_CFI_X8X16)
+		    && (info->chipwidth == FLASH_CFI_BY8)) {
+			size_ratio >>= 1;
+		}
+#endif
+		num_erase_regions = flash_read_uchar (info, FLASH_OFFSET_NUM_ERASE_REGIONS);
+		debugX(2, "size_ratio %d port %d bits chip %d bits\n",
+		       size_ratio, info->portwidth << CFI_FLASH_SHIFT_WIDTH,
+		       info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
+		debugX(2, "found %d erase regions\n", num_erase_regions);
+		sect_cnt = 0;
+		sector = base;
+		for (i = 0; i < num_erase_regions; i++) {
+			if (i > MAX_NUM_ERASE_REGIONS) {
+				printf ("%d erase regions found, only %d used\n",
+					num_erase_regions, MAX_NUM_ERASE_REGIONS);
+				break;
+			}
+			// CFI Erase Block Region Information:
+			// Bits[31:16] = sect_size/256, 0 means 128-byte
+			// Bits[15:0]  = num_sectors - 1
+			tmp = flash_read_long(info, 0,
+					      FLASH_OFFSET_ERASE_REGIONS + i * 4);
+			debug("CFI erase block region info[%d]: 0x%08x, ",
+			      i, tmp);
+			erase_region_count = (tmp & 0xffff) + 1;
+			tmp >>= 16;
+			erase_region_size = (tmp ? tmp * 256 : 128);
+			debug ("erase_region_count=%d erase_region_size=%d\n",
+				erase_region_count, erase_region_size);
+#if 0
+                        erase_region_size  = CFG_FLASH_SECTOR_SIZE;	// Commented out
+                        erase_region_count = CFG_FLASH_SECTOR_COUNT;	// Commented out
+#endif
+			if (sect_cnt + erase_region_count > CONFIG_SYS_MAX_FLASH_SECT) {
+			    printf("Warning: Erase region %d adds too many flash sectors"
+				   " %d+%d; reducing to fit total limit of %d\n",
+				   i, sect_cnt, erase_region_count, CONFIG_SYS_MAX_FLASH_SECT);
+			    erase_region_count = CONFIG_SYS_MAX_FLASH_SECT - sect_cnt;
+			}
+			for (j = 0; j < erase_region_count; j++) {
+				info->start[sect_cnt] = sector;
+				sector += (erase_region_size * size_ratio);
+
+				/*
+				 * Only read protection status from supported devices (intel...)
+				 */
+				switch (info->vendor) {
+				case CFI_CMDSET_INTEL_EXTENDED:
+				case CFI_CMDSET_INTEL_STANDARD:
+					info->protect[sect_cnt] =
+						flash_isset (info, sect_cnt,
+							     FLASH_OFFSET_PROTECT,
+							     FLASH_STATUS_PROTECT);
+					break;
+				default:
+					info->protect[sect_cnt] = 0; /* default: not protected */
+				}
+
+				sect_cnt++;
+			}
+		}
+
+		info->sector_count = sect_cnt;
+		/* multiply the size by the number of chips */
+		// info->size = (1 << flash_read_uchar (info, FLASH_OFFSET_SIZE)) * size_ratio;
+		// Use only the sectors that fit within the flash_info array size.
+		info->size = sector - base;
+		printf("Flash bank %d at %08x has 0x%x bytes in %d sectors"
+		       " (chipSize 1<<%d, size_ratio %d).\n",
+		       banknum, base, info->size, info->sector_count,
+		       flash_read_uchar(info, FLASH_OFFSET_SIZE), size_ratio);
+
+		info->buffer_size = (1 << flash_read_uchar (info, FLASH_OFFSET_BUFFER_SIZE));		
+		/* Limit the buffer size to 32bytes to meet most of AMD-styles flash's minimum requirement */
+		if (info->buffer_size > 32)
+		    info->buffer_size = 32;    
+		tmp = 1 << flash_read_uchar (info, FLASH_OFFSET_ETOUT);
+		info->erase_blk_tout = (tmp * (1 << flash_read_uchar (info, FLASH_OFFSET_EMAX_TOUT)));
+		tmp = 1 << flash_read_uchar (info, FLASH_OFFSET_WBTOUT);
+		info->buffer_write_tout = (tmp * (1 << flash_read_uchar (info, FLASH_OFFSET_WBMAX_TOUT)));
+		tmp = 1 << flash_read_uchar (info, FLASH_OFFSET_WTOUT);
+		info->write_tout = (tmp * (1 << flash_read_uchar (info, FLASH_OFFSET_WMAX_TOUT))) / 1000;
+		info->flash_id = FLASH_MAN_CFI;
+#if 0
+		if ((info->interface == FLASH_CFI_X8X16) && (info->chipwidth == FLASH_CFI_BY8)) {
+			info->portwidth >>= 1;	/* XXX - Need to test on x8/x16 in parallel. */
+		}
+#endif
+	}
+
+	flash_write_cmd (info, 0, 0, info->cmd_reset);
+	return (info->size);
+}
+
+
+/*-----------------------------------------------------------------------
+ */
+static int flash_write_cfiword (flash_info_t * info, ulong dest,
+				cfiword_t cword)
+{
+
+	cfiptr_t ctladdr;
+	cfiptr_t cptr;
+	int flag;
+
+	ctladdr.cp = flash_make_addr (info, 0, 0);
+	cptr.cp = (uchar *) dest;
+
+
+	/* Check if Flash is (sufficiently) erased */
+	switch (info->portwidth) {
+	case FLASH_CFI_8BIT:
+		flag = ((cptr.cp[0] & cword.c) == cword.c);
+		break;
+	case FLASH_CFI_16BIT:
+		flag = ((cptr.wp[0] & cword.w) == cword.w);
+		break;
+	case FLASH_CFI_32BIT:
+		flag = ((cptr.lp[0] & cword.l) == cword.l);
+		break;
+	case FLASH_CFI_64BIT:
+		flag = ((cptr.llp[0] & cword.ll) == cword.ll);
+		break;
+	default:
+		return 2;
+	}
+	if (!flag)
+		return 2;
+
+	/* Disable interrupts which might cause a timeout here */
+	flag = disable_interrupts ();
+
+	switch (info->vendor) {
+	case CFI_CMDSET_INTEL_EXTENDED:
+	case CFI_CMDSET_INTEL_STANDARD:
+		flash_write_cmd_nodbg (info, 0, 0, FLASH_CMD_CLEAR_STATUS);
+		flash_write_cmd_nodbg (info, 0, 0, FLASH_CMD_WRITE);
+		break;
+	case CFI_CMDSET_AMD_EXTENDED:
+	case CFI_CMDSET_AMD_STANDARD:
+		flash_unlock_seq (info, 0);
+		flash_write_cmd_nodbg (info, 0, AMD_ADDR_START, AMD_CMD_WRITE);
+		break;
+	}
+
+	switch (info->portwidth) {
+	case FLASH_CFI_8BIT:
+		cptr.cp[0] = cword.c;
+		break;
+	case FLASH_CFI_16BIT:
+		cptr.wp[0] = cword.w;
+		break;
+	case FLASH_CFI_32BIT:
+		cptr.lp[0] = cword.l;
+		break;
+	case FLASH_CFI_64BIT:
+		cptr.llp[0] = cword.ll;
+		break;
+	}
+
+	/* re-enable interrupts if necessary */
+	if (flag)
+		enable_interrupts ();
+
+	return flash_full_status_check (info, 0, info->write_tout, "write");
+}
+
+#ifdef CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+
+/* loop through the sectors from the highest address
+ * when the passed address is greater or equal to the sector address
+ * we have a match
+ */
+static flash_sect_t find_sector (flash_info_t * info, ulong addr)
+{
+	flash_sect_t sector;
+
+	for (sector = info->sector_count - 1; sector >= 0; sector--) {
+		if (addr >= info->start[sector])
+			break;
+	}
+	return sector;
+}
+
+static int flash_write_cfibuffer (flash_info_t * info, ulong dest, uchar * cp,
+				  int len)
+{
+	flash_sect_t sector;
+	int cnt;
+	int retcode;
+	volatile cfiptr_t src;
+	volatile cfiptr_t dst;
+
+/* Add AMD write buffer mode support, ycchen@102006 */
+#if 0
+	/* buffered writes in the AMD chip set is not supported yet */
+	if((info->vendor ==  CFI_CMDSET_AMD_STANDARD) ||
+		(info->vendor == CFI_CMDSET_AMD_EXTENDED))
+		return ERR_INVAL;
+#endif
+	if((info->vendor ==  CFI_CMDSET_AMD_STANDARD) ||
+		(info->vendor == CFI_CMDSET_AMD_EXTENDED))
+	{
+		retcode = flash_write_cfibuffer_amd(info, dest, cp, len);
+                return retcode;
+        }
+
+	src.cp = cp;
+	dst.cp = (uchar *) dest;
+	sector = find_sector (info, dest);
+	flash_write_cmd (info, sector, 0, FLASH_CMD_CLEAR_STATUS);
+	flash_write_cmd (info, sector, 0, FLASH_CMD_WRITE_TO_BUFFER);
+	if ((retcode =
+	     flash_status_check (info, sector, info->buffer_write_tout,
+				 "write to buffer")) == ERR_OK) {
+		/* reduce the number of loops by the width of the port	*/
+		switch (info->portwidth) {
+		case FLASH_CFI_8BIT:
+			cnt = len;
+			break;
+		case FLASH_CFI_16BIT:
+			cnt = len >> 1;
+			break;
+		case FLASH_CFI_32BIT:
+			cnt = len >> 2;
+			break;
+		case FLASH_CFI_64BIT:
+			cnt = len >> 3;
+			break;
+		default:
+			return ERR_INVAL;
+			break;
+		}
+		flash_write_cmd (info, sector, 0, (uchar) cnt - 1);
+		while (cnt-- > 0) {
+			switch (info->portwidth) {
+			case FLASH_CFI_8BIT:
+				*dst.cp++ = *src.cp++;
+				break;
+			case FLASH_CFI_16BIT:
+				*dst.wp++ = *src.wp++;
+				break;
+			case FLASH_CFI_32BIT:
+				*dst.lp++ = *src.lp++;
+				break;
+			case FLASH_CFI_64BIT:
+				*dst.llp++ = *src.llp++;
+				break;
+			default:
+				return ERR_INVAL;
+				break;
+			}
+		}
+		flash_write_cmd (info, sector, 0,
+				 FLASH_CMD_WRITE_BUFFER_CONFIRM);
+		retcode =
+			flash_full_status_check (info, sector,
+						 info->buffer_write_tout,
+						 "buffer write");
+	}
+	flash_write_cmd (info, sector, 0, FLASH_CMD_CLEAR_STATUS);
+	return retcode;
+}
+
+
+static int flash_write_cfibuffer_amd (flash_info_t * info, ulong dest, uchar * cp,
+				  int len)
+{
+	flash_sect_t sector;
+	int cnt;
+	int retcode;
+	volatile cfiptr_t src;
+	volatile cfiptr_t dst;
+	volatile cfiword_t tmpsrc, tmpdst;
+
+	src.cp = cp;
+	dst.cp = (uchar *) dest;
+	sector = find_sector (info, dest);
+	flash_unlock_seq (info, 0);
+	if ((retcode =
+	     flash_status_check (info, sector, info->buffer_write_tout,
+				 "write to buffer")) == ERR_OK) {
+		/* reduce the number of loops by the width of the port	*/
+		switch (info->portwidth) {
+		case FLASH_CFI_8BIT:
+			cnt = len;
+			*dst.cp = (uchar) (AMD_CMD_WRITE_TO_BUFFER);
+			*dst.cp = (uchar) (cnt -1);
+			break;
+		case FLASH_CFI_16BIT:
+			cnt = len >> 1;
+			*dst.wp = (unsigned short) (AMD_CMD_WRITE_TO_BUFFER);
+			*dst.wp = (unsigned short) (cnt -1);
+			break;
+		case FLASH_CFI_32BIT:
+			cnt = len >> 2;
+			*dst.lp = (unsigned long) (AMD_CMD_WRITE_TO_BUFFER);
+			*dst.lp = (unsigned long) (cnt -1);
+			break;
+		case FLASH_CFI_64BIT:
+			cnt = len >> 3;
+			*dst.llp = (unsigned long long) (AMD_CMD_WRITE_TO_BUFFER);
+			*dst.llp = (unsigned long long) (cnt -1);
+			break;
+		default:
+			return ERR_INVAL;
+			break;
+		}
+		while (cnt-- > 0) {
+			switch (info->portwidth) {
+			case FLASH_CFI_8BIT:
+				*dst.cp++ = *src.cp++;
+				break;
+			case FLASH_CFI_16BIT:
+				*dst.wp++ = *src.wp++;
+				break;
+			case FLASH_CFI_32BIT:
+				*dst.lp++ = *src.lp++;
+				break;
+			case FLASH_CFI_64BIT:
+				*dst.llp++ = *src.llp++;
+				break;
+			default:
+				return ERR_INVAL;
+				break;
+			}
+		}				
+		switch (info->portwidth) {
+		case FLASH_CFI_8BIT:
+		        src.cp--;
+		        dst.cp--;
+			*dst.cp = (unsigned char) (AMD_CMD_BUFFER_TO_FLASH);
+		        tmpsrc.c = *src.cp & 0x80;
+		        
+		        do {
+		            tmpdst.c = *(volatile uchar *)(dst.cp);		        
+		        	
+		            if (tmpdst.c & 0x20) {	/* toggle DQ5 */
+		                 tmpdst.c = *(volatile uchar *)(dst.cp);		        
+		                 if ((tmpdst.c & 0x80) != tmpsrc.c)
+		                 {
+		                     printf("program error occurred\n");
+			             flash_write_cmd (info, sector, 0, info->cmd_reset);		            
+			             return ERR_PROG_ERROR;			             
+			         }    
+		            }
+		            else if (tmpdst.c & 0x02) {	/* toggle DQ1 */
+		                 tmpdst.c = *(volatile uchar *)(dst.cp);		        
+		                 if ((tmpdst.c & 0x80) != tmpsrc.c)
+		                 {
+		                     printf("write buffer error occurred \n");
+		                     write_buffer_abort_reset(info, sector);
+			             return ERR_PROG_ERROR;			             
+			         } 		            
+		            }	
+		            		                	
+		        } while ((tmpdst.c & 0x80) != tmpsrc.c);
+		        			        
+			break;
+		case FLASH_CFI_16BIT:
+		        src.wp--;
+		        dst.wp--;
+			*dst.wp = (unsigned short) (AMD_CMD_BUFFER_TO_FLASH);
+		        tmpsrc.w = *src.wp & 0x80;
+
+		        do {
+		            tmpdst.w = *(volatile short *)(dst.wp);		        
+		        	
+		            if (tmpdst.w & 0x20) {	/* toggle DQ5 */
+		                 tmpdst.w = *(volatile ushort *)(dst.wp);		        
+		                 if ((tmpdst.w & 0x80) != tmpsrc.w)
+		                 {
+		                     printf("program error occurred\n");
+			             flash_write_cmd (info, sector, 0, info->cmd_reset);		            
+			             return ERR_PROG_ERROR;			             
+			         }    
+		            }
+		            else if (tmpdst.w & 0x02) {	/* toggle DQ1 */
+		                 tmpdst.w = *(volatile ushort *)(dst.wp);		        
+		                 if ((tmpdst.w & 0x80) != tmpsrc.w)
+		                 {
+		                     printf("write buffer error occurred \n");
+		                     write_buffer_abort_reset(info, sector);
+			             return ERR_PROG_ERROR;			             
+			         } 		            
+		            }	
+		            		                	
+		        } while ((tmpdst.w & 0x80) != tmpsrc.w);
+		        
+			break;
+		case FLASH_CFI_32BIT:
+		        src.lp--;
+		        dst.lp--;
+			*dst.lp = (unsigned long) (AMD_CMD_BUFFER_TO_FLASH);
+		        tmpsrc.l = *src.lp & 0x80;
+		        
+		        do {
+		            tmpdst.l = *(volatile ulong *)(dst.lp);		        
+		        	
+		            if (tmpdst.l & 0x20) {	/* toggle DQ5 */
+		                 tmpdst.l = *(volatile ulong *)(dst.lp);		        
+		                 if ((tmpdst.l & 0x80) != tmpsrc.l)
+		                 {
+		                     printf("program error occurred\n");
+			             flash_write_cmd (info, sector, 0, info->cmd_reset);		            
+			             return ERR_PROG_ERROR;			             
+			         }    
+		            }
+		            else if (tmpdst.l & 0x02) {	/* toggle DQ1 */
+		                 tmpdst.l = *(volatile ulong *)(dst.lp);		        
+		                 if ((tmpdst.l & 0x80) != tmpsrc.l)
+		                 {
+		                     printf("write buffer error occurred \n");
+		                     write_buffer_abort_reset(info, sector);
+			             return ERR_PROG_ERROR;			             
+			         } 		            
+		            }	
+		            		                	
+		        } while ((tmpdst.l & 0x80) != tmpsrc.l);
+		        
+			break;
+		case FLASH_CFI_64BIT:
+		        src.llp--;
+		        dst.llp--;
+			*dst.llp = (unsigned long long) (AMD_CMD_BUFFER_TO_FLASH);
+		        tmpsrc.ll = *src.llp & 0x80;
+		        
+		        do {
+		            tmpdst.ll = *(volatile unsigned long long *)(dst.llp);		        
+		        	
+		            if (tmpdst.ll & 0x20) {	/* toggle DQ5 */
+		                 tmpdst.ll = *(volatile unsigned long long *)(dst.llp);		        
+		                 if ((tmpdst.ll & 0x80) != tmpsrc.ll)
+		                 {
+		                     printf("program error occurred\n");
+			             flash_write_cmd (info, sector, 0, info->cmd_reset);		            
+			             return ERR_PROG_ERROR;			             
+			         }    
+		            }
+		            else if (tmpdst.ll & 0x02) {	/* toggle DQ1 */
+		                 tmpdst.ll = *(volatile unsigned long long *)(dst.llp);		        
+		                 if ((tmpdst.ll & 0x80) != tmpsrc.ll)
+		                 {
+		                     printf("write buffer error occurred \n");
+		                     write_buffer_abort_reset(info, sector);
+			             return ERR_PROG_ERROR;			             
+			         } 		            
+		            }	
+		            		                	
+		        } while ((tmpdst.ll & 0x80) != tmpsrc.ll);
+		        
+			break;
+		default:
+			return ERR_INVAL;
+			break;
+		}
+
+		retcode =
+			flash_full_status_check (info, sector,
+						 info->buffer_write_tout,
+						 "buffer write");
+	}
+
+	return retcode;
+}
+#endif /* CONFIG_SYS_FLASH_USE_BUFFER_WRITE */
+
+#ifdef	CONFIG_FLASH_AST2300_DMA
+#define STCBaseAddress			0x1e620000
+
+/* for DMA */
+#define REG_FLASH_INTERRUPT_STATUS	0x08
+#define REG_FLASH_DMA_CONTROL		0x80
+#define REG_FLASH_DMA_FLASH_BASE	0x84
+#define REG_FLASH_DMA_DRAM_BASE		0x88
+#define REG_FLASH_DMA_LENGTH		0x8c
+
+#define FLASH_STATUS_DMA_BUSY		0x0000
+#define FLASH_STATUS_DMA_READY		0x0800
+#define FLASH_STATUS_DMA_CLEAR		0x0800
+
+#define FLASH_DMA_ENABLE		0x01
+
+void * memmove_dma(void * dest,const void *src,size_t count)
+{
+	ulong count_align, poll_time, data;
+	
+	count_align = (count + 3) & 0xFFFFFFFC;	/* 4-bytes align */
+        poll_time = 100;			/* set 100 us as default */
+
+	*(ulong *) (STCBaseAddress + REG_FLASH_DMA_CONTROL) = (ulong) (~FLASH_DMA_ENABLE);
+	
+	*(ulong *) (STCBaseAddress + REG_FLASH_DMA_FLASH_BASE) = (ulong *) (src);
+	*(ulong *) (STCBaseAddress + REG_FLASH_DMA_DRAM_BASE) = (ulong *) (dest);
+	*(ulong *) (STCBaseAddress + REG_FLASH_DMA_LENGTH) = (ulong) (count_align);
+        udelay(10);
+	*(ulong *) (STCBaseAddress + REG_FLASH_DMA_CONTROL) = (ulong) (FLASH_DMA_ENABLE);
+	
+	/* wait poll */
+	do {
+	    udelay(poll_time);	
+	    data = *(ulong *) (STCBaseAddress + REG_FLASH_INTERRUPT_STATUS);
+	} while (!(data & FLASH_STATUS_DMA_READY));
+	
+	/* clear status */
+	*(ulong *) (STCBaseAddress + REG_FLASH_INTERRUPT_STATUS) |= FLASH_STATUS_DMA_CLEAR;
+}	
+#endif
+#endif /* CFG_FLASH_CFI */
diff --git a/board/aspeed/ast2300/flash_spi.c b/board/aspeed/ast2300/flash_spi.c
new file mode 100755
index 0000000..6660628
--- /dev/null
+++ b/board/aspeed/ast2300/flash_spi.c
@@ -0,0 +1,1639 @@
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * History
+ * 01/20/2004 - combined variants of original driver.
+ * 01/22/2004 - Write performance enhancements for parallel chips (Tolunay)
+ * 01/23/2004 - Support for x8/x16 chips (Rune Raknerud)
+ * 01/27/2004 - Little endian support Ed Okerson
+ *
+ * Tested Architectures
+ * Port Width  Chip Width    # of banks	   Flash Chip  Board
+ * 32	       16	     1		   28F128J3    seranoa/eagle
+ * 64	       16	     1		   28F128J3    seranoa/falcon
+ *
+ */
+
+/* The DEBUG define must be before common to enable debugging */
+/* #define DEBUG	*/
+
+#include <common.h>
+#include <asm/processor.h>
+#include <asm/byteorder.h>
+#include <environment.h>
+#ifdef	CONFIG_FLASH_SPI
+
+/*
+ * This file implements a Common Flash Interface (CFI) driver for U-Boot.
+ * The width of the port and the width of the chips are determined at initialization.
+ * These widths are used to calculate the address for access CFI data structures.
+ * It has been tested on an Intel Strataflash implementation and AMD 29F016D.
+ *
+ * References
+ * JEDEC Standard JESD68 - Common Flash Interface (CFI)
+ * JEDEC Standard JEP137-A Common Flash Interface (CFI) ID Codes
+ * Intel Application Note 646 Common Flash Interface (CFI) and Command Sets
+ * Intel 290667-008 3 Volt Intel StrataFlash Memory datasheet
+ *
+ * TODO
+ *
+ * Use Primary Extended Query table (PRI) and Alternate Algorithm Query
+ * Table (ALT) to determine if protection is available
+ *
+ * Add support for other command sets Use the PRI and ALT to determine command set
+ * Verify erase and program timeouts.
+ */
+
+#ifndef CONFIG_FLASH_BANKS_LIST
+#define CONFIG_FLASH_BANKS_LIST { CONFIG_SYS_FLASH_BASE }
+#endif
+
+/* use CFG_MAX_FLASH_BANKS_DETECT if defined */
+#ifdef CONFIG_SYS_MAX_FLASH_BANKS_DETECT
+static ulong bank_base[CONFIG_SYS_MAX_FLASH_BANKS_DETECT] = CONFIG_FLASH_BANKS_LIST;
+flash_info_t flash_info[CONFIG_SYS_MAX_FLASH_BANKS_DETECT];	/* FLASH chips info */
+#else
+static ulong bank_base[CONFIG_SYS_MAX_FLASH_BANKS] = CONFIG_FLASH_BANKS_LIST;
+flash_info_t flash_info[CONFIG_SYS_MAX_FLASH_BANKS];		/* FLASH chips info */
+#endif
+
+/* Support Flash ID */
+#define STM25P64		0x172020
+#define STM25P128		0x182020
+#define N25Q256			0x19ba20
+#define N25Q512			0x20ba20
+#define S25FL064A		0x160201
+#define S25FL128P		0x182001
+#define S25FL256S		0x190201
+#define W25X16			0x1530ef
+#define W25X64			0x1730ef
+#define W25Q64BV		0x1740ef
+#define W25Q128BV		0x1840ef
+#define W25Q256FV		0x1940ef
+#define MX25L1605D		0x1520C2
+#define MX25L12805D		0x1820C2
+#define MX25L25635E		0x1920C2
+#define SST25VF016B             0x4125bf
+#define SST25VF064C             0x4b25bf
+#define AT25DF161		0x02461F
+#define AT25DF321		0x01471F
+
+/* SPI Define */
+#if	defined(CONFIG_FLASH_AST2300) || defined(CONFIG_AST1300)
+#if	defined(CONFIG_AST1300)
+#define STCBaseAddress			0x00620000
+#else
+#define STCBaseAddress			0x1e620000
+#endif
+#define SCU_REVISION_REGISTER		0x1e6e207c
+#define SCU_CACHE_CTRL_REGISTER		0x1e6e2118
+
+#define SPICtrlRegOffset		0x10
+#define SPICtrlRegOffset2		0x14
+
+#define SPIMiscCtrlRegOffset		0x54
+
+/* for DMA */
+#define REG_FLASH_INTERRUPT_STATUS	0x08
+#define REG_FLASH_DMA_CONTROL		0x80
+#define REG_FLASH_DMA_FLASH_BASE	0x84
+#define REG_FLASH_DMA_DRAM_BASE		0x88
+#define REG_FLASH_DMA_LENGTH		0x8c
+
+#define FLASH_STATUS_DMA_BUSY		0x0000
+#define FLASH_STATUS_DMA_READY		0x0800
+#define FLASH_STATUS_DMA_CLEAR		0x0800
+
+#define FLASH_DMA_ENABLE		0x01
+#else
+#define STCBaseAddress			0x16000000
+
+#define SPICtrlRegOffset		0x04
+#define SPICtrlRegOffset2		0x0C
+#endif	/* CONFIG_FLASH_AST2300 */
+
+#define CMD_MASK		0xFFFFFFF8
+
+#define NORMALREAD		0x00
+#define	FASTREAD		0x01
+#define NORMALWRITE		0x02
+#define USERMODE		0x03
+
+#define CE_LOW			0x00
+#define CE_HIGH			0x04
+
+/* AST2300 only */
+#define IOMODEx1		0x00000000
+#define IOMODEx2		0x20000000
+#define IOMODEx2_dummy		0x30000000
+#define IOMODEx4		0x40000000
+#define IOMODEx4_dummy		0x50000000
+
+#define DUMMY_COMMAND_OUT	0x00008000
+/* ~AST2300 only */
+
+/* specificspi */
+#define SpecificSPI_N25Q512	0x00000001		
+
+static ulong AST2300_SPICLK_DIV[16] = {0x0F, 0x07, 0x0E, 0x06, 0x0D, 0x05, 0x0C, 0x04, \
+                                       0x0B, 0x03, 0x0A, 0x02, 0x09, 0x01, 0x08, 0x00 };
+
+/*-----------------------------------------------------------------------
+ * Functions
+ */
+static void reset_flash (flash_info_t * info);
+static void enable_write (flash_info_t * info);
+static void write_status_register (flash_info_t * info, uchar data);
+static void enable4b (flash_info_t * info);
+static void enable4b_spansion (flash_info_t * info);
+static void enable4b_numonyx (flash_info_t * info);
+static ulong flash_get_size (ulong base, int banknum);
+static int flash_write_buffer (flash_info_t *info, uchar *src, ulong addr, int len);
+#if defined(CFG_ENV_IS_IN_FLASH) || defined(CFG_ENV_ADDR_REDUND) || (CFG_MONITOR_BASE >= CFG_FLASH_BASE)
+static flash_info_t *flash_get_info(ulong base);
+#endif
+
+
+/*-----------------------------------------------------------------------
+ * create an address based on the offset and the port width
+ */
+inline uchar *flash_make_addr (flash_info_t * info, flash_sect_t sect, uint offset)
+{
+#ifdef CONFIG_2SPIFLASH
+        if (info->start[0] >= PHYS_FLASH_2)
+	    return ((uchar *) (info->start[sect] + (offset * 1) - (PHYS_FLASH_2 - PHYS_FLASH_2_BASE) ));        
+        else
+	    return ((uchar *) (info->start[sect] + (offset * 1)));
+#else
+	return ((uchar *) (info->start[sect] + (offset * 1)));
+#endif	
+}
+
+/*-----------------------------------------------------------------------
+ * read a character at a port width address
+ */
+inline uchar flash_read_uchar (flash_info_t * info, uint offset)
+{
+	uchar *cp;
+
+	cp = flash_make_addr (info, 0, offset);
+#if defined(__LITTLE_ENDIAN)
+	return (cp[0]);
+#else
+	return (cp[1 - 1]);
+#endif
+}
+
+/*-----------------------------------------------------------------------
+ * read a short word by swapping for ppc format.
+ */
+ushort flash_read_ushort (flash_info_t * info, flash_sect_t sect, uint offset)
+{
+	uchar *addr;
+	ushort retval;
+
+#ifdef DEBUG
+	int x;
+#endif
+	addr = flash_make_addr (info, sect, offset);
+
+#ifdef DEBUG
+	debug ("ushort addr is at %p 1 = %d\n", addr,
+	       1);
+	for (x = 0; x < 2 * 1; x++) {
+		debug ("addr[%x] = 0x%x\n", x, addr[x]);
+	}
+#endif
+#if defined(__LITTLE_ENDIAN)
+	retval = ((addr[(1)] << 8) | addr[0]);
+#else
+	retval = ((addr[(2 * 1) - 1] << 8) |
+		  addr[1 - 1]);
+#endif
+
+	debug ("retval = 0x%x\n", retval);
+	return retval;
+}
+
+/*-----------------------------------------------------------------------
+ * read a long word by picking the least significant byte of each maiximum
+ * port size word. Swap for ppc format.
+ */
+ulong flash_read_long (flash_info_t * info, flash_sect_t sect, uint offset)
+{
+	uchar *addr;
+	ulong retval;
+
+#ifdef DEBUG
+	int x;
+#endif
+	addr = flash_make_addr (info, sect, offset);
+
+#ifdef DEBUG
+	debug ("long addr is at %p 1 = %d\n", addr,
+	       1);
+	for (x = 0; x < 4 * 1; x++) {
+		debug ("addr[%x] = 0x%x\n", x, addr[x]);
+	}
+#endif
+#if defined(__LITTLE_ENDIAN)
+	retval = (addr[0] << 16) | (addr[(1)] << 24) |
+		(addr[(2 * 1)]) | (addr[(3 * 1)] << 8);
+#else
+	retval = (addr[(2 * 1) - 1] << 24) |
+		(addr[(1) - 1] << 16) |
+		(addr[(4 * 1) - 1] << 8) |
+		addr[(3 * 1) - 1];
+#endif
+	return retval;
+}
+
+/*-----------------------------------------------------------------------
+ */
+static void disable_cache(void)
+{
+#if	defined(AST1300_CPU_CACHE_ENABLE)
+        ulong uldata;
+        
+        uldata  = *(volatile ulong *) (SCU_CACHE_CTRL_REGISTER);
+        uldata &= 0xfffffffd;
+        *(ulong *) (SCU_CACHE_CTRL_REGISTER) = uldata;        
+#endif
+}	
+
+static void enable_cache(void)
+{
+#if	defined(AST1300_CPU_CACHE_ENABLE)
+        ulong uldata;
+        
+        uldata  = *(volatile ulong *) (SCU_CACHE_CTRL_REGISTER);
+        uldata |= 0x00000002;
+        *(ulong *) (SCU_CACHE_CTRL_REGISTER) = uldata;        
+#endif
+}
+	 
+static void reset_flash (flash_info_t * info)
+{
+        ulong ulCtrlData, CtrlOffset, MiscCtrlOffset;
+        
+        if (info->CE == 2)
+        {
+            CtrlOffset = SPICtrlRegOffset2;
+        }    
+        else
+        {
+            CtrlOffset = SPICtrlRegOffset;
+        }    
+
+#if    defined(CONFIG_FLASH_AST2300) || defined(CONFIG_AST1300)
+        ulCtrlData = info->iomode | (info->readcmd << 16) | (info->tCK_Read << 8) | (info->dummybyte << 6) | FASTREAD;
+#if 0        
+        if (info->quadport)
+        {        	
+            MiscCtrlOffset = SPIMiscCtrlRegOffset;
+            *(ulong *) (STCBaseAddress + MiscCtrlOffset) = info->dummydata;                	                   
+            ulCtrlData |= DUMMY_COMMAND_OUT;
+        }
+#endif        
+#else      
+        ulCtrlData  = (info->readcmd << 16) | (info->tCK_Read << 8) | (info->dummybyte << 6) | FASTREAD;         
+        if (info->dualport)
+            ulCtrlData  |= 0x08;        
+#endif        
+        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;        
+        
+        enable_cache();    
+}
+	 
+static void enable_write (flash_info_t * info)
+{
+	ulong base;
+        ulong ulCtrlData, CtrlOffset;
+        uchar jReg;
+        
+        if (info->CE == 2)
+        {
+            CtrlOffset = SPICtrlRegOffset2;
+        }    
+        else
+        {
+            CtrlOffset = SPICtrlRegOffset;
+        }    
+                  
+	//base = info->start[0];
+	base = flash_make_addr (info, 0, 0);
+
+        ulCtrlData  = (info->tCK_Write << 8);        
+        ulCtrlData |= CE_LOW | USERMODE;
+        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+        udelay(200);
+        *(uchar *) (base) = (uchar) (0x06);
+        udelay(10);
+        ulCtrlData &= CMD_MASK;
+        ulCtrlData |= CE_HIGH | USERMODE;
+        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+        udelay(200);
+
+        ulCtrlData &= CMD_MASK;
+        ulCtrlData |= CE_LOW | USERMODE;
+        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+        udelay(200);
+        *(uchar *) (base) = (uchar) (0x05);
+        udelay(10);
+        do {                                
+            jReg = *(volatile uchar *) (base);
+        } while (!(jReg & 0x02));                  	                
+        ulCtrlData &= CMD_MASK;
+        ulCtrlData |= CE_HIGH | USERMODE;
+        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+        udelay(200);
+
+}
+		
+static void write_status_register (flash_info_t * info, uchar data)
+{
+	ulong base;
+        ulong ulSMMBase, ulCtrlData, CtrlOffset;
+        uchar jReg;
+        
+        if (info->CE == 2)
+        {
+            CtrlOffset = SPICtrlRegOffset2;
+        }    
+        else
+        {
+            CtrlOffset = SPICtrlRegOffset;
+        }    
+    
+	//base = info->start[0];
+	base = flash_make_addr (info, 0, 0);
+
+        enable_write (info);
+
+        ulCtrlData  = (info->tCK_Write << 8);
+        ulCtrlData |= CE_LOW | USERMODE;
+        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+        udelay(200);
+        *(uchar *) (base) = (uchar) (0x01);
+        udelay(10);
+        *(uchar *) (base) = (uchar) (data);                
+        ulCtrlData &= CMD_MASK;
+        ulCtrlData |= CE_HIGH | USERMODE;
+        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+        udelay(200);
+
+        ulCtrlData &= CMD_MASK;
+        ulCtrlData |= CE_LOW | USERMODE;
+        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+        udelay(200);
+        *(uchar *) (base) = (uchar) (0x05);
+        udelay(10);
+        do {                                
+            jReg = *(volatile uchar *) (base);
+        } while (jReg & 0x01);
+        ulCtrlData &= CMD_MASK;                          	                
+        ulCtrlData |= CE_HIGH | USERMODE;
+        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+        udelay(200);
+
+}
+
+static void enable4b (flash_info_t * info)
+{
+	ulong base;
+        ulong ulSMMBase, ulCtrlData, CtrlOffset;
+        uchar jReg;
+        
+        if (info->CE == 2)
+        {
+            CtrlOffset = SPICtrlRegOffset2;
+        }    
+        else
+        {
+            CtrlOffset = SPICtrlRegOffset;
+        }    
+    
+	//base = info->start[0];
+	base = flash_make_addr (info, 0, 0);
+
+        ulCtrlData  = (info->tCK_Write << 8);
+        ulCtrlData |= CE_LOW | USERMODE;
+        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+        udelay(200);
+        *(uchar *) (base) = (uchar) (0xb7);
+        ulCtrlData &= CMD_MASK;                          	                
+        ulCtrlData |= CE_HIGH | USERMODE;
+        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+        udelay(200);
+ 
+} /* enable4b */
+
+static void enable4b_spansion (flash_info_t * info)
+{
+	ulong base;
+    	ulong ulSMMBase, ulCtrlData, CtrlOffset;
+    	uchar jReg;
+        
+    	if (info->CE == 2)
+    	{
+            CtrlOffset = SPICtrlRegOffset2;
+    	}    
+    	else
+    	{
+            CtrlOffset = SPICtrlRegOffset;
+    	}    
+    
+	//base = info->start[0];
+	base = flash_make_addr (info, 0, 0);
+
+	/* Enable 4B: BAR0 D[7] = 1 */
+    	ulCtrlData  = (info->tCK_Write << 8);
+    	ulCtrlData |= CE_LOW | USERMODE;
+    	*(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+    	udelay(200);
+    	*(uchar *) (base) = (uchar) (0x17);
+    	udelay(10);
+    	*(uchar *) (base) = (uchar) (0x80);    
+    	ulCtrlData &= CMD_MASK;                          	                
+    	ulCtrlData |= CE_HIGH | USERMODE;
+    	*(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+    	udelay(200);
+
+    	ulCtrlData &= CMD_MASK;                          	                
+    	ulCtrlData |= CE_LOW | USERMODE;
+    	*(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+    	udelay(200);
+    	*(uchar *) (base) = (uchar) (0x16);
+    	udelay(10);
+    	do {                                
+            jReg = *(volatile uchar *) (base);
+    	} while (!(jReg & 0x80));
+    	ulCtrlData &= CMD_MASK;                          	                                          	                
+    	ulCtrlData |= CE_HIGH | USERMODE;
+   	 *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+    	udelay(200);
+	
+} /* enable4b_spansion */
+
+static void enable4b_numonyx (flash_info_t * info)
+{
+	ulong base;
+    	ulong ulSMMBase, ulCtrlData, CtrlOffset;
+    	uchar jReg;
+        
+    	if (info->CE == 2)
+    	{
+            CtrlOffset = SPICtrlRegOffset2;
+    	}    
+    	else
+    	{
+            CtrlOffset = SPICtrlRegOffset;
+    	}    
+    
+	//base = info->start[0];
+	base = flash_make_addr (info, 0, 0);
+
+	/* Enable Write */
+	enable_write (info);
+	
+	/* Enable 4B: CMD:0xB7 */
+    	ulCtrlData  = (info->tCK_Write << 8);
+    	ulCtrlData |= CE_LOW | USERMODE;
+    	*(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+    	udelay(200);
+    	*(uchar *) (base) = (uchar) (0xB7);
+    	udelay(10);
+    	ulCtrlData &= CMD_MASK;                          	                
+    	ulCtrlData |= CE_HIGH | USERMODE;
+    	*(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+    	udelay(200);
+
+} /* enable4b_numonyx */
+
+/*
+ *
+ */
+static ulong flash_get_size (ulong base, int banknum)
+{
+	flash_info_t *info = &flash_info[banknum];
+	int j;
+	unsigned long sector;
+	int erase_region_size;
+        ulong ulCtrlData, CtrlOffset;
+        ulong ulID;
+        uchar ch[3];
+        ulong cpuclk, div, reg;
+        ulong WriteClk, EraseClk, ReadClk;
+        ulong vbase;
+        ulong SCURevision;
+
+        ulong ulRefPLL;
+        ulong ulDeNumerator;
+        ulong ulNumerator;
+        ulong ulOD;                    
+                  
+        disable_cache();
+        
+	info->start[0] = base;
+	vbase = flash_make_addr (info, 0, 0);
+
+#if	defined(CONFIG_FLASH_AST2300) || defined(CONFIG_AST1300)
+        CtrlOffset = SPICtrlRegOffset;        	
+        info->CE = 0;                	
+#else
+        if (vbase == PHYS_FLASH_1)
+        {
+            CtrlOffset = SPICtrlRegOffset2;
+            info->CE = 2;
+        }    
+        else
+        {
+            CtrlOffset = SPICtrlRegOffset;        	
+            info->CE = 0;        	
+        }    
+#endif
+            
+        /* Get Flash ID */
+        ulCtrlData  = *(ulong *) (STCBaseAddress + CtrlOffset) & CMD_MASK;        
+        ulCtrlData |= CE_LOW | USERMODE;
+        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+        udelay(200);
+        *(uchar *) (vbase) = (uchar) (0x9F);
+        udelay(10);
+        ch[0] = *(volatile uchar *)(vbase);
+        udelay(10);
+        ch[1] = *(volatile uchar *)(vbase);
+        udelay(10);
+        ch[2] = *(volatile uchar *)(vbase);
+        udelay(10);               
+        ulCtrlData  = *(ulong *) (STCBaseAddress + CtrlOffset) & CMD_MASK;        
+        ulCtrlData |= CE_HIGH | USERMODE;
+        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+        udelay(200);
+        ulID = ((ulong)ch[0]) | ((ulong)ch[1] << 8) | ((ulong)ch[2] << 16) ;        
+        info->flash_id = ulID;
+        
+        //printf("SPI Flash ID: %x \n", ulID);
+
+        /* init default */        
+        info->iomode = IOMODEx1;
+        info->address32 = 0;
+        info->quadport = 0;
+        info->specificspi = 0;
+
+        switch (info->flash_id)
+        {
+        case STM25P64:
+	    info->sector_count = 128;
+	    info->size = 0x800000;        	
+            erase_region_size  = 0x10000;
+            info->readcmd = 0x0b;
+            info->dualport = 0;
+            info->dummybyte = 1;
+            info->buffersize = 256;
+            WriteClk = 40;
+            EraseClk = 20;
+            ReadClk  = 40;
+            break;
+
+        case STM25P128:
+	    info->sector_count = 64;
+	    info->size = 0x1000000;        	
+            erase_region_size  = 0x40000;
+            info->readcmd = 0x0b;            
+            info->dualport = 0;
+            info->dummybyte = 1;
+            info->buffersize = 256;            
+            WriteClk = 50;
+            EraseClk = 20;
+            ReadClk  = 50;
+            break;
+            
+        case N25Q256:
+	    info->sector_count = 256;
+	    info->size = 0x1000000;        	
+            erase_region_size  = 0x10000;
+            info->readcmd = 0x0b;            
+            info->dualport = 0;
+            info->dummybyte = 1;
+            info->buffersize = 256;            
+            WriteClk = 50;
+            EraseClk = 20;
+            ReadClk  = 50;
+#if	defined(CONFIG_FLASH_AST2300) || defined(CONFIG_AST1300)
+	    info->sector_count = 512;
+	    info->size = 0x2000000;
+	    info->address32 = 1;        	
+#endif
+	    break;
+
+        case N25Q512:
+	    info->sector_count = 256;
+	    info->size = 0x1000000;        	
+            erase_region_size  = 0x10000;
+            info->readcmd = 0x0b;            
+            info->dualport = 0;
+            info->dummybyte = 1;
+            info->buffersize = 256; 
+            info->specificspi = SpecificSPI_N25Q512;           
+            WriteClk = 50;
+            EraseClk = 20;
+            ReadClk  = 50;
+#if	defined(CONFIG_FLASH_AST2300) || defined(CONFIG_AST1300)
+	    info->sector_count = 1024;
+	    info->size = 0x4000000;
+	    info->address32 = 1;        	
+#endif
+	    break;
+	    	    	                            
+        case W25X16:
+	    info->sector_count = 32;
+	    info->size = 0x200000;        	
+            erase_region_size  = 0x10000;
+            info->readcmd = 0x3b;            
+            info->dualport = 1;            
+            info->dummybyte = 1;
+            info->iomode = IOMODEx2; 
+            info->buffersize = 256;                                   
+            WriteClk = 50;
+            EraseClk = 25;
+            ReadClk  = 50;            
+            break;
+            
+        case W25X64:
+	    info->sector_count = 128;
+	    info->size = 0x800000;        	
+            erase_region_size  = 0x10000;
+            info->readcmd = 0x3b;            
+            info->dualport = 1;            
+            info->dummybyte = 1;
+            info->iomode = IOMODEx2;
+            info->buffersize = 256;                                    
+            WriteClk = 50;
+            EraseClk = 25;
+            ReadClk  = 50;            
+            break;
+
+        case W25Q64BV:
+	    info->sector_count = 128;
+	    info->size = 0x800000;        	
+            erase_region_size  = 0x10000;
+            info->readcmd = 0x3b;            
+            info->dualport = 1;            
+            info->dummybyte = 1;
+            info->iomode = IOMODEx2; 
+            info->buffersize = 256;                                   
+            WriteClk = 80;
+            EraseClk = 40;
+            ReadClk  = 80;
+            break;
+            
+        case W25Q128BV:
+	    info->sector_count = 256;
+	    info->size = 0x1000000;        	
+            erase_region_size  = 0x10000;
+            info->readcmd = 0x3b;            
+            info->dualport = 1;            
+            info->dummybyte = 1;
+            info->iomode = IOMODEx2; 
+            info->buffersize = 256;                                   
+            WriteClk = 104;
+            EraseClk = 50;
+            ReadClk  = 104;
+            break;
+
+        case W25Q256FV:
+	    info->sector_count = 256;
+	    info->size = 0x1000000;        	
+            erase_region_size  = 0x10000;
+            info->readcmd = 0x0b;            
+            info->dualport = 0;
+            info->dummybyte = 1;
+            info->buffersize = 256;            
+            WriteClk = 50;
+            EraseClk = 20;
+            ReadClk  = 50;
+#if	defined(CONFIG_FLASH_AST2300) || defined(CONFIG_AST1300)
+	    info->sector_count = 512;
+	    info->size = 0x2000000;
+	    info->address32 = 1;        	
+#endif
+	    break;
+	                
+        case S25FL064A:
+	    info->sector_count = 128;
+	    info->size = 0x800000;        	
+            erase_region_size  = 0x10000;
+            info->readcmd = 0x0b;            
+            info->dualport = 0;            
+            info->dummybyte = 1;
+            info->buffersize = 256;            
+            WriteClk = 50;
+            EraseClk = 25;
+            ReadClk  = 50;            
+            break;
+
+        case S25FL128P:
+	    info->sector_count = 256;
+	    info->size = 0x1000000;        	
+            erase_region_size  = 0x10000;
+            info->readcmd = 0x0b;            
+            info->dualport = 0;            
+            info->dummybyte = 1;
+            info->buffersize = 256;            
+            WriteClk = 100;
+            EraseClk = 40;
+            ReadClk  = 100;            
+            break;
+
+        case S25FL256S:
+	    info->sector_count = 256;
+	    info->size = 0x1000000;        	
+            erase_region_size  = 0x10000;
+            info->readcmd = 0x0b;            
+            info->dualport = 0;
+            info->dummybyte = 1;
+            info->buffersize = 256;            
+            WriteClk = 50;
+            EraseClk = 20;
+            ReadClk  = 50;
+#if	defined(CONFIG_FLASH_AST2300) || defined(CONFIG_AST1300)
+	    info->sector_count = 512;
+	    info->size = 0x2000000;
+	    info->address32 = 1;        	
+#endif
+	    break;
+
+        case MX25L25635E:
+	    info->sector_count = 256;
+	    info->size = 0x1000000;        	
+            erase_region_size  = 0x10000;
+            info->readcmd = 0x0b;            
+            info->dualport = 0;
+            info->dummybyte = 1;
+            info->buffersize = 256;            
+            WriteClk = 50;
+            EraseClk = 20;
+            ReadClk  = 50;
+#if	defined(CONFIG_FLASH_AST2300) || defined(CONFIG_AST1300)
+	    info->sector_count = 512;
+	    info->size = 0x2000000;
+	    info->address32 = 1;        	
+#if	defined(CONFIG_FLASH_SPIx2_Dummy)
+            info->readcmd = 0xbb;            
+            info->dummybyte = 1;
+            info->dualport = 1;            
+            info->iomode = IOMODEx2_dummy;
+#elif	defined(CONFIG_FLASH_SPIx4_Dummy)
+            info->readcmd = 0xeb;            
+            info->dummybyte = 3;
+            info->dualport = 0;            
+            info->iomode = IOMODEx4_dummy;
+            info->quadport = 1;
+            info->dummydata = 0xaa;            
+#endif            
+#endif             
+            break;
+
+        case MX25L12805D:
+	    info->sector_count = 256;
+	    info->size = 0x1000000;        	
+            erase_region_size  = 0x10000;
+            info->readcmd = 0x0b;            
+            info->dualport = 0;
+            info->dummybyte = 1;
+            info->buffersize = 256;            
+/*
+SCU7C: Silicon Revision ID Register
+D[31:24]: Chip ID
+0: AST2050/AST2100/AST2150/AST2200/AST3000
+1: AST2300
+
+D[23:16] Silicon revision ID for AST2300 generation and later
+0: A0
+1: A1
+2: A2
+.
+.
+.
+FPGA revision starts from 0x80
+
+AST2300 A0 SPI can't run faster than 50Mhz
+*/
+            WriteClk = 50;
+            EraseClk = 20;
+            ReadClk  = 50;
+
+            SCURevision = *(ulong *) (SCU_REVISION_REGISTER);
+            if (((SCURevision >> 24) & 0xff) == 0x01) { //AST2300
+            	if (((SCURevision >> 16) & 0xff) == 0x00) { //A0
+            		WriteClk = 25;
+            		EraseClk = 20;
+            		ReadClk  = 25;
+            	}
+            }
+#if	defined(CONFIG_FLASH_AST2300) || defined(CONFIG_AST1300)
+#if	defined(CONFIG_FLASH_SPIx2_Dummy)
+            info->readcmd = 0xbb;            
+            info->dummybyte = 1;
+            info->dualport = 1;            
+            info->iomode = IOMODEx2_dummy;
+#elif	defined(CONFIG_FLASH_SPIx4_Dummy)
+            info->readcmd = 0xeb;            
+            info->dummybyte = 3;
+            info->dualport = 0;            
+            info->iomode = IOMODEx4_dummy;
+            info->quadport = 1;
+            info->dummydata = 0xaa;            
+#endif            
+#endif             
+            break;
+
+        case MX25L1605D:
+	    info->sector_count = 32;
+	    info->size = 0x200000;        	
+            erase_region_size  = 0x10000;
+            info->readcmd = 0x0b;            
+            info->dualport = 0;
+            info->dummybyte = 1;
+            info->buffersize = 256;            
+            WriteClk = 50;
+            EraseClk = 20;
+            ReadClk  = 50;
+            break;
+
+        case SST25VF016B:
+	    info->sector_count = 32;
+	    info->size = 0x200000;        	
+            erase_region_size  = 0x10000;
+            info->readcmd = 0x0b;            
+            info->dualport = 0;            
+            info->dummybyte = 1;
+            info->buffersize = 1;            
+            WriteClk = 50;
+            EraseClk = 25;
+            ReadClk  = 50;            
+            break;
+
+        case SST25VF064C:
+	    info->sector_count = 128;
+	    info->size = 0x800000;        	
+            erase_region_size  = 0x10000;
+            info->readcmd = 0x0b;            
+            info->dualport = 0;            
+            info->dummybyte = 1;
+            info->buffersize = 1;            
+            WriteClk = 50;
+            EraseClk = 25;
+            ReadClk  = 50;            
+            break;
+
+        case AT25DF161:
+	    info->sector_count = 32;
+	    info->size = 0x200000;        	
+            erase_region_size  = 0x10000;
+            info->readcmd = 0x0b;            
+            info->dualport = 0;            
+            info->dummybyte = 1;
+            info->buffersize = 1;            
+            WriteClk = 50;
+            EraseClk = 25;
+            ReadClk  = 50;            
+            break;
+ 
+        case AT25DF321:
+	    info->sector_count = 32;
+	    info->size = 0x400000;        	
+            erase_region_size  = 0x10000;
+            info->readcmd = 0x0b;            
+            info->dualport = 0;            
+            info->dummybyte = 1;
+            info->buffersize = 1;            
+            WriteClk = 50;
+            EraseClk = 25;
+            ReadClk  = 50;            
+            break;
+                                                                      
+        default:	/* use JEDEC ID */
+            erase_region_size  = 0x10000;
+            info->readcmd = 0x0b;                        
+            info->dualport  = 0;            
+            info->dummybyte = 1;
+            info->buffersize = 1;            
+            WriteClk = 50;
+            EraseClk = 25;
+            ReadClk  = 50;  
+            if ((info->flash_id & 0xFF) == 0x1F)	/* Atmel */
+            {
+                switch (info->flash_id & 0x001F00)
+                {
+                case 0x000400:	
+        	    info->sector_count = 8;
+    	            info->size = 0x80000;        	
+	            break;	            	                
+                case 0x000500:	
+        	    info->sector_count = 16;
+    	            info->size = 0x100000;        	
+	            break;	            	                
+                case 0x000600:	
+        	    info->sector_count = 32;
+    	            info->size = 0x200000;        	
+	            break;
+                case 0x000700:	
+        	    info->sector_count = 64;
+    	            info->size = 0x400000;        	
+	            break;
+                case 0x000800:	
+        	    info->sector_count = 128;
+    	            info->size = 0x800000;        	
+	            break;	            
+                case 0x000900:	
+        	    info->sector_count = 256;
+    	            info->size = 0x1000000;        	
+	            break;	            	            
+                default:
+                    printf("Can't support this SPI Flash!! \n");
+                    return 0;	            
+                }   	            
+            } /* Atmel JDEC */        
+            else	/* JDEC */				
+            {
+                switch (info->flash_id & 0xFF0000)
+                {
+                case 0x120000:	
+        	    info->sector_count = 4;
+    	            info->size = 0x40000;        	
+	            break;
+                case 0x130000:	
+	            info->sector_count = 8;
+	            info->size = 0x80000;        	
+	            break;
+                case 0x140000:	
+	            info->sector_count =16;
+	            info->size = 0x100000;        	
+	            break;
+                case 0x150000:	
+	            info->sector_count =32;
+	            info->size = 0x200000;        	
+	            break;
+                case 0x160000:	
+	            info->sector_count =64;
+	            info->size = 0x400000;        	
+	            break;
+                case 0x170000:	
+	            info->sector_count =128;
+	            info->size = 0x800000;        	
+	            break;
+                case 0x180000:	
+	            info->sector_count =256;
+	            info->size = 0x1000000;        	
+	            break;
+                case 0x190000:	
+	            info->sector_count =256;
+	            info->size = 0x1000000;
+#if	defined(CONFIG_FLASH_AST2300) || defined(CONFIG_AST1300)
+	            info->sector_count = 512;
+	            info->size = 0x2000000;
+	            info->address32 = 1;        	
+#if	defined(CONFIG_FLASH_SPIx2_Dummy)
+                    info->readcmd = 0xbb;            
+                    info->dummybyte = 1;
+                    info->dualport = 1;            
+                    info->iomode = IOMODEx2_dummy;
+#elif	defined(CONFIG_FLASH_SPIx4_Dummy)
+                    info->readcmd = 0xeb;            
+                    info->dummybyte = 3;
+                    info->dualport = 0;            
+                    info->iomode = IOMODEx4_dummy;
+                    info->quadport = 1;
+                    info->dummydata = 0xaa;            
+#endif            
+#endif             	                	
+	            break;
+	            
+                case 0x200000:	
+	            info->sector_count =256;
+	            info->size = 0x1000000;
+                    if ((info->flash_id & 0xFF) == 0x20)	/* numonyx */
+                        info->specificspi = SpecificSPI_N25Q512;
+#if	defined(CONFIG_FLASH_AST2300) || defined(CONFIG_AST1300)
+	            info->sector_count = 1024;
+	            info->size = 0x4000000;
+	            info->address32 = 1;        	
+#if	defined(CONFIG_FLASH_SPIx2_Dummy)
+                    info->readcmd = 0xbb;            
+                    info->dummybyte = 1;
+                    info->dualport = 1;            
+                    info->iomode = IOMODEx2_dummy;
+#elif	defined(CONFIG_FLASH_SPIx4_Dummy)
+                    info->readcmd = 0xeb;            
+                    info->dummybyte = 3;
+                    info->dualport = 0;            
+                    info->iomode = IOMODEx4_dummy;
+                    info->quadport = 1;
+                    info->dummydata = 0xaa;            
+#endif            
+#endif             	                	
+	            break;
+	            	        	            	        
+                default:
+                    printf("Can't support this SPI Flash!! \n");
+                    return 0;
+                }    
+            } /* JDEC */        
+        }
+        				
+        debug ("erase_region_count = %d erase_region_size = %d\n",
+		erase_region_count, erase_region_size);
+
+	sector = base;			
+	for (j = 0; j < info->sector_count; j++) {
+		
+		info->start[j] = sector;
+		sector += erase_region_size;
+		info->protect[j] = 0; /* default: not protected */
+	}
+
+        /* set SPI flash extended info */
+#if 	defined(CONFIG_AST1300)
+	if (info->size > 0x200000)	/* limit MAX Flash to 2MB for AST1300 */
+	    info->size = 0x200000;
+#endif
+#if	defined(CONFIG_AST2400) || defined(CONFIG_AST2300) || defined(CONFIG_AST2300_FPGA_1) || defined(CONFIG_AST2300_FPGA_2) || defined(CONFIG_AST1300)
+        reg = *((volatile ulong*) 0x1e6e2024);
+        if (reg & 0x40000)
+        {
+            reg = *((volatile ulong*) 0x1e6e2070);	        
+	        
+            ulRefPLL = 24;
+            ulDeNumerator = reg & 0x0F;
+            ulNumerator = (reg & 0x07E0) >> 5;
+            ulOD = (reg & 0x10) ? 1:2;                    
+     	    
+            cpuclk = ulRefPLL * ulOD * (ulNumerator + 2) / (ulDeNumerator + 1);    
+        }        
+        else
+        {
+            reg = *((volatile ulong*) 0x1e6e2070);	        
+#if	defined(CONFIG_AST2400)
+            if (reg & 0x00800000)	//ref. clk:25MHz
+            {
+                switch (reg & 0x300)
+                {
+                case 0x000:
+                    cpuclk = 400;
+                    break;
+                case 0x100:
+                    cpuclk = 375;
+                    break;        
+                case 0x200:
+                    cpuclk = 350;
+                    break;        
+                case 0x300:
+                    cpuclk = 325;
+                    break;
+                }	            	            
+            }        
+            else
+            {
+                switch (reg & 0x300)	//ref. clk:24MHz
+                {
+                case 0x000:
+                    cpuclk = 384;
+                    break;
+                case 0x100:
+                    cpuclk = 360;
+                    break;        
+                case 0x200:
+                    cpuclk = 336;
+                    break;        
+                case 0x300:
+                    cpuclk = 312;
+                    break;
+                }	            
+            }
+#else	        
+            switch (reg & 0x300)
+            {
+            case 0x000:
+                 cpuclk = 384;
+                 break;
+            case 0x100:
+                 cpuclk = 360;
+                 break;        
+            case 0x200:
+                 cpuclk = 336;
+                 break;        
+            case 0x300:
+                 cpuclk = 408;
+                 break;
+            }
+#endif            
+        }	
+        
+        reg = *((volatile ulong*) 0x1e6e2070);        
+        switch (reg & 0xc00)
+        {
+        case 0x000:
+                 cpuclk /= 1;
+                 break;
+        case 0x400:
+                 cpuclk /= 2;
+                 break;        
+        case 0x800:	
+                 cpuclk /= 4;
+                 break;
+        case 0xC00:	
+                 cpuclk /= 3;
+                 break;                                 
+        }
+#else	/* AST2100 */        
+        reg = *((volatile ulong*) 0x1e6e2070);
+        switch (reg & 0xe00)
+        {
+        case 0x000:
+                 cpuclk = 266;
+                 break;
+        case 0x200:
+                 cpuclk = 233;
+                 break;        
+        case 0x400:
+                 cpuclk = 200;
+                 break;        
+        case 0x600:
+                 cpuclk = 166;
+                 break;        
+        case 0x800:
+                 cpuclk = 133;
+                 break;        
+        case 0xA00:
+                 cpuclk = 100;
+                 break;        
+        case 0xC00:
+                 cpuclk = 300;
+                 break;        
+        case 0xE00:	
+                 cpuclk = 24;
+                 break;        
+        }	
+        switch (reg & 0x3000)
+        {
+        case 0x1000:
+                 cpuclk /= 2;
+                 break;
+        case 0x2000:
+                 cpuclk /= 4;
+                 break;        
+        case 0x3000:	
+                 cpuclk /= 3;
+                 break;        
+        }
+#endif
+
+#if	defined(CONFIG_AST2400) || defined(CONFIG_AST2300) || defined(CONFIG_AST2300_FPGA_1) || defined(CONFIG_AST2300_FPGA_2) || defined(CONFIG_AST1300)
+
+#if     defined(CONFIG_AST2300) || defined(CONFIG_AST1300)
+        /* limit Max SPI CLK to 50MHz (Datasheet v1.2) */
+        if (WriteClk > 50) WriteClk = 50;
+        if (EraseClk > 50) EraseClk = 50;
+        if (ReadClk > 50)  ReadClk  = 50;
+#endif
+
+        div = 1;
+        while ( ((cpuclk/div) > WriteClk) && (div < 16) )
+        {
+            div++;	
+        }
+        info->tCK_Write = AST2300_SPICLK_DIV[div-1];
+        
+        div = 1;
+        while ( ((cpuclk/div) > EraseClk) && (div < 16) )
+        {
+            div++;	
+        }        
+        info->tCK_Erase = AST2300_SPICLK_DIV[div-1];
+
+        div = 1;
+        while ( ((cpuclk/div) > ReadClk) && (div < 16) )
+        {
+            div++;	
+        }        
+        info->tCK_Read = AST2300_SPICLK_DIV[div-1];
+#else        	
+        div = 2;
+        info->tCK_Write = 7;
+        while ( (cpuclk/div) > WriteClk )
+        {
+            info->tCK_Write--;	
+            div +=2;	
+        }
+        div = 2;
+        info->tCK_Erase = 7;
+        while ( (cpuclk/div) > EraseClk )
+        {
+            info->tCK_Erase--;	
+            div +=2;	
+        }
+        div = 2;
+        info->tCK_Read = 7;
+        while ( (cpuclk/div) > ReadClk )
+        {
+            info->tCK_Read--;	
+            div +=2;	
+        }
+#endif
+	
+	/* unprotect flash */	
+        write_status_register(info, 0);
+
+        if (info->quadport)
+            write_status_register(info, 0x40);	/* enable QE */
+
+        if (info->address32)	 
+        {          
+            reg = *((volatile ulong*) 0x1e6e2070);	/* set H/W Trappings */
+            reg |= 0x10;
+            *((volatile ulong*) 0x1e6e2070) = reg;
+            
+            reg  = *((volatile ulong*) 0x1e620004);	/* enable 32b control bit*/
+            reg |= (0x01 << info->CE);
+            *((volatile ulong*) 0x1e620004) = reg;
+            
+            /* set flash chips to 32bits addressing mode */
+            if ((info->flash_id & 0xFF) == 0x01)	/* Spansion */
+                enable4b_spansion(info);
+            else if ((info->flash_id & 0xFF) == 0x20)	/* Numonyx */
+                enable4b_numonyx(info);                
+            else /* MXIC, Winbond */
+                enable4b(info);                
+                
+        }    
+                    
+        reset_flash(info);
+        
+	return (info->size);
+}
+
+
+/*-----------------------------------------------------------------------
+ */
+static int flash_write_buffer (flash_info_t *info, uchar *src, ulong addr, int len)
+{
+        ulong j, base, offset;
+        ulong ulSMMBase, ulCtrlData, CtrlOffset;
+        uchar jReg;
+
+        if (info->CE == 2)
+        {
+            CtrlOffset = SPICtrlRegOffset2;
+        }    
+        else
+        {
+            CtrlOffset = SPICtrlRegOffset;
+        }    
+            
+	base = info->start[0];
+	offset = addr - base;
+	base = flash_make_addr (info, 0, 0);
+	
+        enable_write (info);
+
+        ulCtrlData  = (info->tCK_Write << 8);
+
+        ulCtrlData &= CMD_MASK;
+        ulCtrlData |= CE_LOW | USERMODE;
+        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+        udelay(200);
+        *(uchar *) (base) = (uchar) (0x02);
+        udelay(10);
+        if (info->address32)
+        {
+            *(uchar *) (base) = (uchar) ((offset & 0xff000000) >> 24);
+            udelay(10);
+        }
+        *(uchar *) (base) = (uchar) ((offset & 0xff0000) >> 16);
+        udelay(10);
+        *(uchar *) (base) = (uchar) ((offset & 0x00ff00) >> 8);
+        udelay(10);
+        *(uchar *) (base) = (uchar) ((offset & 0x0000ff));
+        udelay(10);
+
+        for (j=0; j<len; j++)
+        {
+            *(uchar *) (base) = *(uchar *) (src++);
+            udelay(10);
+        }    
+                 
+        ulCtrlData &= CMD_MASK;
+        ulCtrlData |= CE_HIGH | USERMODE;
+        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+        udelay(200);
+
+        ulCtrlData &= CMD_MASK;
+        ulCtrlData |= CE_LOW | USERMODE;
+        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+        udelay(200);
+        *(uchar *) (base) = (uchar) (0x05);
+        udelay(10);
+        do {                             
+            jReg = *(volatile uchar *) (base);
+        } while ((jReg & 0x01));
+        ulCtrlData &= CMD_MASK;
+        ulCtrlData |= CE_HIGH | USERMODE;
+        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+        udelay(200);
+
+        /* RFSR */
+        if (info->specificspi == SpecificSPI_N25Q512)
+        {
+            ulCtrlData &= CMD_MASK;
+            ulCtrlData |= CE_LOW | USERMODE;
+            *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+            udelay(200);
+            *(uchar *) (base) = (uchar) (0x70);
+            udelay(10);
+            do {                                                            
+                jReg = *(volatile uchar *) (base);
+            } while (!(jReg & 0x80));
+            ulCtrlData &= CMD_MASK;
+            ulCtrlData |= CE_HIGH | USERMODE;
+            *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+            udelay(200);
+        }           
+}	
+
+/*-----------------------------------------------------------------------
+ *
+ * export functions
+ *  
+ */
+ 
+/*-----------------------------------------------------------------------
+ * 
+ */
+unsigned long flash_init (void)
+{
+	unsigned long size = 0;
+	int i;
+
+	/* Init: no FLASHes known */
+	for (i = 0; i < CONFIG_SYS_MAX_FLASH_BANKS; ++i) {
+		flash_info[i].flash_id = FLASH_UNKNOWN;
+		size += flash_info[i].size = flash_get_size (bank_base[i], i);
+		if (flash_info[i].flash_id == FLASH_UNKNOWN) {
+#ifndef CFG_FLASH_QUIET_TEST
+			printf ("## Unknown FLASH on Bank %d - Size = 0x%08lx = %ld MB\n",
+				i, flash_info[i].size, flash_info[i].size << 20);
+#endif /* CFG_FLASH_QUIET_TEST */
+		}
+	}
+
+	/* Monitor protection ON by default */
+#if (CONFIG_MONITOR_BASE >= CONFIG_SYS_FLASH_BASE)
+	flash_protect (FLAG_PROTECT_SET,
+		       CONFIG_MONITOR_BASE,
+		       CONFIG_MONITOR_BASE + monitor_flash_len  - 1,
+		       flash_get_info(CONFIG_MONITOR_BASE));
+#endif
+
+	/* Environment protection ON by default */
+#ifdef CONFIG_ENV_IS_IN_FLASH
+	flash_protect (FLAG_PROTECT_SET,
+		       CONFIG_ENV_ADDR,
+		       CONFIG_ENV_ADDR + CONFIG_ENV_SECT_SIZE - 1,
+		       flash_get_info(CONFIG_ENV_ADDR));
+#endif
+
+	/* Redundant environment protection ON by default */
+#ifdef CONFIG_ENV_ADDR_REDUND
+	flash_protect (FLAG_PROTECT_SET,
+		       CONFIG_ENV_ADDR_REDUND,
+		       CONFIG_ENV_ADDR_REDUND + CONFIG_ENV_SIZE_REDUND - 1,
+		       flash_get_info(CONFIG_ENV_ADDR_REDUND));
+#endif
+	return (size);
+}
+
+/*-----------------------------------------------------------------------
+ */
+#if defined(CONFIG_ENV_IS_IN_FLASH) || defined(CONFIG_ENV_ADDR_REDUND) || (CONFIG_MONITOR_BASE >= CONFIG_SYS_FLASH_BASE)
+static flash_info_t *flash_get_info(ulong base)
+{
+	int i;
+	flash_info_t * info = 0;
+
+	for (i = 0; i < CONFIG_SYS_MAX_FLASH_BANKS; i ++) {
+		info = & flash_info[i];
+		if (info->size && info->start[0] <= base &&
+		    base <= info->start[0] + info->size - 1)
+			break;
+	}
+
+	return i == CONFIG_SYS_MAX_FLASH_BANKS ? 0 : info;
+}
+#endif
+
+/*-----------------------------------------------------------------------
+ */
+int flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+	int rcode = 0;
+	int prot;
+	flash_sect_t sect;
+
+        ulong base, offset;
+        ulong ulSMMBase, ulCtrlData, CtrlOffset;
+        uchar jReg;
+        
+        disable_cache();
+        
+        if (info->CE == 2)
+        {
+            CtrlOffset = SPICtrlRegOffset2;
+        }    
+        else
+        {
+            CtrlOffset = SPICtrlRegOffset;
+        }    
+                    
+	if ((s_first < 0) || (s_first > s_last)) {
+		puts ("- no sectors to erase\n");
+		return 1;
+	}
+
+	prot = 0;
+	for (sect = s_first; sect <= s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+	if (prot) {
+		printf ("- Warning: %d protected sectors will not be erased!\n", prot);
+	} else {
+		putc ('\n');
+	}
+
+        ulCtrlData  = (info->tCK_Erase << 8);
+	for (sect = s_first; sect <= s_last; sect++) {
+		if (info->protect[sect] == 0) { /* not protected */
+                        /* start erasing */
+                        enable_write(info);
+
+	                base = info->start[0];
+                        offset = info->start[sect] - base;
+	                base = flash_make_addr (info, 0, 0);
+
+                        ulCtrlData &= CMD_MASK;
+                        ulCtrlData |= CE_LOW | USERMODE;
+                        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+                        udelay(200);
+                        *(uchar *) (base) = (uchar) (0xd8);
+                        udelay(10);
+                        if (info->address32)
+                        { 
+                            *(uchar *) (base) = (uchar) ((offset & 0xff000000) >> 24);
+                            udelay(10);
+                        }                        
+                        *(uchar *) (base) = (uchar) ((offset & 0xff0000) >> 16);
+                        udelay(10);
+                        *(uchar *) (base) = (uchar) ((offset & 0x00ff00) >> 8);
+                        udelay(10);
+                        *(uchar *) (base) = (uchar) ((offset & 0x0000ff));
+                        udelay(10);
+
+                        ulCtrlData &= CMD_MASK;
+                        ulCtrlData |= CE_HIGH | USERMODE;
+                        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+                        udelay(200);
+
+                        ulCtrlData &= CMD_MASK;
+                        ulCtrlData |= CE_LOW | USERMODE;
+                        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+                        udelay(200);
+                        *(uchar *) (base) = (uchar) (0x05);
+                        udelay(10);
+                        do {                                                            
+                            jReg = *(volatile uchar *) (base);
+                        } while ((jReg & 0x01));
+                        ulCtrlData &= CMD_MASK;
+                        ulCtrlData |= CE_HIGH | USERMODE;
+                        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+                        udelay(200);
+
+                        /* RFSR */
+                        if (info->specificspi == SpecificSPI_N25Q512)
+                        {
+                            ulCtrlData &= CMD_MASK;
+                            ulCtrlData |= CE_LOW | USERMODE;
+                            *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+                            udelay(200);
+                            *(uchar *) (base) = (uchar) (0x70);
+                            udelay(10);
+                            do {                                                            
+                                jReg = *(volatile uchar *) (base);
+                            } while (!(jReg & 0x80));
+                            ulCtrlData &= CMD_MASK;
+                            ulCtrlData |= CE_HIGH | USERMODE;
+                            *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+                            udelay(200);
+                        }   
+                        
+			putc ('.');
+		}
+	}
+	puts (" done\n");
+	
+	reset_flash(info);
+	
+	return rcode;
+}
+
+/*-----------------------------------------------------------------------
+ */
+void flash_print_info (flash_info_t * info)
+{
+	putc ('\n');
+	return;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash, returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ */
+int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+	int count;
+	unsigned char pat[] = {'|', '-', '/', '\\'};
+	int patcnt;
+	
+        disable_cache();	
+        
+	/* get lower aligned address */	
+        if (addr & (info->buffersize - 1))
+        {
+            count = cnt >= info->buffersize ? (info->buffersize - (addr & 0xff)):cnt;	
+            flash_write_buffer (info, src, addr, count);
+            addr+= count;
+            src += count;
+            cnt -= count;	
+        }
+	
+	/* prog */		
+	while (cnt > 0) {				
+	    count = cnt >= info->buffersize ? info->buffersize:cnt;
+            flash_write_buffer (info, src, addr, count);
+            addr+= count;
+            src += count;
+            cnt -= count;
+            printf("%c\b", pat[(patcnt++) & 0x03]);            	     	
+	} 		
+
+	reset_flash(info);
+
+        return (0);
+}
+
+#ifdef	CONFIG_FLASH_AST2300_DMA
+void * memmove_dma(void * dest,const void *src,size_t count)
+{
+	ulong count_align, poll_time, data;
+	
+	count_align = (count + 3) & 0xFFFFFFFC;	/* 4-bytes align */
+        poll_time = 100;			/* set 100 us as default */
+
+        /* force end of burst read */
+	*(volatile ulong *) (STCBaseAddress + SPICtrlRegOffset) |= CE_HIGH;
+	*(volatile ulong *) (STCBaseAddress + SPICtrlRegOffset) &= ~CE_HIGH;
+          
+	*(ulong *) (STCBaseAddress + REG_FLASH_DMA_CONTROL) = (ulong) (~FLASH_DMA_ENABLE);	
+	*(ulong *) (STCBaseAddress + REG_FLASH_DMA_FLASH_BASE) = (ulong *) (src);
+	*(ulong *) (STCBaseAddress + REG_FLASH_DMA_DRAM_BASE) = (ulong *) (dest);
+	*(ulong *) (STCBaseAddress + REG_FLASH_DMA_LENGTH) = (ulong) (count_align);
+	*(ulong *) (STCBaseAddress + REG_FLASH_DMA_CONTROL) = (ulong) (FLASH_DMA_ENABLE);
+	
+	/* wait poll */
+	do {
+	    udelay(poll_time);	
+	    data = *(ulong *) (STCBaseAddress + REG_FLASH_INTERRUPT_STATUS);
+	} while (!(data & FLASH_STATUS_DMA_READY));
+	
+	/* clear status */
+	*(ulong *) (STCBaseAddress + REG_FLASH_INTERRUPT_STATUS) |= FLASH_STATUS_DMA_CLEAR;
+}	
+#endif
+#endif /* CONFIG_FLASH_SPI */
diff --git a/board/aspeed/ast2300/hactest.c b/board/aspeed/ast2300/hactest.c
new file mode 100755
index 0000000..bfa87d5
--- /dev/null
+++ b/board/aspeed/ast2300/hactest.c
@@ -0,0 +1,762 @@
+/*
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Diagnostics support
+ */
+#include <common.h>
+#include <command.h>
+#include <post.h>
+#include "slt.h"
+
+#if ((CFG_CMD_SLT & CFG_CMD_HACTEST) && defined(CONFIG_SLT))
+#include "hactest.h"
+
+#include "aes.c"
+#include "rc4.c"
+
+static unsigned char crypto_src[CRYPTO_MAX_SRC], crypto_dst[CRYPTO_MAX_DST], crypto_context[CRYPTO_MAX_CONTEXT];
+static unsigned char hash_src[HASH_MAX_SRC], hash_dst[HASH_MAX_DST], hmac_key[HMAC_MAX_KEY];
+
+/*
+ * table 
+ */
+static aes_test aestest[] = {
+    { CRYPTOMODE_ECB, 128,
+     {0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c, '\0'},
+     {0x32, 0x43, 0xf6, 0xa8, 0x88, 0x5a, 0x30, 0x8d, 0x31, 0x31, 0x98, 0xa2, 0xe0, 0x37, 0x07, 0x34, '\0'},
+     {0x39, 0x25, 0x84, 0x1d, 0x02, 0xdc, 0x09, 0xfb, 0xdc, 0x11, 0x85, 0x97, 0x19, 0x6a, 0x0b, 0x32, '\0'} },
+    {0xFF, 0xFF, "", "", ""},		/* End Mark */
+};
+
+static rc4_test rc4test[] = {
+    {{0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, '\0'},
+     {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, '\0'}}, 	
+    {{0xff}, {0xff}},				/* End Mark */	
+};
+
+static hash_test hashtest[] = {
+    {HASHMODE_SHA1, 20,
+     "abc",
+     {0x53, 0x20, 0xb0, 0x8c, 0xa1, 0xf5, 0x74, 0x62, 0x50, 0x71, 0x89, 0x41, 0xc5, 0x0a, 0xdf, 0x4e, 0xbb, 0x55, 0x76, 0x06, '\0'}},
+    {0xFF, 0xFF, "", ""},			/* End Mark */ 
+};
+
+static hmac_test hmactest[] = {
+    {HASHMODE_SHA1, 64, 20,
+     {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16,0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, '\0' },
+     "Sample #1",
+     {0xbf, 0x39, 0xda, 0xb1, 0x7d, 0xc2, 0xe1, 0x23, 0x0d, 0x28, 0x35, 0x3b, 0x8c, 0xcb, 0x14, 0xb6, 0x22, 0x02, 0x65, 0xb3, '\0'}},
+    {0xFF, 0xFF, 0xFF, "", "", ""},			/* End Mark */ 
+};
+
+void EnableHMAC(void)
+{
+    unsigned long ulData;
+    	
+    /* init SCU */
+    *(unsigned long *) (0x1e6e2000) = 0x1688a8a8;
+    
+    ulData = *(volatile unsigned long *) (0x1e6e200c);
+    ulData &= 0xfdfff;
+    *(unsigned long *) (0x1e6e200c) = ulData;
+    udelay(100);
+    ulData = *(volatile unsigned long *) (0x1e6e2004);
+    ulData &= 0xfffef;
+    *(unsigned long *) (0x1e6e2004) = ulData;
+    
+}
+
+/* AES */
+void aes_enc_ast3000(aes_context *ctx, uint8 *input, uint8 *iv, uint8 *output, uint32 ulMsgLength , uint32 ulAESMode)
+{
+
+    unsigned long i, ulTemp, ulCommand;
+    unsigned char ch;
+    unsigned char *pjsrc, *pjdst, *pjcontext;
+    
+    ulCommand = CRYPTO_ENABLE_RW | CRYPTO_ENABLE_CONTEXT_LOAD | CRYPTO_ENABLE_CONTEXT_SAVE | \
+                CRYPTO_AES | CRYPTO_ENCRYPTO | CRYPTO_SYNC_MODE_ASYNC;
+
+    switch (ctx->nr)
+    {
+    case 10:
+        ulCommand |= CRYPTO_AES128;
+        break;
+    case 12:
+        ulCommand |= CRYPTO_AES192;
+        break;    
+    case 14:
+        ulCommand |= CRYPTO_AES256;
+        break;    
+    }
+
+    switch (ulAESMode)
+    {
+    case CRYPTOMODE_ECB:
+        ulCommand |= CRYPTO_AES_ECB;
+        break;
+    case CRYPTOMODE_CBC:
+        ulCommand |= CRYPTO_AES_CBC;
+        break;
+    case CRYPTOMODE_CFB:
+        ulCommand |= CRYPTO_AES_CFB;
+        break;
+    case CRYPTOMODE_OFB:
+        ulCommand |= CRYPTO_AES_OFB;
+        break;
+    case CRYPTOMODE_CTR:
+        ulCommand |= CRYPTO_AES_CTR;
+        break;                
+    }
+
+    pjsrc = (unsigned char *) m16byteAlignment((unsigned long) crypto_src);
+    pjdst = (unsigned char *) m16byteAlignment((unsigned long) crypto_dst);
+    pjcontext = (unsigned char *) m16byteAlignment((unsigned long) crypto_context);
+    	
+    /* Init HW */
+    *(unsigned long *) (HAC_REG_BASE + REG_CRYPTO_SRC_BASE_OFFSET) = (unsigned long) pjsrc;
+    *(unsigned long *) (HAC_REG_BASE + REG_CRYPTO_DST_BASE_OFFSET) = (unsigned long) pjdst;
+    *(unsigned long *) (HAC_REG_BASE + REG_CRYPTO_CONTEXT_BASE_OFFSET) = (unsigned long) pjcontext;
+    *(unsigned long *) (HAC_REG_BASE + REG_CRYPTO_LEN_OFFSET) = ulMsgLength;
+
+    /* Set source */
+    for (i=0; i< ulMsgLength; i++)
+    {
+    	ch = *(uint8 *)(input + i);    	
+    	*(uint8 *) (pjsrc + i) = ch;
+    }
+     
+    /* Set Context */
+    /* Set IV */
+    for (i=0; i<16; i++)
+    {
+        ch = *(uint8 *) (iv + i);
+    	*(uint8 *) (pjcontext + i) = ch;
+    }
+       
+    /* Set Expansion Key */   
+    for (i=0; i<(4*(ctx->nr+1)); i++)
+    {
+        ulTemp = ((ctx->erk[i] & 0xFF) << 24) + ((ctx->erk[i] & 0xFF00) << 8) + ((ctx->erk[i] & 0xFF0000) >> 8) + ((ctx->erk[i] & 0xFF000000) >> 24);
+    	*(uint32 *) (pjcontext + i*4 + 16) = ulTemp;
+    }
+
+    /* fire cmd */
+    *(unsigned long *) (HAC_REG_BASE + REG_CRYPTO_CMD_BASE_OFFSET) = ulCommand;
+    do {
+        ulTemp = *(volatile unsigned long *) (HAC_REG_BASE + REG_CRYPTO_STATUS_OFFSET);
+    } while (ulTemp & CRYPTO_BUSY);	
+    
+    /* Output */
+    for (i=0; i<ulMsgLength; i++)
+    {
+        ch = *(uint8 *) (pjdst + i);        
+        *(uint8 *) (output + i) = ch;    
+    }
+    
+} /* aes_enc_ast3000 */
+
+
+void aes_dec_ast3000(aes_context *ctx, uint8 *input, uint8 *iv, uint8 *output, uint32 ulMsgLength , uint32 ulAESMode)
+{
+    unsigned long i, ulTemp, ulCommand;
+    unsigned char ch;
+    unsigned char *pjsrc, *pjdst, *pjcontext;
+    
+    ulCommand = CRYPTO_ENABLE_RW | CRYPTO_ENABLE_CONTEXT_LOAD | CRYPTO_ENABLE_CONTEXT_SAVE | \
+                CRYPTO_AES | CRYPTO_DECRYPTO | CRYPTO_SYNC_MODE_ASYNC;
+
+    switch (ctx->nr)
+    {
+    case 10:
+        ulCommand |= CRYPTO_AES128;
+        break;
+    case 12:
+        ulCommand |= CRYPTO_AES192;
+        break;    
+    case 14:
+        ulCommand |= CRYPTO_AES256;
+        break;    
+    }
+
+    switch (ulAESMode)
+    {
+    case CRYPTOMODE_ECB:
+        ulCommand |= CRYPTO_AES_ECB;
+        break;
+    case CRYPTOMODE_CBC:
+        ulCommand |= CRYPTO_AES_CBC;
+        break;
+    case CRYPTOMODE_CFB:
+        ulCommand |= CRYPTO_AES_CFB;
+        break;
+    case CRYPTOMODE_OFB:
+        ulCommand |= CRYPTO_AES_OFB;
+        break;
+    case CRYPTOMODE_CTR:
+        ulCommand |= CRYPTO_AES_CTR;
+        break;                
+    }
+
+    pjsrc = (unsigned char *) m16byteAlignment((unsigned long) crypto_src);
+    pjdst = (unsigned char *) m16byteAlignment((unsigned long) crypto_dst);
+    pjcontext = (unsigned char *) m16byteAlignment((unsigned long) crypto_context);
+	
+    /* Init HW */
+    *(unsigned long *) (HAC_REG_BASE + REG_CRYPTO_SRC_BASE_OFFSET) = (unsigned long) pjsrc;
+    *(unsigned long *) (HAC_REG_BASE + REG_CRYPTO_DST_BASE_OFFSET) = (unsigned long) pjdst;
+    *(unsigned long *) (HAC_REG_BASE + REG_CRYPTO_CONTEXT_BASE_OFFSET) = (unsigned long) pjcontext;
+    *(unsigned long *) (HAC_REG_BASE + REG_CRYPTO_LEN_OFFSET) = ulMsgLength;
+
+    /* Set source */
+    for (i=0; i< ulMsgLength; i++)
+    {
+    	ch = *(uint8 *)(input + i);    	
+    	*(uint8 *) (pjsrc + i) = ch;
+    }
+     
+    /* Set Context */
+    /* Set IV */
+    for (i=0; i<16; i++)
+    {
+        ch = *(uint8 *) (iv + i);
+    	*(uint8 *) (pjcontext + i) = ch;
+    }
+       
+    /* Set Expansion Key */   
+    for (i=0; i<(4*(ctx->nr+1)); i++)
+    {
+        ulTemp = ((ctx->erk[i] & 0xFF) << 24) + ((ctx->erk[i] & 0xFF00) << 8) + ((ctx->erk[i] & 0xFF0000) >> 8) + ((ctx->erk[i] & 0xFF000000) >> 24);
+    	*(uint32 *) (pjcontext + i*4 + 16) = ulTemp;
+    }
+
+    /* fire cmd */
+    *(unsigned long *) (HAC_REG_BASE + REG_CRYPTO_CMD_BASE_OFFSET) = ulCommand;
+    do {
+        ulTemp = *(volatile unsigned long *) (HAC_REG_BASE + REG_CRYPTO_STATUS_OFFSET);
+    } while (ulTemp & CRYPTO_BUSY);	
+    
+    /* Output */
+    for (i=0; i<ulMsgLength; i++)
+    {
+        ch = *(uint8 *) (pjdst + i);        
+        *(uint8 *) (output + i) = ch;    
+    }
+
+} /* aes_dec_ast3000 */
+
+void rc4_crypt_ast3000(uint8 *data, int ulMsgLength, uint8 *rc4_key, uint32 ulKeyLength)
+{
+    struct rc4_state s;
+    unsigned long i, ulTemp, ulCommand;
+    unsigned char ch;
+    unsigned char *pjsrc, *pjdst, *pjcontext;
+
+    ulCommand = CRYPTO_ENABLE_RW | CRYPTO_ENABLE_CONTEXT_LOAD | CRYPTO_ENABLE_CONTEXT_SAVE | \
+                CRYPTO_RC4 | CRYPTO_SYNC_MODE_ASYNC;
+
+    rc4_setup( &s, rc4_key, ulKeyLength );
+
+    pjsrc = (unsigned char *) m16byteAlignment((unsigned long) crypto_src);
+    pjdst = (unsigned char *) m16byteAlignment((unsigned long) crypto_dst);
+    pjcontext = (unsigned char *) m16byteAlignment((unsigned long) crypto_context);
+	
+    /* Init HW */
+    *(uint32 *) (HAC_REG_BASE + REG_CRYPTO_SRC_BASE_OFFSET) = (unsigned long) pjsrc;	
+    *(uint32 *) (HAC_REG_BASE + REG_CRYPTO_DST_BASE_OFFSET) = (unsigned long) pjdst;	
+    *(uint32 *) (HAC_REG_BASE + REG_CRYPTO_CONTEXT_BASE_OFFSET) = (unsigned long) pjcontext;	
+    *(uint32 *) (HAC_REG_BASE + REG_CRYPTO_LEN_OFFSET) = ulMsgLength;	
+          	
+
+    /* Set source */
+    for (i=0; i< ulMsgLength; i++)
+    {
+    	ch = *(uint8 *)(data + i);
+    	*(uint8 *) (pjsrc + i) = ch;
+    }
+     
+    /* Set Context */
+    /* Set i, j */
+    *(uint32 *) (pjcontext + 8) = 0x0001;	
+       
+    /* Set Expansion Key */   
+    for (i=0; i<(256/4); i++)
+    {
+       ulTemp = (s.m[i * 4] & 0xFF) + ((s.m[i * 4 + 1] & 0xFF) << 8) + ((s.m[i * 4 + 2] & 0xFF) << 16) + ((s.m[i * 4+ 3] & 0xFF) << 24);
+       *(uint32 *) (pjcontext + i*4 + 16) = ulTemp;	
+    }
+
+    /* fire cmd */
+    *(uint32 *) (HAC_REG_BASE + REG_CRYPTO_CMD_BASE_OFFSET) = ulCommand;    
+    do {
+    	ulTemp = *(volatile uint32 *) (HAC_REG_BASE + REG_CRYPTO_STATUS_OFFSET);
+    } while (ulTemp & CRYPTO_BUSY);	
+
+    /* Output */
+    for (i=0; i<ulMsgLength; i++)
+    {
+        ch = *(volatile uint8 *) (pjdst + i);
+        *(uint8 *) (data + i) = ch;    
+    }
+
+} /* rc4_crypt_ast3000	*/
+
+/* Hash */
+void hash_ast3000(uint8 *msg, uint32 ulLength, unsigned char *output, uint32 ulHashMode)
+{
+   uint32 i, ulTemp, ulCommand, ulDigestLength, ulMyMsgLength;
+   uint8 ch;
+   unsigned char *pjsrc, *pjdst;
+   
+   /* Get Info */
+   switch (ulHashMode)
+   {
+   case HASHMODE_MD5:
+        ulCommand = HASH_ALG_SELECT_MD5;
+        ulDigestLength = 16;
+       break;
+   case HASHMODE_SHA1:
+        ulCommand = HASH_ALG_SELECT_SHA1 | 0x08;
+        ulDigestLength = 20;
+       break;
+   case HASHMODE_SHA256:
+        ulCommand = HASH_ALG_SELECT_SHA256 | 0x08;
+        ulDigestLength = 32;
+       break;
+   case HASHMODE_SHA224:
+        ulCommand = HASH_ALG_SELECT_SHA224 | 0x08;
+        ulDigestLength = 28;
+       break;       	
+   }   	    
+
+    pjsrc = (unsigned char *) m16byteAlignment((unsigned long) hash_src);
+    pjdst = (unsigned char *) m16byteAlignment((unsigned long) hash_dst);
+
+    /* 16byte alignment */
+    ulMyMsgLength = m16byteAlignment(ulLength);
+   	
+   /* Init. HW */
+    *(uint32 *) (HAC_REG_BASE + REG_HASH_SRC_BASE_OFFSET) = (unsigned long) pjsrc;	
+    *(uint32 *) (HAC_REG_BASE + REG_HASH_DST_BASE_OFFSET) = (unsigned long) pjdst;	
+    *(uint32 *) (HAC_REG_BASE + REG_HASH_LEN_OFFSET) = ulMyMsgLength;	
+        
+    /* write src */
+    for (i=0; i<ulLength; i++)
+    {
+    	ch = *(uint8 *)(msg+i);
+    	*(uint8 *) (pjsrc + i) = ch;
+    }    
+    for (i=ulLength; i<ulMyMsgLength; i++)
+        *(uint8 *) (pjsrc + i) = 0;
+        
+    /* fire cmd */
+    *(uint32 *) (HAC_REG_BASE + REG_HASH_CMD_OFFSET) = ulCommand;	
+    
+    /* get digest */
+    do {
+    	ulTemp = *(volatile uint32 *) (HAC_REG_BASE + REG_HASH_STATUS_OFFSET);    	
+    } while (ulTemp & HASH_BUSY);	
+    	
+    for (i=0; i<ulDigestLength; i++)
+    {
+        ch = *(volatile uint8 *) (pjdst + i);
+       *(uint8 *) (output + i) = ch;    
+    }        
+ 
+} /* hash_ast3000 */	
+
+/* HMAC */
+void hmackey_ast3000(uint8 *key, uint32 ulKeyLength, uint32 ulHashMode)
+{
+    uint32 i, ulBlkLength, ulDigestLength, ulTemp, ulCommand;
+    uint8 k0[64], sum[32];
+    uint8 ch;
+    unsigned char *pjsrc, *pjdst, *pjkey;
+
+   /* Get Info */
+   switch (ulHashMode)
+   {
+   case HASHMODE_MD5:
+        ulCommand = HASH_ALG_SELECT_MD5;
+        ulDigestLength = 16;
+       break;
+   case HASHMODE_SHA1:
+        ulCommand = HASH_ALG_SELECT_SHA1 | 0x08;
+        ulDigestLength = 20;
+       break;
+   case HASHMODE_SHA256:
+        ulCommand = HASH_ALG_SELECT_SHA256 | 0x08;
+        ulDigestLength = 32;
+       break;
+   case HASHMODE_SHA224:
+        ulCommand = HASH_ALG_SELECT_SHA224 | 0x08;
+        ulDigestLength = 28;
+       break;       	
+   }   	    
+   ulBlkLength = 64;				/* MD5, SHA1/256/224: 64bytes */
+
+    /* Init */
+    memset( (void *) k0, 0, 64);		/* reset to zero */
+    memset( (void *) sum, 0, 32);		/* reset to zero */
+
+    /* Get k0 */
+    if (ulKeyLength <= ulBlkLength)
+        memcpy( (void *) k0, (void *) key, ulKeyLength );       
+    else /* (ulKeyLength > ulBlkLength) */
+    {
+        hash_ast3000(key, ulKeyLength, sum, ulHashMode);
+        memcpy( (void *) k0, (void *) sum, ulDigestLength );                           
+    }    	
+
+    pjsrc = (unsigned char *) m16byteAlignment((unsigned long) hash_src);
+    pjdst = (unsigned char *) m16byteAlignment((unsigned long) hash_dst);
+    pjkey = (unsigned char *) m64byteAlignment((unsigned long) hmac_key);
+    
+    /* Calculate digest */
+    *(uint32 *) (HAC_REG_BASE + REG_HASH_SRC_BASE_OFFSET) = (unsigned long) pjsrc;
+    *(uint32 *) (HAC_REG_BASE + REG_HASH_DST_BASE_OFFSET) = (unsigned long) pjdst;
+    *(uint32 *) (HAC_REG_BASE + REG_HASH_KEY_BASE_OFFSET) = (unsigned long) pjkey;
+    *(uint32 *) (HAC_REG_BASE + REG_HASH_LEN_OFFSET) = ulBlkLength;
+        
+    /* write key to src */
+    for (i=0; i<ulBlkLength; i++)
+    {
+    	ch = *(uint8 *)(k0+i);
+        *(uint8 *) (pjsrc + i) = ch;
+    }    
+    
+    /* fire cmd for calculate */
+    *(uint32 *) (HAC_REG_BASE + REG_HASH_CMD_OFFSET) = ulCommand | HAC_DIGEST_CAL_ENABLE;    
+    do {
+    	ulTemp = *(volatile uint32 *) (HAC_REG_BASE + REG_HASH_STATUS_OFFSET);    	
+    } while (ulTemp & HASH_BUSY);	
+         
+} /* hmackey_ast3000 */
+
+void hmac_ast3000(uint8 *key, uint32 ulKeyLength, uint8 *msg, uint32 ulMsgLength, uint32 ulHashMode, unsigned char *output)
+{
+    uint32 i, ulTemp, ulCommand, ulDigestLength, ulMyMsgLength;;
+    uint8 ch;
+    unsigned char *pjsrc, *pjdst, *pjkey;
+
+    /* Calculate digest */
+   switch (ulHashMode)
+   {
+   case HASHMODE_MD5:
+        ulCommand = HASH_ALG_SELECT_MD5;
+        ulDigestLength = 16;
+       break;
+   case HASHMODE_SHA1:
+        ulCommand = HASH_ALG_SELECT_SHA1 | 0x08;
+        ulDigestLength = 20;
+       break;
+   case HASHMODE_SHA256:
+        ulCommand = HASH_ALG_SELECT_SHA256 | 0x08;
+        ulDigestLength = 32;
+       break;
+   case HASHMODE_SHA224:
+        ulCommand = HASH_ALG_SELECT_SHA224 | 0x08;
+        ulDigestLength = 28;
+       break;       	
+   }   	    
+ 
+    pjsrc = (unsigned char *) m16byteAlignment((unsigned long) hash_src);
+    pjdst = (unsigned char *) m16byteAlignment((unsigned long) hash_dst);
+    pjkey = (unsigned char *) m64byteAlignment((unsigned long) hmac_key);
+    
+    /* 16byte alignment */
+    ulMyMsgLength = m16byteAlignment(ulMsgLength);
+    		
+    /* Init. HW */
+    *(uint32 *) (HAC_REG_BASE + REG_HASH_SRC_BASE_OFFSET) = (unsigned long) pjsrc;
+    *(uint32 *) (HAC_REG_BASE + REG_HASH_DST_BASE_OFFSET) = (unsigned long) pjdst;
+    *(uint32 *) (HAC_REG_BASE + REG_HASH_KEY_BASE_OFFSET) = (unsigned long) pjkey;
+    *(uint32 *) (HAC_REG_BASE + REG_HASH_LEN_OFFSET) = ulMyMsgLength;
+
+    /* write Text to src */
+    for (i=0; i<ulMsgLength; i++)
+    {
+    	ch = *(uint8 *)(msg+i);
+        *(uint8 *) (pjsrc + i) = ch;
+    }    
+    for (i=ulMsgLength; i<ulMyMsgLength; i++)
+        *(uint8 *) (pjsrc + i) = 0;
+    
+    /* fire cmd */
+    *(uint32 *) (HAC_REG_BASE + REG_HASH_CMD_OFFSET) = ulCommand | HAC_ENABLE;        
+    do {
+    	ulTemp = *(volatile uint32 *) (HAC_REG_BASE + REG_HASH_STATUS_OFFSET);    	
+    } while (ulTemp & HASH_BUSY);
+
+    /* Output Digest */
+    for (i=0; i<ulDigestLength; i++)
+    {
+        ch = *(uint8 *) (pjdst + i);
+        *(uint8 *) (output + i) = ch;    
+    }
+
+} /* hmac_ast3000 */
+
+/* main hactest procedure */
+int do_hactest (void)
+{
+        unsigned long i, j, Flags = 0;
+	aes_test *pjaes_test;
+        aes_context aes_ctx;
+        unsigned char AES_Mode[8], aes_output[64];
+	unsigned long ulAESMsgLength;
+	
+	rc4_test *pjrc4_test;
+	unsigned char rc4_buf_sw[64], rc4_buf_hw[64];
+	unsigned long ulRC4KeyLength, ulRC4MsgLength;
+	
+	hash_test *pjhash_test;
+	unsigned char HASH_Mode[8], hash_out[64];
+
+	hmac_test *pjhmac_test;
+	unsigned char HMAC_Mode[8], hmac_out[64];
+
+	EnableHMAC();
+	
+	/* AES Test */
+	pjaes_test = aestest;
+	while (pjaes_test->aes_mode != 0xFF)
+	{
+
+            if (pjaes_test->aes_mode == CRYPTOMODE_CBC)
+                strcpy (AES_Mode, "CBC");
+            else if (pjaes_test->aes_mode == CRYPTOMODE_CFB)
+                strcpy (AES_Mode, "CFB");
+            else if (pjaes_test->aes_mode == CRYPTOMODE_OFB)
+                strcpy (AES_Mode, "OFB");
+            else if (pjaes_test->aes_mode == CRYPTOMODE_CTR)
+                strcpy (AES_Mode, "CTR");
+            else    
+                strcpy (AES_Mode, "ECB");
+
+            /* Get Msg. Length */
+            ulAESMsgLength = strlen(pjaes_test->plaintext);
+            j = ( (ulAESMsgLength + 15) >> 4) << 4;
+            for (i=ulAESMsgLength; i<j; i++)
+                pjaes_test->plaintext[i] = 0;
+            ulAESMsgLength = j;    
+                		
+            aes_set_key(&aes_ctx, pjaes_test->key, pjaes_test->key_length);
+            
+            /* Encryption Test */
+            aes_enc_ast3000(&aes_ctx, pjaes_test->plaintext, pjaes_test->key, aes_output, ulAESMsgLength, pjaes_test->aes_mode);	    
+	    if (strncmp(aes_output, pjaes_test->ciphertext, ulAESMsgLength))
+	    {
+	    	Flags |= FLAG_AESTEST_FAIL;	    	
+	        printf("[INFO] AES%d %s Mode Encryption Failed \n", pjaes_test->key_length, AES_Mode);
+	        printf("[DBG] Golden Data Dump .... \n");	        
+	        for (i=0; i< ulAESMsgLength; i++)
+	        {
+	            printf("%02x ", pjaes_test->ciphertext[i]);	        	
+	            if (((i+1) % 8) == 0)
+	                printf("\n");        
+	        }        
+	        printf("\n [DBG] Error Data Dump .... \n");
+	        for (i=0; i< ulAESMsgLength; i++)
+	        {
+	            printf("%02x ", aes_output[i]);	        	
+	            if (((i+1) % 8) == 0)
+	                printf("\n");        
+	        }
+	        printf("\n");	                
+	    }
+	    else
+	    {
+	    	/*
+	        printf("[INFO] AES%d %s Mode Encryption Passed \n", pjaes_test->key_length, AES_Mode);
+	        */
+	    }	
+
+            /* Decryption Test */
+            aes_dec_ast3000(&aes_ctx, pjaes_test->ciphertext, pjaes_test->key, aes_output, ulAESMsgLength, pjaes_test->aes_mode);	    
+	    if (strncmp(aes_output, pjaes_test->plaintext, ulAESMsgLength))
+	    {
+	    	Flags |= FLAG_AESTEST_FAIL;
+	        printf("[INFO] AES%d %s Mode Decryption Failed \n", pjaes_test->key_length, AES_Mode);	        
+	        printf("[DBG] Golden Data Dump .... \n");
+	        for (i=0; i< ulAESMsgLength; i++)
+	        {
+	            printf("%02x ", pjaes_test->plaintext[i]);	        	
+	            if (((i+1) % 8) == 0)
+	                printf("\n");        
+	        }        
+	        printf("\n [DBG] Error Data Dump .... \n");
+	        for (i=0; i< ulAESMsgLength; i++)
+	        {
+	            printf("%02x ", aes_output[i]);	        	
+	            if (((i+1) % 8) == 0)
+	                printf("\n");        
+	        }
+	        printf("\n");	                
+	    }
+	    else
+	    {
+	    	/*
+	        printf("[INFO] AES%d %s Mode Decryption Passed \n", pjaes_test->key_length, AES_Mode);
+	        */
+	    }	
+	    
+	    pjaes_test++;
+        } /* AES */
+
+	/* RC4 Test */
+	pjrc4_test = rc4test;
+	while ((pjrc4_test->key[0] != 0xff) && (pjrc4_test->data[0] != 0xff))
+	{
+
+            /* Get Info */
+            ulRC4KeyLength = strlen(pjrc4_test->key);
+            ulRC4MsgLength = strlen(pjrc4_test->data);
+            memcpy( (void *) rc4_buf_sw, (void *) pjrc4_test->data, ulRC4MsgLength );
+            memcpy( (void *) rc4_buf_hw, (void *) pjrc4_test->data, ulRC4MsgLength );                                       
+
+            /* Crypto */
+            rc4_crypt_sw(rc4_buf_sw, ulRC4MsgLength, pjrc4_test->key, ulRC4KeyLength);
+            rc4_crypt_ast3000(rc4_buf_hw, ulRC4MsgLength, pjrc4_test->key, ulRC4KeyLength);
+           
+	    if (strncmp(rc4_buf_hw, rc4_buf_sw, ulRC4MsgLength))
+	    {
+	    	Flags |= FLAG_RC4TEST_FAIL;	    	
+	        printf("[INFO] RC4 Encryption Failed \n");
+	        printf("[DBG] Golden Data Dump .... \n");
+	        for (i=0; i< ulRC4MsgLength; i++)
+	        {
+	            printf("%02x ", rc4_buf_sw[i]);
+	            if (((i+1) % 8) == 0)
+	                printf("\n");        
+	        }
+	        printf("\n [DBG] Error Data Dump .... \n");
+	        for (i=0; i< ulRC4MsgLength; i++)
+	        {
+	            printf("%02x ", rc4_buf_hw[i]);
+	            if (((i+1) % 8) == 0)
+	                printf("\n");        
+	        }
+	        printf("\n");	        
+	    }
+	    else
+	    {
+	    	/*
+	        printf("[INFO] RC4 Encryption Passed \n");
+	        */
+	    }	
+
+	    pjrc4_test++;
+	    
+        } /* RC4 */
+       
+	/* Hash Test */
+	pjhash_test = hashtest;
+	while (pjhash_test->hash_mode != 0xFF)
+	{
+
+            if (pjhash_test->hash_mode == HASHMODE_MD5)
+                strcpy (HASH_Mode, "MD5");
+            else if (pjhash_test->hash_mode == HASHMODE_SHA1)
+                strcpy (HASH_Mode, "SHA1");
+            else if (pjhash_test->hash_mode == HASHMODE_SHA256)
+                strcpy (HASH_Mode, "SHA256");
+            else if (pjhash_test->hash_mode == HASHMODE_SHA224)
+                strcpy (HASH_Mode, "SHA224");
+            
+            /* Hash */   		
+            hash_ast3000(pjhash_test->input, strlen(pjhash_test->input), hash_out, pjhash_test->hash_mode);            
+	    if (strncmp(hash_out, pjhash_test->digest, pjhash_test->digest_length))
+	    {
+	    	Flags |= FLAG_HASHTEST_FAIL;	    	
+	        printf("[INFO] HASH %s Failed \n", HASH_Mode);
+	        printf("[DBG] Golden Data Dump .... \n");	        
+	        for (i=0; i< pjhash_test->digest_length; i++)
+	        {
+	            printf("%02x ",pjhash_test->digest[i]);
+	            if (((i+1) % 8) == 0) 	
+	                printf("\n");        
+	        }        
+	        printf("\n [DBG] Error Data Dump .... \n");
+	        for (i=0; i< pjhash_test->digest_length; i++)
+	        {
+	            printf("%02x ",hash_out[i]);
+	            if (((i+1) % 8) == 0) 	
+	                printf("\n");        
+	        }
+	        printf("\n");
+	    }
+	    else
+	    {
+	    	/*
+	        printf("[INFO] HASH %s Passed \n", HASH_Mode);
+	        */
+	    }	
+
+            pjhash_test++;
+            
+        } /* Hash Test */
+
+	/* HMAC Test */
+	pjhmac_test = hmactest;
+	while (pjhmac_test->hash_mode != 0xFF)
+	{
+
+            if (pjhmac_test->hash_mode == HASHMODE_MD5)
+                strcpy (HMAC_Mode, "MD5");
+            else if (pjhmac_test->hash_mode == HASHMODE_SHA1)
+                strcpy (HMAC_Mode, "SHA1");
+            else if (pjhmac_test->hash_mode == HASHMODE_SHA256)
+                strcpy (HMAC_Mode, "SHA256");
+            else if (pjhmac_test->hash_mode == HASHMODE_SHA224)
+                strcpy (HMAC_Mode, "SHA224");
+            
+            /* HMAC */   		
+            hmackey_ast3000(pjhmac_test->key, pjhmac_test->key_length, pjhmac_test->hash_mode);
+            hmac_ast3000(pjhmac_test->key, pjhmac_test->key_length, pjhmac_test->input, strlen(pjhmac_test->input), pjhmac_test->hash_mode, hmac_out);            
+	    if (strncmp(hmac_out, pjhmac_test->digest, pjhmac_test->digest_length))
+	    {
+	    	Flags |= FLAG_HASHTEST_FAIL;	    	
+	        printf("[INFO] HMAC %s Failed \n", HMAC_Mode);
+	        printf("[DBG] Golden Data Dump .... \n");	        
+	        for (i=0; i< pjhmac_test->digest_length; i++)
+	        {
+	            printf("%02x ",pjhmac_test->digest[i]);
+	            if (((i+1) % 8) == 0) 	
+	                printf("\n");        
+	        }        
+	        printf("\n [DBG] Error Data Dump .... \n");
+	        for (i=0; i< pjhmac_test->digest_length; i++)
+	        {
+	            printf("%02x ",hmac_out[i]);
+	            if (((i+1) % 8) == 0) 	
+	                printf("\n");        
+	        }
+	        printf("\n");
+	    }
+	    else
+	    {
+	    	/*
+	        printf("[INFO] HMAC %s Passed \n", HMAC_Mode);
+	        */
+	    }	
+
+            pjhmac_test++;
+            
+        } /* HMAC Test */
+
+	return Flags;
+	
+}
+
+#endif /* CONFIG_SLT */
diff --git a/board/aspeed/ast2300/hactest.h b/board/aspeed/ast2300/hactest.h
new file mode 100755
index 0000000..fcf2186
--- /dev/null
+++ b/board/aspeed/ast2300/hactest.h
@@ -0,0 +1,194 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* Err Flags */
+#define FLAG_AESTEST_FAIL  		0x00000001
+#define FLAG_RC4TEST_FAIL  		0x00000002
+#define FLAG_HASHTEST_FAIL  		0x00000004
+
+/* Specific */
+/*
+#define DRAM_BASE			0x40000000
+#define	CRYPTO_SRC_BASE			(DRAM_BASE + 0x100000)
+#define	CRYPTO_DST_BASE			(DRAM_BASE + 0x200000)
+#define	CRYPTO_CONTEXT_BASE		(DRAM_BASE + 0x300000)
+
+#define	HASH_SRC_BASE			(DRAM_BASE + 0x400000)
+#define	HASH_DST_BASE			(DRAM_BASE + 0x500000)
+#define	HMAC_KEY_BASE			(DRAM_BASE + 0x600000)
+*/
+#define m08byteAlignment(x)		((x + 0x00000007) & 0xFFFFFFF8)
+#define m16byteAlignment(x)		((x + 0x0000000F) & 0xFFFFFFF0)
+#define m64byteAlignment(x)		((x + 0x0000003F) & 0xFFFFFFC0)
+
+#define CRYPTO_ALIGNMENT		16
+#define CRYPTO_MAX_SRC			(100+CRYPTO_ALIGNMENT)
+#define CRYPTO_MAX_DST			(100+CRYPTO_ALIGNMENT)
+#define CRYPTO_MAX_CONTEXT		(100+CRYPTO_ALIGNMENT)
+
+#define HASH_ALIGNMENT			16
+#define HMAC_KEY_ALIGNMENT	 	64
+#define HASH_MAX_SRC			(100+HASH_ALIGNMENT)
+#define HASH_MAX_DST			(32+HASH_ALIGNMENT)
+#define HMAC_MAX_KEY			(64+HMAC_KEY_ALIGNMENT)
+
+/* General */
+#define HAC_REG_BASE 			0x1e6e3000
+
+#define MAX_KEYLENGTH			100
+#define MAX_TEXTLENGTH			100
+#define MAX_AESTEXTLENGTH		256
+#define MAX_RC4TEXTLENGTH		256
+#define MAX_RC4KEYLENGTH		256
+
+#define CRYPTOMODE_ECB			0x00
+#define CRYPTOMODE_CBC			0x01
+#define CRYPTOMODE_CFB			0x02
+#define CRYPTOMODE_OFB			0x03
+#define CRYPTOMODE_CTR			0x04
+
+#define HASHMODE_MD5			0x00
+#define HASHMODE_SHA1			0x01
+#define HASHMODE_SHA256			0x02
+#define HASHMODE_SHA224			0x03
+
+#define MIXMODE_DISABLE                 0x00
+#define MIXMODE_CRYPTO                  0x02
+#define MIXMODE_HASH                    0x03
+
+#define REG_CRYPTO_SRC_BASE_OFFSET	0x00
+#define REG_CRYPTO_DST_BASE_OFFSET	0x04
+#define REG_CRYPTO_CONTEXT_BASE_OFFSET	0x08
+#define REG_CRYPTO_LEN_OFFSET		0x0C
+#define REG_CRYPTO_CMD_BASE_OFFSET	0x10
+//#define REG_CRYPTO_ENABLE_OFFSET	0x14
+#define REG_CRYPTO_STATUS_OFFSET	0x1C
+
+#define REG_HASH_SRC_BASE_OFFSET	0x20
+#define REG_HASH_DST_BASE_OFFSET	0x24
+#define REG_HASH_KEY_BASE_OFFSET	0x28
+#define REG_HASH_LEN_OFFSET		0x2C
+#define REG_HASH_CMD_OFFSET		0x30
+//#define REG_HASH_ENABLE_OFFSET		0x14
+#define REG_HASH_STATUS_OFFSET		0x1C
+
+#define HASH_BUSY			0x01
+#define CRYPTO_BUSY			0x02
+
+//#define ENABLE_HASH			0x01
+//#define DISABLE_HASH			0x00
+//#define ENABLE_CRYPTO			0x02
+//#define DISABLE_CRYPTO			0x00
+
+#define CRYPTO_SYNC_MODE_MASK		0x03
+#define CRYPTO_SYNC_MODE_ASYNC		0x00
+#define CRYPTO_SYNC_MODE_PASSIVE	0x02
+#define CRYPTO_SYNC_MODE_ACTIVE		0x03
+
+#define CRYPTO_AES128			0x00
+#define CRYPTO_AES192			0x04
+#define CRYPTO_AES256			0x08
+
+#define CRYPTO_AES_ECB			0x00
+#define CRYPTO_AES_CBC			0x10
+#define CRYPTO_AES_CFB			0x20
+#define CRYPTO_AES_OFB			0x30
+#define CRYPTO_AES_CTR			0x40
+
+#define CRYPTO_ENCRYPTO			0x80
+#define CRYPTO_DECRYPTO			0x00
+
+#define CRYPTO_AES			0x000
+#define CRYPTO_RC4			0x100
+
+#define CRYPTO_ENABLE_RW		0x000
+#define CRYPTO_ENABLE_CONTEXT_LOAD	0x000
+#define CRYPTO_ENABLE_CONTEXT_SAVE	0x000
+
+#define HASH_SYNC_MODE_MASK		0x03
+#define HASH_SYNC_MODE_ASYNC		0x00
+#define HASH_SYNC_MODE_PASSIVE		0x02
+#define HASH_SYNC_MODE_ACTIVE		0x03
+
+#define HASH_READ_SWAP_ENABLE		0x04
+#define HMAC_SWAP_CONTROL_ENABLE	0x08
+
+#define HASH_ALG_SELECT_MASK		0x70
+#define HASH_ALG_SELECT_MD5		0x00
+#define HASH_ALG_SELECT_SHA1		0x20
+#define HASH_ALG_SELECT_SHA224		0x40
+#define HASH_ALG_SELECT_SHA256		0x50
+
+#define HAC_ENABLE			0x80
+#define HAC_DIGEST_CAL_ENABLE		0x180
+#define HASH_INT_ENABLE			0x200
+
+/* AES */
+#ifndef uint8
+#define uint8  unsigned char
+#endif
+
+#ifndef uint32
+#define uint32 unsigned long int
+#endif
+
+typedef struct
+{
+    uint32 erk[64];     /* encryption round keys */
+    uint32 drk[64];     /* decryption round keys */
+    int nr;             /* number of rounds */
+}
+aes_context;
+
+typedef struct
+{
+    int	  aes_mode;
+    int	  key_length;
+	
+    uint8 key[32];	/* as iv in CTR mode */
+    uint8 plaintext[64];
+    uint8 ciphertext[64];
+    
+}
+aes_test;
+
+/* RC4 */
+typedef struct
+{
+    uint8 key[32];
+    uint8 data[64];
+}
+rc4_test;
+
+/* Hash */
+typedef struct
+{
+    int	  hash_mode;
+    int	  digest_length;
+	
+    uint8 input[64];
+    uint8 digest[64];
+    
+}
+hash_test;
+	
+/* HMAC */
+typedef struct
+{
+    int	  hash_mode;
+    int	  key_length;
+    int	  digest_length;
+
+    uint8 key[100];	
+    uint8 input[64];
+    uint8 digest[64];
+    
+}
+hmac_test;
diff --git a/board/aspeed/ast2300/mactest.c b/board/aspeed/ast2300/mactest.c
new file mode 100755
index 0000000..5566b65
--- /dev/null
+++ b/board/aspeed/ast2300/mactest.c
@@ -0,0 +1,504 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/*
+ * (C) Copyright 2007 ASPEED Software
+ * MAC Manufacture Test in ASPEED's SDK version 0.20.01
+ *
+ * Release History
+ * 1. First Release, river@20071130
+ * 2. Fix the endless loop when PHY is not ready, river@20071204
+ *
+ * Test items:
+ * 1. Support MARVELL PHY only in this version
+ * 2. MDC/MDIO
+ * 3. GMAC/Duplex TX/RX Full_Size, Packet_Length Test
+ * 4. 100M/Duplex TX/RX Full_Size, Packet_Length Test
+ *
+ *
+ *
+*/
+
+
+/*
+* Diagnostics support
+*/
+#include <common.h>
+#include <command.h>
+#include <post.h>
+#include <malloc.h>
+#include <net.h>
+#include "slt.h"
+
+#if ((CFG_CMD_SLT & CFG_CMD_MACTEST) && defined(CONFIG_SLT))
+#include "mactest.h"
+
+static int INL(u_long base, u_long addr)
+{
+	return le32_to_cpu(*(volatile u_long *)(addr + base));
+}
+
+static void OUTL(u_long base, int command, u_long addr)
+{
+	*(volatile u_long *)(addr + base) = cpu_to_le32(command);
+}
+
+
+static void SCU_MAC1_Enable (void)
+{
+	unsigned int SCU_Register;
+
+//MAC1 RESET/PHY_LINK in SCU
+        SCU_Register = INL(SCU_BASE, SCU_RESET_CONTROL_REG);
+	OUTL(SCU_BASE, SCU_Register & ~(0x800), SCU_RESET_CONTROL_REG);
+	
+}
+
+/*------------------------------------------------------------
+ . Reads a register from the MII Management serial interface
+ .-------------------------------------------------------------*/
+static u16 phy_read_register (u8 PHY_Register, u8 PHY_Address)
+{
+	u32 Data, Status = 0, Loop_Count = 0, PHY_Ready = 1;
+	u16 Return_Data;
+
+	OUTL(MAC1_IO_BASE, (PHY_Register << 21) + (PHY_Address << 16) + MIIRD + MDC_CYCTHR, PHYCR_REG);
+	do {
+		Status = (INL (MAC1_IO_BASE, PHYCR_REG) & MIIRD);
+		Loop_Count++;
+		if (Loop_Count >= PHY_LOOP) {
+			PHY_Ready = 0;
+			break;
+		}
+	} while (Status == MIIRD);
+       
+	if (PHY_Ready == 0) {
+		printf ("PHY NOT REDAY\n");
+		return 0;
+	}
+	
+	udelay(5*1000);
+	Data = INL (MAC1_IO_BASE, PHYDATA_REG);
+	Return_Data = (Data >> 16);
+
+	return Return_Data;
+}
+
+static void phy_write_register (u8 PHY_Register, u8 PHY_Address, u16 PHY_Data)
+{
+	u32 Status = 0, Loop_Count = 0, PHY_Ready = 1;
+
+	OUTL(MAC1_IO_BASE, PHY_Data, PHYDATA_REG);
+	OUTL(MAC1_IO_BASE, (PHY_Register << 21) + (PHY_Address << 16) + MIIWR + MDC_CYCTHR, PHYCR_REG);
+	do {
+		Status = (INL (MAC1_IO_BASE, PHYCR_REG) & MIIWR);
+		Loop_Count++;
+		if (Loop_Count >= PHY_LOOP) {
+			PHY_Ready = 0;
+			break;
+		}
+	} while (Status == MIIWR);
+	if (PHY_Ready == 0) {
+		printf ("PHY NOT REDAY\n");
+	}
+}
+
+static int wait_link_resolve (void)
+{
+	int resolved_status, Loop_Count = 0, PHY_Ready = 1;
+
+        do {
+       		resolved_status = (phy_read_register (0x11, 0) & (PHY_RESOLVED_bit | PHY_LINK_bit));
+               	Loop_Count++;
+               	if (Loop_Count >= PHY_LOOP) {
+                   	PHY_Ready = 0;
+                    	printf ("PHY NOT READY\n");
+                    	break;
+                }
+        } while (resolved_status != (PHY_RESOLVED_bit | PHY_LINK_bit));
+        
+        return PHY_Ready;
+}
+
+static void set_phy_speed (int chip, int speed, int duplex)
+{
+	unsigned short data, status;
+
+
+	if (chip == PHYID_VENDOR_MARVELL) {
+		if ((speed == PHY_SPEED_1G) && (duplex == DUPLEX_FULL)) {
+//Manual Control
+			phy_write_register (18, 0, 0);
+			data = phy_read_register (9, 0);
+			phy_write_register (9, 0, data | 0x1800);
+//PHY Reset
+			phy_write_register (0, 0, 0x0140 | 0x8000);
+			do {
+				status = (phy_read_register (0, 0) & 0x8000); 
+			} while (status != 0);
+	
+//Force 1G
+			phy_write_register (29, 0, 0x07);
+			data = phy_read_register (30, 0);
+			phy_write_register (30, 0, data | 0x08);
+			phy_write_register (29, 0, 0x10);
+			data = phy_read_register (30, 0);
+			phy_write_register (30, 0, data | 0x02);
+			phy_write_register (29, 0, 0x12);
+			data = phy_read_register (30, 0);
+			phy_write_register (30, 0, data | 0x01);
+	
+			printf ("FORCE MARVELL PHY to 1G/DUPLEX DONE\n");
+		}
+		else if ((speed == PHY_SPEED_100M) && (duplex == DUPLEX_FULL)) {
+//PHY Reset
+			phy_write_register (0, 0, 0x2100 | 0x8000);
+			do {
+				status = (phy_read_register (0, 0) & 0x8000); 
+			} while (status != 0);
+	
+//Force 100M
+			data = phy_read_register (0, 0);
+			phy_write_register (0, 0, data | 0x4000 | 0x8000);
+			do {
+				status = (phy_read_register (0, 0) & 0x8000); 
+			} while (status != 0);
+			data = phy_read_register (0, 0);
+
+			printf ("FORCE MARVELL PHY to 100M/DUPLEX DONE\n");
+		}
+	}
+	else if ( (chip == PHYID_VENDOR_RTL8201E) || (chip == PHYID_VENDOR_BROADCOM) ){
+		/* basic setting */
+		data  = phy_read_register (0, 0);
+		data &= 0x7140;
+		data |= 0x4000;
+		if (speed == PHY_SPEED_100M)
+		    data |= 0x2000;
+                if (duplex == DUPLEX_FULL)		    
+                    data |= 0x0100;
+		phy_write_register (0, 0, data);
+
+                /* reset */
+		phy_write_register (0, 0, data | 0x8000);
+		do {
+			status = (phy_read_register (0, 0) & 0x8000); 
+		} while (status != 0);
+	        udelay(100*1000);
+		
+		/* basic setting */
+		phy_write_register (0, 0, data);
+
+                if (chip == PHYID_VENDOR_RTL8201E)
+		    printf ("FORCE RTL8201E PHY to 100M/DUPLEX DONE\n");		
+                else if (chip == PHYID_VENDOR_BROADCOM)
+		    printf ("FORCE Broadcom PHY to 100M/DUPLEX DONE\n");		
+		    
+	}	
+	
+}
+
+static void MAC1_reset (void)
+{
+    OUTL(MAC1_IO_BASE, SW_RST_bit, MACCR_REG);
+    for (; (INL(MAC1_IO_BASE, MACCR_REG ) & SW_RST_bit) != 0; ) {udelay(1000);}
+    OUTL(MAC1_IO_BASE, 0, IER_REG );
+}
+
+static int set_mac1_control_register (int Chip_ID)
+{
+	unsigned long	MAC_CR_Register = 0;
+	int    PHY_Ready = 1;
+	u16    PHY_Status, PHY_Speed, PHY_Duplex, Advertise, Link_Partner;
+
+	MAC_CR_Register = SPEED_100M_MODE_bit | RX_ALLADR_bit | FULLDUP_bit | RXMAC_EN_bit | RXDMA_EN_bit | TXMAC_EN_bit | TXDMA_EN_bit | CRC_APD_bit;
+
+	if ( (Chip_ID == PHYID_VENDOR_BROADCOM) || (Chip_ID == PHYID_VENDOR_RTL8201E)) {
+		Advertise = phy_read_register (0x04, 0);
+		Link_Partner = phy_read_register (0x05, 0);
+		Advertise = (Advertise & PHY_SPEED_DUPLEX_MASK);
+		Link_Partner = (Link_Partner & PHY_SPEED_DUPLEX_MASK);
+		if ((Advertise & Link_Partner) & PHY_100M_DUPLEX) {
+			MAC_CR_Register |= SPEED_100M_MODE_bit;
+			MAC_CR_Register |= FULLDUP_bit;
+		}
+		else if ((Advertise & Link_Partner) & PHY_100M_HALF) {
+			MAC_CR_Register |= SPEED_100M_MODE_bit;
+			MAC_CR_Register &= ~FULLDUP_bit;
+		}
+		else if ((Advertise & Link_Partner) & PHY_10M_DUPLEX) {
+			MAC_CR_Register &= ~SPEED_100M_MODE_bit;
+			MAC_CR_Register |= FULLDUP_bit;
+		}
+		else if ((Advertise & Link_Partner) & PHY_10M_HALF) {
+			MAC_CR_Register &= ~SPEED_100M_MODE_bit;
+			MAC_CR_Register &= ~FULLDUP_bit;
+		}
+	}
+	else if (Chip_ID == PHYID_VENDOR_MARVELL) {
+
+		PHY_Ready = wait_link_resolve ();
+
+		if (PHY_Ready == 1) {
+			PHY_Status = phy_read_register (0x11, 0);
+			PHY_Speed = (PHY_Status & PHY_SPEED_MASK) >> 14;
+			PHY_Duplex = (PHY_Status & PHY_DUPLEX_MASK) >> 13;
+
+			if (PHY_Speed == SPEED_1000M) {
+				MAC_CR_Register |= GMAC_MODE_bit;
+                	}
+			else {
+				MAC_CR_Register &= ~GMAC_MODE_bit;
+				if (PHY_Speed == SPEED_10M) {
+                        		MAC_CR_Register &= ~SPEED_100M_MODE_bit;
+                    		}
+                	}
+                	if (PHY_Duplex == DUPLEX_HALF) {
+				MAC_CR_Register &= ~FULLDUP_bit;
+			}
+		}
+	}
+	OUTL(MAC1_IO_BASE, MAC_CR_Register, MACCR_REG);
+
+	return PHY_Ready;
+}
+
+static void ring_buffer_alloc (void)
+{
+	unsigned int i, j;
+
+//Write data into TX buffer
+	for (i = 0; i < NUM_TX; i++) {
+		for (j = 0; j < TX_BUFF_SZ; j++) {
+			tx_buffer[i][j] = i * 4 + j;
+		}
+	}
+//Initialize RX buffer to 0
+	for (i = 0; i < NUM_RX; i++) {
+		for (j = 0; j < RX_BUFF_SZ; j++) {
+			rx_buffer[i][j] = 0;
+		}
+	}
+//Prepare descriptor
+	for (i = 0; i < NUM_RX; i++) {
+		rx_ring[i].status = cpu_to_le32(RXPKT_RDY + RX_BUFF_SZ);
+		rx_ring[i].buf = ((u32) &rx_buffer[i]);
+		rx_ring[i].reserved = 0;
+	}
+	for (i = 0; i < NUM_TX; i++) {
+		tx_ring[i].status = 0;
+		tx_ring[i].des1 = 0;
+		tx_ring[i].buf = ((u32) &tx_buffer[i]);
+		tx_ring[i].reserved = 0;
+	}
+
+	rx_ring[NUM_RX - 1].status |= cpu_to_le32(EDORR);
+	tx_ring[NUM_TX - 1].status |= cpu_to_le32(EDOTR);
+
+	OUTL(MAC1_IO_BASE, ((u32) &tx_ring), TXR_BADR_REG);
+	OUTL(MAC1_IO_BASE, ((u32) &rx_ring), RXR_BADR_REG);
+	
+	tx_new = 0;
+	rx_new = 0;
+}
+
+static int packet_test (void)
+{
+	unsigned int rx_status, length, i, Loop_Count = 0;
+
+	tx_ring[tx_new].status |= cpu_to_le32(LTS | FTS | TX_BUFF_SZ);
+	tx_ring[tx_new].status |= cpu_to_le32(TXDMA_OWN);
+	OUTL(MAC1_IO_BASE, POLL_DEMAND, TXPD_REG);
+
+//Compare result
+	do {
+		rx_status = rx_ring[rx_new].status;
+		Loop_Count++;
+	} while (!(rx_status & RXPKT_STATUS) && (Loop_Count < PHY_LOOP));
+	if (rx_status & (RX_ERR | CRC_ERR | FTL | RUNT | RX_ODD_NB)) {
+		/* There was an error.*/
+		printf("RX error status = 0x%08X\n", rx_status);
+		return PACKET_TEST_FAIL;
+	} else {
+		length = (rx_status & BYTE_COUNT_MASK);
+		for (i = 0; i < RX_BUFF_SZ / 4; i++) {
+			if (rx_buffer[rx_new][i] != tx_buffer[tx_new][i]) {
+				printf ("ERROR at packet %d, address %x\n", rx_new, i);
+				printf ("Gold = %8x, Real = %8x\n", tx_buffer[tx_new][i], rx_buffer[rx_new][i]);
+				return PACKET_TEST_FAIL;
+			}
+		}
+	}
+    	tx_new = (tx_new + 1) % NUM_TX;
+	rx_new = (rx_new + 1) % NUM_RX;
+
+	return TEST_PASS;
+}
+
+static int packet_length_test (int packet_length)
+{
+	unsigned int rx_status, length, i, Loop_Count = 0;
+
+	tx_ring[tx_new].status &= (~(BYTE_COUNT_MASK));
+	tx_ring[tx_new].status |= cpu_to_le32(LTS | FTS | packet_length);
+	tx_ring[tx_new].status |= cpu_to_le32(TXDMA_OWN);
+	OUTL(MAC1_IO_BASE, POLL_DEMAND, TXPD_REG);
+
+//Compare result
+	do {
+		rx_status = rx_ring[rx_new].status;
+		Loop_Count++;
+	} while (!(rx_status & RXPKT_STATUS) && (Loop_Count < PHY_LOOP));
+	if (rx_status & (RX_ERR | CRC_ERR | FTL | RUNT | RX_ODD_NB)) {
+		/* There was an error.*/
+		printf("RX error status = 0x%08X\n", rx_status);
+		return PACKET_LENGTH_TEST_FAIL;
+	} else {
+		length = (rx_status & BYTE_COUNT_MASK) - 4;
+                if (length != packet_length) {
+			printf ("Received Length ERROR. Gold = %d, Fail = %d\n",packet_length, length);
+			printf ("rx_new = %d, tx_new = %d\n", rx_new, tx_new);
+			return PACKET_LENGTH_TEST_FAIL;
+                }
+		for (i = 0; i < length; i++) {
+		    if (rx_buffer[rx_new][i] != tx_buffer[tx_new][i]) {
+		    	printf ("ERROR at packet %d, address %x\n", rx_new, i);
+		    	printf ("Gold = %8x, Real = %8x\n", tx_buffer[tx_new][i], rx_buffer[rx_new][i]);
+		    	return PACKET_LENGTH_TEST_FAIL;
+		    }
+		}
+	}
+	rx_ring[rx_new].status &= (~(RXPKT_STATUS));
+    	tx_new = (tx_new + 1) % NUM_TX;
+	rx_new = (rx_new + 1) % NUM_RX;
+
+	return TEST_PASS;
+}
+
+static int MAC1_init (int id)
+{
+	int phy_status = 0;
+
+	MAC1_reset ();
+	phy_status = set_mac1_control_register (id);
+       	ring_buffer_alloc ();
+       	
+       	return phy_status;
+}
+
+int do_mactest (void)
+{
+	unsigned int phy_id, i;
+	int test_result = 0, phy_status = 0;
+
+	SCU_MAC1_Enable();
+	phy_id = ((phy_read_register (0x02, 0) << 16) + phy_read_register (0x03, 0)) & PHYID_VENDOR_MASK;
+	if (phy_id == PHYID_VENDOR_MARVELL) {
+        	printf ("PHY DETECTED ------> MARVELL\n");
+
+        	set_phy_speed (phy_id, PHY_SPEED_1G, DUPLEX_FULL);
+        	if ((phy_status = MAC1_init (phy_id)) != 0) {
+	        	for (i = 0; i < NUM_TX; i++) {
+				test_result |= packet_test ();
+				if (test_result != 0)
+					break;
+        		}
+        	}
+		else if (phy_status == 0) {
+			printf ("PHY FAIL: Please Check If you are using LOOP BACK Connector\n");
+			test_result = 3;
+			return	test_result;
+		}
+        	if ((phy_status = MAC1_init (phy_id)) != 0) {
+        		for (i = 60; i < TX_BUFF_SZ; i++) {
+				test_result |= packet_length_test (i);
+				if (test_result != 0)
+					break;
+        		}
+        	}
+		else if (phy_status == 0) {
+			printf ("PHY FAIL: Please Check If you are using LOOP BACK Connector\n");
+			test_result = 3;
+			return	test_result;
+		}
+        	set_phy_speed (phy_id, PHY_SPEED_100M, DUPLEX_FULL);
+        	if ((phy_status = MAC1_init (phy_id)) != 0) {
+        		for (i = 0; i < NUM_TX; i++) {
+				test_result |= packet_test ();
+				if (test_result != 0)
+					break;
+        		}
+        	}
+		else if (phy_status == 0) {
+			printf ("PHY FAIL: Please Check If you are using LOOP BACK Connector\n");
+			test_result = 3;
+			return	test_result;
+		}
+
+        	if ((phy_status = MAC1_init (phy_id)) != 0) {
+        		for (i = 60; i < TX_BUFF_SZ; i++) {
+				test_result |= packet_length_test (i);
+        			if (test_result != 0)
+	        	    		break;
+        		}
+        	}
+		else if (phy_status == 0) {
+			printf ("PHY FAIL: Please Check If you are using LOOP BACK Connector\n");
+			test_result = 3;
+			return	test_result;
+		}
+        }
+	else if ( (phy_id == PHYID_VENDOR_RTL8201E) || (phy_id == PHYID_VENDOR_BROADCOM) ){
+		
+        	if (phy_id == PHYID_VENDOR_RTL8201E)
+        	    printf ("PHY DETECTED ------> RTL 8201E \n");
+        	else if (phy_id == PHYID_VENDOR_BROADCOM)
+        	    printf ("PHY DETECTED ------> Broadcom \n");
+        	
+        	set_phy_speed (phy_id, PHY_SPEED_100M, DUPLEX_FULL);
+        	if ((phy_status = MAC1_init (phy_id)) != 0) {
+        		for (i = 0; i < NUM_TX; i++) {
+				test_result |= packet_test ();
+				if (test_result != 0)
+					break;
+        		}
+        	}
+		else if (phy_status == 0) {
+			printf ("PHY FAIL: Please Check If you are using LOOP BACK Connector\n");
+			test_result = 3;
+			return	test_result;
+		}
+
+        	if ((phy_status = MAC1_init (phy_id)) != 0) {
+        		for (i = 60; i < TX_BUFF_SZ; i++) {
+				test_result |= packet_length_test (i);
+        			if (test_result != 0)
+	        	    		break;
+        		}
+        	}
+		else if (phy_status == 0) {
+			printf ("PHY FAIL: Please Check If you are using LOOP BACK Connector\n");
+			test_result = 3;
+			return	test_result;
+		}        	
+        }	
+          
+	if ((phy_status == 0) && (test_result & PACKET_TEST_FAIL)) {
+		printf ("Packet Test FAIL !\n");
+	}
+	else if ((phy_status == 0) && (test_result & PACKET_LENGTH_TEST_FAIL)) {
+		printf ("Packet Length Test FAIL !\n");
+	}
+
+	return test_result;
+	
+}
+
+#endif /* CONFIG_SLT */
diff --git a/board/aspeed/ast2300/mactest.h b/board/aspeed/ast2300/mactest.h
new file mode 100755
index 0000000..e75b7bb
--- /dev/null
+++ b/board/aspeed/ast2300/mactest.h
@@ -0,0 +1,215 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* MACTest.h */
+
+// --------------------------------------------------------------------
+//              General Definition
+// --------------------------------------------------------------------
+#define MAC1_IO_BASE		0x1E660000
+#define PHY_LOOP		100000
+#define NUM_RX			48
+#define NUM_TX			48
+#define RX_BUFF_SZ		1514
+#define TX_BUFF_SZ		1514
+#define TOUT_LOOP		1000000
+#define ETH_ALEN		6
+#define POLL_DEMAND		1
+
+
+// --------------------------------------------------------------------
+//              MAC Register Index
+// --------------------------------------------------------------------
+#define ISR_REG			0x00				// interrups status register
+#define IER_REG			0x04				// interrupt maks register
+#define MAC_MADR_REG		0x08				// MAC address (Most significant)
+#define MAC_LADR_REG		0x0c				// MAC address (Least significant)
+#define MAHT0_REG		0x10				// Multicast Address Hash Table 0 register
+#define MAHT1_REG		0x14				// Multicast Address Hash Table 1 register
+#define TXPD_REG		0x18				// Transmit Poll Demand register
+#define RXPD_REG		0x1c				// Receive Poll Demand register
+#define TXR_BADR_REG		0x20				// Transmit Ring Base Address register
+#define RXR_BADR_REG		0x24				// Receive Ring Base Address register
+#define HPTXPD_REG		0x28
+#define HPTXR_BADR_REG		0x2c
+#define ITC_REG			0x30				// interrupt timer control register
+#define APTC_REG		0x34				// Automatic Polling Timer control register
+#define DBLAC_REG		0x38				// DMA Burst Length and Arbitration control register
+#define DMAFIFOS_REG		0x3c
+#define FEAR_REG		0x44
+#define TPAFCR_REG		0x48
+#define RBSR_REG		0x4c
+#define MACCR_REG		0x50				// MAC control register
+#define MACSR_REG		0x54				// MAC status register
+#define PHYCR_REG		0x60				// PHY control register
+#define PHYDATA_REG		0x64				// PHY Write Data register
+
+// --------------------------------------------------------------------
+//		PHYCR_REG
+// --------------------------------------------------------------------
+#define PHY_RE_AUTO_bit			(1UL<<9)
+#define PHY_READ_bit			(1UL<<26)
+#define PHY_WRITE_bit			(1UL<<27)
+// --------------------------------------------------------------------
+//		PHYCR_REG 
+// --------------------------------------------------------------------
+#define PHY_AUTO_OK_bit			(1UL<<5)
+// --------------------------------------------------------------------
+//		PHY INT_STAT_REG 
+// --------------------------------------------------------------------
+#define PHY_SPEED_CHG_bit		(1UL<<14)
+#define PHY_DUPLEX_CHG_bit		(1UL<<13)
+#define PHY_LINK_CHG_bit		(1UL<<10)
+#define PHY_AUTO_COMP_bit		(1UL<<11)
+// --------------------------------------------------------------------
+//		PHY SPE_STAT_REG 
+// --------------------------------------------------------------------
+#define PHY_RESOLVED_bit		(1UL<<11)
+#define PHY_LINK_bit			(1UL<<10)
+#define PHY_SPEED_mask			0xC000
+#define PHY_SPEED_10M			0x0
+#define PHY_SPEED_100M			0x1
+#define PHY_SPEED_1G			0x2
+#define PHY_DUPLEX_mask                 0x2000
+#define PHY_SPEED_DUPLEX_MASK           0x01E0
+#define PHY_100M_DUPLEX                 0x0100
+#define PHY_100M_HALF                   0x0080
+#define PHY_10M_DUPLEX                  0x0040
+#define PHY_10M_HALF                    0x0020
+#define LINK_STATUS                     0x04
+#define PHYID_VENDOR_MASK		0xfffffc00
+#define PHYID_VENDOR_MARVELL		0x01410c00
+#define PHYID_VENDOR_BROADCOM		0x00406000
+#define PHYID_VENDOR_RTL8201E		0x001cc800
+#define DUPLEX_FULL			0x01
+#define DUPLEX_HALF			0x00
+
+
+
+// --------------------------------------------------------------------
+//		MACCR_REG
+// --------------------------------------------------------------------
+
+#define SW_RST_bit		(1UL<<31)				// software reset/
+#define DIRPATH_bit		(1UL<<21)
+#define RX_IPCS_FAIL_bit	(1UL<<20)
+#define SPEED_100M_MODE_bit		(1UL<<19)
+#define RX_UDPCS_FAIL_bit	(1UL<<18)
+#define RX_BROADPKT_bit		(1UL<<17)				// Receiving broadcast packet
+#define RX_MULTIPKT_bit		(1UL<<16)				// receiving multicast packet
+#define RX_HT_EN_bit		(1UL<<15)
+#define RX_ALLADR_bit		(1UL<<14)				// not check incoming packet's destination address
+#define JUMBO_LF_bit		(1UL<<13)
+#define RX_RUNT_bit		(1UL<<12)				// Store incoming packet even its length is les than 64 byte
+#define CRC_CHK_bit		(1UL<<11)
+#define CRC_APD_bit		(1UL<<10)				// append crc to transmit packet
+#define GMAC_MODE_bit		(1UL<<9)
+#define FULLDUP_bit		(1UL<<8)				// full duplex
+#define ENRX_IN_HALFTX_bit	(1UL<<7)
+#define LOOP_EN_bit		(1UL<<6)				// Internal loop-back
+#define HPTXR_EN_bit		(1UL<<5)
+#define REMOVE_VLAN_bit		(1UL<<4)
+#define RXMAC_EN_bit		(1UL<<3)				// receiver enable
+#define TXMAC_EN_bit		(1UL<<2)				// transmitter enable
+#define RXDMA_EN_bit		(1UL<<1)				// enable DMA receiving channel
+#define TXDMA_EN_bit		(1UL<<0)				// enable DMA transmitting channel
+
+
+// --------------------------------------------------------------------
+//		SCU_REG
+// --------------------------------------------------------------------
+#define  SCU_BASE			0x1E6E2000
+#define  SCU_PROTECT_KEY_REG            0x0
+#define  SCU_PROT_KEY_MAGIC             0x1688a8a8
+#define  SCU_RESET_CONTROL_REG          0x04
+#define  SCU_RESET_MAC1                 (1u << 11)
+#define  SCU_RESET_MAC2                 (1u << 12)
+#define  SCU_HARDWARE_TRAPPING_REG      0x70
+#define  SCU_HT_MAC_INTF_LSBIT          6
+#define  SCU_HT_MAC_INTERFACE           (0x7u << SCU_HT_MAC_INTF_LSBIT)
+#define  MAC_INTF_SINGLE_PORT_MODES     (1u<<0/*GMII*/ | 1u<<3/*MII_ONLY*/ | 1u<<4/*RMII_ONLY*/)
+#define  SCU_HT_MAC_GMII                0x0u
+// MII and MII mode
+#define  SCU_HT_MAC_MII_MII             0x1u
+#define  SCU_HT_MAC_MII_ONLY            0x3u
+#define  SCU_HT_MAC_RMII_ONLY           0x4u
+#define  SCU_MULTIFUNCTION_PIN_REG      0x74
+#define  SCU_MFP_MAC2_PHYLINK           (1u << 26)
+#define  SCU_MFP_MAC1_PHYLINK           (1u << 25)
+#define  SCU_MFP_MAC2_MII_INTF          (1u << 21)
+#define  SCU_MFP_MAC2_MDC_MDIO          (1u << 20)
+#define  SCU_SILICON_REVISION_REG       0x7C
+
+//---------------------------------------------------
+//  PHY R/W Register Bit
+//---------------------------------------------------
+#define MIIWR                   (1UL<<27)
+#define MIIRD                   (1UL<<26)
+#define MDC_CYCTHR              0x34
+#define PHY_SPEED_MASK          0xC000
+#define PHY_DUPLEX_MASK         0x2000
+#define SPEED_1000M             0x02
+#define SPEED_100M              0x01
+#define SPEED_10M               0x00
+#define DUPLEX_FULL             0x01
+#define DUPLEX_HALF             0x00
+#define RESOLVED_BIT            0x800
+
+#define PHY_SPEED_DUPLEX_MASK   0x01E0
+#define PHY_100M_DUPLEX         0x0100
+#define PHY_100M_HALF           0x0080
+#define PHY_10M_DUPLEX          0x0040
+#define PHY_10M_HALF            0x0020
+
+//---------------------------------------------------
+// Descriptor bits.
+//---------------------------------------------------
+#define TXDMA_OWN	0x80000000	/* Own Bit */
+#define RXPKT_RDY       0x00000000      
+#define RXPKT_STATUS    0x80000000
+#define EDORR		0x40000000	/* Receive End Of Ring */
+#define LRS		0x10000000	/* Last Descriptor */
+#define RD_ES		0x00008000	/* Error Summary */
+#define EDOTR		0x40000000	/* Transmit End Of Ring */
+#define T_OWN		0x80000000	/* Own Bit */
+#define LTS		0x10000000	/* Last Segment */
+#define FTS		0x20000000	/* First Segment */
+#define CRC_ERR         0x00080000
+#define TD_ES		0x00008000	/* Error Summary */
+#define TD_SET		0x08000000	/* Setup Packet */
+#define RX_ERR          0x00040000
+#define FTL             0x00100000
+#define RUNT            0x00200000
+#define RX_ODD_NB       0x00400000
+#define BYTE_COUNT_MASK 0x00003FFF
+
+//---------------------------------------------------
+// SPEED/DUPLEX Parameters
+//---------------------------------------------------
+
+//---------------------------------------------------
+// Return Status
+//---------------------------------------------------
+#define TEST_PASS			0
+#define PACKET_TEST_FAIL		1
+#define PACKET_LENGTH_TEST_FAIL		2
+
+struct  mac_desc {
+	volatile s32 status;
+	u32 des1;
+	u32 reserved;
+	u32 buf;	
+};
+static struct mac_desc rx_ring[NUM_RX] __attribute__ ((aligned(32))); /* RX descriptor ring         */
+static struct mac_desc tx_ring[NUM_TX] __attribute__ ((aligned(32))); /* TX descriptor ring         */
+static int rx_new;                             /* RX descriptor ring pointer */
+static int tx_new;                             /* TX descriptor ring pointer */
+static volatile unsigned char rx_buffer[NUM_RX][RX_BUFF_SZ] __attribute__ ((aligned(32))); /* RX buffer         */
+static volatile unsigned char tx_buffer[NUM_TX][TX_BUFF_SZ] __attribute__ ((aligned(32))); /* TX buffer         */
diff --git a/board/aspeed/ast2300/mictest.c b/board/aspeed/ast2300/mictest.c
new file mode 100755
index 0000000..1b2b342
--- /dev/null
+++ b/board/aspeed/ast2300/mictest.c
@@ -0,0 +1,146 @@
+/*
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Diagnostics support
+ */
+#include <common.h>
+#include <command.h>
+#include <post.h>
+#include "slt.h"
+
+#if ((CFG_CMD_SLT & CFG_CMD_MICTEST) && defined(CONFIG_SLT))
+#include "mictest.h"
+
+static unsigned char ctrlbuf[MIC_MAX_CTRL];
+static unsigned char chksumbuf[MIC_MAX_CHKSUM];
+
+void vInitSCU(void)
+{
+    unsigned long ulData;
+
+    *(unsigned long *) (0x1e6e2000) = 0x1688A8A8;
+
+    udelay(100);
+
+    ulData = *(unsigned long *) (0x1e6e2004);
+    ulData &= 0xbffff;
+    *(unsigned long *) (0x1e6e2004) = ulData;
+         	
+}
+
+void vInitMIC(void)
+{
+    unsigned long i, j, ulPageNumber;
+    unsigned char *pjctrl, *pjsum;
+    
+    ulPageNumber = DRAMSIZE >> 12;	
+
+    pjctrl = (unsigned char *)(m16byteAlignment((unsigned long) ctrlbuf));
+    pjsum = (unsigned char *)(m16byteAlignment((unsigned long) chksumbuf));
+    
+    /* init ctrl buffer (2bits for one page) */
+    for (i=0; i< (ulPageNumber/4); i++)
+        *(unsigned char *) (pjctrl + i) = DEFAULT_CTRL;
+      
+    /* init chksum buf (4bytes for one page) */
+    for (i=0; i<ulPageNumber; i++)
+        *(unsigned long *) (pjsum + i*4) = DEFAULT_CHKSUM;
+    
+    *(unsigned long *) (MIC_BASE + MIC_CTRLBUFF_REG)   = (unsigned long) pjctrl;
+    *(unsigned long *) (MIC_BASE + MIC_CHKSUMBUF_REG)  = (unsigned long) pjsum;
+    *(unsigned long *) (MIC_BASE + MIC_RATECTRL_REG)   = (unsigned long) DEFAULT_RATE;
+    *(unsigned long *) (MIC_BASE + MIC_ENGINECTRL_REG) = MIC_ENABLE_MIC | (DRAMSIZE - 0x1000);
+	
+}
+
+void vDisableMIC(void)
+{
+    *(unsigned long *) (MIC_BASE + MIC_ENGINECTRL_REG)   = MIC_RESET_MIC;
+	
+}
+
+int do_chksum(void)
+{
+    unsigned long i, j, k, ulPageNumber;
+    int Status = 0;
+    unsigned short tmp;
+    volatile unsigned long sum1, sum2;
+    unsigned long goldensum, chksum;
+    unsigned long len, tlen;
+    unsigned char *pjsum;
+
+    ulPageNumber = DRAMSIZE >> 12;	
+    pjsum = (unsigned char *)(m16byteAlignment((unsigned long) chksumbuf));
+
+    /* start test */    
+    for (i=0; i<ulPageNumber; i++)
+    {
+    	
+    	sum1 = 0xffff, sum2 = 0xffff;
+    	len = 0x0800;
+    	j = 0;
+    	
+    	while (len)
+    	{
+    	    tlen = len > 360 ? 360 : len;
+    	    len -= tlen;
+    	    do {
+    	       tmp = *(unsigned short *) (DRAM_BASE + ((i << 12) + j));	
+               sum1 += (unsigned long) tmp;   	    	
+    	       sum2 += sum1;
+    	       j+=2;
+    	    } while (--tlen);
+    	    sum1 = (sum1 & 0xffff) + (sum1 >> 16);
+    	    sum2 = (sum2 & 0xffff) + (sum2 >> 16);   	        	
+    	}
+    	
+    	sum1 = (sum1 & 0xffff) + (sum1 >> 16);
+    	sum2 = (sum2 & 0xffff) + (sum2 >> 16);
+    	
+    	goldensum = (sum2 << 16) | sum1;
+        k= 0;
+        do {
+            chksum = *(unsigned long *) (pjsum + i*4);
+            udelay(100);
+            k++;
+    	} while ((chksum == 0) && (k<1000));
+    	
+    	if (chksum != goldensum)
+    	{
+    	        Status = 1;	
+                printf("[FAIL] MIC Chksum Failed at Page %x \n", i);
+    	}
+
+    } /* end of i loop */
+		
+    return (Status);
+    	
+}
+
+int do_mictest (void)
+{
+        unsigned long Flags = 0;
+
+        vInitSCU();
+        vInitMIC();
+        
+        if (do_chksum())
+            Flags = 1;
+            
+        vDisableMIC();
+        
+	return Flags;
+	
+}
+
+#endif /* CONFIG_SLT */
diff --git a/board/aspeed/ast2300/mictest.h b/board/aspeed/ast2300/mictest.h
new file mode 100755
index 0000000..e14bb41
--- /dev/null
+++ b/board/aspeed/ast2300/mictest.h
@@ -0,0 +1,55 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* Macro */
+#define m08byteAlignment(x)		((x + 0x00000007) & 0xFFFFFFF8)
+#define m16byteAlignment(x)		((x + 0x0000000F) & 0xFFFFFFF0)
+#define m64byteAlignment(x)		((x + 0x0000003F) & 0xFFFFFFC0)
+
+/* Options */
+#define MIC_TEST_PAGE		32
+#define DRAMSIZE		(MIC_TEST_PAGE * 0x1000)
+#define MIC_MAX_CTRL		(MIC_TEST_PAGE / 4 + 16)
+#define MIC_MAX_CHKSUM		(MIC_TEST_PAGE * 4 + 16)
+
+/* Default Setting */
+#define DEFAULT_RATE		0x00000000
+#define DEFAULT_CTRL		0xFF
+#define DEFAULT_CHKSUM		0x00000000
+#define DEFAULT_WRITEBACK	0x08880000
+
+/* Reg. Definition */
+#define DRAM_BASE		0x40000000
+#define MIC_BASE		0x1e640000
+#define MIC_CTRLBUFF_REG	0x00
+#define MIC_CHKSUMBUF_REG	0x04
+#define MIC_RATECTRL_REG	0x08
+#define MIC_ENGINECTRL_REG	0x0C
+#define MIC_STOPPAGE_REG	0x10
+#define MIC_STATUS_REG		0x14
+#define MIC_STATUS1_REG		0x18
+#define MIC_STATUS2_REG		0x1C
+
+#define MIC_RESET_MIC		0x00000000
+#define MIC_ENABLE_MIC		0x10000000
+#define MIC_MAXPAGE_MASK	0x0FFFF000
+#define MIC_WRITEBACK_MASK	0xFFFF0000
+#define MIC_STOPPAGE_MASK	0x0000FFFF
+#define MIC_PAGEERROR		0x40000000
+#define MIC_PAGE1ERROR		0x10000000
+#define MIC_PAGE2ERROR		0x20000000
+#define MIC_INTMASK		0x00060000
+#define MIC_ERRPAGENO_MASK	0x0000FFFF
+
+#define MIC_CTRL_MASK		0x03
+#define MIC_CTRL_SKIP		0x00
+#define MIC_CTRL_CHK1		0x01
+#define MIC_CTRL_CHK2		0x02
+#define MIC_CTRL_CHK3		0x03
diff --git a/board/aspeed/ast2300/pci.c b/board/aspeed/ast2300/pci.c
new file mode 100755
index 0000000..5b17466
--- /dev/null
+++ b/board/aspeed/ast2300/pci.c
@@ -0,0 +1,243 @@
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2, or (at
+ * your option) any later version.
+ */
+
+#include <common.h>
+#include <pci.h>
+
+#ifdef CONFIG_PCI
+
+#define PCI_CSR_BASE		0x60000000
+#define ASPEED_PCI_IO_BASE	0x00000000
+#define ASPEED_PCI_IO_SIZE	0x00010000
+#define ASPEED_PCI_MEM_BASE	0x68000000
+#define ASPEED_PCI_MEM_SIZE	0x18000000
+
+#define CSR_CRP_CMD_OFFSET	0x00
+#define CSR_CRP_WRITE_OFFSET    0x04
+#define CSR_CRP_READ_OFFSET	0x08
+#define CSR_PCI_ADDR_OFFSET	0x0C
+#define CSR_PCI_CMD_OFFSET	0x10
+#define CSR_PCI_WRITE_OFFSET	0x14
+#define CSR_PCI_READ_OFFSET	0x18
+#define CSR_PCI_STATUS_OFFSET	0x1C
+
+#define CRP_ADDR_REG		(volatile ulong*) (PCI_CSR_BASE + CSR_CRP_CMD_OFFSET)
+#define CRP_WRITE_REG		(volatile ulong*) (PCI_CSR_BASE + CSR_CRP_WRITE_OFFSET)
+#define CRP_READ_REG		(volatile ulong*) (PCI_CSR_BASE + CSR_CRP_READ_OFFSET)
+#define PCI_ADDR_REG		(volatile ulong*) (PCI_CSR_BASE + CSR_PCI_ADDR_OFFSET)
+#define PCI_CMD_REG		(volatile ulong*) (PCI_CSR_BASE + CSR_PCI_CMD_OFFSET)
+#define PCI_WRITE_REG		(volatile ulong*) (PCI_CSR_BASE + CSR_PCI_WRITE_OFFSET)
+#define PCI_READ_REG		(volatile ulong*) (PCI_CSR_BASE + CSR_PCI_READ_OFFSET)
+
+#define PCI_CMD_READ		0x0A
+#define PCI_CMD_WRITE		0x0B
+
+#define RESET_PCI_STATUS        *(volatile ulong*) (PCI_CSR_BASE + CSR_PCI_STATUS_OFFSET) = 0x01
+#define CHK_PCI_STATUS          (*(volatile ulong*) (PCI_CSR_BASE + CSR_PCI_STATUS_OFFSET) & 0x03)
+
+static int pci_config_access (u8 access_type, u32 dev, u32 reg, u32 * data)
+{
+	u32 bus;
+	u32 device;
+	u32 function;
+
+	bus = ((dev & 0xff0000) >> 16);
+	device = ((dev & 0xf800) >> 11);
+	function = (dev & 0x0700);
+
+	if (bus == 0) {
+		// Type 0 Configuration 		
+		*PCI_ADDR_REG = (u32) (1UL << device | function | (reg & 0xfc));
+	} else {
+		// Type 1 Configuration 
+		*PCI_ADDR_REG = (u32) (dev | ((reg / 4) << 2) | 1);
+	}
+
+        RESET_PCI_STATUS;
+        
+	if (access_type == PCI_CMD_WRITE) {
+		*PCI_CMD_REG = (ulong) PCI_CMD_WRITE;
+		*PCI_WRITE_REG = *data;
+	} else {
+		*PCI_CMD_REG = (ulong) PCI_CMD_READ;		
+		*data = *PCI_READ_REG;
+	}
+            
+	return (CHK_PCI_STATUS);
+}
+
+static int aspeed_pci_read_config_byte (u32 hose, u32 dev, u32 reg, u8 * val)
+{
+	u32 data;
+
+	if (pci_config_access (PCI_CMD_READ, dev, reg, &data)) {
+		*val = 0;
+		return -1;
+	}	
+
+	*val = (data >> ((reg & 3) << 3)) & 0xff;
+
+	return 0;
+}
+
+
+static int aspeed_pci_read_config_word (u32 hose, u32 dev, u32 reg, u16 * val)
+{
+	u32 data;
+
+	if (reg & 1)
+		return -1;
+
+	if (pci_config_access (PCI_CMD_READ, dev, reg, &data)) {
+		*val = 0;
+		return -1;
+	} 		
+
+	*val = (data >> ((reg & 3) << 3)) & 0xffff;
+
+	return 0;
+}
+
+
+static int aspeed_pci_read_config_dword (u32 hose, u32 dev, u32 reg,
+					 u32 * val)
+{
+	u32 data = 0;
+
+	if (reg & 3)
+		return -1;
+
+	if (pci_config_access (PCI_CMD_READ, dev, reg, &data))	{
+		*val = 0;
+		return -1;
+	}		
+
+	*val = data;
+
+	return (0);
+}
+
+static int aspeed_pci_write_config_byte (u32 hose, u32 dev, u32 reg, u8 val)
+{
+	u32 data = 0;
+
+	if (pci_config_access (PCI_CMD_READ, dev, reg, &data))
+		return -1;
+
+	data = (data & ~(0xff << ((reg & 3) << 3))) | (val <<
+						       ((reg & 3) << 3));
+
+	if (pci_config_access (PCI_CMD_WRITE, dev, reg, &data))
+		return -1;
+
+	return 0;
+}
+
+
+static int aspeed_pci_write_config_word (u32 hose, u32 dev, u32 reg, u16 val)
+{
+	u32 data = 0;
+
+	if (reg & 1)
+		return -1;
+
+	if (pci_config_access (PCI_CMD_READ, dev, reg, &data))
+		return -1;
+
+	data = (data & ~(0xffff << ((reg & 3) << 3))) | (val <<
+							 ((reg & 3) << 3));
+
+	if (pci_config_access (PCI_CMD_WRITE, dev, reg, &data))
+		return -1;
+
+	return 0;
+}
+
+static int aspeed_pci_write_config_dword (u32 hose, u32 dev, u32 reg, u32 val)
+{
+	u32 data;
+
+	if (reg & 3) {
+		return -1;
+	}
+
+	data = val;
+
+	if (pci_config_access (PCI_CMD_WRITE, dev, reg, &data))
+		return -1;
+
+	return (0);
+}
+
+/*
+ *	Initialize PCIU
+ */
+aspeed_pciu_init ()
+{
+
+    unsigned long reg;
+
+    /* Reset PCI Host */
+    reg = *((volatile ulong*) 0x1e6e2004);
+    *((volatile ulong*) 0x1e6e2004) = reg | 0x00280000;
+
+    reg = *((volatile ulong*) 0x1e6e2074);		/* REQ2 */    
+    *((volatile ulong*) 0x1e6e2074) = reg | 0x00000010;
+
+    *((volatile ulong*) 0x1e6e2008) |= 0x00080000;        
+    reg = *((volatile ulong*) 0x1e6e200c); 
+    *((volatile ulong*) 0x1e6e200c) = reg & 0xfff7ffff;
+    udelay(1); 
+    *((volatile ulong*) 0x1e6e2004) &= 0xfff7ffff;
+                 
+    /* Initial PCI Host */
+    RESET_PCI_STATUS;
+	
+    *CRP_ADDR_REG = ((ulong)(PCI_CMD_READ) << 16) | 0x04;
+    reg = *CRP_READ_REG;
+    
+    *CRP_ADDR_REG = ((ulong)(PCI_CMD_WRITE) << 16) | 0x04;
+    *CRP_WRITE_REG = reg | 0x07;
+   
+}
+
+/*
+ *	Initialize Module
+ */
+
+void aspeed_init_pci (struct pci_controller *hose)
+{
+	hose->first_busno = 0;
+	hose->last_busno = 0xff;
+
+	aspeed_pciu_init ();			/* Initialize PCIU */
+
+	/* PCI memory space #1 */
+	pci_set_region (hose->regions + 0,
+			ASPEED_PCI_MEM_BASE, ASPEED_PCI_MEM_BASE, ASPEED_PCI_MEM_SIZE, PCI_REGION_MEM);
+
+	/* PCI I/O space */
+	pci_set_region (hose->regions + 1,
+			ASPEED_PCI_IO_BASE, ASPEED_PCI_IO_BASE, ASPEED_PCI_IO_SIZE, PCI_REGION_IO);
+
+	hose->region_count = 2;
+
+	hose->read_byte   = aspeed_pci_read_config_byte;
+	hose->read_word   = aspeed_pci_read_config_word;
+	hose->read_dword  = aspeed_pci_read_config_dword;
+	hose->write_byte  = aspeed_pci_write_config_byte;
+	hose->write_word  = aspeed_pci_write_config_word;
+	hose->write_dword = aspeed_pci_write_config_dword;
+
+	pci_register_hose (hose);
+
+	hose->last_busno = pci_hose_scan (hose);
+
+	return;
+}
+#endif /* CONFIG_PCI */
+
diff --git a/board/aspeed/ast2300/platform.S b/board/aspeed/ast2300/platform.S
new file mode 100644
index 0000000..27e8f26
--- /dev/null
+++ b/board/aspeed/ast2300/platform.S
@@ -0,0 +1,3089 @@
+/*
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/*
+ * Board specific setup info
+ *
+ ******************************************************************************
+ * ASPEED Technology Inc.
+ * AST2300/AST2400 DDR2/DDR3 SDRAM controller initialization and calibration sequence
+ *
+ * Gary Hsu, <gary_hsu@aspeedtech.com>
+ *
+ * Release date: 2014.12.29 formal release for SDK0.60
+ *
+ * Modified list from v0.23
+ * EC1. Modify DQIDLY and DQSI-MCLK2X calibration algorithm
+ * EC2. Remove pass 2 DQIDLY finetune process
+ * EC3. Modify ECC code
+ * EC4. Add AST2400 supporting
+ * EC5. Add SPI timing calibration for AST2400
+ * EC6. Remove AST2300-A0 PCI-e workaround
+ * EC7. Add CK duty calibration for AST2400
+ * EC8. Remove #define CONFIG_DRAM_UART_OUT, default has message output to UART5
+ * EC9. Add DRAM size auto-detection
+ * EC10. Add GPIO register clear when watchdog reboot (only for AST2400)
+ * EC11. Move the "Solve ASPM" code position of AST2300 to avoid watchdog reset
+ *
+ * Modified list from v0.53
+ * EC1. Add solution of LPC lock issue due to watchdog reset. (AP note A2300-11)
+ *
+ * Modified list from v0.56
+ * EC1. Fix read DQS input mask window too late issue if DRAM's t_DQSCK is earlier too much
+ *      (ex. Nanya NT5CB64M16FP)
+ *      1. Change init value of MCR18[4] from '1' to '0'
+ *      2. Add CBR4 code to finetune MCR18[4]
+ *
+ * Modified list from v0.59
+ * EC1. Add DQS input gating window delay tuning (1/2 T) when CBR retry
+ * EC2. Modify DLL1 MAdj = 0x4C
+ *
+ * Optional define variable
+ * 1. DRAM Speed             //
+ *    CONFIG_DRAM_336        // 336MHz (DDR-667)
+ *    CONFIG_DRAM_408        // 408MHz (DDR-800) (default)
+ * 2. ECC Function enable
+ *    CONFIG_DRAM_ECC        // define to enable ECC function
+ *                           // when enabled, must define the ECC protected memory size at 0x1e6e0054
+ * 3. UART5 message output   //
+ *    CONFIG_DRAM_UART_38400 // set the UART baud rate to 38400, default is 115200
+ ******************************************************************************
+ */
+
+#include <config.h>
+#include <version.h>
+/******************************************************************************
+ Calibration Macro Start
+ Usable registers:
+  r0, r1, r2, r3, r5, r6, r7, r8, r9, r10, r11
+ ******************************************************************************/
+/* PATTERN_TABLE,
+   init_delay_timer,
+   check_delay_timer,
+   clear_delay_timer,
+   record_dll2_pass_range,
+   record_dll2_pass_range_h,
+   are for DRAM calibration */
+
+PATTERN_TABLE:
+    .word   0xff00ff00
+    .word   0xcc33cc33
+    .word   0xaa55aa55
+    .word   0x88778877
+    .word   0x92cc4d6e       @ 5
+    .word   0x543d3cde
+    .word   0xf1e843c7
+    .word   0x7c61d253
+    .word   0x00000000       @ 8
+
+    .macro init_delay_timer
+    ldr r0, =0x1e782024                          @ Set Timer3 Reload
+    str r2, [r0]
+
+    ldr r0, =0x1e6c0038                          @ Clear Timer3 ISR
+    ldr r1, =0x00040000
+    str r1, [r0]
+
+    ldr r0, =0x1e782030                          @ Enable Timer3
+    ldr r1, [r0]
+    mov r2, #7
+    orr r1, r1, r2, lsl #8
+    str r1, [r0]
+
+    ldr r0, =0x1e6c0090                          @ Check ISR for Timer3 timeout
+    .endm
+
+    .macro check_delay_timer
+    ldr r1, [r0]
+    bic r1, r1, #0xFFFBFFFF
+    mov r2, r1, lsr #18
+    cmp r2, #0x01
+    .endm
+
+    .macro clear_delay_timer
+    ldr r0, =0x1e782030                          @ Disable Timer3
+    ldr r1, [r0]
+    bic r1, r1, #0x00000F00
+    str r1, [r0]
+
+    ldr r0, =0x1e6c0038                          @ Clear Timer3 ISR
+    ldr r1, =0x00040000
+    str r1, [r0]
+    .endm
+
+    .macro record_dll2_pass_range
+    ldr                 r1, [r0]
+    bic                 r2, r1, #0xFFFFFF00
+    cmp                 r2, r3                   @ record min
+    bicgt               r1, r1, #0x000000FF
+    orrgt               r1, r1, r3
+    bic                 r2, r1, #0xFFFF00FF
+    cmp                 r3, r2, lsr #8           @ record max
+    bicgt               r1, r1, #0x0000FF00
+    orrgt               r1, r1, r3, lsl #8
+    str                 r1, [r0]
+    .endm
+
+    .macro record_dll2_pass_range_h
+    ldr                 r1, [r0]
+    bic                 r2, r1, #0xFF00FFFF
+    mov                 r2, r2, lsr #16
+    cmp                 r2, r3                   @ record min
+    bicgt               r1, r1, #0x00FF0000
+    orrgt               r1, r1, r3, lsl #16
+    bic                 r2, r1, #0x00FFFFFF
+    cmp                 r3, r2, lsr #24          @ record max
+    bicgt               r1, r1, #0xFF000000
+    orrgt               r1, r1, r3, lsl #24
+    str                 r1, [r0]
+    .endm
+
+    .macro init_spi_checksum
+    ldr r0, =0x1e620084
+    ldr r1, =0x20010000
+    str r1, [r0]
+    ldr r0, =0x1e62008C
+    ldr r1, =0x20000200
+    str r1, [r0]
+    ldr r0, =0x1e620080
+    ldr r1, =0x0000000D
+    orr r2, r2, r7
+    orr r1, r1, r2, lsl #8
+    and r2, r6, #0xF
+    orr r1, r1, r2, lsl #4
+    str r1, [r0]
+    ldr r0, =0x1e620008
+    ldr r2, =0x00000800
+    .endm
+
+/******************************************************************************
+ Calibration Macro End
+ ******************************************************************************/
+LPC_Patch:                                       @ load to SRAM base 0x1e720400
+    str   r1, [r0]
+    str   r3, [r2]
+    bic   r1, r1, #0xFF
+LPC_Patch_S1:
+    subs  r5, r5, #0x01
+    moveq pc, r8
+    ldr   r3, [r2]
+    tst   r3, #0x01
+    movne pc, r8
+    mov   pc, r7
+LPC_Patch_S2:                                    @ load to SRAM base 0x1e720480
+    str   r1, [r0]
+    mov   pc, r9
+LPC_Patch_E:
+
+.globl lowlevel_init
+lowlevel_init:
+
+init_dram:
+    /* save lr */
+    mov r4, lr
+/* Test - DRAM initial time */
+    ldr r0, =0x1e782044
+    ldr r1, =0xFFFFFFFF
+    str r1, [r0]
+
+    ldr r0, =0x1e782030
+    ldr r1, [r0]
+    bic r1, r1, #0x0000F000
+    str r1, [r0]
+    mov r2, #3
+    orr r1, r1, r2, lsl #12
+    str r1, [r0]
+/* Test - DRAM initial time */
+
+    /*Set Scratch register Bit 7 before initialize*/
+    ldr r0, =0x1e6e2000
+    ldr r1, =0x1688a8a8
+    str r1, [r0]
+
+    ldr r0, =0x1e6e2040
+    ldr r1, [r0]
+    orr r1, r1, #0x80
+    str r1, [r0]
+
+    /* Fix LPC lock issue for AST2300 */
+    ldr r0, =0x1e6e207c                          @ Check AST2300
+    ldr r1, [r0]
+    mov r1, r1, lsr #24
+    cmp r1, #0x01
+    bne lpc_recover_end                          @ not match AST2300
+
+    mov r3, #0x0
+lpc_recover_check:
+    ldr r0, =0x1e78900c                          @ check HICR3[4]=0x1
+    ldr r1, [r0]
+    tst r1, #0x10
+    beq lpc_recover_end
+    ldr r0, =0x1e789004                          @ check HICR1[7]=0x1
+    ldr r1, [r0]
+    tst r1, #0x80
+    beq lpc_recover_end
+    ldr r0, =0x1e7890a0                          @ check LHCR0[27:24]=0x6
+    ldr r1, [r0]
+    mov r1, r1, lsr #24
+    and r1, r1, #0xF
+    cmp r1, #0x06
+    bne lpc_recover_end
+    add r3, r3, #0x01
+    cmp r3, #0x5                                 @ repeat 5 times
+    ble lpc_recover_check
+
+    mov r3, #0x0
+lpc_recover_init:
+    ldr r0, =0x1e7890a4                          @ set LHCR1[1:0]=0x0
+    ldr r1, =0x00000000
+    str r1, [r0]
+    add r3, r3, #0x01
+    cmp r3, #0x20
+    bge lpc_recover_end
+    ldr r1, [r0]
+    tst r1, #0x01
+    bne lpc_recover_init
+
+    ldr r0, =0x1e7890b0                          @ set LHCR4[7:0]=0xFF
+    ldr r1, =0x000000FF
+    str r1, [r0]
+    ldr r0, =0x1e7890b4                          @ set LHCR5[31:0]=0xFFFFFFFF
+    ldr r1, =0xFFFFFFFF
+    str r1, [r0]
+    ldr r0, =0x1e7890b8                          @ set LHCR6[31:0]=0xFFFFFFFF
+    str r1, [r0]
+
+    adr r6, LPC_Patch
+    adr r7, LPC_Patch_S2
+    ldr r0, =0x1e720400
+copy_lpc_patch_1:
+    ldr r1, [r6]
+    str r1, [r0]
+    add r6, r6, #0x4
+    add r0, r0, #0x4
+    cmp r6, r7
+    bne copy_lpc_patch_1
+
+    adr r6, LPC_Patch_S2
+    adr r7, LPC_Patch_E
+    ldr r0, =0x1e720480
+copy_lpc_patch_2:
+    ldr r1, [r6]
+    str r1, [r0]
+    add r6, r6, #0x4
+    add r0, r0, #0x4
+    cmp r6, r7
+    bne copy_lpc_patch_2
+
+    ldr r0, =0x1e7890a0                          @ set LHCR0[31:0]=0xFFFFFF01
+    ldr r1, =0xFFFFFF01
+    add r2, r0, #0x4
+    mov r3, #0x01
+    mov r5, #0x10
+    adr r9, lpc_recover_end
+    adr r6, LPC_Patch
+    adr r7, LPC_Patch_S1
+    sub r6, r7, r6
+    ldr r7, =0x1e720400
+    add r7, r7, r6
+    ldr r8, =0x1e720480
+    ldr pc, =0x1e720400
+
+lpc_recover_end:
+    ldr r0, =0x1e7890a0                          @ set LHCR0[31:0]=0xFFFFFF00
+    ldr r1, =0xFFFFFF00
+    str r1, [r0]
+    /* <END> Fix LPC lock issue for AST2300 */
+
+    /* Check Scratch Register Bit 6 */
+    ldr r0, =0x1e6e2040
+    ldr r1, [r0]
+    bic r1, r1, #0xFFFFFFBF
+    mov r2, r1, lsr #6
+    cmp r2, #0x01
+    beq platform_exit
+
+    ldr r2, =0x033103F1                          @ load PLL parameter for 24Mhz CLKIN (396:324)
+/*  ldr r2, =0x019001F0                          @ load PLL parameter for 24Mhz CLKIN (408:336) */
+    ldr r0, =0x1e6e207c                          @ Check Revision ID
+    ldr r1, [r0]
+    mov r1, r1, lsr #24
+    cmp r1, #0x02
+    bne set_MPLL                                 @ not match AST2400
+
+    ldr r0, =0x1e6e2070                          @ Check CLKIN freq
+    ldr r1, [r0]
+    mov r1, r1, lsr #23
+    tst r1, #0x01
+    ldrne r2, =0x017001D0                        @ load PLL parameter for 25Mhz CLKIN (400:325)
+
+set_MPLL:
+    ldr r0, =0x1e6e2020                          @ M-PLL (DDR SDRAM) Frequency
+    ldr r1, =0xFFFF
+#if defined(CONFIG_DRAM_336)
+    mov r2, r2, lsr #16
+#endif
+    and r1, r2, r1
+    str r1, [r0]
+
+/* Debug - UART console message */
+    ldr r0, =0x1e78400c
+    mov r1, #0x83
+    str r1, [r0]
+
+    ldr r0, =0x1e6e202c
+    ldr r2, [r0]
+    mov r2, r2, lsr #12
+    tst r2, #0x01
+    ldr r0, =0x1e784000
+    moveq r1, #0x0D                              @ Baudrate 115200
+    movne r1, #0x01                              @ Baudrate 115200, div13
+#if defined(CONFIG_DRAM_UART_38400)
+    moveq r1, #0x27                              @ Baudrate 38400
+    movne r1, #0x03                              @ Baudrate 38400 , div13
+#endif
+    str r1, [r0]
+
+    ldr r0, =0x1e784004
+    mov r1, #0x00
+    str r1, [r0]
+
+    ldr r0, =0x1e78400c
+    mov r1, #0x03
+    str r1, [r0]
+
+    ldr r0, =0x1e784008
+    mov r1, #0x07
+    str r1, [r0]
+
+    ldr r0, =0x1e784000
+    mov r1, #0x0D                                @ '\r'
+    str r1, [r0]
+    mov r1, #0x0A                                @ '\n'
+    str r1, [r0]
+    mov r1, #0x44                                @ 'D'
+    str r1, [r0]
+    mov r1, #0x52                                @ 'R'
+    str r1, [r0]
+    mov r1, #0x41                                @ 'A'
+    str r1, [r0]
+    mov r1, #0x4D                                @ 'M'
+    str r1, [r0]
+    mov r1, #0x20                                @ ' '
+    str r1, [r0]
+    mov r1, #0x49                                @ 'I'
+    str r1, [r0]
+    mov r1, #0x6E                                @ 'n'
+    str r1, [r0]
+    mov r1, #0x69                                @ 'i'
+    str r1, [r0]
+    mov r1, #0x74                                @ 't'
+    str r1, [r0]
+    mov r1, #0x2D                                @ '-'
+    str r1, [r0]
+    mov r1, #0x44                                @ 'D'
+    str r1, [r0]
+    mov r1, #0x44                                @ 'D'
+    str r1, [r0]
+    mov r1, #0x52                                @ 'R'
+    str r1, [r0]
+/* Debug - UART console message */
+
+    /* Delay about 100us */
+    ldr r0, =0x1e782030                          @ Init Timer3 Control
+    ldr r1, [r0]
+    bic r1, r1, #0x00000F00
+    str r1, [r0]
+
+    ldr r2, =0x00000064                          @ Set Timer3 Reload = 100 us
+    init_delay_timer
+delay_0:
+    check_delay_timer
+    bne delay_0
+    clear_delay_timer
+    /* end delay 100us */
+
+/******************************************************************************
+ Init DRAM common registers
+ ******************************************************************************/
+    ldr r0, =0x1e6e0000
+    ldr r1, =0xfc600309
+    str r1, [r0]
+
+    /* Reset MMC */
+    ldr r1, =0x00000000
+    ldr r0, =0x1e6e0034
+    str r1, [r0]
+    ldr r0, =0x1e6e0018
+    str r1, [r0]
+    ldr r0, =0x1e6e0024
+    str r1, [r0]
+    ldr r0, =0x1e6e0064                          @ REG_MADJ, power down DLL
+    str r1, [r0]
+
+    ldr r1, =0x00034C4C                          @ REG_MADJ, reset DLL
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0068                          @ REG_SADJ
+    ldr r1, =0x00001800
+    str r1, [r0]
+
+    /* Delay about 10us */
+    ldr r2, =0x0000000B                          @ Set Timer3 Reload = 10 us
+    init_delay_timer
+delay_1:
+    check_delay_timer
+    bne delay_1
+    clear_delay_timer
+    /* end delay 10us */
+
+    ldr r0, =0x1e6e0064                          @ REG_MADJ | 0xC0000, enable DLL
+    ldr r1, [r0]
+    ldr r2, =0xC0000
+    orr r1, r1, r2
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0008
+    ldr r1, =0x0090040f                          /* VGA */
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0018
+    ldr r1, =0x4000A120
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0018
+    ldr r1, =0x00000120
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0038
+    ldr r1, =0x00000000
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0040
+    ldr r1, =0xFF444444
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0044
+    ldr r1, =0x22222222
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0048
+    ldr r1, =0x22222222
+    str r1, [r0]
+
+    ldr r0, =0x1e6e004c
+    ldr r1, =0x22222222
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0050
+    ldr r1, =0x80000000
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0050
+    ldr r1, =0x00000000
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0054
+    ldr r1, =0x00000000
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0060                          @ REG_DRV
+    ldr r1, =0x000000FA                          @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr r1, =0x000000FA
+#endif
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0070
+    ldr r1, =0x00000000
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0074
+    ldr r1, =0x00000000
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0078
+    ldr r1, =0x00000000
+    str r1, [r0]
+
+    ldr r0, =0x1e6e007c
+    ldr r1, =0x00000000
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0080
+    ldr r1, =0x00000000
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0084
+    ldr r1, =0x00FFFFFF
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0088                          @ REG_DQIDLY
+    ldr r1, =0x00000089                          @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr r1, =0x00000074
+#endif
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0020                          @ REG_DQSIC
+    ldr r1, =0x000000E2                          @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr r1, =0x000000BA
+#endif
+    str r1, [r0]
+
+    /* Delay about 10us */
+    ldr r2, =0x0000000B                          @ Set Timer3 Reload = 10 us
+    init_delay_timer
+delay_2:
+    check_delay_timer
+    bne delay_2
+    clear_delay_timer
+    /* end delay 10us */
+
+    /* Check DRAM Type by H/W Trapping */
+    ldr r0, =0x1e6e2070
+    ldr r1, [r0]
+    bic r1, r1, #0xFEFFFFFF                      @ bit[24]=1 => DDR2
+    mov r2, r1, lsr #24
+    cmp r2, #0x01
+    beq ddr2_init
+    b   ddr3_init
+.LTORG
+
+/******************************************************************************
+ DDR3 Init
+
+ tRCD   = 15     ns
+ tRAS   = 37.5   ns
+ tRRD   = max(4 CK,10 ns)
+ tRP    = 15     ns
+ tRFC   = 110ns/1Gbit, 160ns/2Gbit, 300ns/4Gbit
+ tRTP   = max(4 CK,7.5 ns)
+ tWR    = 15     ns
+ tXSNR  = max(10 CK,200 ns)
+ tWTR   = max(4 CK,7.5 ns)
+ tFAW   = 50     ns
+ tMRD   = max(15 CK,20 ns)
+ ******************************************************************************/
+ddr3_init:
+/* Debug - UART console message */
+    ldr r0, =0x1e784000
+    mov r1, #0x33                                @ '3'
+    str r1, [r0]
+    mov r1, #0x0D                                @ '\r'
+    str r1, [r0]
+    mov r1, #0x0A                                @ '\n'
+    str r1, [r0]
+/* Debug - UART console message */
+
+    ldr r0, =0x1e6e0004
+    ldr r1, =0x00000531                          @ Default set to 1Gbit
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0010                          @ REG_AC1
+    ldr r1, =0x33302825                          @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr r1, =0x22202725
+#endif
+    str r1, [r0]
+
+    /* Check DRAM CL Timing by H/W Trapping */
+    ldr r0, =0x1e6e2070
+    ldr r1, [r0]
+    bic r1, r1, #0xF9FFFFFF
+    mov r2, r1, lsr #9                           @ Set CL
+    ldr r1, =0x00020000
+    add r2, r2, r1
+    ldr r1, [r0]
+    bic r1, r1, #0xFBFFFFFF
+    mov r1, r1, lsr #6                           @ Set CWL
+    orr r2, r2, r1
+    ldr r1, =0x00300000
+    add r2, r2, r1
+
+    ldr r0, =0x1e6e0014                          @ REG_AC2
+    ldr r1, =0xCC00963F                          @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr r1, =0xAA007636
+#endif
+    orr r1, r1, r2
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0004                          @ check 2400 mode
+    ldr r2, [r0]
+    mov r2, r2, lsr #10
+
+    ldr r0, =0x1e6e006c                          @ REG_IOZ
+    ldr r1, =0x00002312                          @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr r1, =0x00002312
+#endif
+    tst r2, #0x01
+    moveq r1, r1, lsr #8
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0120
+    mov r1, #0
+    str r1, [r0]
+    tst r2, #0x01                                @ check AST2300
+    beq CBRDLL1_2300_Start
+    ldr r0, =0x1e6e207c                          @ check AST2400 revision A0
+    ldr r1, [r0]
+    mov r1, r1, lsr #16
+    and r1, r1, #0xFF
+    cmp r1, #0x0
+    beq CBRDLL1_2300_Start
+    b   CBRDLL1_2400_Start
+MCLK2X_Phase_CBR_Done_DDR3:
+    ldr r0, =0x1e6e0018
+    ldr r1, [r0]
+    orr r1, r1, #0x40
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0034
+    ldr r1, =0x00000001
+    str r1, [r0]
+
+    ldr r0, =0x1e6e000c
+    ldr r1, =0x00000040
+    str r1, [r0]
+
+    /* Delay about 400us */
+    ldr r2, =0x00000190                          @ Set Timer3 Reload = 400 us
+    init_delay_timer
+delay3_4:
+    check_delay_timer
+    bne delay3_4
+    clear_delay_timer
+    /* end delay 400us */
+
+    /* Check DRAM CL Timing by H/W Trapping */
+    ldr r0, =0x1e6e2070
+    ldr r1, [r0]
+    bic r1, r1, #0xF9FFFFFF
+    mov r2, r1, lsr #21                          @ Set CL
+    ldr r1, =0x00000010
+    add r2, r2, r1
+    ldr r1, [r0]
+    bic r1, r1, #0xFBFFFFFF
+    mov r1, r1, lsr #7                           @ Set CWL
+    orr r2, r2, r1
+
+    ldr r0, =0x1e6e002c                          @ REG_MRS
+    ldr r1, =0x04001700                          @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr r1, =0x04001500
+#endif
+    orr r1, r1, r2
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0030                          @ REG_EMRS
+    ldr r1, =0x00000000                          @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr r1, =0x00000000
+#endif
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0028                          @ Set EMRS2
+    ldr r1, =0x00000005
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0028                          @ Set EMRS3
+    ldr r1, =0x00000007
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0028                          @ Set EMRS
+    ldr r1, =0x00000003
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0028                          @ Set MRS
+    ldr r1, =0x00000001
+    str r1, [r0]
+
+    ldr r0, =0x1e6e002c                          @ REG_MRS
+    ldr r1, =0x04001600                          @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr r1, =0x04001400
+#endif
+    orr r1, r1, r2
+    str r1, [r0]
+
+    ldr r0, =0x1e6e000c                          @ Refresh 8 times
+    ldr r1, =0x00005C48
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0028                          @ Set MRS
+    ldr r1, =0x00000001
+    str r1, [r0]
+
+    ldr r0, =0x1e6e000c                          @ Set refresh cycle
+    ldr r1, =0x00002001
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0014
+    ldr r1, [r0]
+    bic r1, r1, #0xFFF9FFFF
+    mov r2, r1, lsr #3                           @ get CL
+
+    ldr r0, =0x1e6e0034                          @ REG_PWC
+    ldr r1, =0x00000303                          @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr r1, =0x00000303
+#endif
+    orr r1, r1, r2
+    str r1, [r0]
+
+    b   Calibration_Start
+.LTORG
+/******************************************************************************
+ End DDR3 Init
+ ******************************************************************************/
+
+/******************************************************************************
+ DDR2 Init
+
+ tRCD   = 15    ns
+ tRAS   = 45    ns
+ tRRD   = 10    ns
+ tRP    = 15    ns
+ tRFC   = 105ns/512Mbit, 127.5ns/1Gbit, 197.5ns/2Gbit, 327.5ns/4Gbit
+ tRTP   = 7.5   ns
+ tWR    = 15    ns
+ tXSNR  = 200   ns
+ tWTR   = 7.5   ns
+ tFAW   = 50    ns
+ tMRD   = 4     CK
+ ******************************************************************************/
+ddr2_init:
+/* Debug - UART console message */
+    ldr r0, =0x1e784000
+    mov r1, #0x32                                @ '2'
+    str r1, [r0]
+    mov r1, #0x0D                                @ '\r'
+    str r1, [r0]
+    mov r1, #0x0A                                @ '\n'
+    str r1, [r0]
+/* Debug - UART console message */
+
+    ldr r0, =0x1e6e0004
+    ldr r1, =0x00000510                          @ Default set to 512Mbit
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0010                          @ REG_AC1
+    ldr r1, =0x33302714                          @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr r1, =0x22201613
+#endif
+    str r1, [r0]
+
+    /* Check DRAM CL Timing by H/W Trapping */
+    ldr r0, =0x1e6e2070
+    ldr r1, [r0]
+    bic r1, r1, #0xF9FFFFFF
+    mov r2, r1, lsr #5                           @ Set CL
+    mov r1, r2, lsr #4                           @ Set CWL
+    orr r2, r2, r1
+    ldr r1, =0x00110000
+    add r2, r2, r1
+
+    ldr r0, =0x1e6e0014                          @ REG_AC2
+    ldr r1, =0xCC00B03F                          @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr r1, =0xAA00903B
+#endif
+    orr r1, r1, r2
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0004                          @ check 2400 mode
+    ldr r2, [r0]
+    mov r2, r2, lsr #10
+
+    ldr r0, =0x1e6e006c                          @ REG_IOZ
+    ldr r1, =0x00002312                          @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr r1, =0x00002312
+#endif
+    tst r2, #0x01
+    moveq r1, r1, lsr #8
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0120
+    mov r1, #1
+    str r1, [r0]
+    tst r2, #0x01                                @ check AST2300
+    beq CBRDLL1_2300_Start
+    ldr r0, =0x1e6e207c                          @ check AST2400 revision A0
+    ldr r1, [r0]
+    mov r1, r1, lsr #16
+    and r1, r1, #0xFF
+    cmp r1, #0x0
+    beq CBRDLL1_2300_Start
+    b   CBRDLL1_2400_Start
+MCLK2X_Phase_CBR_Done_DDR2:
+
+    ldr r0, =0x1e6e0034
+    ldr r1, =0x00000001
+    str r1, [r0]
+
+    ldr r0, =0x1e6e000c
+    ldr r1, =0x00000000
+    str r1, [r0]
+
+    /* Delay about 400us */
+    ldr r2, =0x00000190                          @ Set Timer3 Reload = 400 us
+    init_delay_timer
+delay2_4:
+    check_delay_timer
+    bne delay2_4
+    clear_delay_timer
+    /* end delay 400us */
+
+    /* Check DRAM CL Timing by H/W Trapping */
+    ldr r0, =0x1e6e2070
+    ldr r1, [r0]
+    bic r1, r1, #0xF9FFFFFF
+    mov r2, r1, lsr #21                          @ Set CL
+    ldr r1, =0x00000040
+    orr r2, r2, r1
+
+    ldr r0, =0x1e6e002c                          @ REG_MRS
+    ldr r1, =0x00000D03                          @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr r1, =0x00000B03
+#endif
+    orr r1, r1, r2
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0030                          @ REG_EMRS
+    ldr r1, =0x00000040                          @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr r1, =0x00000040
+#endif
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0028                          @ Set EMRS2
+    ldr r1, =0x00000005
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0028                          @ Set EMRS3
+    ldr r1, =0x00000007
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0028                          @ Set EMRS
+    ldr r1, =0x00000003
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0028                          @ Set MRS
+    ldr r1, =0x00000001
+    str r1, [r0]
+
+    ldr r0, =0x1e6e000c                          @ Refresh 8 times
+    ldr r1, =0x00005C08
+    str r1, [r0]
+
+    ldr r0, =0x1e6e002c                          @ REG_MRS
+    ldr r1, =0x00000C03                          @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr r1, =0x00000A03
+#endif
+    orr r1, r1, r2
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0028                          @ Set MRS
+    ldr r1, =0x00000001
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0030                          @ REG_EMRS
+    ldr r1, =0x000003C0                          @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr r1, =0x000003C0
+#endif
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0028                          @ Set EMRS
+    ldr r1, =0x00000003
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0030                          @ REG_EMRS
+    ldr r1, =0x00000040                          @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr r1, =0x00000040
+#endif
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0028                          @ Set EMRS
+    ldr r1, =0x00000003
+    str r1, [r0]
+
+    ldr r0, =0x1e6e000c                          @ Set refresh cycle
+    ldr r1, =0x00002001
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0014
+    ldr r1, [r0]
+    bic r1, r1, #0xFFF9FFFF
+    mov r2, r1, lsr #3                           @ get CL
+
+    ldr r0, =0x1e6e0034                          @ REG_PWC
+    ldr r1, =0x00000503                          @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr r1, =0x00000503
+#endif
+    orr r1, r1, r2
+    str r1, [r0]
+
+    b   Calibration_Start
+.LTORG
+/******************************************************************************
+ End DDR2 Init
+ ******************************************************************************/
+/******************************************************************************
+ DDR CK duty finetune program
+    SRAM buffer definition
+    0x1E720204 : gdll     golden DLL1 record
+    0x1E720208 : gduty    golden duty setting record
+    0x1E72020C : gdutysum golden duty data record
+    0x1E720210 : duty record of delay 0  invert
+    0x1E720214 : duty record of delay 1  invert
+    ....
+    0x1E72024C : duty record of delay 15 invert
+    0x1E720250 : duty record of delay 0
+    0x1E720254 : duty record of delay 1
+    ....
+    0x1E72028C : duty record of delay 15
+
+    Register usage
+    r0 - r3 = free
+    r4  = record the return pc value, do not use
+    r5  = free
+    r6  = free
+    r7  = duty count
+    r8  = gdll
+    r9  = gduty
+    r10 = gdutysum
+ ******************************************************************************/
+CBRDLL1_2400_Start:
+    ldr   r0, =0x1e6e0120
+    ldr   r1, [r0]
+    orr   r1, r1, #0x02
+    str   r1, [r0]
+
+    ldr   r1, =0x00000000
+    ldr   r0, =0x1e720204
+    ldr   r2, =0x1e7202a0
+init_sram_start0:
+    str   r1, [r0]
+    add   r0, r0, #4
+    cmp   r0, r2
+    blt   init_sram_start0
+
+    ldr   r0, =0x1e6e0034
+    mov   r1, #0x20
+    str   r1, [r0]
+
+    ldr   r0, =0x1e6e0060
+    ldr   r1, [r0]
+    mov   r2, #0x01
+    orr   r1, r1, r2, lsl #13
+    str   r1, [r0]
+
+    mov   r7, #0x0                               @ init duty count
+    mov   r8, #0x0                               @ init gdll
+    mov   r9, #0x0                               @ init gduty
+    mov   r10, #0x0                              @ init gdutysum
+cbrdll1_duty_start:
+    cmp   r7, #32
+    bge   cbrdll1_duty_end
+
+    ldr   r0, =0x1e6e0018
+    ldr   r1, =0x00008120
+    str   r1, [r0]
+
+    ldr   r0, =0x1e6e0060
+    ldr   r1, [r0]
+    bic   r1, r1, #0x00001F00
+    orr   r1, r1, r7, lsl #8
+    mov   r2, #0x10
+    eor   r1, r1, r2, lsl #8
+    str   r1, [r0]
+
+    ldr   r0, =0x1e6e0000                        @ dummy read
+    ldr   r1, [r0]
+
+    b     CBRDLL1_2300_Start
+CBRDLL1_2400_Call:
+
+    mov   r5, #0x01                              @ init dqidly count
+    mov   r6, #0x00                              @ init duty sum
+cbrdll1_duty_cal_start:
+    cmp   r5, #0x05
+    bge   cbrdll1_duty_cal_end
+
+    ldr   r0, =0x1e6e0018
+    ldr   r1, =0x00200120
+    orr   r1, r1, r5, lsl #16
+    str   r1, [r0]
+
+    ldr   r0, =0x1e6e0000
+    ldr   r1, [r0]
+
+    ldr   r0, =0x1e6e0018
+    ldr   r1, [r0]
+    mov   r2, #0x10
+    orr   r1, r1, r2, lsl #24
+    str   r1, [r0]
+
+    ldr   r0, =0x1e6e0080
+    ldr   r1, =0x80000000                        @ init duty cal waiting
+cbrdll1_duty_cal_wait:
+    ldr   r2, [r0]
+    tst   r2, r1
+    beq   cbrdll1_duty_cal_wait
+
+    ldr   r0, =0x1e6e008c
+    ldr   r2, [r0]
+
+    ldr   r0, =0x1e720210
+    add   r0, r0, r7, lsl #2
+    str   r2, [r0]
+
+    ldr   r1, =0xFFFF
+    and   r3, r1, r2
+    cmp   r3, r1
+    moveq r2, r2, lsr #16
+    and   r3, r1, r2
+    add   r6, r6, r3
+    ldr   r1, =0xF000
+    cmp   r3, r1
+    blt   cbrdll1_duty_cal_end
+    add   r5, r5, #0x01
+    b     cbrdll1_duty_cal_start
+
+cbrdll1_duty_cal_end:
+    mov   r6, r6, lsr #2                         @ get dutysum
+    cmp   r6, r10                                @ check dutysum > gdutysum
+    ble   cbrdll1_duty_next
+    ldr   r0, =0x1e6e0068
+    ldr   r8, [r0]
+    eor   r9, r7, #0x10
+    mov   r10, r6
+
+cbrdll1_duty_next:
+    add   r7, r7, #0x01
+    cmp   r7, #16                                @ check duty >= 15
+    blt   cbrdll1_duty_start
+    ldr   r0, =0xFA00                            @ check gdutysum > 0xFA00
+    cmp   r10, r0
+    blt   cbrdll1_duty_start
+
+cbrdll1_duty_end:
+    ldr   r0, =0x1e6e0060
+    ldr   r1, [r0]
+    bic   r1, r1, #0x00001F00
+    orr   r1, r1, r9, lsl #8
+    str   r1, [r0]
+
+    ldr   r0, =0x1e6e0068
+    bic   r8, r8, #0xFF000000
+    bic   r8, r8, #0x00FF0000
+    str   r8, [r0]
+
+    ldr   r0, =0x1e720204                        @ record result
+    str   r8, [r0]
+    add   r0, r0, #0x04
+    str   r9, [r0]
+    add   r0, r0, #0x04
+    str   r10, [r0]
+
+    ldr   r0, =0x1e6e0018
+    ldr   r1, =0x00008120
+    str   r1, [r0]
+    ldr   r0, =0x1e6e0000                        @ dummy read
+    ldr   r1, [r0]
+    ldr   r0, =0x1e6e0018
+    ldr   r1, =0x00000120
+    str   r1, [r0]
+
+    ldr   r0, =0x1e6e0120
+    ldr   r1, [r0]
+    cmp   r1, #0x3
+    beq   MCLK2X_Phase_CBR_Done_DDR2
+    b     MCLK2X_Phase_CBR_Done_DDR3
+
+/******************************************************************************
+ MCLK2X lock to MCLK program
+  r0 - r3 = free
+  r5 = madjmax
+  r6 = dllend
+  0x1E720200 = 0x96cnt:failcnt:dllmax:dllmin
+ ******************************************************************************/
+CBRDLL1_2300_Start:
+    ldr   r0, =0x1e6e0064
+    ldr   r5, [r0]
+    and   r5, r5, #0xFF                          @ init madjmax
+    mov   r6, r5                                 @ init dllend
+
+    ldr   r1, =0x000000ff
+    ldr   r0, =0x1e720200
+    str   r1, [r0]                               @ init dllcnt2:dllmax:dllmin
+
+    mov   r3, #0x0                               @ init loop count
+cbrdll1_scan_start:
+    cmp   r3, r6
+    bge   cbrdll1_scan_end
+
+    ldr   r0, =0x1e6e0018
+    ldr   r1, =0x00008120
+    str   r1, [r0]
+
+    ldr   r0, =0x1e6e0068
+    mov   r1, r3
+    cmp   r1, r5
+    subge r1, r1, r5
+    str   r1, [r0]
+
+    ldr   r0, =0x1e6e0000                        @ dummy read
+    ldr   r1, [r0]
+
+    ldr   r0, =0x1e6e0018
+    ldr   r1, =0x00000120
+    str   r1, [r0]
+
+    ldr   r0, =0x1e6e0000                        @ dummy read
+    ldr   r1, [r0]
+    ldr   r0, =0x1e6e0000                        @ dummy read
+    ldr   r1, [r0]
+
+    ldr   r0, =0x1e6e001c
+    ldr   r1, [r0]
+    mov   r1, r1, lsr #16
+    and   r1, r1, #0xFF
+
+    and   r2, r1, #0x96
+    cmp   r2, #0x96
+    beq   cbrdll1_scan_pass                      @ if (mclk2x_phase & 0x96) == 0x96
+    ldr   r0, =0x1e720200
+    ldr   r1, [r0]
+    mov   r2, r1, lsr #8
+    ands  r2, r2, #0xFF                          @ get dllmax
+    beq   cbrdll1_scan_next                      @ if dllmax == 0
+    mov   r2, r1, lsr #16
+    and   r2, r2, #0xFF
+    add   r2, r2, #0x01
+    cmp   r2, #0x02
+    movge r6, r3
+    bic   r1, r1, #0x00FF0000
+    orr   r1, r1, r2, lsl #16
+    str   r1, [r0]
+    b     cbrdll1_scan_next
+
+cbrdll1_scan_pass:
+    cmp   r3, #0x0                               @ if dll = 0
+    moveq r3, #0x0F
+    addeq r6, r6, #0x10
+    beq   cbrdll1_scan_next
+    ldr   r0, =0x1e720200
+    ldr   r2, [r0]
+    cmp   r1, #0x96
+    bne   cbrdll1_scan_pass2
+    mov   r1, r2, lsr #24
+    add   r1, r1, #0x01
+    bic   r2, r2, #0xFF000000
+    orr   r2, r2, r1, lsl #24
+    cmp   r1, #0x03                              @ check (phase == 0x96) count == 3
+    bicge r2, r2, #0x0000FF00
+    bicge r2, r2, #0x000000FF
+    orrge r2, r2, r3, lsl #8
+    orrge r2, r2, r3
+    str   r2, [r0]
+    bge   cbrdll1_scan_end
+
+cbrdll1_scan_pass2:
+    and   r1, r2, #0xFF                          @ if(dllmin > dll)
+    cmp   r1, r3
+    bicgt r2, r2, #0x000000FF
+    orrgt r2, r2, r3
+
+    mov   r1, r2, lsr #8                         @ if(dllmax < dll)
+    and   r1, r1, #0xFF
+    cmp   r1, r3
+    biclt r2, r2, #0x0000FF00
+    orrlt r2, r2, r3, lsl #8
+
+    bic   r2, r2, #0x00FF0000
+    str   r2, [r0]
+
+cbrdll1_scan_next:
+    add   r3, r3, #0x01
+    b     cbrdll1_scan_start
+
+cbrdll1_scan_end:
+    ldr   r0, =0x1e720200
+    ldr   r1, [r0]
+    mov   r2, r1, lsr #8                         @ get dllmax
+    ands  r2, r2, #0xFF
+    bne   cbrdll1_scan_done                      @ if(dllmax != 0)
+    ldr   r0, =0x1e6e0064
+    ldr   r3, [r0]
+    bic   r1, r3, #0x000C0000
+    str   r1, [r0]
+    add   r0, r0, #0x04
+    mov   r1, #0x0
+    str   r1, [r0]
+
+    /* Delay about 10us */
+    ldr r2, =0x0000000A                          @ Set Timer3 Reload = 10 us
+    init_delay_timer
+delay0_1:
+    check_delay_timer
+    bne delay0_1
+    clear_delay_timer
+    /* end delay 10us */
+
+    ldr   r0, =0x1e6e0064
+    str   r3, [r0]
+
+    /* Delay about 10us */
+    ldr r2, =0x0000000A                          @ Set Timer3 Reload = 10 us
+    init_delay_timer
+delay0_2:
+    check_delay_timer
+    bne delay0_2
+    clear_delay_timer
+    /* end delay 10us */
+
+    b     CBRDLL1_2300_Start
+
+cbrdll1_scan_done:
+    and   r1, r1, #0xFF
+    add   r1, r1, r2
+    mov   r6, r1, lsr #1                         @ dll1.0 = (dllmin + dllmax) >> 1
+    cmp   r6, r5
+    subge r6, r6, r5
+    add   r3, r6, r5, lsr #2                     @ dll1.1 = dll1.0 + (MADJ >> 2)
+
+    ldr   r0, =0x1e6e0004
+    ldr   r1, [r0]
+    mov   r1, r1, lsr #10
+    tst   r1, #0x1
+    bne   cbrdll1_scan_set_2400
+    cmp   r3, r5
+    subge r3, r3, r5
+    mov   r2, #0x0
+    tst   r3, #0x08
+    beq   cbrdll1_scan_set_2300_2                @ if !(dll & 8)
+cbrdll1_scan_set_2300_1:                         @ if  (dll & 8)
+    mov   r1, #0x0
+    tst   r3, #0x08
+    addeq r1, r1, #0x01
+    cmp   r2, #0x05
+    addge r1, r1, #0x01
+    cmp   r1, #0x02
+    beq   cbrdll1_scan_set
+    add   r2, r2, #0x01
+    add   r3, r3, #0x01
+    cmp   r3, r5
+    subge r3, r3, r5
+    b     cbrdll1_scan_set_2300_1
+
+cbrdll1_scan_set_2300_2:
+    and   r1, r3, #0x07
+    cmp   r1, #0x07
+    beq   cbrdll1_scan_set
+    cmp   r2, #0x05
+    bge   cbrdll1_scan_set
+    add   r2, r2, #0x01
+    add   r3, r3, #0x01
+    cmp   r3, r5
+    subge r3, r3, r5
+    b     cbrdll1_scan_set_2300_2
+
+cbrdll1_scan_set_2400:
+    add   r3, r3, #0x05                          @ dll1.1 = dll1.0 + (MADJ >> 2) + 5
+    cmp   r3, r5
+    subge r3, r3, r5
+
+cbrdll1_scan_set:
+    orr   r1, r6, r3, lsl #8
+    ldr   r0, =0x1e6e0068
+    str   r1, [r0]
+
+    ldr   r0, =0x1e6e0120
+    ldr   r1, [r0]
+    cmp   r1, #0x0
+    beq   MCLK2X_Phase_CBR_Done_DDR3
+    cmp   r1, #0x1
+    beq   MCLK2X_Phase_CBR_Done_DDR2
+    b     CBRDLL1_2400_Call
+
+.LTORG
+
+/******************************************************************************
+ Calibration Code Start
+    SRAM buffer definition
+    0x1E720000 : Pass 1, DLLI MIN value range
+    0x1E720008 : DQS0 DLL valid range, 2nd time CBR
+    0x1E72000C : DQS1 DLL valid range, 2nd time CBR
+    0x1E720010 : DQ0  DLL valid range, Pass 1
+    0x1E720014 : DQ1  DLL valid range, Pass 1
+    ....
+    0x1E720048 : DQ14 DLL valid range, Pass 1
+    0x1E72004C : DQ15 DLL valid range, Pass 1
+    0x1E720090 : DLL1 SAdj record
+    0x1E720094 : DQL  Pass1 finetune result
+    0x1E720098 : DQH  Pass1 finetune result
+    0x1E72009C : DRAM initial time, (us)
+    0x1E7200A0 : CBR3 retry counter
+    0x1E7200A4 : DRAM initial time, (us)
+    0x1E7200A8 : Released date
+    0x1E7200AC : Released SDK version
+    0x1E7200B0 : DQS input mask window for MCR18[4] = 0
+    0x1E7200B4 : DQS input mask window for MCR18[4] = 1
+    0x1E720100 : DQIDLY=00, DLL valid range
+    0x1E720104 : DQIDLY=01, DLL valid range
+    ....
+    0x1E720178 : DQIDLY=30, DLL valid range
+    0x1E72017C : DQIDLY=31, DLL valid range
+    0x1E720180 : DQSI-MCLK2X P-phase pass record DLL2= 0-31
+    0x1E720184 : DQSI-MCLK2X P-phase pass record DLL2=32-63
+    0x1E720188 : DQSI-MCLK2X N-phase pass record DLL2= 0-31
+    0x1E72018C : DQSI-MCLK2X N-phase pass record DLL2=32-63
+ ******************************************************************************/
+Calibration_Start_pre:                           @ Toggle DQSI mask delay
+    ldr r0, =0x1e6e0018
+    ldr r1, [r0]
+    eor r1, r1, #0x10
+    str r1, [r0]
+
+Calibration_Start:
+/* Init SRAM buffer */
+    ldr r1, =0x000000ff
+    ldr r0, =0x1e720000
+    ldr r2, =0x1e720100
+init_sram_start:
+    str r1, [r0]
+    add r0, r0, #4
+    cmp r0, r2
+    blt init_sram_start
+
+    ldr r1, =0x00ff00ff
+    ldr r0, =0x1e720100
+    ldr r2, =0x1e720180
+init_sram_start2:
+    str r1, [r0]
+    add r0, r0, #4
+    cmp r0, r2
+    blt init_sram_start2
+
+    ldr r1, =0x00000000
+    ldr r0, =0x1e720180
+    ldr r2, =0x1e720200
+init_sram_start3:
+    str r1, [r0]
+    add r0, r0, #4
+    cmp r0, r2
+    blt init_sram_start3
+
+    ldr r0, =0x1e6e0068                          @ save the DLL1 SAdj initial value
+    ldr r1, [r0]
+    ldr r0, =0x1e720090
+    str r1, [r0]
+
+/* Start
+  r0 = free
+  r1 = free
+  r2 = free
+  r3 = free
+  r4 = record the return pc value, do not use
+  r5 = pattern table index
+  r6 = pass count
+  r7 = dram DLL2 parameter index (0x1e6e0068), max is 0x4C
+*/
+/******************************************************************************
+ Fine DQI delay and DQSI-MCLK phase
+  r8  = DQIDLY count
+  r9  = DQSI-MCLK2X phase count
+  r10 = pattern fail retry counter, initialize to 2 (fail 2 times)
+  r11 = passcnt accumulator for each DQIDLY
+ *****************************************************************************/
+CBR0_START:
+/* Debug - UART console message */
+    ldr r0, =0x1e784000
+    mov r1, #0x43                                @ 'C'
+    str r1, [r0]
+    mov r1, #0x42                                @ 'B'
+    str r1, [r0]
+    mov r1, #0x52                                @ 'R'
+    str r1, [r0]
+    mov r1, #0x30                                @ '0'
+    str r1, [r0]
+    mov r1, #0x2D                                @ '-'
+    str r1, [r0]
+/* Debug - UART console message */
+
+    ldr   r0, =0x1e6e0018
+    ldr   r1, [r0]
+    bic   r1, r1, #0xFF000000
+    bic   r1, r1, #0x00FF0000
+    str   r1, [r0]
+
+    ldr   r0, =0x1e6e0074                        @ set the testing DRAM size = 1KB
+    ldr   r1, =0x000003FF
+    str   r1, [r0]
+
+    mov   r8, #0x00                              @ init DQIDLY
+    mov   r9, #0x00                              @ init DQSI-MCLK2X phase
+    mov   r11, #0x01                             @ init passcnt accumulator
+
+cbr0_next_dqidly:
+    cmp   r9, #0x00
+    bne   cbr0_next_dqsiphase
+    cmp   r11, #0x00
+    addeq r8, r8, #0x01                          @ jump 1 stage if no pass at previous stage
+    mov   r11, #0x00
+    add   r8, r8, #0x01
+    cmp   r8, #0x1F                              @ max DQIDLY = 31
+    bgt   CBR0_END
+
+/* Debug - UART console message */
+    ldr   r0, =0x1e784000
+    and   r1, r8, #0x07
+    add   r1, r1, #0x30                          @ '0-7'
+    str   r1, [r0]
+/* Debug - UART console message */
+
+    ldr   r0, =0x1e6e0018
+    ldr   r1, [r0]
+    bic   r1, r1, #0x00FF0000
+    orr   r1, r1, r8, lsl #16
+    str   r1, [r0]
+    mov   r9, #0x01                              @ '1':p_phase, '0':n_phase
+
+    /* Delay about 3us */                        @ wait DQIDLY load
+    ldr r2, =0x00000003                          @ Set Timer4 Reload = 3 us
+    init_delay_timer
+delay_4:
+    check_delay_timer
+    bne delay_4
+    clear_delay_timer
+    /* end delay 3us */
+
+    b     cbr0_dll2_scan_start
+
+cbr0_next_dqsiphase:
+    ldr   r0, =0x1e6e0018
+    ldr   r1, [r0]
+    orr   r1, r1, r9, lsl #23                    @ set DQSI-MCLK2X phase
+    str   r1, [r0]
+    mov   r9, #0x00
+
+cbr0_dll2_scan_start:
+    mov   r6, #0x00                              @ init pass count
+    mov   r7, #0x00                              @ init DLL2 parameter index
+
+/****************************
+ DLL2 delay margin test loop
+ ***************************/
+cbr0_next_dll2_parameter:
+    ldr   r0, =0x1e6e0068                        @ load DLL2 parameter
+    ldr   r1, [r0]
+    bic   r1, r1, #0x00FF0000
+    bic   r1, r1, #0xFF000000
+    orr   r1, r1, r7, lsl #16
+    str   r1, [r0]
+    ldr   r2, =0x40404040                        @ DLL2 max is 0x40404040
+    cmp   r7, r2
+    bge   cbr0_next_dqidly
+    ldr   r2, =0x01010101
+    add   r7, r7, r2
+
+/* CBRScan3() start */
+    adrl  r5, PATTERN_TABLE                      @ init pattern table index
+/****************************
+ Test pattern iteration loop
+ ***************************/
+cbr0_next_test_pattern:
+    mov   r10, #2                                @ set the retry loop = 2 of each pattern
+    ldr   r1, [r5]                               @ load test pattern
+    ldr   r0, =0x1e6e007c
+    str   r1, [r0]
+    cmp   r1, #0x00                              @ the last data in pattern is 0x00
+    bne   cbr0_test_burst
+
+    and   r3, r7, #0xFF
+    sub   r3, r3, #0x01                          @ we add 1 after loop check so we need to decrease 1
+    cmp   r3, #0x00
+    beq   cbr0_next_dqidly                       @ pass at dlli = 0, invalid
+    add   r6, r6, #0x01                          @ increment pass count
+    add   r11, r11, #0x01                        @ increment pass count
+
+    ldr   r0, =0x1e720180                        @ record DLL2 pass window
+    cmp   r9, #0x00                              @ DQSI-MCLK2X phase check
+    addeq r0, r0, #0x08
+    cmp   r3, #32
+    addge r0, r0, #0x4
+    and   r1, r3, #0x1F
+    mov   r2, #0x1
+    mov   r2, r2, lsl r1
+    ldr   r1, [r0]
+    orr   r1, r1, r2
+    str   r1, [r0]
+
+    ldr   r0, =0x1e720100                        @ record DLL2 min:max value for each DQIDLY
+    add   r0, r0, r8, lsl #2
+    cmp   r9, #0x00                              @ DQSI-MCLK2X phase check
+    beq   cbr0_test_pass_dqsin
+    record_dll2_pass_range
+    b     cbr0_next_dll2_parameter
+
+cbr0_test_pass_dqsin:
+    record_dll2_pass_range_h
+    b     cbr0_next_dll2_parameter
+
+cbr0_test_pattern_fail:
+    cmp   r6, #5                                 @ passcnt >= 5
+    bge   cbr0_next_dqidly
+    ldr   r0, =0x1e720100                        @ reset DLL2 min:max value
+    add   r0, r0, r8, lsl #2
+    ldr   r1, [r0]
+    ldr   r2, =0xFFFF0000
+    ldr   r3, =0x000000FF
+    cmp   r9, #0x00
+    moveq r2, r2, lsr #16
+    moveq r3, r3, lsl #16
+    and   r1, r1, r2
+    orr   r1, r1, r3
+    str   r1, [r0]
+    b     cbr0_next_dll2_parameter               @ CBRScan3() end and test result fail, go to next step
+
+/****************************
+ Test fail retry loop
+ ***************************/
+cbr0_pattern_fail_retry:
+
+/* CBRTest3() start */
+cbr0_test_burst:
+    ldr   r0, =0x1e6e0070
+    ldr   r1, =0x00000000
+    str   r1, [r0]
+    ldr   r1, =0x000000C1
+    str   r1, [r0]
+    ldr   r3, =0x3000
+cbr0_wait_engine_idle_0:
+    ldr   r2, [r0]
+    tst   r2, r3                                 @ D[12] = idle bit
+    beq   cbr0_wait_engine_idle_0
+
+    ldr   r2, [r0]                               @ read fail bit status
+    mov   r1, #0x0
+    str   r1, [r0]
+    mov   r2, r2, lsr #13                        @ D[13] = fail bit
+    cmp   r2, #0x00
+    bne   cbr0_test_fail
+
+cbr0_test_single:
+    ldr   r0, =0x1e6e0070
+    ldr   r1, =0x00000000
+    str   r1, [r0]
+    ldr   r1, =0x00000085
+    str   r1, [r0]
+    ldr   r3, =0x3000
+cbr0_wait_engine_idle_1:
+    ldr   r2, [r0]
+    tst   r2, r3                                 @ D[12] = idle bit
+    beq   cbr0_wait_engine_idle_1
+
+    ldr   r2, [r0]                               @ read fail bit status
+    mov   r1, #0x0
+    str   r1, [r0]
+    mov   r2, r2, lsr #13                        @ D[13] = fail bit
+    cmp   r2, #0x00
+    beq   cbr0_test_pass
+
+/* CBRTest3() end */
+
+cbr0_test_fail:
+    subs  r10, r10, #1
+    bne   cbr0_pattern_fail_retry
+    b     cbr0_test_pattern_fail                 @ CBRScan3() return(0)
+
+cbr0_test_pass:
+    add   r5, r5, #0x04                          @ increase the test pattern index
+    b     cbr0_next_test_pattern
+
+CBR0_END:
+    mov   r5, #0x0                               @ init DQIDLY search count
+    mov   r6, #0x0                               @ init max_margin:g_margin
+    mov   r8, #0x0                               @ init g_side
+    mov   r7, #0x0                               @ init maximum margin DQIDLY,DQSI-MCLK2X phase
+cbr0_search_dll_margin_s:
+    ldr   r0, =0x1e720100
+    add   r0, r0, r5, lsl #2
+    ldr   r1, [r0]
+    and   r2, r1, #0xFF                          @ get dllmin_p
+    mov   r1, r1, lsr #8
+    and   r3, r1, #0xFF                          @ get dllmax_p
+    subs  r2, r3, r2                             @ get margin-P
+    movmi r2, #0x0
+    mov   r1, r1, lsr #8
+    and   r3, r1, #0xFF                          @ get dllmin_n
+    mov   r1, r1, lsr #8
+    and   r1, r1, #0xFF                          @ get dllmax_n
+    subs  r3, r1, r3                             @ get margin-N
+    movmi r3, #0x0
+    add   r1, r2, r3
+    cmp   r1, #0x0
+    beq   cbr0_search_dll_margin_e               @ if margin-P = 0 && margin-N = 0
+
+    ldr   r9, [r0]
+    ldr   r0, =0x1e720180
+    cmp   r2, r3
+    orrlt r5, r5, #0x80                          @ margin-N > margin-P
+    addlt r0, r0, #0x08
+    movlt r9, r9, lsr #16
+    movge r3, r2                                 @ max(margin-P/N)
+    add   r2, r3, #0x2                           @ define +/- 2 steps of variation
+    mov   r1, r6, lsr #16
+    cmp   r2, r1
+    blt   cbr0_search_dll_margin_e               @ if max(margin-P/N) + 2 < max_margin
+
+    and   r1, r9, #0xFF                          @ r1 = dlli counter
+    cmp   r1, #32
+    ldrge r2, [r0, #0x4]                         @ load pass window
+    ldrlt r2, [r0]
+    and   r1, r1, #0x1F
+    mov   r10, #0x1                              @ init test bit mask
+    mov   r10, r10, lsl r1
+    and   r1, r9, #0xFF
+cbr0_search_dllmin_margin_s:
+    tst   r2, r10
+    beq   cbr0_search_dllmin_margin_e
+    mov   r10, r10, lsr #1
+    cmp   r1, #32
+    ldreq r2, [r0]
+    ldreq r10, =0x80000000
+    subs  r1, r1, #0x1
+    bne   cbr0_search_dllmin_margin_s
+
+cbr0_search_dllmin_margin_e:
+    and   r2, r9, #0xFF
+    sub   r11, r2, r1                            @ get dllmin side margin
+
+    mov   r9, r9, lsr #8
+    and   r1, r9, #0xFF                          @ r1 = dlli counter
+    cmp   r1, #32
+    ldrge r2, [r0, #0x4]                         @ load pass window
+    ldrlt r2, [r0]
+    and   r1, r1, #0x1F
+    mov   r10, #0x1                              @ init test bit mask
+    mov   r10, r10, lsl r1
+    and   r1, r9, #0xFF
+cbr0_search_dllmax_margin_s:
+    tst   r2, r10
+    beq   cbr0_search_dllmax_margin_e
+    mov   r10, r10, lsl #1
+    cmp   r1, #31
+    ldreq r2, [r0, #0x4]
+    ldreq r10, =0x00000001
+    add   r1, r1, #0x1
+    cmp   r1, #64
+    bne   cbr0_search_dllmax_margin_s
+
+cbr0_search_dllmax_margin_e:
+    and   r2, r9, #0xFF
+    sub   r1, r1, r2                             @ get dllmax side margin
+    cmp   r1, r11
+    movlt r11, r1                                @ get side_margin
+
+cbr0_check_dll_margin:                           @ if max(margin-P/N) > g_margin && side_margin >= g_side && dqidly <= 20
+    cmp   r5, #20
+    bgt   cbr0_check_dll_margin2
+    and   r1, r6, #0xFF
+    cmp   r3, r1
+    ble   cbr0_check_dll_margin3
+    cmp   r11, r8
+    bge   cbr0_set_dll_margin
+
+cbr0_check_dll_margin2:                          @ if max(margin-P/N) > g_margin+1 && side_margin >= g_side)
+    and   r1, r6, #0xFF
+    add   r2, r1, #0x1
+    cmp   r3, r2
+    ble   cbr0_check_dll_margin3
+    cmp   r11, r8
+    bge   cbr0_set_dll_margin
+
+cbr0_check_dll_margin3:                          @ if side_margin > g_side && g_side < 8
+    cmp   r8, #8
+    bge   cbr0_search_dll_margin_e
+    cmp   r11, r8
+    ble   cbr0_search_dll_margin_e
+
+cbr0_set_dll_margin:
+    mov   r1, r6, lsr #16
+    cmp   r3, r1
+    bicgt r6, r6, #0x00FF0000
+    orrgt r6, r6, r3, lsl #16
+    bic   r6, r6, #0x000000FF
+    orr   r6, r6, r3
+    mov   r7, r5
+    mov   r8, r11
+
+cbr0_search_dll_margin_e:
+    and   r5, r5, #0x7F
+    add   r5, r5, #0x01
+    cmp   r5, #0x20                              @ last DQIDLY
+    blt   cbr0_search_dll_margin_s
+
+    ldr   r0, =0x1e6e0018
+    ldr   r1, [r0]
+    bic   r1, r1, #0x00FF0000
+    orr   r1, r1, r7, lsl #16
+    str   r1, [r0]
+
+    ldr   r0, =0x1e6e0068
+    ldr   r1, [r0]
+    bic   r1, r1, #0x00FF0000
+    bic   r1, r1, #0xFF000000
+    str   r1, [r0]
+
+    /* Delay about 5us */
+    ldr r2, =0x00000005                          @ Set Timer5 Reload = 5 us
+    init_delay_timer
+delay_5:
+    check_delay_timer
+    bne delay_5
+    clear_delay_timer
+    /* end delay 5us */
+
+    ldr r0, =0x1e6e000c                          @ Set refresh cycle
+    ldr r1, =0x00005C01
+    str r1, [r0]
+
+/******************************************************************************
+ Fine tune per bit DQ input delay -- Pass 1, left edge align
+  r8  = free
+  r9  = DQ fail bit accumulator
+  r10 = pattern fail counter, initialize to 5 (fail 5 times)
+  r11 = free
+ *****************************************************************************/
+CBR1_START:
+/* Debug - UART console message */
+    ldr r0, =0x1e784000
+    mov r1, #0x0D                                @ '\r'
+    str r1, [r0]
+    mov r1, #0x0A                                @ '\n'
+    str r1, [r0]
+    mov r1, #0x43                                @ 'C'
+    str r1, [r0]
+    mov r1, #0x42                                @ 'B'
+    str r1, [r0]
+    mov r1, #0x52                                @ 'R'
+    str r1, [r0]
+    mov r1, #0x31                                @ '1'
+    str r1, [r0]
+/* Debug - UART console message */
+
+    mov   r6, #0x00                              @ init pass count
+    mov   r7, #0x00                              @ init DLL2 parameter index
+
+/****************************
+ DLL2 delay margin test loop
+ ***************************/
+cbr1_next_dll2_parameter:
+    ldr   r0, =0x1e6e0068                        @ load DLL2 parameter
+    ldr   r1, [r0]
+    bic   r1, r1, #0x00FF0000
+    bic   r1, r1, #0xFF000000
+    orr   r1, r1, r7, lsl #16
+    str   r1, [r0]
+    ldr   r2, =0x40404040                        @ parameter's max is to 0x40404040
+    cmp   r7, r2
+    bge   CBR1_END
+    ldr   r2, =0x01010101
+    add   r7, r7, r2
+
+    ldr   r0, =0x1e6e0074                        @ set the testing DRAM size = 4KB
+    ldr   r1, =0x00000FFF
+    str   r1, [r0]
+
+/* CBRScan2() start */
+    ldr   r9, =0xFFFF                            @ init test status
+    adrl  r5, PATTERN_TABLE                      @ init pattern table index
+/****************************
+ Test pattern iteration loop
+ ***************************/
+cbr1_next_test_pattern:
+    mov   r10, #5                                @ set the retry loop of each pattern
+    ldr   r1, [r5]                               @ load test pattern
+    ldr   r0, =0x1e6e007c
+    str   r1, [r0]
+    cmp   r1, #0x00                              @ the last data in pattern is 0x00
+    bne   cbr1_test_single
+
+cbr1_test_pattern_end:
+    cmp   r9, #0x00
+    bne   cbr1_test_pass_dqi
+    cmp   r6, #10
+    bge   CBR1_END
+    b     cbr1_next_dll2_parameter               @ CBRScan2() end and test result fail, go to next step
+
+cbr1_test_pass_dqi:
+    and   r3, r7, #0xFF
+    sub   r3, r3, #0x01                          @ we add 1 after loop check so we need to decrease 1
+    add   r6, r6, #0x01                          @ increment pass count
+    ldr   r0, =0x1e720010
+    mov   r8, #0x01
+cbr1_test_pass_dqi_loop_s:
+    tst   r9, r8
+    beq   cbr1_test_pass_dqi_loop_e
+    record_dll2_pass_range
+
+cbr1_test_pass_dqi_loop_e:
+    add   r0, r0, #0x04
+    mov   r8, r8, lsl #1
+    ldr   r1, =0xFFFF
+    tst   r8, r1
+    bne   cbr1_test_pass_dqi_loop_s
+    b     cbr1_next_dll2_parameter
+
+/****************************
+ Test fail retry loop
+ ***************************/
+cbr1_pattern_fail_retry:
+
+/* CBRTest2() start */
+cbr1_test_single:
+    ldr   r0, =0x1e6e0070
+    ldr   r1, =0x00000000
+    str   r1, [r0]
+    ldr   r1, =0x00000005
+    str   r1, [r0]
+    ldr   r3, =0x1000
+    ldr   r1, =0x1000
+cbr1_wait_engine_idle_0:
+    subs  r1, r1, #1
+    beq   cbr1_test_single_end
+    ldr   r2, [r0]
+    tst   r2, r3                                 @ D[12] = idle bit
+    beq   cbr1_wait_engine_idle_0
+
+cbr1_test_single_end:
+    ldr   r0, =0x1e6e0078                        @ read fail bit status
+    ldr   r11, [r0]
+    orr   r11, r11, r11, lsr #16
+    bic   r11, r11, #0xFF000000
+    bic   r11, r11, #0x00FF0000
+
+    ldr   r1, =0xFFFF
+    cmp   r11, r1
+    beq   cbr1_test_fail
+
+cbr1_test_burst:
+    ldr   r0, =0x1e6e0070
+    ldr   r2, =0x00000000
+    str   r2, [r0]
+    ldr   r2, =0x00000041
+    str   r2, [r0]
+    ldr   r3, =0x1000
+    ldr   r1, =0x1000
+cbr1_wait_engine_idle_1:
+    subs  r1, r1, #1
+    beq   cbr1_test_burst_end
+    ldr   r2, [r0]
+    tst   r2, r3                                 @ D[12] = idle bit
+    beq   cbr1_wait_engine_idle_1
+
+cbr1_test_burst_end:
+    ldr   r0, =0x1e6e0078                        @ read fail bit status
+    ldr   r2, [r0]
+    orr   r2, r2, r2, lsr #16
+    bic   r2, r2, #0xFF000000
+    bic   r2, r2, #0x00FF0000
+    orr   r11, r11, r2
+
+    ldr   r2, =0xFFFF
+    cmp   r11, r2
+    bne   cbr1_test_pass
+/* CBRTest2() end */
+
+cbr1_test_fail:
+    subs  r10, r10, #1
+    bne   cbr1_pattern_fail_retry
+    mov   r9, #0x00
+    b     cbr1_test_pattern_end                  @ CBRScan2() return(0)
+
+cbr1_test_pass:
+    ldr   r1, =0xFFFF                            @ record the pass bit
+    eor   r11, r11, r1
+    and   r9, r9, r11                            @ DQ pass bit
+    cmp   r9, #0x00
+    beq   cbr1_test_pattern_end                  @ CBRScan2() return(0)
+
+    add   r5, r5, #0x04                          @ increase the test pattern index
+    b     cbr1_next_test_pattern
+
+CBR1_END:
+    mov   r5, #0x0                               @ init DQ DLL_min sum
+    mov   r6, #0x0                               @ init DQ DLL_min valid count
+    ldr   r0, =0x1e72000c
+    ldr   r3, =0x1e720050
+cbr1_search_dllmin_s:
+    add   r0, r0, #0x04
+    cmp   r0, r3
+    beq   cbr1_search_dllmin_e
+    ldr   r1, [r0]
+    mov   r2, r1, lsr #8
+    and   r2, r2, #0xFF                          @ get dllmax
+    and   r1, r1, #0xFF                          @ get dllmin
+    subs  r2, r2, r1                             @ dllmax - dllmin
+    bmi   cbr1_search_dllmin_s                   @ no valid margin found, bypass fine tune
+    cmp   r2, #10                                @ (dllmax - dllmin) < 10
+    blt   cbr1_search_dllmin_s                   @ no enough margin found, bypass fine tune
+    add   r5, r5, r1
+    add   r6, r6, #1
+    b     cbr1_search_dllmin_s
+
+cbr1_search_dllmin_e:
+    cmp   r6, #16
+    bne   Calibration_Start_pre                  @ not all bits valid, retry again
+
+    mov   r5, r5, lsr #4
+    ldr   r0, =0x1e720000
+    str   r5, [r0]
+
+    mov   r6, #0x00                              @ init DQL CBR value
+    ldr   r0, =0x1e720030
+    ldr   r7, =0x1e72000c
+cbr1_set_result_dql:
+    sub   r0, r0, #4
+    cmp   r0, r7
+    beq   cbr1_set_result_next
+    mov   r6, r6, lsl #3
+    ldr   r1, [r0]
+    mov   r2, r1, lsr #8
+    and   r2, r2, #0xFF                          @ get dllmax
+    and   r1, r1, #0xFF                          @ get dllmin
+    mov   r3, r1                                 @ dll = dllmin
+    cmp   r5, r3
+    blt   cbr1_set_result_dql_neg
+    sub   r1, r5, r3
+    mov   r2, #19
+    mul   r1, r2, r1
+    mov   r1, r1, lsr #5                         @ dqi_tune = ((gold_dll - dll) * 19) >> 5
+    cmp   r1, #2                                 @ dqi_tune max = 2
+    movgt r1, #2
+    orr   r6, r6, r1
+    b     cbr1_set_result_dql
+
+cbr1_set_result_dql_neg:
+    sub   r1, r3, r5
+    mov   r2, #19
+    mul   r1, r2, r1
+    mov   r1, r1, lsr #5                         @ dqi_tune = ((gold_dll - dll) * 19) >> 5
+    cmp   r1, #2                                 @ dqi_tune max = -2
+    movgt r1, #2
+    mov   r2, #8
+    sub   r1, r2, r1
+    and   r1, r1, #7
+    orr   r6, r6, r1
+    b     cbr1_set_result_dql
+
+cbr1_set_result_next:
+    ldr   r0, =0x1e6e0080                        @ save DQL fine tune result
+    str   r6, [r0]
+    ldr   r0, =0x1e720094
+    str   r6, [r0]
+
+    mov   r6, #0x00                              @ init DQH CBR value
+    ldr   r0, =0x1e720050
+    ldr   r7, =0x1e72002c
+cbr1_set_result_dqh:
+    sub   r0, r0, #4
+    cmp   r0, r7
+    beq   cbr1_set_result_end
+    mov   r6, r6, lsl #3
+    ldr   r1, [r0]
+    mov   r2, r1, lsr #8
+    and   r2, r2, #0xFF                          @ get dllmax
+    and   r1, r1, #0xFF                          @ get dllmin
+    mov   r3, r1                                 @ dll = dllmin
+    cmp   r5, r3
+    blt   cbr1_set_result_dqh_neg
+    sub   r1, r5, r3
+    mov   r2, #19
+    mul   r1, r2, r1
+    mov   r1, r1, lsr #5                         @ dqi_tune = ((gold_dll - dll) * 19) >> 5
+    cmp   r1, #3                                 @ dqi_tune max = 2
+    movgt r1, #3
+    subs  r1, r1, #1
+    movmi r1, #7
+    orr   r6, r6, r1
+    b     cbr1_set_result_dqh
+
+cbr1_set_result_dqh_neg:
+    sub   r1, r3, r5
+    mov   r2, #19
+    mul   r1, r2, r1
+    mov   r1, r1, lsr #5                         @ dqi_tune = ((gold_dll - dll) * 19) >> 5
+    add   r1, r1, #1
+    cmp   r1, #2                                 @ dqi_tune max = -2
+    movgt r1, #2
+    mov   r2, #8
+    sub   r1, r2, r1
+    and   r1, r1, #7
+    orr   r6, r6, r1
+    b     cbr1_set_result_dqh
+
+cbr1_set_result_end:
+    ldr   r0, =0x1e6e0084                        @ save DQH fine tune result
+    str   r6, [r0]
+    ldr   r0, =0x1e720098
+    str   r6, [r0]
+
+/******************************************************************************
+ Search the DLL2 detail margin
+ *****************************************************************************/
+    ldr   r0, =0x1e7200a0
+    mov   r1, #0
+    str   r1, [r0]
+
+CBR3_START:
+/* Debug - UART console message */
+    ldr r0, =0x1e784000
+    mov r1, #0x33                                @ '3'
+    str r1, [r0]
+/* Debug - UART console message */
+
+    mov   r6, #0x00                              @ init pass count
+    mov   r7, #0x00                              @ init DLL2 parameter index
+    ldr   r1, =0x000000ff
+    ldr   r0, =0x1e720008                        @ init DQL dllmax,dllmin
+    str   r1, [r0]
+    ldr   r0, =0x1e72000c                        @ init DQH dllmax,dllmin
+    str   r1, [r0]
+
+    ldr   r0, =0x1e7200a0                        @ CBR3 iteration counter
+    ldr   r1, [r0]
+    add   r1, r1, #1
+    str   r1, [r0]
+
+/****************************
+ DLL2 delay margin test loop
+ ***************************/
+cbr3_next_dll2_parameter:
+    ldr   r0, =0x1e6e0068                        @ load DLL2 parameter
+    ldr   r1, [r0]
+    bic   r1, r1, #0x00FF0000
+    bic   r1, r1, #0xFF000000
+    orr   r1, r1, r7, lsl #16
+    str   r1, [r0]
+    ldr   r2, =0x40404040                        @ parameter's max is to 0x40404040
+    cmp   r7, r2
+    bge   CBR3_END
+    ldr   r2, =0x01010101
+    add   r7, r7, r2
+
+    ldr   r0, =0x1e6e0074                        @ set the testing DRAM size = 64KB
+    ldr   r1, =0x0000FFFF
+    str   r1, [r0]
+
+/* CBRScan() start */
+    mov   r9, #0x03                              @ init test status
+    adrl  r5, PATTERN_TABLE                      @ init pattern table index
+/****************************
+ Test pattern iteration loop
+ ***************************/
+cbr3_next_test_pattern:
+    mov   r10, #5                                @ set the retry loop of each pattern
+    ldr   r1, [r5]                               @ load test pattern
+    ldr   r0, =0x1e6e007c
+    str   r1, [r0]
+    cmp   r1, #0x00                              @ the last data in pattern is 0x00
+    bne   cbr3_test_single
+
+cbr3_test_pattern_end:
+    cmp   r9, #0x00
+    bne   cbr3_test_pass_dql
+    cmp   r6, #10
+    bge   CBR3_END
+    b     cbr3_next_dll2_parameter               @ CBRScan() end and test result fail, go to next step
+
+cbr3_test_pass_dql:
+    and   r3, r7, #0xFF
+    sub   r3, r3, #0x01                          @ we add one after loop check so we need to decrease 1
+    add   r6, r6, #0x01                          @ increment pass count
+    tst   r9, #0x01
+    beq   cbr3_test_pass_dqh
+
+    ldr   r0, =0x1E720008
+    record_dll2_pass_range
+
+cbr3_test_pass_dqh:
+    tst   r9, #0x02
+    beq   cbr3_next_dll2_parameter
+    ldr   r0, =0x1E72000c
+    record_dll2_pass_range
+    b     cbr3_next_dll2_parameter
+
+/****************************
+ Test fail retry loop
+ ***************************/
+cbr3_pattern_fail_retry:
+
+/* CBRTest() start */
+cbr3_test_single:
+    ldr   r0, =0x1e6e0070
+    ldr   r1, =0x00000000
+    str   r1, [r0]
+    ldr   r1, =0x00000005
+    str   r1, [r0]
+    ldr   r3, =0x1000
+    ldr   r8, =0x10000
+cbr3_wait_engine_idle_0:
+    subs  r8, r8, #1
+    beq   cbr3_test_single_end
+    ldr   r2, [r0]
+    tst   r2, r3                                 @ D[12] = idle bit
+    beq   cbr3_wait_engine_idle_0
+
+cbr3_test_single_end:
+    ldr   r0, =0x1e6e0078                        @ read fail bit status
+    ldr   r11, [r0]
+    orr   r11, r11, r11, lsr #16
+    bic   r11, r11, #0xFF000000
+    bic   r11, r11, #0x00FF0000
+
+    ldr   r1, =0xFF
+    tst   r11, r1
+    beq   cbr3_test_burst
+    tst   r11, r1, lsl #8
+    bne   cbr3_test_fail
+
+cbr3_test_burst:
+    mov   r1, #0x00                              @ initialize loop index, r1 is loop's index
+cbr3_test_burst_loop:
+    ldr   r0, =0x1e6e0070
+    ldr   r2, =0x00000000
+    str   r2, [r0]
+    mov   r2, r1, lsl #3
+    orr   r2, r2, #0x41                          @ test command = 0x41 | (datagen << 3)
+    str   r2, [r0]
+    ldr   r3, =0x1000
+    ldr   r8, =0x10000
+cbr3_wait_engine_idle_1:
+    subs  r8, r8, #1
+    beq   cbr3_test_burst_end
+    ldr   r2, [r0]
+    tst   r2, r3                                 @ D[12] = idle bit
+    beq   cbr3_wait_engine_idle_1
+
+cbr3_test_burst_end:
+    ldr   r0, =0x1e6e0078                        @ read fail bit status
+    ldr   r2, [r0]
+    orr   r2, r2, r2, lsr #16
+    bic   r2, r2, #0xFF000000
+    bic   r2, r2, #0x00FF0000
+    orr   r11, r11, r2
+
+    ldr   r2, =0xFF
+    tst   r11, r2
+    beq   cbr3_next_test_burst_mode
+    tst   r11, r2, lsl #8
+    beq   cbr3_next_test_burst_mode
+/* CBRTest() end */
+
+cbr3_test_fail:
+    subs  r10, r10, #1
+    bne   cbr3_pattern_fail_retry
+    mov   r9, #0x00
+    b     cbr3_test_pattern_end                  @ CBRScan() return(0)
+
+cbr3_next_test_burst_mode:
+    add   r1, r1, #1                             @ increase the test mode index
+    cmp   r1, #0x08                              @ there are 8 modes
+    bne   cbr3_test_burst_loop
+
+    ldr   r1, =0xFF                              @ record the pass byte
+    tst   r11, r1
+    andne r9, r9, #0x02                          @ DQL fail
+    tst   r11, r1, lsl #8
+    andne r9, r9, #0x01                          @ DQH fail
+    cmp   r9, #0x00
+    beq   cbr3_test_pattern_end                  @ CBRScan() return(0)
+
+    add   r5, r5, #0x04                          @ increase the test pattern index
+    b     cbr3_next_test_pattern
+
+CBR3_END:
+    ldr   r0, =0x1e72000c                        @ check DQH margin
+    ldr   r1, [r0]
+    mov   r2, r1, lsr #8
+    and   r2, r2, #0xFF                          @ get dllmax
+    and   r1, r1, #0xFF                          @ get dllmin
+    subs  r5, r2, r1                             @ dllmax - dllmin
+    bmi   CBR3_START                             @ no valid margin found, retry again
+    cmp   r5, #10                                @ (dllmax - dllmin) < 10
+    blt   CBR3_START                             @ no enough margin found, retry again
+    add   r2, r1, r2                             @ (dllmin[1] + dllmax[1] + 1) >> 1
+    add   r2, r2, #0x01
+    mov   r1, r2, lsr #1
+    mov   r3, r1, lsl #8
+    ldr   r1, [r0]                               @ store the dll search result
+    bic   r1, r1, #0xFF000000
+    bic   r1, r1, #0x00FF0000
+    orr   r1, r1, r3, lsl #8
+    str   r1, [r0]
+
+    ldr   r0, =0x1e720008                        @ check DQL margin
+    ldr   r1, [r0]
+    mov   r2, r1, lsr #8
+    and   r2, r2, #0xFF                          @ get dllmax
+    and   r1, r1, #0xFF                          @ get dllmin
+    subs  r5, r2, r1                             @ dllmax - dllmin
+    bmi   CBR3_START                             @ no valid margin found, retry again
+    cmp   r5, #10                                @ (dllmax - dllmin) < 10
+    blt   CBR3_START                             @ no enough margin found, retry again
+    add   r2, r1, r2                             @ (dllmin[0] + dllmax[0] + 1) >> 1
+    add   r2, r2, #0x01
+    mov   r1, r2, lsr #1
+    ldr   r2, [r0]                               @ store the dll search result
+    bic   r2, r2, #0xFF000000
+    bic   r2, r2, #0x00FF0000
+    orr   r2, r2, r1, lsl #16
+    str   r2, [r0]
+    orr   r3, r3, r1
+
+    ldr   r0, =0x1e6e0068                        @ save the result dll value
+    ldr   r1, [r0]
+    bic   r1, r1, #0xFF000000
+    bic   r1, r1, #0x00FF0000
+    orr   r1, r1, r3, lsl #16
+    str   r1, [r0]
+    b     CBR4_START
+
+.LTORG
+
+/******************************************************************************
+ Search the DQS input mask margin
+ *****************************************************************************/
+CBR4_START:
+/* Debug - UART console message */
+    ldr r0, =0x1e784000
+    mov r1, #0x34                                @ '4'
+    str r1, [r0]
+/* Debug - UART console message */
+
+    ldr   r0, =0x1e6e0074                        @ set the testing DRAM size = 4KB
+    ldr   r1, =0x00000FFF
+    str   r1, [r0]
+
+    mov   r8, #0x00                              @ init MCR18[4]
+    ldr   r1, =0x000000ff
+    ldr   r0, =0x1e7200b0                        @ init MCR18[4]=0 max,min
+    str   r1, [r0]
+    ldr   r0, =0x1e7200b4                        @ init MCR18[4]=1 max,min
+    str   r1, [r0]
+
+    ldr   r0, =0x1e6e0018
+    ldr   r1, [r0]
+    bic   r1, r1, #0x0000001F
+    str   r1, [r0]
+
+    b     cbr4_scan_start
+
+cbr4_next_maskdly:
+    add   r8, r8, #0x01
+    and   r2, r8, #0x01
+    ldr   r0, =0x1e6e0018
+    ldr   r1, [r0]
+    bic   r1, r1, #0x0000001F
+    orr   r1, r1, r2, lsl #4
+    str   r1, [r0]
+    cmp   r8, #0x02
+    bge   CBR4_END
+
+cbr4_scan_start:
+    mov   r6, #0x00                              @ init pass count
+    mov   r7, #0x00                              @ init mask delay
+
+/****************************
+ DQS Mask delay margin test loop
+ ***************************/
+cbr4_next_parameter:
+    cmp   r7, #0x10                              @ max delay = 0xF
+    bge   cbr4_next_maskdly
+    ldr   r0, =0x1e6e0018                        @ load MCR18 parameter
+    ldr   r1, [r0]
+    bic   r1, r1, #0x0000000F
+    orr   r1, r1, r7
+    str   r1, [r0]
+    add   r7, r7, #0x01
+
+/* CBRScan3() start */
+    adrl  r5, PATTERN_TABLE                      @ init pattern table index
+/****************************
+ Test pattern iteration loop
+ ***************************/
+cbr4_next_test_pattern:
+    mov   r10, #2                                @ set the retry loop = 2 of each pattern
+    ldr   r1, [r5]                               @ load test pattern
+    ldr   r0, =0x1e6e007c
+    str   r1, [r0]
+    cmp   r1, #0x00                              @ the last data in pattern is 0x00
+    bne   cbr4_test_burst
+
+    and   r3, r7, #0xFF
+    sub   r3, r3, #0x01                          @ we add 1 after loop check so we need to decrease 1
+    add   r6, r6, #0x01                          @ increment pass count
+
+    ldr   r0, =0x1e7200b0                        @ record pass window
+    add   r0, r0, r8, lsl #2
+    record_dll2_pass_range
+    mov   r2, #0x01
+    add   r1, r1, r2, lsl #16
+    str   r1, [r0]
+    b     cbr4_next_parameter
+
+cbr4_test_pattern_fail:
+    cmp   r6, #5                                 @ passcnt >= 5
+    bge   cbr4_next_maskdly
+    b     cbr4_next_parameter
+
+/****************************
+ Test fail retry loop
+ ***************************/
+cbr4_pattern_fail_retry:
+
+/* CBRTest3() start */
+cbr4_test_burst:
+    ldr   r0, =0x1e6e0070
+    ldr   r1, =0x00000000
+    str   r1, [r0]
+    ldr   r1, =0x000000C1
+    str   r1, [r0]
+    ldr   r3, =0x3000
+cbr4_wait_engine_idle_0:
+    ldr   r2, [r0]
+    tst   r2, r3                                 @ D[12] = idle bit
+    beq   cbr4_wait_engine_idle_0
+
+    ldr   r2, [r0]                               @ read fail bit status
+    mov   r1, #0x0
+    str   r1, [r0]
+    mov   r2, r2, lsr #13                        @ D[13] = fail bit
+    cmp   r2, #0x00
+    bne   cbr4_test_fail
+
+cbr4_test_single:
+    ldr   r0, =0x1e6e0070
+    ldr   r1, =0x00000000
+    str   r1, [r0]
+    ldr   r1, =0x00000085
+    str   r1, [r0]
+    ldr   r3, =0x3000
+cbr4_wait_engine_idle_1:
+    ldr   r2, [r0]
+    tst   r2, r3                                 @ D[12] = idle bit
+    beq   cbr4_wait_engine_idle_1
+
+    ldr   r2, [r0]                               @ read fail bit status
+    mov   r1, #0x0
+    str   r1, [r0]
+    mov   r2, r2, lsr #13                        @ D[13] = fail bit
+    cmp   r2, #0x00
+    beq   cbr4_test_pass
+
+/* CBRTest3() end */
+
+cbr4_test_fail:
+    subs  r10, r10, #1
+    bne   cbr4_pattern_fail_retry
+    b     cbr4_test_pattern_fail                 @ CBRScan3() return(0)
+
+cbr4_test_pass:
+    add   r5, r5, #0x04                          @ increase the test pattern index
+    b     cbr4_next_test_pattern
+
+CBR4_END:
+    ldr   r0, =0x1e7200b0                        @ check mask margin
+    ldr   r1, [r0]
+    add   r0, r0, #0x04
+    ldr   r2, [r0]
+    ands  r6, r2, #0xFF                          @ get min of MCR18[4] = 1
+    bne   cbr4_noset_delay
+    ands  r5, r1, #0xFF                          @ get min of MCR18[4] = 0
+    bne   cbr4_set_delay
+    mov   r1, r1, lsr #8                         @ get max of MCR18[4] = 0
+    and   r1, r1, #0xFF
+    mov   r2, r2, lsr #8                         @ get max of MCR18[4] = 1
+    and   r2, r2, #0xFF
+    sub   r1, r1, r5
+    sub   r2, r2, r6
+    cmp   r1, r2
+    bge   cbr4_noset_delay
+
+cbr4_set_delay:
+    ldr   r0, =0x1e6e0018
+    ldr   r1, [r0]
+    orr   r1, r1, #0x10
+    str   r1, [r0]
+
+cbr4_noset_delay:
+    ldr   r0, =0x1e6e0070
+    ldr   r1, =0x00000000
+    str   r1, [r0]
+
+/******************************************************************************
+ CBR Finish
+ *****************************************************************************/
+/******************************************************************************
+ Check DRAM Size
+ *****************************************************************************/
+    ldr   r0, =0x1e6e2070
+    ldr   r1, [r0]
+    bic   r1, r1, #0xFEFFFFFF                    @ bit[24]=1 => DDR2
+    mov   r2, r1, lsr #24
+    cmp   r2, #0x01
+    beq   check_ddr2_size
+
+    ldr   r0, =0x1e6e0004
+    ldr   r5, [r0]
+    bic   r5, r5, #0x00000003                    @ record MCR04
+    orr   r1, r5, #0x3
+    str   r1, [r0]                               @ set to 4Gbit
+    ldr   r6, =0x003F2217
+#if defined(CONFIG_DRAM_336)
+    ldr   r6, =0x00361C13
+#endif
+    b     check_dram_size
+
+check_ddr2_size:
+    ldr   r0, =0x1e6e0004
+    ldr   r5, [r0]
+    bic   r5, r5, #0x00000023                    @ record MCR04
+    orr   r1, r5, #0x23
+    str   r1, [r0]                               @ set to 4Gbit
+    ldr   r6, =0x3F2B1B16
+#if defined(CONFIG_DRAM_336)
+    ldr   r6, =0x3B231612
+#endif
+
+    ldr   r0, =0x40000000
+    ldr   r1, =0x1817191A
+    str   r1, [r0]
+    ldr   r0, =0x40002000
+    ldr   r1, =0x73616532
+    str   r1, [r0]
+    ldr   r0, =0x40000000
+    ldr   r1, =0x1817191A
+    ldr   r2, [r0]
+    cmp   r1, r2
+    bne   check_dram_size_end                    @ == 512Mbit
+    orr   r5, r5, #0x20                          @ >= 1Gbit
+    mov   r6, r6, lsr #8
+
+check_dram_size:
+    ldr   r0, =0x50100000
+    ldr   r1, =0x41424344
+    str   r1, [r0]
+    ldr   r0, =0x48100000
+    ldr   r1, =0x25262728
+    str   r1, [r0]
+    ldr   r0, =0x40100000
+    ldr   r1, =0x191A1B1C
+    str   r1, [r0]
+    ldr   r0, =0x50100000
+    ldr   r1, =0x41424344
+    ldr   r2, [r0]
+    cmp   r2, r1                                 @ == 4Gbit
+    orreq r5, r5, #0x03
+    moveq r6, r6, lsr #16
+    beq   check_dram_size_end
+    ldr   r0, =0x48100000
+    ldr   r1, =0x25262728
+    ldr   r2, [r0]
+    cmp   r2, r1                                 @ == 2Gbit
+    orreq r5, r5, #0x02
+    moveq r6, r6, lsr #8
+    beq   check_dram_size_end
+    orr   r5, r5, #0x01                          @ == 1Gbit
+
+check_dram_size_end:
+    ldr   r0, =0x1e6e0004
+    str   r5, [r0]
+    ldr   r0, =0x1e6e0014
+    ldr   r1, [r0]
+    bic   r1, r1, #0x000000FF
+    and   r6, r6, #0xFF
+    orr   r1, r1, r6
+    str   r1, [r0]
+
+    ldr   r0, =0x1e6e0120                        @ VGA Compatible Mode
+    ldr   r1, =0x000050C0                        @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr   r1, =0x00004DC0
+#endif
+    str   r1, [r0]
+
+/******************************************************************************
+ Version Number
+ *****************************************************************************/
+    ldr   r0, =0x1e7200a8
+    ldr   r1, =0x20141229                        @ released date
+    str   r1, [r0]
+
+    add   r0, r0, #4
+    ldr   r1, =0x00000060                        @ released SDK version
+    str   r1, [r0]
+
+/******************************************************************************
+ Calibration Code End
+ ******************************************************************************/
+
+set_scratch:
+    /*Set Scratch register Bit 6 after ddr initial finished */
+    ldr r0, =0x1e6e2040
+    ldr r1, [r0]
+    orr r1, r1, #0x40
+    str r1, [r0]
+
+/* Debug - UART console message */
+    ldr r0, =0x1e784000
+    mov r1, #0x44                                @ 'D'
+    str r1, [r0]
+    mov r1, #0x6F                                @ 'o'
+    str r1, [r0]
+    mov r1, #0x6E                                @ 'n'
+    str r1, [r0]
+    mov r1, #0x65                                @ 'e'
+    str r1, [r0]
+    mov r1, #0x0D                                @ '\r'
+    str r1, [r0]
+    mov r1, #0x0A                                @ '\n'
+    str r1, [r0]
+/* Debug - UART console message */
+
+/******************************************************************************
+ Solve PCIe ASPM issue, only applied to AST2300 series
+ ******************************************************************************/
+    ldr r0, =0x1e6e207c                          @ Check bounding for AST1150 existence
+    ldr r1, [r0]
+    mov r2, r1, lsr #24
+    cmp r2, #0x01
+    bne platform_exit                            @ not match AST2300
+    bic r1, r1, #0xFFFFFCFF
+    mov r1, r1, lsr #8
+    cmp r1, #0x02
+    beq platform_exit                            @ match AST1050
+
+    ldr r0, =0x1e6e2004                          @ Disable I2C controller reset
+    ldr r1, [r0]
+    orr r1, r1, #0x04
+    str r1, [r0]
+    bic r1, r1, #0x04
+    str r1, [r0]
+
+    ldr r0, =0x1e78a054                          @ Check I2C bus state, if busy then quit
+    ldr r1, [r0]
+    mov r1, r1, lsr #17
+    and r1, r1, #0x03
+    cmp r1, #0x03
+    bne platform_exit
+
+    ldr r0, =0x1e78a040                          @ Init I2C1 controller
+    mov r1, #0x01
+    orr r1, r1, r1, lsl #16
+    str r1, [r0]
+
+    ldr r0, =0x1e78a044
+    ldr r1, =0x77776704
+    str r1, [r0]
+
+    mov r1, #0x0
+    ldr r0, =0x1e78a048
+    str r1, [r0]
+    ldr r0, =0x1e78a04c
+    str r1, [r0]
+
+    ldr r0, =0x1e78a050
+    ldr r1, =0xFFFFFFFF
+    str r1, [r0]
+
+    ldr r0, =0x1e78a200                          @ Set AST1150 I2C password
+    ldr r1, =0x00A88FA8
+    str r1, [r0]
+
+    ldr r0, =0x1e78a05c
+    ldr r1, =0x00000200                          @ Enable buffer mode transfering 3 bytes
+    str r1, [r0]
+
+    ldr r0, =0x1e78a054
+    ldr r1, =0x00000063                          @ Fire commmand
+    str r1, [r0]
+
+    ldr r0, =0x1e78a050
+i2c_wait_cmddone_1:
+    ldr r1, [r0]
+    tst r1, #0x38
+    beq i2c_wait_cmddone_1
+    tst r1, #0x2A                                @ transmit error
+    bne platform_exit2
+    ldr r1, =0xFFFFFFFF
+    str r1, [r0]
+
+    ldr r0, =0x1e78a200                          @ Disable ASPM capability
+    ldr r1, =0x04005DA8
+    str r1, [r0]
+
+    ldr r0, =0x1e78a204
+    ldr r1, =0x00000024
+    str r1, [r0]
+
+    ldr r0, =0x1e78a05c
+    ldr r1, =0x00000200                          @ Enable buffer mode transfering 3 bytes
+    str r1, [r0]
+
+    ldr r0, =0x1e78a054
+    ldr r1, =0x00000063                          @ Fire commmand
+    str r1, [r0]
+
+    ldr r0, =0x1e78a050
+i2c_wait_cmddone_2:
+    ldr r1, [r0]
+    tst r1, #0x38
+    beq i2c_wait_cmddone_2
+    tst r1, #0x2A                                @ transmit error
+    bne platform_exit2
+    ldr r1, =0xFFFFFFFF
+    str r1, [r0]
+
+platform_exit2:
+    ldr r0, =0x1e78a040                          @ Disable I2C1 controller
+    mov r1, #0x00
+    str r1, [r0]
+
+    b   platform_exit
+.LTORG
+
+platform_exit:
+#ifdef      CONFIG_DRAM_ECC
+    ldr r0, =0x1e6e0004
+    ldr r1, [r0]
+    orr r1, r1, #0x80
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0054
+    ldr r1, =0x05000000                          /* ECC protected memory size, default set at 80M   */
+    str r1, [r0]
+
+    ldr r0, =0x1e6e007C
+    ldr r1, =0x00000000
+    str r1, [r0]
+    ldr r0, =0x1e6e0074
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0070
+    ldr r1, =0x00000221
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0070
+    ldr r2, =0x00001000
+ECC_Init_Flag:
+    ldr r1, [r0]
+    tst r1, r2                                   @ D[12] = 1, Done
+    beq ECC_Init_Flag
+
+    ldr r0, =0x1e6e0070
+    ldr r1, =0x00000000
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0050
+    ldr r1, =0x80000000
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0050
+    ldr r1, =0x00000000
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0070
+    ldr r1, =0x00000400
+    str r1, [r0]
+#endif
+    ldr r0, =0x1e6e2008                          @ Set Video ECLK phase
+    ldr r1, [r0]
+    ldr r2, =0xfffffff3
+    and r1, r1, r2
+    orr r1, r1, #0x08
+    str r1, [r0]
+
+    ldr r0, =0x1e6e2004
+    ldr r1, [r0]
+    ldr r2, =0xFFBFFFFF                          @ Enable JTAG Master, solve ARM stucked by JTAG issue
+    and r1, r1, r2
+    str r1, [r0]
+
+    ldr r0, =0x1e6e2048                          @ Set MAC interface delay timing
+    ldr r1, =0x2255
+    str r1, [r0]
+
+    ldr r0, =0x1e6e2070                          @ Set MAC AHB bus clock
+    ldr r1, [r0]
+    mov r2, #0x04                                @ Default RMII, set MHCLK = HPLL/10
+    tst r1, #0xC0
+    movne r2, #0x02                              @ if RGMII,     set MHCLK = HPLL/6
+    ldr r0, =0x1e6e2008
+    ldr r1, [r0]
+    bic r1, r1, #0x00070000
+    orr r1, r1, r2, lsl #16
+    str r1, [r0]
+
+/* Test - DRAM initial time */
+    ldr r0, =0x1e782040
+    ldr r1, [r0]
+    ldr r0, =0xFFFFFFFF
+    sub r1, r0, r1
+    ldr r0, =0x1e72009c
+    str r1, [r0]
+    ldr r0, =0x1e7200a4
+    str r1, [r0]
+    ldr r0, =0x1e782030
+    ldr r1, [r0]
+    bic r1, r1, #0x0000F000
+    str r1, [r0]
+/* Test - DRAM initial time */
+
+/******************************************************************************
+ Reset GPIO registers when watchdog reset
+ ******************************************************************************/
+    ldr r0, =0x1e6e207c                          @ Check Revision ID
+    ldr r1, [r0]
+    mov r1, r1, lsr #24
+    cmp r1, #0x02
+    bne platform_exit3                           @ not match AST2400
+
+    ldr r0, =0x1e6e203c                          @ Check watchdog reset event
+    ldr r1, [r0]
+    and r1, r1, #0x06
+    cmp r1, #0x0
+    beq platform_exit3                           @ no watchdog reset event
+
+    ldr r0, =0x1e6e209c                          @ Check watchdog GPIO selection
+    ldr r1, [r0]
+    mov r1, r1, lsr #21
+    tst r1, #0x01
+    beq platform_exit3                           @ no watchdog reset selection
+
+    ldr r1, =0x00000000                          @ clear GPIO register reset by PRST_N
+    ldr r2, =0xFFFFFFFF
+    ldr r0, =0x1e780008
+    str r1, [r0]
+    ldr r0, =0x1e78000c
+    str r1, [r0]
+    ldr r0, =0x1e780010
+    str r1, [r0]
+    ldr r0, =0x1e780014
+    str r1, [r0]
+    ldr r0, =0x1e780018
+    str r2, [r0]
+    ldr r0, =0x1e780028
+    str r1, [r0]
+    ldr r0, =0x1e78002c
+    str r1, [r0]
+    ldr r0, =0x1e780030
+    str r1, [r0]
+    ldr r0, =0x1e780034
+    str r1, [r0]
+    ldr r0, =0x1e780038
+    str r2, [r0]
+    ldr r0, =0x1e780040
+    str r1, [r0]
+    ldr r0, =0x1e780044
+    str r1, [r0]
+    ldr r0, =0x1e780048
+    str r1, [r0]
+    ldr r0, =0x1e78004c
+    str r1, [r0]
+    ldr r0, =0x1e780050
+    str r1, [r0]
+    ldr r0, =0x1e780054
+    str r1, [r0]
+    ldr r0, =0x1e780058
+    str r1, [r0]
+    ldr r0, =0x1e780060
+    str r1, [r0]
+    ldr r0, =0x1e780064
+    str r1, [r0]
+    ldr r0, =0x1e780068
+    str r1, [r0]
+    ldr r0, =0x1e78006c
+    str r1, [r0]
+    ldr r0, =0x1e780090
+    str r1, [r0]
+    ldr r0, =0x1e780094
+    str r1, [r0]
+    ldr r0, =0x1e780098
+    str r1, [r0]
+    ldr r0, =0x1e78009c
+    str r1, [r0]
+    ldr r0, =0x1e7800a0
+    str r1, [r0]
+    ldr r0, =0x1e7800a4
+    str r1, [r0]
+    ldr r0, =0x1e7800a8
+    str r2, [r0]
+    ldr r0, =0x1e7800b0
+    str r1, [r0]
+    ldr r0, =0x1e7800b4
+    str r1, [r0]
+    ldr r0, =0x1e7800b8
+    str r1, [r0]
+    ldr r0, =0x1e7800e0
+    str r1, [r0]
+    ldr r0, =0x1e7800e4
+    str r1, [r0]
+    ldr r0, =0x1e7800e8
+    str r1, [r0]
+    ldr r0, =0x1e7800ec
+    str r1, [r0]
+    ldr r0, =0x1e7800f0
+    str r1, [r0]
+    ldr r0, =0x1e7800f4
+    str r1, [r0]
+    ldr r0, =0x1e7800f8
+    str r2, [r0]
+    ldr r0, =0x1e780100
+    str r1, [r0]
+    ldr r0, =0x1e780104
+    str r1, [r0]
+    ldr r0, =0x1e780108
+    str r1, [r0]
+    ldr r0, =0x1e780110
+    str r1, [r0]
+    ldr r0, =0x1e780114
+    str r1, [r0]
+    ldr r0, =0x1e780118
+    str r1, [r0]
+    ldr r0, =0x1e78011c
+    str r1, [r0]
+    ldr r0, =0x1e780120
+    str r1, [r0]
+    ldr r0, =0x1e780124
+    str r1, [r0]
+    ldr r0, =0x1e780128
+    str r2, [r0]
+    ldr r0, =0x1e780130
+    str r1, [r0]
+    ldr r0, =0x1e780134
+    str r1, [r0]
+    ldr r0, =0x1e780138
+    str r1, [r0]
+    ldr r0, =0x1e780140
+    str r1, [r0]
+    ldr r0, =0x1e780144
+    str r1, [r0]
+    ldr r0, =0x1e780148
+    str r1, [r0]
+    ldr r0, =0x1e78014c
+    str r1, [r0]
+    ldr r0, =0x1e780150
+    str r1, [r0]
+    ldr r0, =0x1e780154
+    str r1, [r0]
+    ldr r0, =0x1e780158
+    str r2, [r0]
+    ldr r0, =0x1e780160
+    str r1, [r0]
+    ldr r0, =0x1e780164
+    str r1, [r0]
+    ldr r0, =0x1e780168
+    str r1, [r0]
+    ldr r0, =0x1e780170
+    str r1, [r0]
+    ldr r0, =0x1e780174
+    str r1, [r0]
+    ldr r0, =0x1e780178
+    str r1, [r0]
+    ldr r0, =0x1e78017c
+    str r1, [r0]
+    ldr r0, =0x1e780180
+    str r1, [r0]
+    ldr r0, =0x1e780184
+    str r1, [r0]
+    ldr r0, =0x1e780188
+    str r2, [r0]
+    ldr r0, =0x1e780190
+    str r1, [r0]
+    ldr r0, =0x1e780194
+    str r1, [r0]
+    ldr r0, =0x1e780198
+    str r1, [r0]
+    ldr r0, =0x1e7801d0
+    str r1, [r0]
+    ldr r0, =0x1e7801d4
+    str r1, [r0]
+
+    ldr r0, =0x1e780204                          @ clear SGPIOM register reset by PRST_N
+    str r1, [r0]
+    ldr r0, =0x1e780208
+    str r1, [r0]
+    ldr r0, =0x1e78020c
+    str r1, [r0]
+    ldr r0, =0x1e780210
+    str r1, [r0]
+    ldr r0, =0x1e780214
+    str r2, [r0]
+    ldr r0, =0x1e780220
+    str r1, [r0]
+    ldr r0, =0x1e780224
+    str r1, [r0]
+    ldr r0, =0x1e780228
+    str r1, [r0]
+    ldr r0, =0x1e78022c
+    str r1, [r0]
+    ldr r0, =0x1e780230
+    str r2, [r0]
+    ldr r0, =0x1e78023c
+    str r1, [r0]
+    ldr r0, =0x1e780240
+    str r1, [r0]
+    ldr r0, =0x1e780244
+    str r1, [r0]
+    ldr r0, =0x1e780248
+    str r1, [r0]
+    ldr r0, =0x1e78024c
+    str r2, [r0]
+    ldr r0, =0x1e780254
+    ldr r3, =0x01000040
+    str r3, [r0]
+    ldr r0, =0x1e780258
+    str r1, [r0]
+    ldr r0, =0x1e78025c
+    str r1, [r0]
+    ldr r0, =0x1e780260
+    str r1, [r0]
+
+    ldr r0, =0x1e780300                          @ clear SGPIOS register reset by PRST_N
+    str r1, [r0]
+    ldr r0, =0x1e780304
+    str r1, [r0]
+    ldr r0, =0x1e780308
+    str r1, [r0]
+    ldr r0, =0x1e78030c
+    str r1, [r0]
+    ldr r0, =0x1e780310
+    str r1, [r0]
+    ldr r0, =0x1e780314
+    str r1, [r0]
+    ldr r0, =0x1e780318
+    str r2, [r0]
+    ldr r0, =0x1e78031c
+    str r2, [r0]
+    ldr r0, =0x1e780320
+    str r2, [r0]
+
+platform_exit3:
+
+/******************************************************************************
+ SPI Timing Calibration, not applicable to AST2300 series
+ ******************************************************************************/
+    ldr r0, =0x1e6e207c                          @ Check Revision ID
+    ldr r1, [r0]
+    mov r1, r1, lsr #24
+    cmp r1, #0x02
+    blt platform_exit4                           @ not match AST2400 or later
+
+    ldr r0, =0x1e6e2070                          @ Check SPI flash
+    ldr r1, [r0]
+    and r1, r1, #0x03
+    cmp r1, #0x02
+    bne platform_exit4
+
+    mov r2, #0x0
+    mov r6, #0x0
+    mov r7, #0x0
+    init_spi_checksum
+spi_checksum_wait_0:
+    ldr r1, [r0]
+    tst r1, r2
+    beq spi_checksum_wait_0
+    ldr r0, =0x1e620090
+    ldr r5, [r0]                                 @ record golden checksum
+    ldr r0, =0x1e620080
+    mov r1, #0x0
+    str r1, [r0]
+
+    ldr r0, =0x1e620010                          @ set to fast read mode
+    ldr r1, =0x000B0041
+    str r1, [r0]
+
+    ldr r6, =0x00F7E6D0                          @ Init spiclk loop
+    mov r8, #0x0                                 @ Init delay record
+
+spi_cbr_next_clkrate:
+    mov r6, r6, lsr #0x4
+    cmp r6, #0x0
+    beq spi_cbr_end
+
+    mov r7, #0x0                                 @ Init delay loop
+    mov r8, r8, lsl #4
+
+spi_cbr_next_delay_s:
+    mov r2, #0x8
+    init_spi_checksum
+spi_checksum_wait_1:
+    ldr r1, [r0]
+    tst r1, r2
+    beq spi_checksum_wait_1
+    ldr r0, =0x1e620090
+    ldr r2, [r0]                                 @ read checksum
+    ldr r0, =0x1e620080
+    mov r1, #0x0
+    str r1, [r0]
+    cmp r2, r5
+    bne spi_cbr_next_delay_e
+
+    mov r2, #0x0
+    init_spi_checksum
+spi_checksum_wait_2:
+    ldr r1, [r0]
+    tst r1, r2
+    beq spi_checksum_wait_2
+    ldr r0, =0x1e620090
+    ldr r2, [r0]                                 @ read checksum
+    ldr r0, =0x1e620080
+    mov r1, #0x0
+    str r1, [r0]
+    cmp r2, r5
+    bne spi_cbr_next_delay_e
+
+    orr r8, r8, r7                               @ record passed delay
+    b   spi_cbr_next_clkrate
+
+spi_cbr_next_delay_e:
+    add r7, r7, #0x1
+    cmp r7, #0x6
+    blt spi_cbr_next_delay_s
+    b   spi_cbr_next_clkrate
+
+spi_cbr_end:
+    ldr r0, =0x1e620094
+    str r8, [r0]
+    ldr r0, =0x1e620010
+    mov r1, #0x0
+    str r1, [r0]
+
+platform_exit4:
+
+    /* restore lr */
+    mov lr, r4
+
+    /* back to arch calling code */
+    mov pc, lr
diff --git a/board/aspeed/ast2300/rc4.c b/board/aspeed/ast2300/rc4.c
new file mode 100755
index 0000000..32e0ffa
--- /dev/null
+++ b/board/aspeed/ast2300/rc4.c
@@ -0,0 +1,68 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+struct rc4_state
+{
+    int x, y, m[256];
+};
+
+void rc4_setup( struct rc4_state *s, unsigned char *key,  int length )
+{
+    int i, j, k, *m, a;
+
+    s->x = 0;
+    s->y = 0;
+    m = s->m;
+
+    for( i = 0; i < 256; i++ )
+    {
+        m[i] = i;
+    }
+
+    j = k = 0;
+
+    for( i = 0; i < 256; i++ )
+    {
+        a = m[i];
+        j = (unsigned char) ( j + a + key[k] );
+        m[i] = m[j]; m[j] = a;
+        if( ++k >= length ) k = 0;
+    }
+}
+
+void rc4_crypt( struct rc4_state *s, unsigned char *data, int length )
+{ 
+    int i, x, y, *m, a, b;
+
+    x = s->x;
+    y = s->y;
+    m = s->m;
+
+    for( i = 0; i < length; i++ )
+    {
+        x = (unsigned char) ( x + 1 ); a = m[x];
+        y = (unsigned char) ( y + a );
+        m[x] = b = m[y];
+        m[y] = a;
+        data[i] ^= m[(unsigned char) ( a + b )];
+    }
+
+    s->x = x;
+    s->y = y;
+}
+
+void rc4_crypt_sw(unsigned char *data, int ulMsgLength, unsigned char *rc4_key, unsigned long ulKeyLength )
+{
+    struct rc4_state s;
+    
+    rc4_setup( &s, rc4_key, ulKeyLength );
+                                    
+    rc4_crypt( &s, data, ulMsgLength );    
+}
diff --git a/board/aspeed/ast2300/regtest.c b/board/aspeed/ast2300/regtest.c
new file mode 100755
index 0000000..1cd75ae
--- /dev/null
+++ b/board/aspeed/ast2300/regtest.c
@@ -0,0 +1,91 @@
+/*
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Diagnostics support
+ */
+#include <common.h>
+#include <command.h>
+#include <post.h>
+#include "slt.h"
+
+#if ((CFG_CMD_SLT & CFG_CMD_REGTEST) && defined(CONFIG_SLT))
+#include "regtest.h"
+
+int do_regtest (void)
+{
+	_SOCRegTestInfo	*pjSOCRegInfo;
+	_SOCRegTestTbl *pjRegTable;
+	unsigned long ulRegBase;
+        unsigned long ulIndex, ulBack, ulAND, ulMask, ulData, ulTemp;
+        unsigned long Flags = 0;
+	
+	/* unlock reg */
+        *(unsigned long *) (0x1e600000) = 0xaeed1a03;	/* AHBC */
+        *(unsigned long *) (0x1e6e0000) = 0xfc600309;	/* MMC */
+        *(unsigned long *) (0x1e6e2000) = 0x1688a8a8;	/* SCU */
+
+        /* SCU */
+
+        /* do test */	
+        pjSOCRegInfo = SOCRegTestInfo;
+        while (strcmp(pjSOCRegInfo->jName, "END"))
+        {
+            /* Reg. Test Start */
+            ulRegBase = pjSOCRegInfo->ulRegOffset;
+            pjRegTable = pjSOCRegInfo->pjTblIndex;
+            
+            while (pjRegTable->ulIndex != 0xFFFFFFFF)
+            {
+                ulIndex = ulRegBase + pjRegTable->ulIndex;	
+
+                ulBack = *(unsigned long *) (ulIndex);
+
+                ulMask  = pjRegTable->ulMask;
+                ulAND  = ~pjRegTable->ulMask;
+       	        	    	
+                ulData  = 0xFFFFFFFF & pjRegTable->ulMask;
+                *(unsigned long *) (ulIndex) = ulData;                
+                ulTemp = *(volatile unsigned long *) (ulIndex) & pjRegTable->ulMask;
+                if (ulData != ulTemp)
+                {
+                    Flags |= pjSOCRegInfo->ulFlags;
+                    printf("[DBG] RegTest: Failed Index:%x, Data:%x, Temp:%x \n", ulIndex, ulData, ulTemp);
+                }
+                
+                ulData  = 0x00000000 & pjRegTable->ulMask;
+                *(unsigned long *) (ulIndex) = ulData;                
+                ulTemp = *(volatile unsigned long *) (ulIndex) & pjRegTable->ulMask;
+                if (ulData != ulTemp)
+                {
+                    Flags |= pjSOCRegInfo->ulFlags;
+                    printf("[DBG] RegTest: Failed Index:%x, Data:%x, Temp:%x \n", ulIndex, ulData, ulTemp);
+                }
+                             
+                *(unsigned long *) (ulIndex) = ulBack;
+       
+                pjRegTable++;
+          	
+           } /* Individual Reg. Test */
+
+           if (Flags & pjSOCRegInfo->ulFlags)
+               printf("[INFO] RegTest: %s Failed \n", pjSOCRegInfo->jName);
+           
+           pjSOCRegInfo++;
+           
+        } /* Reg. Test */
+
+	return Flags;
+	
+}
+
+#endif /* CONFIG_SLT */
diff --git a/board/aspeed/ast2300/regtest.h b/board/aspeed/ast2300/regtest.h
new file mode 100755
index 0000000..49a360e
--- /dev/null
+++ b/board/aspeed/ast2300/regtest.h
@@ -0,0 +1,255 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+typedef struct {
+    unsigned long ulIndex;
+    unsigned long ulMask;
+} _SOCRegTestTbl;
+
+typedef struct {
+    unsigned char jName[10];
+    unsigned long ulRegOffset;
+    _SOCRegTestTbl *pjTblIndex;
+    unsigned long ulFlags;
+} _SOCRegTestInfo;
+
+_SOCRegTestTbl SMCRegTestTbl[] = {
+    {0x00000000, 0x00001FF3},
+    {0x00000004, 0xFFFFFFFF},
+    {0x00000008, 0x0FFF17FF},
+    {0x0000000C, 0xFFFFFFFF},
+    {0x00000010, 0xFF5FFFF3},
+    {0x00000018, 0x0FFFFFFF},
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl AHBCRegTestTbl[] = {
+    {0x00000080, 0x0000FFFE},        	
+    {0x00000088, 0x01000000},
+    {0x0000008c, 0x00000031},	
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl MICRegTestTbl[] = {
+/*	
+    {0x00000000, 0x0FFFFFF8},
+    {0x00000004, 0x0FFFFFF8},
+    {0x00000008, 0x0000FFFF},
+    {0x0000000C, 0x0FFFF000},
+    {0x00000010, 0xFFFFFFFF},
+*/
+    {0xFFFFFFFF, 0xFFFFFFFF},
+};
+
+_SOCRegTestTbl MAC1RegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl MAC2RegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl USB2RegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl VICRegTestTbl[] = {
+    {0x0000000C, 0xFFFFFFFF},
+    {0x00000024, 0xFFFFFFFF},
+    {0x00000028, 0xFFFFFFFF},
+    {0x0000002C, 0xFFFFFFFF},
+    {0xFFFFFFFF, 0xFFFFFFFF},
+};
+
+_SOCRegTestTbl MMCRegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl USB11RegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl SCURegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl HASERegTestTbl[] = {
+    {0x00000000, 0x0FFFFFF8},
+    {0x00000004, 0x0FFFFFF8},
+    {0x00000008, 0x0FFFFFF8},
+    {0x0000000C, 0x0FFFFFF8},
+    //{0x00000010, 0x00001FFF},
+    {0x00000020, 0x0FFFFFF8},
+    {0x00000024, 0x0FFFFFF8},
+    {0x00000028, 0x0FFFFFc0},
+    {0x0000002C, 0x0FFFFFFF},
+    //{0x00000030, 0x000003FF},
+    {0xFFFFFFFF, 0xFFFFFFFF},
+};
+
+_SOCRegTestTbl I2SRegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl CRTRegTestTbl[] = {
+/*	
+    {0x00000000, 0x001F3703},
+    {0x00000004, 0x0000FFC1},
+*/    
+    {0x00000010, 0x0FFF0FFF},
+    {0x00000014, 0x0FFF0FFF},
+    {0x00000018, 0x07FF07FF},
+    {0x0000001C, 0x07FF07FF},
+    {0x00000020, 0x0FFFFFF8},
+    {0x00000024, 0x07FF3FF8},
+/*    
+    {0x00000028, 0x003F003F},
+    {0x00000030, 0x003F003F},
+    {0x00000034, 0x0FFF0FFF},
+    {0x00000038, 0x0FFFFFF8},
+*/    
+    {0x00000040, 0x0FFF0FFF},
+    {0x00000044, 0x07FF07FF},
+    {0x00000048, 0x0FFFFFF8},
+    {0x0000004C, 0x00FF07F8},
+    {0x00000050, 0x000F0F0F},
+/*    
+    {0x00000060, 0x001F3703},
+    {0x00000064, 0x0000FFC1},
+*/    
+    {0x00000070, 0x0FFF0FFF},
+    {0x00000074, 0x0FFF0FFF},
+    {0x00000078, 0x07FF07FF},
+    {0x0000007C, 0x07FF07FF},
+    {0x00000080, 0x0FFFFFF8},
+    {0x00000084, 0x07FF3FF8},
+/*    
+    {0x00000088, 0x003F003F},
+    {0x00000090, 0x003F003F},
+    {0x00000094, 0x0FFF0FFF},
+    {0x00000098, 0x0FFFFFF8},
+*/    
+    {0x000000A0, 0x0FFF0FFF},
+    {0x000000A4, 0x07FF07FF},
+    {0x000000A8, 0x0FFFFFF8},
+    {0x000000AC, 0x00FF07F8},
+    {0x000000B0, 0x000F0F0F},
+    {0xFFFFFFFF, 0xFFFFFFFF},
+};
+
+_SOCRegTestTbl VIDEORegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl A2PRegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl MDMARegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl M2DRegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl GPIORegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl RTCRegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl TIMERRegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl UART1RegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl UART2RegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl WDTRegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl PWMRegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl VUART1RegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl VUART2RegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl LPCRegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl I2CRegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl PECIRegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl PCIARegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl PCIRegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+
+/* Test List */
+_SOCRegTestInfo SOCRegTestInfo[] = {
+    /* Test Name, Reg. Offset,      Test Table, Error Code  */
+    {   "SMCREG", 0x16000000,    SMCRegTestTbl, 0x00000001},
+    {  "AHBCREG", 0x1e600000,   AHBCRegTestTbl, 0x00000002},
+    {   "MICREG", 0x1e640000,    MICRegTestTbl, 0x00000004},
+    {  "MAC1REG", 0x1e660000,   MAC1RegTestTbl, 0x00000008},
+    {  "MAC2REG", 0x1e680000,   MAC2RegTestTbl, 0x00000010},
+    {  "USB2REG", 0x1e6a0000,   USB2RegTestTbl, 0x00000020},
+    {   "VICREG", 0x1e6c0000,    VICRegTestTbl, 0x00000040},
+    {   "MMCREG", 0x1e6e0000,    MMCRegTestTbl, 0x00000080},
+    { "USB11REG", 0x1e6e1000,  USB11RegTestTbl, 0x00000100},
+    {   "SCUREG", 0x1e6e2000,    SCURegTestTbl, 0x00000200},
+    {  "HASEREG", 0x1e6e3000,   HASERegTestTbl, 0x00000400},
+    {   "I2SREG", 0x1e6e5000,    I2SRegTestTbl, 0x00000800},
+    {   "CRTREG", 0x1e6e6000,    CRTRegTestTbl, 0x00001000},
+    { "VIDEOREG", 0x1e700000,  VIDEORegTestTbl, 0x00002000},
+    {   "A2PREG", 0x1e720000,    A2PRegTestTbl, 0x00004000},
+    {  "MDMAREG", 0x1e740000,   MDMARegTestTbl, 0x00008000},
+    {    "2DREG", 0x1e760000,    M2DRegTestTbl, 0x00010000},
+    {  "GPIOREG", 0x1e780000,   GPIORegTestTbl, 0x00020000},
+    {   "RTCREG", 0x1e781000,    RTCRegTestTbl, 0x00040000},
+    { "TIMERREG", 0x1e782000,  TIMERRegTestTbl, 0x00080000},
+    { "UART1REG", 0x1e783000,  UART1RegTestTbl, 0x00100000},
+    { "UART2REG", 0x1e784000,  UART2RegTestTbl, 0x00200000},
+    {   "WDTREG", 0x1e785000,    WDTRegTestTbl, 0x00400000},
+    {   "PWMREG", 0x1e786000,    PWMRegTestTbl, 0x00800000},
+    {"VUART1REG", 0x1e787000, VUART1RegTestTbl, 0x01000000},
+    {"VUART2REG", 0x1e788000, VUART2RegTestTbl, 0x02000000},
+    {   "LPCREG", 0x1e789000,    LPCRegTestTbl, 0x04000000},
+    {   "I2CREG", 0x1e78A000,    I2CRegTestTbl, 0x08000000},
+    {  "PECIREG", 0x1e78B000,   PECIRegTestTbl, 0x10000000},
+    {  "PCIAREG", 0x1e78C000,   PCIARegTestTbl, 0x20000000},
+    {   "PCIREG", 0x60000000,    PCIRegTestTbl, 0x40000000},        
+    {      "END", 0xffffffff,             NULL, 0xffffffff}
+};
diff --git a/board/aspeed/ast2300/slt.c b/board/aspeed/ast2300/slt.c
new file mode 100755
index 0000000..3283d34
--- /dev/null
+++ b/board/aspeed/ast2300/slt.c
@@ -0,0 +1,105 @@
+/*
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Diagnostics support
+ */
+#include <common.h>
+#include <command.h>
+#include <post.h>
+#include "slt.h"
+
+#if defined (CONFIG_SLT)
+
+int do_slt (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+    int flags = 0;
+    int loop  = 1;
+	
+    if (argc > 1) {
+        loop = simple_strtoul(argv[1], NULL, 10);
+    }
+	
+    do {
+
+do_slt_start:
+	/* Reg. Test */
+#if (CFG_CMD_SLT & CFG_CMD_REGTEST)
+	if (do_regtest())
+	{
+	    flags |= FLAG_REGTEST_FAIL;	
+            printf("[INFO] RegTest Failed \n");
+	}    
+	else
+            printf("[INFO] RegTest Passed \n");
+#endif
+#if (CFG_CMD_SLT & CFG_CMD_MACTEST)
+	if (do_mactest())
+	{
+	    flags |= FLAG_MACTEST_FAIL;	
+            printf("[INFO] MACTest Failed \n");
+	}    
+	else
+            printf("[INFO] MACTest Passed \n");
+#endif
+#if (CFG_CMD_SLT & CFG_CMD_VIDEOTEST)
+	if (do_videotest())
+	{
+	    flags |= FLAG_VIDEOTEST_FAIL;	
+            printf("[INFO] VideoTest Failed \n");
+	}    
+	else
+            printf("[INFO] VideoTest Passed \n");
+#endif
+#if (CFG_CMD_SLT & CFG_CMD_HACTEST)
+	if (do_hactest())
+	{
+	    flags |= FLAG_HACTEST_FAIL;	
+            printf("[INFO] HACTest Failed \n");
+	}    
+	else
+            printf("[INFO] HACTest Passed \n");
+#endif
+#if (CFG_CMD_SLT & CFG_CMD_MICTEST)
+	if (do_mictest())
+	{
+	    flags |= FLAG_MICTEST_FAIL;	
+            printf("[INFO] MICTest Failed \n");
+	}    
+	else
+            printf("[INFO] MICTest Passed \n");
+#endif
+	
+	/* Summary */
+	if (flags)
+            printf ("[INFO] SLT Test Failed!! \n");
+        else
+            printf ("[INFO] SLT Test Passed!! \n");    
+       
+        if (loop == 0)			/* infinite */
+            goto do_slt_start;
+        else
+            loop--;    
+            
+    } while (loop);
+
+    return 0;
+}
+/***************************************************/
+
+U_BOOT_CMD(
+	slt,	CONFIG_SYS_MAXARGS,	0,	do_slt,
+	"slt - slt test program \n",
+	NULL
+);
+
+#endif /* CONFIG_SLT */
diff --git a/board/aspeed/ast2300/slt.h b/board/aspeed/ast2300/slt.h
new file mode 100755
index 0000000..4e650bc
--- /dev/null
+++ b/board/aspeed/ast2300/slt.h
@@ -0,0 +1,29 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#define CFG_CMD_REGTEST		0x00000001
+#define CFG_CMD_MACTEST		0x00000002
+#define CFG_CMD_VIDEOTEST	0x00000004
+#define CFG_CMD_HACTEST		0x00000008
+#define CFG_CMD_MICTEST		0x00000010
+#define CFG_CMD_OSDTEST		0x00000020
+#define CFG_CMD_2DTEST  	0x00000040
+#define CFG_CMD_HWCTEST  	0x00000080
+
+#define FLAG_REGTEST_FAIL  	0x00000001
+#define FLAG_MACTEST_FAIL  	0x00000002
+#define FLAG_VIDEOTEST_FAIL  	0x00000004
+#define FLAG_HACTEST_FAIL  	0x00000008
+#define FLAG_MICTEST_FAIL  	0x00000010
+#define FLAG_OSDTEST_FAIL  	0x00000020
+#define FLAG_2DTEST_FAIL  	0x00000040
+#define FLAG_HWCTEST_FAIL  	0x00000080
+
+
diff --git a/board/aspeed/ast2300/type.h b/board/aspeed/ast2300/type.h
new file mode 100755
index 0000000..f57ee5a
--- /dev/null
+++ b/board/aspeed/ast2300/type.h
@@ -0,0 +1,116 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef _TYPE_H_
+#define _TYPE_H_
+
+	typedef unsigned char               BOOL;
+	typedef unsigned char               UINT8;
+	typedef unsigned short              UINT16;
+	typedef unsigned int                UINT32;
+
+	#define  FLONG                    unsigned long
+	#define  BYTE                     unsigned char
+	#define  INT                      int
+	#define  VOID                     void
+	#define  BOOLEAN                  unsigned short
+	#define  ULONG                    unsigned long
+	#define  USHORT                   unsigned short
+	#define  UCHAR                    unsigned char
+	#define  CHAR                     char
+	#define  LONG                     long
+	#define  PUCHAR                   UCHAR *
+	#define  PULONG                   ULONG *
+
+	#define  FAIL                     1
+
+	#define  intfunc      int386
+
+	#define  outdwport         outpd
+	#define  indwport          inpd
+	#define  outport           outp
+	#define  inport            inp
+
+	//#define     NULL    ((void *)0)
+	#define     FALSE   0
+	#define     TRUE    1
+
+	#define ReadMemoryBYTE(baseaddress,offset)        *(BYTE *)((ULONG)(baseaddress)+(ULONG)(offset))
+	#define ReadMemoryLong(baseaddress,offset)        *(ULONG *)((ULONG)(baseaddress)+(ULONG)(offset))
+	#define ReadMemoryShort(baseaddress,offset)       *(USHORT *)((ULONG)(baseaddress)+(ULONG)(offset))
+	#define WriteMemoryBYTE(baseaddress,offset,data)  *(BYTE *)((ULONG)(baseaddress)+(ULONG)(offset)) = (BYTE)(data)
+	#define WriteMemoryLong(baseaddress,offset,data)  *(ULONG *)((ULONG)(baseaddress)+(ULONG)(offset))=(ULONG)(data)
+	#define WriteMemoryShort(baseaddress,offset,data) *(USHORT *)((ULONG)(baseaddress)+(ULONG)(offset))=(USHORT)(data)
+	#define WriteMemoryLongWithANDData(baseaddress, offset, anddata, data)  *(ULONG *)((ULONG)(baseaddress)+(ULONG)(offset)) = *(ULONG *)((ULONG)(baseaddress)+(ULONG)(offset)) & (ULONG)(anddata) | (ULONG)(data)
+
+	#define WriteMemoryLongWithMASK(baseaddress, offset, data, mask) \
+	*(volatile ULONG *)((ULONG)(baseaddress)+(ULONG)(offset)) = *(volatile ULONG *)(((ULONG)(baseaddress)+(ULONG)(offset)) & (ULONG)(~(mask))) | ((ULONG)(data) & (ULONG)(mask))
+
+	#define ReadMemoryLongHost(baseaddress,offset)        *(volatile ULONG *)((ULONG)(baseaddress)+(ULONG)(offset))
+	#define WriteMemoryLongHost(baseaddress,offset,data)  *(volatile ULONG *)((ULONG)(baseaddress)+(ULONG)(offset))=(ULONG)(data)
+	#define WriteMemoryBYTEHost(baseaddress,offset,data)  *(volatile BYTE *)((ULONG)(baseaddress)+(ULONG)(offset)) = (BYTE)(data)    
+#define WriteMemoryLongWithMASKHost(baseaddress, offset, data, mask)  *(volatile ULONG *)((ULONG)(baseaddress)+(ULONG)(offset)) = (((*(volatile ULONG *)((ULONG)(baseaddress)+(ULONG)(offset)))&(~mask)) | (ULONG)((data)&(mask)))
+    
+	#define ReadMemoryLongClient(baseaddress,offset)        *(volatile ULONG *)((ULONG)(baseaddress)+(ULONG)(offset))
+	#define WriteMemoryLongClient(baseaddress,offset,data)  *(volatile ULONG *)((ULONG)(baseaddress)+(ULONG)(offset))=(ULONG)(data)
+	#define WriteMemoryBYTEClient(baseaddress,offset,data)  *(volatile BYTE *)((ULONG)(baseaddress)+(ULONG)(offset)) = (BYTE)(data)    
+#define WriteMemoryLongWithMASKClient(baseaddress, offset, data, mask)  *(volatile ULONG *)((ULONG)(baseaddress)+(ULONG)(offset)) = (((*(volatile ULONG *)((ULONG)(baseaddress)+(ULONG)(offset)))&(~mask)) | (ULONG)((data)&(mask)))
+
+#ifdef BUF_GLOBALS
+#define BUF_EXT
+#else
+#define BUF_EXT extern
+#endif
+
+BUF_EXT ULONG    g_CAPTURE_VIDEO1_BUF1_ADDR; /* VIDEO1_BUF_1_ADDR*/ 
+BUF_EXT ULONG    g_CAPTURE_VIDEO1_BUF2_ADDR; /* VIDEO1_BUF_2_ADDR*/
+BUF_EXT ULONG    g_VIDEO1_COMPRESS_BUF_ADDR; /* Encode destination address */
+BUF_EXT ULONG    g_VIDEO1_CRC_BUF_ADDR;
+BUF_EXT ULONG    g_VIDEO1_FLAG_BUF_ADDR;
+BUF_EXT ULONG    g_VIDEO1_RC4_BUF_ADDR;
+
+
+BUF_EXT ULONG    g_CAPTURE_VIDEO2_BUF1_ADDR; 
+BUF_EXT ULONG    g_CAPTURE_VIDEO2_BUF2_ADDR; 
+BUF_EXT ULONG    g_VIDEO2_COMPRESS_BUF_ADDR;
+BUF_EXT ULONG    g_VIDEO2_CRC_BUF_ADDR;
+BUF_EXT ULONG    g_VIDEO2_FLAG_BUF_ADDR;
+BUF_EXT ULONG    g_VIDEO2_RC4_BUF_ADDR;
+
+BUF_EXT ULONG    g_VIDEO1_DECODE_BUF_1_ADDR;
+BUF_EXT ULONG    g_VIDEO1_DECODE_BUF_2_ADDR;
+BUF_EXT ULONG    g_VIDEO1_DECOMPRESS_BUF_ADDR;
+BUF_EXT ULONG    g_VIDEO1_DECODE_RC4_BUF_ADDR;
+
+BUF_EXT ULONG    g_VIDEO2_DECODE_BUF_1_ADDR;
+BUF_EXT ULONG    g_VIDEO2_DECODE_BUF_2_ADDR;
+BUF_EXT ULONG    g_VIDEO2_DECOMPRESS_BUF_ADDR;
+BUF_EXT ULONG    g_VIDEO2_DECODE_RC4_BUF_ADDR;
+
+BUF_EXT ULONG    g_CAPTURE_VIDEOM_BUF1_ADDR; 
+BUF_EXT ULONG    g_CAPTURE_VIDEOM_BUF2_ADDR; 
+BUF_EXT ULONG    g_VIDEOM_COMPRESS_BUF_ADDR;
+BUF_EXT ULONG    g_VIDEOM_FLAG_BUF_ADDR;
+BUF_EXT ULONG    g_VIDEOM_RC4_BUF_ADDR;
+
+BUF_EXT ULONG    g_VIDEOM_DECODE_BUF_1_ADDR;
+BUF_EXT ULONG    g_VIDEOM_DECODE_BUF_2_ADDR;
+BUF_EXT ULONG    g_VIDEOM_DECOMPRESS_BUF_ADDR;
+BUF_EXT ULONG    g_VIDEOM_DECODE_RC4_BUF_ADDR;
+
+#ifdef WIN_GLOBALS
+#define WIN_EXT
+#else
+#define WIN_EXT extern
+#endif
+
+WIN_EXT USHORT	g_DefWidth, g_DefHeight;
+   
+#endif
diff --git a/board/aspeed/ast2300/u-boot.lds b/board/aspeed/ast2300/u-boot.lds
new file mode 100755
index 0000000..b5a90ef
--- /dev/null
+++ b/board/aspeed/ast2300/u-boot.lds
@@ -0,0 +1,45 @@
+/*
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+/*OUTPUT_FORMAT("elf32-arm", "elf32-arm", "elf32-arm")*/
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text	   :
+	{
+	  cpu/arm926ejs/start.o	(.text)
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff --git a/board/aspeed/ast2300/vdef.h b/board/aspeed/ast2300/vdef.h
new file mode 100755
index 0000000..3c99b7e
--- /dev/null
+++ b/board/aspeed/ast2300/vdef.h
@@ -0,0 +1,500 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef _VDEF_H_
+#define _VDEF_H_
+
+#define     VIDEO1                              0
+#define     VIDEO1_ON                           0x01
+#define     VIDEO2                              1
+#define     VIDEO2_ON                           0x02
+
+#define		VIDEOM_ON							0x04
+#define     VIDEOM                              2
+
+#define		CRT_1								0
+#define		CRT_1_ON							0x01
+#define		CRT_2								1
+#define		CRT_2_ON							0x02
+
+#define		SINGLE_CODEC_SINGLE_CAPTURE			0
+#define     AUTO_CODEC_SINGLE_CAPTURE			2
+#define		AUTO_CODEC_AUTO_CAPTURE				3
+
+#define		MAC1_BASE							0x1E660000
+#define     APB_BRIDGE_1_BASE                   0x1E6E0000
+#define     VIDEO_REG_BASE                      0x1E700000
+#define     APB_BRIDGE_2_BASE                   0x1E780000
+
+#define		DRAM_INIT_BASE						0x1E6E0000
+
+#define		SDRAM_PROTECT_REG					0x00
+    #define     SDRAM_WRITE_DISABLE             0
+    #define     SDRAM_WRITE_ENABLE              1
+
+#define		SCU_BASE							0x1E6E0000
+#define		SCU_OFFSET							0x2000
+
+#define		VIC_BASE							0x1E6C0000
+	#define		VIDEO_INT_BIT				7
+
+#define		IRQ_STATUS_REG						0x00
+#define		RAW_INT_STATUS_REG					0x08
+#define		INT_SEL_REG							0x0C
+	#define		FIQ_INT							1
+	#define		IRQ_INT							0	
+#define		INT_EN_REG							0x10
+#define		INT_EN_CLEAR_REG					0x14
+#define		INT_SOFT_REG						0x18
+#define		INT_SOFT_CLEAR_REG					0x1C
+#define		INT_SENSE_REG						0x24
+	#define		LEVEL_SENSE						1
+	#define		EDGE_SENSE						0
+#define		INT_EVENT_REG						0x2C
+	#define		HIGH_LEVEL_SENSE				1
+	#define		LOW_LEVEL_SENSE					0
+
+#define		SCU_HW_TRAPPING_REG					0x70 + SCU_OFFSET
+	#define		CLIENT_MODE_EN_BIT				18
+	#define		CLIENT_MODE_EN_MASK				0x00040000
+		#define		BE_HOST_CHIP				0
+		#define		BE_CLIENT_CHIP				1
+
+#define     SCU_ULOCK_KEY                       0x1688A8A8
+    
+#define     SCU_PROTECT_REG                     0x00 + SCU_OFFSET
+    #define     SCU_WRITE_DISABLE               0
+    #define     SCU_WRITE_ENABLE                1
+
+#define     SCU_CONTROL_REG                     0x04 + SCU_OFFSET    
+	#define     VIDEO_ENGINE_RESET				0x00000040
+		#define     VIDEO_ENGINE_RESET_BIT      6
+		#define     VIDEO_ENGINE_RESET_MASK     0x00000040
+        #define     VIDEO_RESET_EN              1
+        #define     VIDEO_RESET_OFF             0
+
+#define     SCU_CLOCK_SELECTION_REG             0x08 + SCU_OFFSET
+	#define		PORTA_CLOCK_DELAY_MASK			7 << 8	//Video port A output clcok selection
+		#define	PORTA_CLOCK_INV_DELAY_1NS		5 << 8	//Clock inversed and delay ~ 2ns
+		#define	PORTA_CLOCK_INV_DELAY_2NS		6 << 8	//Clock inversed and delay ~ 3ns
+	#define		PORTB_CLOCK_DELAY_MASK			7 << 12	//Video port B output clock delay
+		#define	PORTB_CLOCK_INV_DELAY_1NS		5 << 12	//Clock inversed and delay ~ 3ns
+		#define	PORTB_CLOCK_INV_DELAY_2NS		6 << 12	//Clock inversed and delay ~ 3ns
+	#define		PORTB_CLOCK_SEL					1 << 15 //Video port B clock selection
+		#define	PORTB_FROM_D1CLK				0 << 15
+		#define PORTB_FROM_D2CLK				1 << 15
+	#define		ECLK_CLK_SEL_MASK				(3 << 2)
+		#define	ECLK_FROM_HPLL					(1 << 2)
+
+	#define     D2CLK_CLOCK_SELECTION			0x00020000
+		#define     D2CLK_CLOCK_SELECTION_BIT   17
+		#define     D2CLK_CLOCK_SELECTION_MASK  0x00060000
+		#define		NORMAL_CRT1					0
+        #define     V1CLK_VIDEO1				2
+        #define     V1CLK_VIDEO2				3
+
+#define     SCU_CLOCK_STOP_REG					0x0C + SCU_OFFSET    
+	#define		EN_ECLK							0 << 0	//Enable ECLK (For Video Engine)
+	#define		STOP_ECLK_BIT					0
+	#define		STOP_ECLK_MASK					1 << 0
+	#define		EN_V1CLK						0 << 3  //Enable V1CLK (For Video Capture #1)
+	#define		STOP_V1CLK_BIT					3
+	#define		STOP_V1CLK_MASK					1 << 3
+	#define		EN_D1CLK						0 << 10 //Enable D1CLK (For CRT1)
+	#define		STOP_D1CLK_BIT					10
+	#define		STOP_D1CLK_MASK					1 << 10
+	#define		EN_D2CLK						0 << 11 //Stop D2CLK (For CRT2)
+	#define		STOP_D2CLK						(1 << 11)
+	#define		STOP_D2CLK_BIT					11
+	#define		STOP_D2CLK_MASK					1 << 11
+	#define		EN_V2CLK						0 << 12 //Stop V2CLK (For Video Capture #2)
+	#define		STOP_V2CLK_BIT					12
+	#define		STOP_V2CLK_MASK					1 << 12
+	#define		STOP_HACE_BIT					13
+	#define		EN_HACE							(0 << 13)
+	#define		STOP_HACE_MASK					(1 << 13)
+	#define     EN_I2SCLK						0 << 18
+	#define     STOP_I2SCLK_MASK				1 << 18
+
+#define     SCU_PIN_CTRL1_REG					0x74 + SCU_OFFSET
+	#define		I2C_5_PIN_EN					1 << 12	//Enable I2C #5 PIN
+	#define		I2C_5_PIN_OFF					0 << 12	//Disable I2C #5 PIN
+	#define		I2C_5_PIN_MASK					1 << 12
+	#define		VGA_PIN_OFF						0 << 15 //Enable VGA pins
+	#define		VGA_PIN_MASK					1 << 15
+	#define		VIDEO_PORTA_EN					1 << 16 //Enable Video port A control pins
+	#define		VIDEO_PORTA_MASK				1 << 16
+	#define		VIDEO_PORTB_EN					1 << 17 //Enable Video port B control pins
+	#define		VIDEO_PORTB_MASK				1 << 17
+	#define		VIDEO_VP1_EN					1 << 22 //Enable VP[11:0]
+	#define		VIDEO_VP1_MASK					1 << 22 
+	#define		VIDEO_VP2_EN					1 << 23 //Enable VP[23:12]
+	#define		VIDEO_VP2_MASK					1 << 23
+	#define		I2S_PIN_EN						1 << 29 //Enable I2S function pins
+	#define		I2S_PIN_MASK					1 << 29
+
+#define     SCU_PIN_CTRL2_REG					0x78 + SCU_OFFSET
+	#define		VIDEO_PORTA_SINGLE_EDGE_MASK	1 << 0
+		#define		VIDEO_PORTA_SINGLE_EDGE		1 << 0	//Enable Video port A single mode
+		#define		VIDEO_PORTA_DUAL_EDGE		0 << 0
+	#define		VIDEO_PORTB_SINGLE_EDGE_MASK	1 << 1
+		#define		VIDEO_PORTB_DUAL_EDGE		0 << 1
+		#define		VIDEO_PORTB_SINGLE_EDGE		1 << 1	//Enable Video port B single mode
+
+#define		SCU_M_PLL_PARAM_REG					0x20 + SCU_OFFSET
+
+#define		DRAM_BASE							0x40000000
+
+#define     INPUT_BITCOUNT_YUV444				4
+#define		INPUT_BITCOUNT_YUV420				2
+
+/* HW comment value */
+//PASSWORD
+#define     VIDEO_UNLOCK_KEY                    0x1A038AA8
+#define		SCU_UNLOCK_KEY						0x1688A8A8
+#define		SDRAM_UNLOCK_KEY					0xFC600309
+
+
+//#define     SAMPLE_RATE                                 12000000.0
+#ifdef OSC_NEW
+    #define     SAMPLE_RATE                                 24576000.0
+#else
+    #define     SAMPLE_RATE                                 24000000.0
+#endif
+
+#define     MODEDETECTION_VERTICAL_STABLE_MAXIMUM       0x4
+#define     MODEDETECTION_HORIZONTAL_STABLE_MAXIMUM     0x4
+#define     MODEDETECTION_VERTICAL_STABLE_THRESHOLD     0x4
+#define     MODEDETECTION_HORIZONTAL_STABLE_THRESHOLD   0x8
+
+#define     MODEDETECTION_EDGE_PIXEL_THRES_DIGITAL      2
+#define     MODEDETECTION_EDGE_PIXEL_THRES_ANALOGE      0x0A
+
+#define		MODEDETECTION_OK							0
+#define		MODEDETECTION_ERROR							1
+#define		JUDGE_MODE_ERROR							2
+
+//I2C Loop Count
+#define    LOOP_COUNT                                  1000
+#define    CAN_NOT_FIND_DEVICE                         1
+#define    SET_I2C_DONE                                0
+#define	   I2C_BASE									   0xA000
+#define    AC_TIMING                                   0x77743355
+
+//I2C channel and Devices
+#define     I2C_VIDEO1_EEPROM                           0x2
+#define     I2C_VIDEO2_EEPROM                           0x5
+#define     I2C_VIDEO2_9883                             0x4
+/*
+ULONG    CAPTURE1_ADDRESS =                     0x1000000;
+ULONG    CAPTURE2_ADDRESS =                     0x3000000;
+ULONG    PASS1_ENCODE_SOURCE_ADDRESS =          0x1000000;
+ULONG    PASS1_ENCODE_DESTINATION_ADDRESS =     0x2000000;
+ULONG    Buffer1_DECODE_SOURCE_ADDRESS =        0x1000000;
+ULONG    Buffer2_DECODE_SOURCE_ADDRESS =        0x1400000;
+ULONG    PASS1_DECODE_DESTINATION_ADDRESS =     0x600000;
+ULONG    CAPTURE_2ND_ADDRESS =                  0x1800000;
+ULONG    PASS1_2ND_ENCODE_SOURCE_ADDRESS =      0x1800000;
+ULONG    PASS1_2ND_ENCODE_DESTINATION_ADDRESS = 0x2800000;
+ULONG    PASS1_2ND_DECODE_SOURCE_ADDRESS =      0x1000000;
+ULONG    PASS1_2ND_DECODE_DESTINATION_ADDRESS = 0x600000;
+ULONG    PASS2_ENCODE_SOURCE_ADDRESS =          0x000000;
+ULONG    PASS2_ENCODE_DESTINATION_ADDRESS =     0xC00000;
+ULONG    PASS2_DECODE_SOURCE_ADDRESS =          0xC00000;
+ULONG    PASS2_DECODE_DESTINATION_ADDRESS =     0x600000;
+ULNG    PASS2_DECODE_REFERENCE_ADDRESS =       0x600000;
+*/
+
+typedef struct _CTL_REG_G {
+    ULONG   CompressMode:1;
+    ULONG   SkipEmptyFrame:1;
+    ULONG   MemBurstLen:2;
+    ULONG   LineBufEn:2;
+    ULONG   Unused:26;
+} CTL_REG_G;
+
+
+typedef union _U_CTL_G {
+    ULONG       Value;
+    CTL_REG_G   CtlReg;
+} U_CTL_G;
+
+typedef struct _MODE_DETECTION_PARAM_REG {
+    ULONG   Unused1:8;
+    ULONG   EdgePixelThres:8;
+    ULONG   VerStableMax:4;
+    ULONG   HorStableMax:4;
+    ULONG   VerDiffMax:4;
+    ULONG   HorDiffMax:4;
+} MODE_DETECTION_PARAM_REG;
+
+typedef struct _CRC_PRI_PARAM_REG {
+    ULONG   Enable:1;
+    ULONG   HighBitOnly:1;
+    ULONG   SkipCountMax:6;
+    ULONG   PolyLow:8;
+    ULONG   PolyHigh:16;
+} CRC_PRI_PARAM_REG;
+
+typedef union _U_CRC_PRI_PARAM {
+    ULONG               Value;
+    CRC_PRI_PARAM_REG   CRCPriParam;
+} U_CRC_PRI_PARAM;
+
+typedef struct _CRC_SEC_PARAM_REG {
+    ULONG   Unused1:8;
+    ULONG   PolyLow:8;
+    ULONG   PolyHigh:16;
+} CRC_SEC_PARAM_REG;
+
+typedef union _U_CRC_SEC_PARAM {
+    ULONG               Value;
+    CRC_SEC_PARAM_REG   CRCSecParam;
+} U_CRC_SEC_PARAM;
+
+typedef struct _GENERAL_INFO {
+    BYTE                EnableVideoM;
+    BYTE                CenterMode;
+	BYTE				RC4NoResetFrame;
+	BYTE				RC4TestMode;
+    U_CTL_G             uCtlReg;
+    U_CRC_PRI_PARAM     uCRCPriParam;
+    U_CRC_SEC_PARAM     uCRCSecParam;
+} GENERAL_INFO, *PGENERAL_INFO;
+
+typedef struct _SEQ_CTL_REG {
+    ULONG   Unused1:1;
+    ULONG   Unused2:1;
+    ULONG   Unused3:1;
+    ULONG   CaptureAutoMode:1;
+    ULONG   Unused4:1;
+    ULONG   CodecAutoMode:1;
+    ULONG   Unused5:1;
+    ULONG   WatchDog:1;
+    ULONG   CRTSel:1;
+    ULONG   AntiTearing:1;
+    ULONG   DataType:2;
+    ULONG   Unused6:20;
+} SEQ_CTL_REG;
+
+typedef union _U_SEQ_CTL {
+    ULONG               Value;
+    SEQ_CTL_REG   SeqCtlReg;
+} U_SEQ_CTL;
+
+typedef struct _CTL_REG {
+    ULONG   SrcHsync:1;
+    ULONG   SrcVsync:1;
+    ULONG   ExtSrc:1;
+    ULONG   AnalongExtSrc:1;
+    ULONG   IntTimingGen:1;
+    ULONG   IntDataFrom:1;
+    ULONG   WriteFmt:2;
+    ULONG   VGACursor:1;
+    ULONG   LinearMode:1;
+    ULONG   ClockDelay:2;
+    ULONG   CCIR656Src:1;
+    ULONG   PortClock:1;
+    ULONG   ExtPort:1;        
+    ULONG   Unused1:1;
+    ULONG   FrameRate:8;
+    ULONG   Unused2:8;
+} CTL_REG;
+
+typedef union _U_CTL {
+    ULONG       Value;
+    CTL_REG     CtlReg;
+} U_CTL_REG;
+
+typedef struct _TIMING_GEN_SETTING_H {
+    ULONG   HDEEnd:13;
+    ULONG   Unused1:3;
+    ULONG   HDEStart:13;
+    ULONG   Unused2:3;
+} TIMING_GEN_SETTING_H;
+
+typedef struct _TIMING_GEN_SETTING_V {
+    ULONG   VDEEnd:13;
+    ULONG   Unused1:3;
+    ULONG   VDEStart:13;
+    ULONG   Unused2:3;
+} TIMING_GEN_SETTING_V;
+
+typedef struct _BCD_CTL_REG {
+    ULONG   Enable:1;
+    ULONG   Unused1:15;
+    ULONG   Tolerance:8;
+    ULONG   Unused2:8;
+} BCD_CTL_REG;
+
+typedef union _U_BCD_CTL {
+    ULONG           Value;
+    BCD_CTL_REG     BCDCtlReg;
+} U_BCD_CTL;
+
+typedef struct _COMPRESS_WINDOW_REG {
+    ULONG   VerLine:13;
+    ULONG   Unused1:3;
+    ULONG   HorPixel:13;
+    ULONG   Unused2:3;
+} COMPRESS_WINDOW_REG;
+
+typedef struct _STREAM_BUF_SIZE {
+    ULONG   PacketSize:3;
+    ULONG   RingBufNum:2;
+    ULONG   Unused1:11;
+    ULONG   SkipHighMBThres:7;
+    ULONG   SkipTestMode:2;
+    ULONG   Unused2:7;
+} STREAM_BUF_SIZE;
+
+typedef union _U_STREAM_BUF {
+    ULONG               Value;
+    STREAM_BUF_SIZE     StreamBufSize;
+} U_STREAM_BUF;
+
+
+typedef struct _COMPRESS_CTL_REG {
+    ULONG   JPEGOnly:1; /* True: Jpeg Only mode(Disable VQ), False:Jpeg and VQ mix mode */
+    ULONG   En4VQ:1; /* True: 1, 2, 4 color mode, False: 1,2 color mode */
+    ULONG   CodecMode:1; /* High and best Quantization encoding/decoding setting*/
+    ULONG   DualQuality:1;
+    ULONG   EnBest:1;
+    ULONG   EnRC4:1;
+    ULONG   NorChromaDCTTable:5;
+    ULONG   NorLumaDCTTable:5;
+    ULONG   EnHigh:1;
+    ULONG   TestCtl:2;
+    ULONG   UVFmt:1;
+    ULONG   HufTable:2;
+    ULONG   AlterValue1:5;
+    ULONG   AlterValue2:5;
+} COMPRESS_CTL_REG;
+
+typedef union _U_COMPRESS_CTL {
+    ULONG               Value;
+    COMPRESS_CTL_REG    CompressCtlReg;
+} U_COMPRESS_CTL;
+
+typedef struct _QUANTI_TABLE_LOW_REG {
+    ULONG   ChromaTable:5;
+    ULONG   LumaTable:5;
+    ULONG   Unused1:22;
+} QUANTI_TABLE_LOW_REG;
+
+typedef union _U_CQUANTI_TABLE_LOW {
+    ULONG                   Value;
+    QUANTI_TABLE_LOW_REG    QTableLowReg;
+} U_QUANTI_TABLE_LOW;
+
+typedef struct _QUANTI_VALUE_REG {
+    ULONG   High:15;
+	ULONG	Unused1:1;
+    ULONG   Best:15;
+    ULONG   Unused2:1;
+} QUANTI_VALUE_REG;
+
+typedef union _U_QUANTI_VALUE {
+    ULONG               Value;
+    QUANTI_VALUE_REG    QValueReg;
+} U_QUANTI_VALUE;
+
+typedef struct _BSD_PARAM_REG {
+    ULONG   HighThres:8;
+    ULONG   LowThres:8;
+    ULONG   HighCount:6;
+    ULONG   Unused1:2;
+    ULONG   LowCount:6;
+    ULONG   Unused2:2;
+} BSD_PARAM_REG;
+
+typedef union _U_BSD_PARAM {
+    ULONG           Value;
+    BSD_PARAM_REG   BSDParamReg;
+} U_BSD_PARAM;
+
+typedef struct _VIDEO_INFO {
+    BYTE      ExtADCAct;    /* read from modection register */
+	BYTE	  EnableRC4;
+    BYTE      DownScalingMethod;
+    USHORT    AnalogDifferentialThreshold; /* BCD tolerance */
+    USHORT    DigitalDifferentialThreshold; /* BCD tolerance */
+    USHORT    DstWidth;
+    USHORT    DstHeight;
+    USHORT    SrcWidth;
+    USHORT    SrcHeight;
+    BYTE      HighLumaTable; /* if High and best Jpeg codec enable, use HighLumaTable and HighChromaTable, otherwise HighDeQuantiValue and BestDequantiValue*/
+    BYTE      HighChromaTable;
+    BYTE      HighDeQuantiValue;
+    BYTE      BestDequantiValue;
+    U_SEQ_CTL               uSeqCtlReg;
+    U_CTL_REG               uCtlReg;
+    U_BCD_CTL               uBCDCtlReg;
+    U_STREAM_BUF            uStreamBufSize;
+    U_COMPRESS_CTL          uCompressCtlReg;
+    U_QUANTI_TABLE_LOW      uQTableLowReg;
+    U_QUANTI_VALUE          uQValueReg;
+    U_BSD_PARAM             uBSDParamReg;
+} VIDEO_INFO, *PVIDEO_INFO ;
+
+typedef struct _VIDEOM_SEQ_CTL_REG {
+    ULONG   Unused1:1;  //Bit 0
+    ULONG   Unused2:1;	//Bit 1
+    ULONG   Unused3:1;		//Bit 2
+    ULONG   StreamMode:1;	//Bit 3
+    ULONG   Unused4:1;	//Bit 4
+    ULONG   CodecAutoMode:1;	//Bit 5
+	ULONG	Unused6:1;	//Bit 6
+    ULONG   Unused7:1;	//Bit 7
+    ULONG   SrcSel:1;	//Bit 8
+    ULONG   Unused9:1;	//Bit 9
+    ULONG   DataType:2;  //Bit[11:10]
+    ULONG   Unused12:20;
+} VIDEOM_SEQ_CTL_REG;
+
+typedef union _U_VIDEOM_SEQ_CTL {
+    ULONG					Value;
+    VIDEOM_SEQ_CTL_REG		SeqCtlReg;
+} U_VIDEOM_SEQ_CTL;
+
+typedef struct _VIDEOM_INFO {
+    BYTE      DownScalingMethod;
+    USHORT    AnalogDifferentialThreshold; /* BCD tolerance */
+    USHORT    DigitalDifferentialThreshold; /* BCD tolerance */
+    USHORT    DstWidth;
+    USHORT    DstHeight;
+    USHORT    SrcWidth;
+    USHORT    SrcHeight;
+    BYTE      HighLumaTable; /* if High and best Jpeg codec enable, use HighLumaTable and HighChromaTable, otherwise HighDeQuantiValue and BestDequantiValue*/
+    BYTE      HighChromaTable;
+    BYTE      HighDeQuantiValue;
+    BYTE      BestDequantiValue;
+    BYTE      PacketSize;   //the same as video1 & video2
+    BYTE      RingBufNum;
+	BYTE	  EnableRC4;
+    U_VIDEOM_SEQ_CTL        uSeqCtlReg;
+    U_BCD_CTL               uBCDCtlReg;
+    U_COMPRESS_CTL          uCompressCtlReg;
+    U_QUANTI_TABLE_LOW      uQTableLowReg;
+    U_QUANTI_VALUE          uQValueReg;
+    U_BSD_PARAM             uBSDParamReg;
+} VIDEOM_INFO, *PVIDEOM_INFO ;
+
+typedef struct _VIDEO_MODE_INFO
+{
+    USHORT    X;
+    USHORT    Y;
+    USHORT    ColorDepth;
+    USHORT    RefreshRate;
+    BYTE      ModeIndex;
+} VIDEO_MODE_INFO, *PVIDEO_MODE_INFO;
+
+#endif
+
diff --git a/board/aspeed/ast2300/vesa.h b/board/aspeed/ast2300/vesa.h
new file mode 100755
index 0000000..69aba90
--- /dev/null
+++ b/board/aspeed/ast2300/vesa.h
@@ -0,0 +1,163 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef _VESA_H_
+#define _VESA_H_
+
+typedef enum 
+{
+	VCLK25_175	= 0x00,
+	VCLK28_322	= 0x01,
+	VCLK31_5	= 0x02,
+	VCLK31_574	= 0x03,
+	VCLK32_76	= 0x04,
+	VCLK33_154	= 0x05,
+	VCLK36		= 0x06,
+	VCLK40		= 0x07,
+	VCLK45_978	= 0x08,
+	VCLK49_5	= 0x09,
+	VCLK50		= 0x0A,
+	VCLK52_95	= 0x0B,
+	VCLK56_25	= 0x0C,
+	VCLK65		= 0x0D,
+	VCLK74_48	= 0x0E,
+	VCLK75		= 0x0F,
+	VCLK78_75	= 0x10,
+	VCLK79_373	= 0x11,
+	VCLK81_624	= 0x12,
+	VCLK83_462	= 0x13,
+	VCLK84_715	= 0x14,
+	VCLK94_5	= 0x15,
+	VCLK106_5	= 0x16,
+	VCLK108		= 0x17,
+	VCLK119		= 0x18,
+	VCLK135		= 0x19,
+	VCLK136_358 = 0x1A,
+	VCLK146_25	= 0x1B,
+	VCLK154		= 0x1C,
+	VCLK157_5	= 0x1D,
+	VCLK162		= 0x1E
+} ePIXEL_CLOCK;
+
+typedef struct {
+    USHORT    HorizontalTotal;
+    USHORT    VerticalTotal;
+    USHORT    HorizontalActive;
+    USHORT    VerticalActive;
+    BYTE      RefreshRate;
+    double    HorizontalFrequency;
+    USHORT    HSyncTime;
+    USHORT    HBackPorch;
+    USHORT    VSyncTime;
+    USHORT    VBackPorch;
+    USHORT    HLeftBorder;
+    USHORT    HRightBorder;
+    USHORT    VBottomBorder;
+    USHORT	  VTopBorder;
+	USHORT	  PixelClock;
+	BOOL	  HorPolarity;
+	BOOL	  VerPolarity;
+    BYTE      ADCIndex1;
+    BYTE      ADCIndex2;
+    BYTE      ADCIndex3;
+    BYTE      ADCIndex5;
+    BYTE      ADCIndex6;
+    BYTE      ADCIndex7;
+    BYTE      ADCIndex8;
+    BYTE      ADCIndex9;
+    BYTE      ADCIndexA;
+    BYTE      ADCIndexF;
+    BYTE      ADCIndex15;
+    int       HorizontalShift;
+    int       VerticalShift;
+} VESA_MODE;
+
+#define HOR_POSITIVE 0
+#define HOR_NEGATIVE 1
+#define VER_POSITIVE 0
+#define VER_NEGATIVE 1
+
+#ifdef VESA_GLOBALS
+
+//  Note: Modified for modes which have border issue
+VESA_MODE vModeTable[] = {
+////////////////////////// 60Hz mode
+// 720x480 done
+  {1056, 497,  720,  480,  60, 29.900, 88,  104, 3, 13, 0, 0, 0, 0,	VCLK31_574,  HOR_NEGATIVE, VER_NEGATIVE, 0x41,	0xF0, 0x48, 0x05, 0x20, 0x58, 0x60, 0x60, 0x60,	0x5E, 0xFE,  6,	2},
+// 848x480 done                                                                               
+  {1064, 517,  848,  480,  60, 31.160, 88,  91,  3, 26, 0, 0, 0, 0,	VCLK33_154,  HOR_NEGATIVE, VER_NEGATIVE, 0x42,	0x70, 0x48, 0x05, 0x20, 0x58, 0x60, 0x60, 0x60,	0x5E, 0xFE,  6,	2},
+  {800,  525,  640,  480,  60, 31.469, 96,  40,  2, 25, 1, 1, 8, 8,	VCLK25_175,  HOR_NEGATIVE, VER_NEGATIVE, 0x31,	0xF0, 0x48, 0x05, 0x20, 0x60, 0x60, 0x60, 0x60,	0x5E, 0xFE,  6,	2},
+// 720x576                                                                                    
+  {912,  597,  720,  576,  60, 35.920, 72,  88,  3, 17, 0, 0, 0, 0,	VCLK32_76,   HOR_NEGATIVE, VER_NEGATIVE, 0x38,	0xF0, 0x48, 0x05, 0x20, 0x48, 0x60, 0x60, 0x60,	0x5E, 0xFE,  6,	2},
+// 960x600 GTF done                                                                           
+  {1232, 622,  960,  600,  60, 37.320, 96,  136, 3, 18, 0, 0, 0, 0,	VCLK45_978,  HOR_NEGATIVE, VER_NEGATIVE, 0x4C,	0xF0, 0x60, 0x05, 0x20, 0x60, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	0},
+  {1056, 628,  800,  600,  60, 37.879, 128, 88,  4, 23, 0, 0, 0, 0,	VCLK40,	     HOR_POSITIVE, VER_POSITIVE, 0x41,	0xF0, 0x60, 0x05, 0x20, 0x80, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	0},
+// 1088x612 GTF done                                                                          
+  {1392, 634,  1088, 612,  60, 38.04,  112, 152, 3, 18, 0, 0, 0, 0,	VCLK52_95,   HOR_NEGATIVE, VER_NEGATIVE, 0x56,	0xF0, 0x60, 0x05, 0x20, 0x70, 0x60, 0x60, 0x60, 0x5E, 0xFE, -1, 0},
+// 1280x720 GTF done                                                                          
+  {1664, 746,  1280, 720,  60, 44.760, 136, 192, 3, 22, 0, 0, 0, 0,	VCLK74_48,   HOR_NEGATIVE, VER_NEGATIVE, 0x67,	0xF0, 0xA8, 0x05, 0x20, 0x88, 0x60, 0x60, 0x60, 0x5E, 0xFE, -1, 0},
+// 1360x768 GTF done                                                                          
+  {1776, 795,  1360, 768,  60, 47.700, 144, 208, 3, 23, 0, 0, 0, 0,	VCLK84_715,  HOR_NEGATIVE, VER_NEGATIVE, 0x6E,	0xF0, 0xA8, 0x05, 0x20, 0x90, 0x60, 0x60, 0x60, 0x5E, 0xFE,  7, 1},
+// 1280x768 done                                                                              
+  {1664, 798,  1280, 768,  60, 47.700, 128, 184, 7, 20, 0, 0, 0, 0,	VCLK79_373,  HOR_NEGATIVE, VER_NEGATIVE, 0x67,	0xF0, 0xA8, 0x05, 0x20, 0x80, 0x60, 0x60, 0x60, 0x5E, 0xFE,  7, 1},
+  {1344, 806,  1024, 768,  60, 48.363, 136, 160, 6, 29, 0, 0, 0, 0,	VCLK65,	     HOR_NEGATIVE, VER_NEGATIVE, 0x53,	0xF0, 0xA8, 0x05, 0x20, 0x88, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	7},
+// 1280x800 GTF done                                                                          
+  {1680, 828,  1280, 800,  60, 49.680, 136, 200, 3, 24, 0, 0, 0, 0,	VCLK83_462,  HOR_NEGATIVE, VER_NEGATIVE, 0x68,	0xF0, 0xA8, 0x05, 0x20, 0x88, 0x60, 0x60, 0x60, 0x5E, 0xFE, -1, 0},
+// 1152x864 GTF done                                                                          
+  {1520, 895,  1152, 864,  60, 53.700, 120, 184, 3, 27, 0, 0, 0, 0,	VCLK81_624,  HOR_NEGATIVE, VER_NEGATIVE, 0x5E,	0xF0, 0xA8, 0x05, 0x20, 0x78, 0x60, 0x60, 0x60, 0x5E, 0xFE, -1, 0},
+// 1600x900 GTF done                                                                          
+  {2128, 932,  1600, 900,  60, 55.920, 168, 264, 3, 28, 0, 0, 0, 0,	VCLK119,	 HOR_NEGATIVE, VER_NEGATIVE, 0x84,	0xF0, 0xA8, 0x05, 0x20, 0xA8, 0x60, 0x60, 0x60, 0x5E, 0xFE, -1, 0},
+// 1440X900 CVT done                                                                          
+  {1904, 933,  1440, 900,  60, 55.935, 152, 232, 6,	25,	0, 0, 0, 0,	VCLK106_5,   HOR_NEGATIVE, VER_POSITIVE, 0x76,	0xF0, 0xA8, 0x05, 0x20, 0x96, 0x60, 0x60, 0x60, 0x5E, 0xFE, -1, 0},
+  {1800, 1000, 1280, 960,  60, 60.000, 112, 312, 3, 36, 0, 0, 0, 0,	VCLK108,	 HOR_POSITIVE, VER_POSITIVE, 0x70,	0x70, 0xA8, 0x05, 0x20, 0x70, 0x60, 0x60, 0x60, 0x5E, 0xFE, -1, 0},
+// 1600x1024 GTF done                                                                            
+  {2144, 1060, 1600, 1024, 60, 63.600, 168, 272, 3, 32, 0, 0, 0, 0,	VCLK136_358, HOR_NEGATIVE, VER_NEGATIVE, 0x85,	0xF0, 0xE8, 0x05, 0x20, 0xA8, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	0},
+  {1688, 1066, 1280, 1024, 60, 63.981, 112, 248, 3, 38, 0, 0, 0, 0,	VCLK108,	 HOR_POSITIVE, VER_POSITIVE, 0x69,	0x70, 0xA8, 0x05, 0x20, 0x70, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	0},
+// 1680X1050 CVT done Reduced Blanking                                                          
+  {1840, 1080, 1680, 1050, 60, 64.674, 32,  80,	 6,	21,	0, 0, 0, 0,	VCLK119,	 HOR_POSITIVE, VER_NEGATIVE, 0x72,	0xF0, 0xA8, 0x05, 0x20, 0x20, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	0},
+// 1920X1200 CVT done Reduced Blanking                           
+  {2080, 1235, 1920, 1200, 60, 74.038, 32,  80,  6, 26, 0, 0, 0, 0, VCLK154,     HOR_POSITIVE, VER_NEGATIVE, 0x81,	0xF0, 0xA8, 0x05, 0x20, 0x20, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	0},
+  //{2160,           1250,           1600,           1200, 60,75.000,           192,        304,         3,          46,          0,            0,             0,              0,			VCLK162,		HOR_POSITIVE,	VER_POSITIVE},
+  {2160, 1248, 1600, 1200, 60, 75.000, 192, 304, 3, 46, 0, 0, 0, 0,	VCLK162,	 HOR_POSITIVE, VER_POSITIVE, 0x86,	0xF0, 0xE8, 0x05, 0x20, 0xC0, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	0},
+                                                              
+//////////////////////  Not 60Hz mode                                                                                                                  
+  {900,  449,  720,  400,  70, 31.469, 108, 45,  2, 25, 1, 1, 8, 8,	0,			 HOR_NEGATIVE, VER_NEGATIVE, 0x38,	0x30, 0x48, 0x05, 0x20, 0x6C, 0x60, 0x60, 0x60,	0x5E, 0xFE,  6,	1},
+  {832,  520,  640,  480,  72, 37.861, 40,  120, 3, 20, 1, 1, 8, 8,	0,			 HOR_NEGATIVE, VER_NEGATIVE, 0x33,	0xF0, 0x48, 0x05, 0x20, 0x28, 0x60, 0x60, 0x60,	0x5E, 0xFE,  6,	3},
+  {840,  500,  640,  480,  75, 37.500, 64,  120, 3, 16, 0, 0, 0, 0,	0,			 HOR_NEGATIVE, VER_NEGATIVE, 0x34,	0x70, 0x48, 0x05, 0x20, 0x40, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	3},                                         
+  {832,  509,  640,  480,  85, 43.269, 56,  80,  3, 25, 0, 0, 0, 0,	0,			 HOR_NEGATIVE, VER_NEGATIVE, 0x33,	0xF0, 0x48, 0x05, 0x20, 0x38, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	3},
+  {1024, 625,  800,  600,  56, 35.156, 72,  128, 2, 22, 0, 0, 0, 0,	0,			 HOR_POSITIVE, VER_POSITIVE, 0x3F,	0xF0, 0x60, 0x05, 0x20, 0x48, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	0},
+  {1040, 666,  800,  600,  72, 48.077, 120, 64,  6, 23, 0, 0, 0, 0,	0,			 HOR_POSITIVE, VER_POSITIVE, 0x40,	0xF0, 0x60, 0x05, 0x20, 0x78, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	0},
+  {1056, 625,  800,  600,  75, 46.875, 80,  160, 3, 21, 0, 0, 0, 0,	0,			 HOR_POSITIVE, VER_POSITIVE, 0x41,	0xF0, 0x60, 0x05, 0x20, 0x50, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	0},
+  {1048, 631,  800,  600,  85, 53.674, 64,  152, 3, 27, 0, 0, 0, 0,	0,			 HOR_POSITIVE, VER_POSITIVE, 0x41,	0x70, 0x60, 0x05, 0x20, 0x40, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	0},
+  {1328, 806,  1024, 768,  70, 56.476, 136, 144, 6, 29, 0, 0, 0, 0,	0,			 HOR_NEGATIVE, VER_NEGATIVE, 0x52,	0xF0, 0xA8, 0x05, 0x20, 0x88, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	7},
+  {1312, 800,  1024, 768,  75, 60.023, 96,  176, 3, 28, 0, 0, 0, 0,	0,			 HOR_POSITIVE, VER_POSITIVE, 0x51,	0xF0, 0xA8, 0x05, 0x20, 0x60, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	1},
+  {1376, 808,  1024, 768,  85, 68.677, 96,  208, 3, 36, 0, 0, 0, 0,	0,			 HOR_POSITIVE, VER_POSITIVE, 0x55,	0xF0, 0xA8, 0x05, 0x20, 0x60, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	1},
+  {1600, 900,  1152, 864,  75, 67.500, 128, 256, 3, 32, 0, 0, 0, 0,	0,			 HOR_POSITIVE, VER_POSITIVE, 0x63,	0xF0, 0xA8, 0x05, 0x20, 0x80, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	0},
+  {1728, 1011, 1280, 960,  85, 85.938, 160, 224, 3, 47, 0, 0, 0, 0,	0,			 HOR_POSITIVE, VER_POSITIVE, 0x6B,	0xF0, 0xA8, 0x05, 0x20, 0xA0, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	0},
+  {1688, 1066, 1280, 1024, 75, 79.976, 144, 248, 3, 38, 0, 0, 0, 0,	0,			 HOR_POSITIVE, VER_POSITIVE, 0x69,	0x70, 0xE8, 0x05, 0x20, 0x90, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	0},
+  {1728, 1072, 1280, 1024, 85, 91.146, 160, 224, 3, 44, 0, 0, 0, 0,	0,			 HOR_POSITIVE, VER_POSITIVE, 0x6B,	0xF0, 0xA8, 0x05, 0x20, 0xA0, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	0},
+  {2160, 1250, 1600, 1200, 65, 81.250, 192, 304, 3, 46, 0, 0, 0, 0,	0,			 HOR_POSITIVE, VER_POSITIVE, 0x86,	0xF0, 0xA8, 0x05, 0x20, 0xC0, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	0},
+  {2160, 1250, 1600, 1200, 70, 87.500, 192, 304, 3, 46, 0, 0, 0, 0,	0,			 HOR_POSITIVE, VER_POSITIVE, 0x86,	0xF0, 0xA8, 0x05, 0x20, 0xC0, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	0},
+  {2160, 1250, 1600, 1200, 75, 93.750, 192, 304, 3, 46, 0, 0, 0, 0,	0,			 HOR_POSITIVE, VER_POSITIVE, 0x86,	0xF0, 0xA8, 0x05, 0x20, 0xC0, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	0},
+  {2160, 1250, 1600, 1200, 85, 106.250,192, 304, 3, 46, 0, 0, 0, 0,	0,			 HOR_POSITIVE, VER_POSITIVE, 0x86,	0xF0, 0xA8, 0x05, 0x20, 0xC0, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	0}
+};
+
+USHORT  ModeNumberCount = sizeof (vModeTable) / sizeof (VESA_MODE);
+USHORT  Mode60HZCount = 21;
+
+#else  /* NOT VESA_GLOBALS */
+extern VESA_MODE vModeTable[];
+extern USHORT  ModeNumberCount;
+extern USHORT  Mode60HZCount;
+#endif
+
+#endif /* _VESA_H_ */
+
+
diff --git a/board/aspeed/ast2300/vfun.c b/board/aspeed/ast2300/vfun.c
new file mode 100755
index 0000000..f707e80
--- /dev/null
+++ b/board/aspeed/ast2300/vfun.c
@@ -0,0 +1,545 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#define BUF_GLOBALS
+#include "type.h"
+#include "vdef.h"
+#include "vreg.h"
+#include "crt.h"
+#include "vfun.h"
+
+ULONG UnlockSCURegHost(ULONG   MMIOBase, ULONG Key)
+{
+    WriteMemoryLongHost(SCU_BASE, SCU_PROTECT_REG, Key);
+    return ReadMemoryLongHost(SCU_BASE,SCU_PROTECT_REG);
+}
+
+void ResetVideoHost(void)
+{
+	WriteMemoryLongWithMASKHost(SCU_BASE, SCU_CONTROL_REG, VIDEO_RESET_EN << VIDEO_ENGINE_RESET_BIT, VIDEO_ENGINE_RESET_MASK);
+	WriteMemoryLongWithMASKHost(SCU_BASE, SCU_CONTROL_REG, VIDEO_RESET_OFF << VIDEO_ENGINE_RESET_BIT, VIDEO_ENGINE_RESET_MASK);
+}
+
+void StartModeDetectionTriggerHost(ULONG   MMIOBase, ULONG offset)
+{
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, offset, 0, MODE_DETECTION_TRIGGER);
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, offset, MODE_DETECTION_TRIGGER, MODE_DETECTION_TRIGGER);
+}
+
+BOOL ReadVideoInterruptHost(ULONG   MMIOBase, ULONG value)
+{
+    return ((ReadMemoryLongHost(VIDEO_REG_BASE, VIDEO_INT_CONTROL_READ_REG) & value) ? TRUE : FALSE);
+}
+
+ULONG UnlockVideoRegHost(ULONG   MMIOBase, ULONG Key)
+{
+    WriteMemoryLongHost(VIDEO_REG_BASE, KEY_CONTROL_REG, Key);
+    return ReadMemoryLongHost(VIDEO_REG_BASE,KEY_CONTROL_REG);
+}
+
+void StartVideoCaptureTriggerHost(ULONG   MMIOBase, ULONG offset)
+{
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, offset, 0, VIDEO_CAPTURE_TRIGGER);
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, offset, VIDEO_CAPTURE_TRIGGER, VIDEO_CAPTURE_TRIGGER);
+}
+
+void StartVideoCodecTriggerHost(ULONG   MMIOBase, ULONG offset)
+{
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, offset, 0, VIDEO_CODEC_TRIGGER);
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, offset, VIDEO_CODEC_TRIGGER, VIDEO_CODEC_TRIGGER);
+}
+
+void StopModeDetectionTriggerHost(ULONG   MMIOBase, ULONG offset)
+{
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, offset, 0, MODE_DETECTION_TRIGGER);
+}
+
+void ClearVideoInterruptHost(ULONG   MMIOBase, ULONG value)
+{
+    //WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO_INT_CONTROL_CLEAR_REG, value, value);
+	WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO_INT_CONTROL_CLEAR_REG, value);
+}
+
+/* UnLock SCU Host and Reset Engine */
+BOOL CheckOnStartHost(void)
+{
+    int i=0, dwValue=0;
+    
+    do
+    {
+	dwValue = UnlockSCURegHost(0, SCU_UNLOCK_KEY);
+	i++;
+    }
+    while ((SCU_WRITE_ENABLE != dwValue) && (i<10));
+
+    //Clear SCU Reset Register
+    WriteMemoryLongHost(SCU_BASE, SCU_CONTROL_REG, 0);
+
+    WriteMemoryLongWithMASKHost(SCU_BASE, SCU_CLOCK_STOP_REG, (EN_ECLK | EN_V1CLK | EN_V2CLK), (STOP_ECLK_MASK | STOP_V1CLK_MASK | STOP_V2CLK_MASK));
+
+#if	defined(CONFIG_AST2300)
+    WriteMemoryLongWithMASKHost(SCU_BASE, (0x90 + SCU_OFFSET), 0x00000020, 0x00000030);	//enable 24bits
+    WriteMemoryLongWithMASKHost(SCU_BASE, (0x88 + SCU_OFFSET), 0x000fff00, 0x000fff00);	//enable video multi-pins    
+#else	//AST2100 
+    //WriteMemoryLongWithMASKHost(SCU_BASE, SCU_PIN_CTRL1_REG, (VIDEO_PORTA_EN | VIDEO_PORTB_EN | VIDEO_VP1_EN | VIDEO_VP2_EN) , 
+    //							(VIDEO_PORTA_MASK | VIDEO_PORTB_MASK | VIDEO_VP1_MASK | VIDEO_VP2_MASK));
+    WriteMemoryLongWithMASKHost(SCU_BASE, SCU_PIN_CTRL2_REG, (VIDEO_PORTA_SINGLE_EDGE | VIDEO_PORTB_SINGLE_EDGE) , 
+	      						     (VIDEO_PORTA_SINGLE_EDGE_MASK | VIDEO_PORTB_SINGLE_EDGE_MASK));
+#endif	      						     
+
+    ResetVideoHost();
+
+    return TRUE;
+}
+
+BOOL CheckOnStartClient(void)
+{
+	int i=0, dwValue=0;
+    
+	do
+	{
+		dwValue = UnlockSCURegHost(0, SCU_UNLOCK_KEY);
+		i++;
+	}
+	while ((SCU_WRITE_ENABLE != dwValue) && (i<10));
+
+	//Clear SCU Reset Register
+	WriteMemoryLongClient(SCU_BASE, SCU_CONTROL_REG, 0);
+
+	WriteMemoryLongWithMASKClient(SCU_BASE, SCU_CLOCK_STOP_REG, (EN_ECLK | EN_V1CLK | EN_D1CLK | EN_D2CLK | EN_V2CLK), 
+								  (STOP_ECLK_MASK | STOP_D1CLK_MASK | STOP_D2CLK_MASK | STOP_V1CLK_MASK | STOP_V2CLK_MASK));
+
+	//WriteMemoryLongWithMASKClient(SCU_BASE, SCU_CLOCK_SELECTION_REG, PORTB_FROM_D2CLK | PORTB_CLOCK_INV_DELAY_3NS | PORTA_CLOCK_INV_DELAY_3NS, PORTB_CLOCK_SEL | PORTB_CLOCK_DELAY_MASK | PORTA_CLOCK_DELAY_MASK);
+	//A1EVA
+	WriteMemoryLongWithMASKClient(SCU_BASE, SCU_CLOCK_SELECTION_REG, (PORTB_FROM_D2CLK | PORTB_CLOCK_INV_DELAY_1NS | PORTA_CLOCK_INV_DELAY_1NS), (PORTB_CLOCK_SEL | PORTB_CLOCK_DELAY_MASK | PORTA_CLOCK_DELAY_MASK));
+	WriteMemoryLongWithMASKClient(SCU_BASE, 0x202C, (0x03<<9), (0x03<<9));
+
+	WriteMemoryLongWithMASKClient(SCU_BASE, SCU_PIN_CTRL1_REG, (VIDEO_PORTA_EN | VIDEO_PORTB_EN | VIDEO_VP1_EN | VIDEO_VP2_EN), 
+								  (VIDEO_PORTA_MASK | VIDEO_PORTB_MASK | VIDEO_VP1_MASK | VIDEO_VP2_MASK));
+
+#if CONFIG_AST3000
+	WriteMemoryLongWithMASKClient(SCU_BASE, SCU_PIN_CTRL2_REG, (VIDEO_PORTA_DUAL_EDGE | VIDEO_PORTB_DUAL_EDGE), 
+								  (VIDEO_PORTA_SINGLE_EDGE_MASK | VIDEO_PORTB_SINGLE_EDGE_MASK));
+#else
+	//2100 is single edge
+	WriteMemoryLongWithMASKClient(SCU_BASE, SCU_PIN_CTRL2_REG, (VIDEO_PORTA_SINGLE_EDGE | VIDEO_PORTB_SINGLE_EDGE), 
+								  (VIDEO_PORTA_SINGLE_EDGE_MASK | VIDEO_PORTB_SINGLE_EDGE_MASK));
+#endif
+
+	WriteMemoryLongWithMASKClient(SCU_BASE, SCU_CLOCK_STOP_REG, (EN_D1CLK | EN_D2CLK), (STOP_D1CLK_MASK | STOP_D2CLK_MASK));
+	WriteMemoryLongWithMASKClient(SCU_BASE, SCU_PIN_CTRL1_REG, VGA_PIN_OFF, VGA_PIN_MASK);
+
+    //ResetVideoHost();
+
+	return TRUE;
+}
+
+ULONG  InitializeVideoEngineHost (ULONG                MMIOBase,
+                               int                  nVideo,
+							   BOOL					HorPolarity,
+							   BOOL					VerPolarity)
+{
+    //ULONG   temp, temp1, temp2; 
+    ULONG   dwRegOffset = nVideo * 0x100;
+    ULONG   dwValue;
+    int     i;
+
+
+    /* General Video Control */
+    //LineBufEn 0
+    //dwValue = (COMPRESS_MODE << CODEC_DECOMPRESS_MODE_BIT) | DELAY_VSYNC_EN;
+    dwValue = 0;
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO_CONTROL_REG, dwValue);
+    //Video Data Truncation Register
+	WriteMemoryLongHost(VIDEO_REG_BASE, 0x328, 0);
+
+	//D2CLK clock must config according to video's line buffer
+	if (VIDEO1 == nVideo)
+	    dwValue = LINE_BUFFER_VIDEO1;
+    else
+        dwValue = LINE_BUFFER_VIDEO2;
+    
+	//D2CLK clock must config according to video's line buffer
+	switch (dwValue)
+	{
+	case LINE_BUFFER_OFF:
+		WriteMemoryLongWithMASKHost(SCU_BASE, SCU_CLOCK_SELECTION_REG, NORMAL_CRT1, D2CLK_CLOCK_SELECTION_MASK);
+		WriteMemoryLongWithMASKHost(SCU_BASE, SCU_CLOCK_STOP_REG, STOP_D2CLK, STOP_D2CLK_MASK);
+		break;
+	case LINE_BUFFER_VIDEO1:
+		WriteMemoryLongWithMASKHost(SCU_BASE, SCU_CLOCK_SELECTION_REG, V1CLK_VIDEO1 << D2CLK_CLOCK_SELECTION_BIT, D2CLK_CLOCK_SELECTION_MASK);
+		WriteMemoryLongWithMASKHost(SCU_BASE, SCU_CLOCK_STOP_REG, EN_D2CLK, STOP_D2CLK_MASK);
+		break;
+	case LINE_BUFFER_VIDEO2:
+		WriteMemoryLongWithMASKHost(SCU_BASE, SCU_CLOCK_SELECTION_REG, V1CLK_VIDEO2 << D2CLK_CLOCK_SELECTION_BIT, D2CLK_CLOCK_SELECTION_MASK);
+		WriteMemoryLongWithMASKHost(SCU_BASE, SCU_CLOCK_STOP_REG, EN_D2CLK, STOP_D2CLK_MASK);
+		break;
+	case LINE_BUFFER_VIDEOM:
+		//If select this option, it will config at videoM INIT
+		break;
+	default:
+		break;
+	}
+
+    dwValue = 0;
+    //VR30 now is capture window in the compression
+    dwValue = g_DefHeight << CAPTURE_VER_LINE_BIT |
+    g_DefWidth << CAPTURE_HOR_PIXEL_BIT;
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_CAPTURE_WINDOWS_REG + dwRegOffset, dwValue);        
+
+    dwValue = 0;
+    //VR34 now is destionation window in the compression
+	dwValue = g_DefHeight << COMPRESS_VER_LINE_BIT |
+	g_DefWidth << COMPRESS_HOR_PIXEL_BIT;
+
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_COMPRESS_WINDOWS_REG + dwRegOffset, dwValue);        
+
+    //BitCOUNT according compress data format
+    dwValue = YUV444_MODE;
+	if (YUV444_MODE == dwValue)
+		WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_BUF_LINE_OFFSET_REG + dwRegOffset, g_DefWidth * INPUT_BITCOUNT_YUV444, BUF_LINE_OFFSET_MASK);
+	else
+		WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_BUF_LINE_OFFSET_REG + dwRegOffset, g_DefWidth * INPUT_BITCOUNT_YUV420, BUF_LINE_OFFSET_MASK);
+              
+    //  CRC
+    //Disable
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO_CRC_PRIMARY_REG, 0x0);    
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO_CRC_SECOND_REG, 0x0);
+    
+    /* Sequence Control register */
+	//Oonly Encoder need to set
+	/* Engine Sequence Contol Register */
+	dwValue = (WATCH_DOG_EN << WATCH_DOG_ENABLE_BIT) |
+	            VIDEO_CAPTURE_AUTO_MODE |
+	            VIDEO_CODEC_AUTO_MODE;
+    
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_ENGINE_SEQUENCE_CONTROL_REG + dwRegOffset, dwValue);
+    
+    /* Control register */
+	dwValue = (HOR_NEGATIVE == HorPolarity) ? NO_INVERSE_POL : INVERSE_POL;
+	dwValue = (((VER_NEGATIVE == VerPolarity) ? NO_INVERSE_POL : INVERSE_POL) << VIDEO_VSYNC_POLARITY_BIT) | dwValue;
+    
+	/* HW Recommand*/
+	//dwValue = (TILE_MODE << 9) | dwValue;
+	dwValue = (EXTERNAL_VGA_SOURCE << EXTERNAL_SOURCE_BIT) | dwValue;
+    
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_CONTROL_REG + dwRegOffset, dwValue);
+        
+    /* BCD register */
+    //NO BCD
+    dwValue = 0;
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_BCD_CONTROL_REG + dwRegOffset, dwValue);
+
+    /* Stream Buffer Size register */
+    dwValue = (YUV_TEST << SKIP_TEST_MODE_BIT) |
+                (PACKET_SIZE_32KB << STREAM_PACKET_SIZE_BIT) |
+                (PACKETS_8 << RING_BUF_PACKET_NUM_BIT);
+    /* the same with Video1, Video2, and VideoM*/
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_STREAM_BUF_SIZE, dwValue);
+
+    /* Comression control register */
+    dwValue = (USE_UV_CIR656 << UV_CIR656_FORMAT_BIT)|
+                (JPEG_MIX_MODE << JPEG_ONLY_BIT)|
+                (VQ_4_COLOR_MODE << VQ_4_COLOR_BIT)|
+                (QUANTI_CODEC_MODE << QUALITY_CODEC_SETTING_BIT)|
+                (7 << NORMAL_QUANTI_CHROMI_TABLE_BIT) |
+                (23 << NORMAL_QUANTI_LUMI_TABLE_BIT);
+   
+    //Video2 have same value as video1
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_COMPRESS_CONTROL_REG, dwValue);
+
+    /* JPEG Quantization Table register */
+    dwValue = 0;
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_QUANTI_TABLE_LOW_REG, dwValue);
+    
+    /* Quantization value register */
+    //Video2 have same value as video1
+    dwValue = 0;
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_QUANTI_VALUE_REG, dwValue);
+
+    //Video BSD Parameter Register
+    //Video2 have same value as video1
+    dwValue = 0;
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_BSD_PARA_REG, dwValue);
+
+    //no scale
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_SCALE_FACTOR_REG,  0x10001000);
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_SCALE_FACTOR_PARAMETER0_REG, 0x00200000);
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_SCALE_FACTOR_PARAMETER1_REG, 0x00200000);
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_SCALE_FACTOR_PARAMETER2_REG, 0x00200000);
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_SCALE_FACTOR_PARAMETER3_REG, 0x00200000);
+    return TRUE;
+}
+
+ULONG  InitializeVideoEngineClient (ULONG                MMIOBase,
+                               int                  nVideo)
+{
+    //ULONG   temp, temp1, temp2; 
+    ULONG   dwRegOffset = nVideo * 0x100;
+    ULONG   dwValue;
+    int     i;
+
+
+    /* General Video Control */
+    //LineBufEn 0
+    dwValue = (DECOMPRESS_MODE << CODEC_DECOMPRESS_MODE_BIT);
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO_CONTROL_REG, dwValue);
+    //Video Data Truncation Register
+	WriteMemoryLongHost(VIDEO_REG_BASE, 0x328, 0);
+
+    //VR30 now is capture window in the compression
+    dwValue = g_DefHeight << CAPTURE_VER_LINE_BIT |
+    g_DefWidth << CAPTURE_HOR_PIXEL_BIT;
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_CAPTURE_WINDOWS_REG + dwRegOffset, dwValue, CAPTURE_VER_LINE_MASK | CAPTURE_HOR_PIXEL_MASK);        
+
+    //VR34 now is destionation window in the compression
+	dwValue = g_DefHeight << COMPRESS_VER_LINE_BIT |
+	g_DefWidth << COMPRESS_HOR_PIXEL_BIT;
+
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_COMPRESS_WINDOWS_REG + dwRegOffset, dwValue, COMPRESS_VER_LINE_MASK | COMPRESS_HOR_PIXEL_MASK);        
+
+    //BitCOUNT according compress data format
+    dwValue = YUV444_MODE;
+	if (YUV444_MODE == dwValue)
+		WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_BUF_LINE_OFFSET_REG + dwRegOffset, g_DefWidth * INPUT_BITCOUNT_YUV444, BUF_LINE_OFFSET_MASK);
+	else
+		WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_BUF_LINE_OFFSET_REG + dwRegOffset, g_DefWidth * INPUT_BITCOUNT_YUV420, BUF_LINE_OFFSET_MASK);
+              
+    //  CRC
+    //Disable
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO_CRC_PRIMARY_REG, 0x0);    
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO_CRC_SECOND_REG, 0x0);
+    
+    /* Sequence Control register */
+	//Oonly Encoder need to set
+	/* Engine Sequence Contol Register */
+    dwValue = VIDEO_CAPTURE_AUTO_MODE |
+        VIDEO_CODEC_AUTO_MODE;
+    
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_ENGINE_SEQUENCE_CONTROL_REG + dwRegOffset, dwValue);
+    
+    /* Control register */
+	/* HW Recommand*/
+	dwValue = (TILE_MODE << 9); 	
+    
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_CONTROL_REG + dwRegOffset, dwValue);
+        
+    /* BCD register */
+    //NO BCD
+    dwValue = 0;
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_BCD_CONTROL_REG + dwRegOffset, dwValue);
+
+    /* Stream Buffer Size register */
+    dwValue = (YUV_TEST << SKIP_TEST_MODE_BIT) |
+                (PACKET_SIZE_32KB << STREAM_PACKET_SIZE_BIT) |
+                (PACKETS_8 << RING_BUF_PACKET_NUM_BIT);
+    /* the same with Video1, Video2, and VideoM*/
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_STREAM_BUF_SIZE, dwValue);
+        
+
+    /* Comression control register */
+    dwValue = (USE_UV_CIR656 << UV_CIR656_FORMAT_BIT)|
+                (JPEG_MIX_MODE << JPEG_ONLY_BIT)|
+                (VQ_4_COLOR_MODE << VQ_4_COLOR_BIT)|
+                (QUANTI_CODEC_MODE << QUALITY_CODEC_SETTING_BIT)|
+                (7 << NORMAL_QUANTI_CHROMI_TABLE_BIT) |
+                (23 << NORMAL_QUANTI_LUMI_TABLE_BIT);
+   
+    //Video2 have same value as video1
+    if (VIDEO1 == nVideo)
+    {
+        WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_COMPRESS_CONTROL_REG, dwValue);
+    }
+    else
+    {
+        WriteMemoryLongHost(VIDEO_REG_BASE, VIDEOM_COMPRESS_CONTROL_REG, dwValue);
+    }
+
+    /* JPEG Quantization Table register */
+    dwValue = 0;
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_QUANTI_TABLE_LOW_REG, dwValue);
+    
+    /* Quantization value register */
+    //Video2 have same value as video1
+    dwValue = 0;
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_QUANTI_VALUE_REG, dwValue);
+
+    //Video BSD Parameter Register
+    //Video2 have same value as video1
+    dwValue = 0;
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_BSD_PARA_REG, dwValue);
+
+    return TRUE;
+}
+
+BYTE  GetI2CRegClient(ULONG  MMIOBase, 
+				 BYTE DeviceSelect, 
+				 BYTE DeviceAddress, 
+				 BYTE RegisterIndex)
+{
+    BYTE    Data;
+    ULONG   Status;
+
+//  Reset
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x00, 0);
+//  Set AC Timing and Speed
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x04, AC_TIMING);
+//  Lower Speed
+//    WriteMemoryLongWithANDData (VideoEngineInfo->VGAPCIInfo.ulMMIOBaseAddress, I2C_BASE + DeviceSelect * 0x40 + 0x04, 0, 0x33317805);
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x08, 0);
+//  Clear Interrupt
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x10, 0xFFFFFFFF);
+//  Enable Master Mode
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x00, 1);
+//  Enable Interrupt
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x0C, 0xAF);
+//  BYTE I2C Mode
+//  Start and Send Device Address
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x20, DeviceAddress);
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x14, 0x3);
+//  Wait TX ACK
+    do {
+        Status = ReadMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x10) & 0x03;
+    } while (Status != 1);
+//  Clear Interrupt
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x10, 0xFFFFFFFF);
+//  Send Device Register Index
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x20, RegisterIndex);
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x14, 0x2);
+//  Wait Tx ACK
+    do {
+        Status = ReadMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x10) & 0x03;
+    } while (Status != 1);
+//  Clear Interrupt
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x10, 0xFFFFFFFF);
+//  Start, Send Device Address + 1(Read Mode), Receive Data
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x20, DeviceAddress + 1);
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x14, 0x1B);
+//  Wait Rx Done
+    do {
+        Status = (ReadMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x10) & 0x04) >> 2;
+    } while (Status != 1);
+//  Clear Interrupt
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x10, 0xFFFFFFFF);
+
+//  Enable STOP Interrupt
+    WriteMemoryLongWithMASKClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x0C, 0x10, 0x10);
+//  Issue STOP Command
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x14, 0x20);
+//  Wait STOP
+    do {
+        Status = (ReadMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x10) & 0x10) >> 4;
+    } while (Status != 1);
+//  Disable STOP Interrupt
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x0C, 0x10);
+//  Clear Interrupt
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x10, 0xFFFFFFFF);
+//  Read Received Data
+    Data = (BYTE)((ReadMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x20) & 0xFF00) >> 8);
+
+    return    Data;
+}
+
+ULONG  SetI2CRegClient(ULONG  MMIOBase, 
+                 BYTE   DeviceSelect, 
+                 BYTE   DeviceAddress, 
+                 BYTE   RegisterIndex, 
+                 BYTE   RegisterValue)
+{
+    ULONG   Status; 
+	ULONG   Count = 0;
+
+//  Reset
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x00, 0);
+//  Set Speed
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x04, AC_TIMING);
+//  Lower Speed
+//    WriteMemoryLongWithANDData (VideoEngineInfo->VGAPCIInfo.ulMMIOBaseAddress, I2C_BASE + DeviceSelect * 0x40 + 0x04, 0, 0x33317805);
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x08, 0);
+//  Clear Interrupt
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x10, 0xFFFFFFFF);
+//  Enable Master Mode
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x00, 1);
+//  Enable Interrupt
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x0C, 0xAF);
+//  BYTE I2C Mode
+//  Start and Send Device Address
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x20, DeviceAddress);
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x14, 0x3);
+//  Wait Tx ACK
+    do {
+        Count++;
+        Status = ReadMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x10) & 0x03;
+
+		if (2 == Status)
+		{
+			//Clear Interrupt
+			WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x10, 0xFFFFFFFF);
+			//Re-Send Start and Send Device Address while NACK return
+			WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x20, DeviceAddress);
+			WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x14, 0x3);
+		}
+		//else
+		{
+			if (Count > LOOP_COUNT) {
+				return CAN_NOT_FIND_DEVICE;
+			}
+		}
+    } while (Status != 1);
+    Count = 0;
+//  Clear Interrupt
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x10, 0xFFFFFFFF);
+//  Send Device Register Index
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x20, RegisterIndex);
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x14, 0x2);
+//  Wait Tx ACK
+    do {
+        Count++;
+        Status = ReadMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x10) & 0x03;
+        if (Count > LOOP_COUNT) {
+            return CAN_NOT_FIND_DEVICE;
+        }
+    } while (Status != 1);
+    Count = 0;
+//  Clear Interrupt
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x10, 0xFFFFFFFF);
+//  Send Device Register Value and Stop
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x20, RegisterValue);
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x14, 0x2);
+//  Wait Tx ACK
+    do {
+        Count++;
+        Status = ReadMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x10) & 0x03;
+        if (Count > LOOP_COUNT) {
+            return CAN_NOT_FIND_DEVICE;
+        }
+    } while (Status != 1);
+    Count = 0;
+//  Clear Interrupt
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x10, 0xFFFFFFFF);
+//  Enable STOP Interrupt
+    WriteMemoryLongWithMASKClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x0C, 0x10, 0x10);
+//  Issue STOP Command
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x14, 0x20);
+//  Wait STOP
+    do {
+        Count++;
+        Status = (ReadMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x10) & 0x10) >> 4;
+        if (Count > LOOP_COUNT) {
+            return CAN_NOT_FIND_DEVICE;
+        }
+    } while (Status != 1);
+//  Disable STOP Interrupt
+    WriteMemoryLongWithMASKClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x0C, 0, 0x10);
+//  Clear Interrupt
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x10, 0xFFFFFFFF);
+
+    return SET_I2C_DONE;
+}
diff --git a/board/aspeed/ast2300/vfun.h b/board/aspeed/ast2300/vfun.h
new file mode 100755
index 0000000..90f9ec4
--- /dev/null
+++ b/board/aspeed/ast2300/vfun.h
@@ -0,0 +1,79 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef _VFUN_H_
+#define _VFUN_H_
+
+//#define vBufAlign(x)		    ((x + 0x0000007F) & 0xFFFFFF80) //128 byte alignment
+#define vBufAlign(x)		    ((x + 0x000003FF) & 0xFFFFFC00) //128 byte alignment
+#define vBufAlign2(x)		    ((x + 0x0000FFFF) & 0xFFFF0000) //128 byte alignment
+#define v16byteAlign(x)		    ((x + 0x0000000F) & 0xFFFFFFF0)
+#define vBuf_ALIGNMENT			128
+
+#define HOST_TOTAL_SIZE         0x8000000   /* 128M */
+#define STATION_TOTAL_SIZE      0xF800000   /* 120M */
+
+#define VIDEO_SOURCE_SIZE       0x200000    /* 800X600X4 = 0x1D4C00 */
+#define VIDEO_MAX_STREAM_SIZE   0x400000    /* 32X128K = 0x400000 */
+#define VIDEO_FLAG_SIZE         0x5000      /* 1920X1200/128 = 0x4650*/ 
+#define VIDEO_CRC_SIZE          0x50000     /* 1920/64X1200X8 = 0x46500*/
+
+#define VIDEO1_EN_TOTAL_SIZE    (VIDEO_SOURCE_SIZE*2+VIDEO_MAX_STREAM_SIZE+VIDEO_FLAG_SIZE+VIDEO_CRC_SIZE) /* 0x1655000 =  about 23M*/
+#define VIDEO2_EN_TOTAL_SIZE    VIDEO1_EN_TOTAL_SIZE
+//#define VIDEOM_EN_TOTAL_SIZE    (VIDEO_SOURCE_SIZE*2+VIDEO_MAX_STREAM_SIZE+VIDEO_FLAG_SIZE) /* 0x1605000 = about 22.7M */
+//#define VIDEO_HOST_SIZE         (VIDEO1_EN_TOTAL_SIZE + VIDEO2_EN_TOTAL_SIZE + VIDEOM_EN_TOTAL_SIZE) /* 0x69922816 = about 70M */
+#define VIDEO_HOST_SIZE         (VIDEO1_EN_TOTAL_SIZE + VIDEO2_EN_TOTAL_SIZE) /* NOT NEED VIDEOM */
+
+#define VIDEO1_EN_BASE          0x100000
+#define VIDEO2_EN_BASE          (VIDEO1_EN_BASE + VIDEO1_EN_TOTAL_SIZE)
+#define VIDEOM_EN_BASE          (VIDEO2_EN_BASE + VIDEO2_EN_TOTAL_SIZE)
+
+#define VIDEO1_DE_TOTAL_SIZE    (VIDEO_MAX_STREAM_SIZE + VIDEO_SOURCE_SIZE) /* 0xD00000 = 13M*/
+#define VIDEO2_DE_TOTAL_SIZE    (VIDEO1_DE_TOTAL_SIZE)
+#define VIDEO_STATION_SIZE      (VIDEO1_DE_TOTAL_SIZE + VIDEO2_DE_TOTAL_SIZE) /* 26M */
+
+#define VIDEO1_DE_BASE          VIDEO_HOST_SIZE
+#define VIDEO2_DE_BASE          (VIDEO1_DE_BASE + VIDEO1_DE_TOTAL_SIZE)
+#define VIDEO_ALL_SIZE          (VIDEO_HOST_SIZE + VIDEO_STATION_SIZE) //Host and Station
+
+#define OutdwmBankModeHost(offset,data)         WriteMemoryLongHost(DRAM_BASE,offset,data)
+#define IndwmBankModeHost(offset)               ReadMemoryLongHost(DRAM_BASE,offset)      
+
+ULONG UnlockVideoRegHost(ULONG   MMIOBase, ULONG Key);
+BOOL CheckOnStartHost(void);
+BOOL CheckOnStartClient(void);
+void StartVideoCaptureTriggerHost(ULONG   MMIOBase, ULONG offset);
+void StartVideoCaptureTriggerHost(ULONG   MMIOBase, ULONG offset);
+void StartVideoCodecTriggerHost(ULONG   MMIOBase, ULONG offset);
+ULONG UnlockSCURegHost(ULONG   MMIOBase, ULONG Key);
+ULONG UnlockSCURegHost(ULONG   MMIOBase, ULONG Key);
+void StartModeDetectionTriggerHost(ULONG   MMIOBase, ULONG offset);
+void ClearVideoInterruptHost(ULONG   MMIOBase, ULONG value);
+BOOL ReadVideoInterruptHost(ULONG   MMIOBase, ULONG value);
+void StopModeDetectionTriggerHost(ULONG   MMIOBase, ULONG offset);
+void ResetVideoHost(void);
+ULONG  InitializeVideoEngineHost (ULONG                MMIOBase,
+                               int                  nVideo,
+							   BOOL					HorPolarity,
+				  BOOL					VerPolarity);
+ULONG  InitializeVideoEngineClient (ULONG                MMIOBase,
+				    int                  nVideo);
+BYTE  GetI2CRegClient(ULONG  MMIOBase, 
+				 BYTE DeviceSelect, 
+				 BYTE DeviceAddress, 
+				 BYTE RegisterIndex);
+
+ULONG  SetI2CRegClient(ULONG  MMIOBase, 
+                 BYTE   DeviceSelect, 
+                 BYTE   DeviceAddress, 
+                 BYTE   RegisterIndex, 
+				 BYTE   RegisterValue);
+#endif //_VFUN_H_
+
diff --git a/board/aspeed/ast2300/vgahw.h b/board/aspeed/ast2300/vgahw.h
new file mode 100755
index 0000000..7cbba0d
--- /dev/null
+++ b/board/aspeed/ast2300/vgahw.h
@@ -0,0 +1,175 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/******************************************************************************
+ * Mode Stuff
+ ******************************************************************************/
+/* Default Settings */
+#define CRT_LOW_THRESHOLD_VALUE         0x12
+#define CRT_HIGH_THRESHOLD_VALUE        0x1E
+
+/* Output Selection */
+#define CRT1				0x00
+#define CRT2				0x01
+#define DVI1				0x10
+#define DVI2				0x11
+#define LVDS1				0x20
+#define LVDS2				0x21
+
+/* Mode Limitation */
+#define MAX_HResolution		1600
+#define MAX_VResolution		1200
+ 
+/* Std. Table Index Definition */
+#define TextModeIndex 		0
+#define EGAModeIndex 		1
+#define VGAModeIndex 		2
+#define HiCModeIndex 		3
+#define TrueCModeIndex 		4
+
+/* DCLK Index */
+#define VCLK25_175     		0x00
+#define VCLK28_322     		0x01
+#define VCLK31_5       		0x02
+#define VCLK36         		0x03
+#define VCLK40         		0x04
+#define VCLK49_5       		0x05
+#define VCLK50         		0x06
+#define VCLK56_25      		0x07
+#define VCLK65		 	0x08
+#define VCLK75	        	0x09
+#define VCLK78_75      		0x0A
+#define VCLK94_5       		0x0B
+#define VCLK108        		0x0C
+#define VCLK135        		0x0D
+#define VCLK157_5      		0x0E
+#define VCLK162        		0x0F
+#define VCLK119        		0x10
+
+/* Flags Definition */
+#define Charx8Dot               0x00000001
+#define HalfDCLK                0x00000002
+#define DoubleScanMode          0x00000004
+#define LineCompareOff          0x00000008
+#define SyncPP                  0x00000000
+#define SyncPN                  0x00000040
+#define SyncNP                  0x00000080
+#define SyncNN                  0x000000C0
+#define HBorder                 0x00000020
+#define VBorder                 0x00000010
+#define COLORINDEX		0x00000000
+#define MONOINDEX		0x00000100
+
+/* DAC Definition */
+#define DAC_NUM_TEXT		64
+#define DAC_NUM_EGA		64
+#define DAC_NUM_VGA		256
+
+/* AST3000 Reg. Definition */
+#define	AST3000_VGAREG_BASE	0x1e6e6000
+#define AST3000_VGA1_CTLREG	0x00
+#define AST3000_VGA1_CTLREG2	0x04
+#define AST3000_VGA1_STATUSREG	0x08 
+#define AST3000_VGA1_PLL	0x0C
+#define AST3000_VGA1_HTREG	0x10
+#define AST3000_VGA1_HRREG	0x14
+#define AST3000_VGA1_VTREG	0x18
+#define AST3000_VGA1_VRREG	0x1C
+#define AST3000_VGA1_STARTADDR	0x20
+#define AST3000_VGA1_OFFSETREG	0x24
+#define AST3000_VGA1_THRESHOLD	0x28
+#define AST3000_HWC1_OFFSET     0x30
+#define AST3000_HWC1_XY		0x34
+#define AST3000_HWC1_PBase      0x38
+#define AST3000_OSD1_H          0x40
+#define AST3000_OSD1_V          0x44
+#define AST3000_OSD1_PBase      0x48
+#define AST3000_OSD1_Offset     0x4C
+#define AST3000_OSD1_THRESHOLD  0x50
+
+#define AST3000_VGA2_CTLREG	0x60
+#define AST3000_VGA2_CTLREG2	0x64
+#define AST3000_VGA2_STATUSREG	0x68 
+#define AST3000_VGA2_PLL	0x6C
+#define AST3000_VGA2_HTREG	0x70
+#define AST3000_VGA2_HRREG	0x74
+#define AST3000_VGA2_VTREG	0x78
+#define AST3000_VGA2_VRREG	0x7C
+#define AST3000_VGA2_STARTADDR	0x80
+#define AST3000_VGA2_OFFSETREG	0x84
+#define AST3000_VGA2_THRESHOLD	0x88
+#define AST3000_HWC2_OFFSET     0x90
+#define AST3000_HWC2_XY		0x94
+#define AST3000_HWC2_PBase      0x98
+#define AST3000_OSD2_H          0xA0
+#define AST3000_OSD2_V          0xA4
+#define AST3000_OSD2_PBase      0xA8
+#define AST3000_OSD2_Offset     0xAC
+#define AST3000_OSD2_THRESHOLD  0xB0
+
+/* Data Structure */
+typedef struct {
+    UCHAR ModeName[20];
+    USHORT usModeIndex;
+    USHORT usModeID;
+    USHORT usColorIndex;
+    USHORT usRefreshRateIndex;
+    USHORT usWidth;
+    USHORT usHeight;
+    USHORT usBitsPerPlane;
+    USHORT usRefreshRate;    
+} ModeInfoStruct;
+
+typedef struct {
+	
+    UCHAR MISC;	
+    UCHAR SEQ[4];
+    UCHAR CRTC[25];
+    UCHAR AR[20];	    
+    UCHAR GR[9];
+    
+} VBIOS_STDTABLE_STRUCT, *PVBIOS_STDTABLE_STRUCT;
+
+typedef struct {
+	
+    ULONG HT;
+    ULONG HDE;
+    ULONG HFP;
+    ULONG HSYNC;
+    ULONG VT;
+    ULONG VDE;
+    ULONG VFP;
+    ULONG VSYNC;
+    ULONG DCLKIndex;        
+    ULONG Flags;
+
+    ULONG ulRefreshRate;
+    ULONG ulRefreshRateIndex;
+    ULONG ulModeID;
+        
+} VBIOS_ENHTABLE_STRUCT, *PVBIOS_ENHTABLE_STRUCT;
+
+typedef struct {
+    UCHAR Param1;
+    UCHAR Param2;
+    UCHAR Param3;	
+} VBIOS_DCLK_INFO, *PVBIOS_DCLK_INFO;
+
+typedef struct {
+    UCHAR DACR;
+    UCHAR DACG;
+    UCHAR DACB;	
+} VBIOS_DAC_INFO, *PVBIOS_DAC_INFO;
+
+typedef struct {
+    PVBIOS_STDTABLE_STRUCT pStdTableEntry;
+    PVBIOS_ENHTABLE_STRUCT pEnhTableEntry;
+    	
+} VBIOS_MODE_INFO, *PVBIOS_MODE_INFO;
diff --git a/board/aspeed/ast2300/vhace.c b/board/aspeed/ast2300/vhace.c
new file mode 100755
index 0000000..d045cbd
--- /dev/null
+++ b/board/aspeed/ast2300/vhace.c
@@ -0,0 +1,66 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#define HASH_GLOBALS
+#include "type.h"
+#include "vdef.h"
+#include "vhace.h"
+#include "vfun.h"
+
+void HashAst3000(ULONG ulLength, ULONG *output, ULONG ulHashMode)
+{
+	ULONG i, ulTemp, ulCommand, ulDigestLength;
+	ULONG ulValue;
+   
+	/* Get Info */
+	switch (ulHashMode)
+	{
+	case VHASHMODE_MD5:
+		ulCommand = VHASH_ALG_SELECT_MD5;
+		ulDigestLength = 16;
+		break;
+	case VHASHMODE_SHA1:
+		ulCommand = VHASH_ALG_SELECT_SHA1;
+		ulDigestLength = 20;
+		break;
+	case VHASHMODE_SHA256:
+		ulCommand = VHASH_ALG_SELECT_SHA256;
+		ulDigestLength = 32;
+		break;
+	case VHASHMODE_SHA224:
+		ulCommand = VHASH_ALG_SELECT_SHA224;
+		ulDigestLength = 28;
+		break;       	
+	}
+   	
+	/* Init. HW */
+	WriteMemoryLongHost(VHAC_REG_BASE, VREG_HASH_SRC_BASE_OFFSET, g_HashSrcBuffer);
+	WriteMemoryLongHost(VHAC_REG_BASE, VREG_HASH_DST_BASE_OFFSET, g_HashDstBuffer);
+	WriteMemoryLongHost(VHAC_REG_BASE, VREG_HASH_LEN_OFFSET, ulLength);
+        
+    /* write src */
+	//already fill in g_VIDEO1_COMPRESS_BUF_ADDR
+
+    /* fire cmd */
+	WriteMemoryLongHost(VHAC_REG_BASE, VREG_HASH_CMD_OFFSET, ulCommand);
+    
+    /* get digest */
+    do {
+    	ulTemp = ReadMemoryLongHost(VHAC_REG_BASE, VREG_HASH_STATUS_OFFSET);
+    } while (ulTemp & VHASH_BUSY);	
+    	
+    for (i=0; i<ulDigestLength/4; i++)
+    {
+                ulValue = *(((ULONG *)g_HashDstBuffer) + i); 
+
+		//output is ULONG pointer
+		*(output + i) = ulValue;    
+    }        
+}
diff --git a/board/aspeed/ast2300/vhace.h b/board/aspeed/ast2300/vhace.h
new file mode 100755
index 0000000..460989b
--- /dev/null
+++ b/board/aspeed/ast2300/vhace.h
@@ -0,0 +1,58 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef _VHACE_H_
+#define _VHACE_H_
+
+#define VHASHMODE_MD5			0x00
+#define VHASHMODE_SHA1			0x01
+#define VHASHMODE_SHA256			0x02
+#define VHASHMODE_SHA224			0x03
+
+#define VHASH_ALG_SELECT_MASK		0x70
+#define VHASH_ALG_SELECT_MD5			0x00
+#define VHASH_ALG_SELECT_SHA1		0x20
+#define VHASH_ALG_SELECT_SHA224		0x40
+#define VHASH_ALG_SELECT_SHA256		0x50
+
+#define VHASH_BUSY			0x01
+
+#define VHAC_REG_BASE 			0x1e6e0000
+#define	VHAC_REG_OFFSET			0x3000
+
+#define VREG_HASH_SRC_BASE_OFFSET	(0x20+VHAC_REG_OFFSET)
+#define VREG_HASH_DST_BASE_OFFSET	(0x24+VHAC_REG_OFFSET)
+#define VREG_HASH_KEY_BASE_OFFSET	(0x28+VHAC_REG_OFFSET)
+#define VREG_HASH_LEN_OFFSET			(0x2C+VHAC_REG_OFFSET)
+#define VREG_HASH_CMD_OFFSET			(0x30+VHAC_REG_OFFSET)
+
+#define VREG_HASH_STATUS_OFFSET		(0x1C+VHAC_REG_OFFSET)
+
+typedef struct
+{
+	int HashMode;
+	int DigestLen;
+} HASH_METHOD;
+
+
+#ifdef HASH_GLOBALS
+#define HASH_EXT
+#else
+#define HASH_EXT extern
+#endif
+
+HASH_EXT HASH_METHOD	g_HashMethod;
+HASH_EXT BYTE			g_DigestBuf[32];
+HASH_EXT ULONG			g_HashSrcBuffer;
+HASH_EXT ULONG			g_HashDstBuffer;
+
+void HashAst3000(ULONG ulLength, ULONG *output, ULONG ulHashMode);
+#endif
+
diff --git a/board/aspeed/ast2300/videotest.c b/board/aspeed/ast2300/videotest.c
new file mode 100755
index 0000000..f2e4953
--- /dev/null
+++ b/board/aspeed/ast2300/videotest.c
@@ -0,0 +1,779 @@
+/*
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Diagnostics support
+ */
+#include <common.h>
+#include <command.h>
+#include <malloc.h>
+#include <post.h>
+
+#include "slt.h"
+#define WIN_GLOBALS
+#include "type.h"
+#include "vreg.h"
+#define VESA_GLOBALS
+#include "vesa.h"
+#include "vfun.h"
+#include "vdef.h"
+#include "vhace.h"
+#include "crt.h"
+#include "videotest.h"
+
+#define VHASH_ALIGNMENT			16
+#define VHASH_MAX_DST			(32+VHASH_ALIGNMENT)
+
+
+#if ((CFG_CMD_SLT & CFG_CMD_VIDEOTEST) && defined(CONFIG_SLT))
+#include "videotest.h"
+
+#define RAND_MAX 32767 //2^16-1
+
+ULONG randSeed = 1;
+
+void srand(ULONG seed)
+{
+  randSeed = seed;
+}
+
+int rand(void)
+{
+  randSeed = randSeed * 214013 + 2531011;
+  return (int)(randSeed >> 17); //32 -15 = 17
+}
+
+//static unsigned char CaptureVideo1Buf1Addr[VIDEO_SOURCE_SIZE], CaptureVideo1Buf2Addr[VIDEO_SOURCE_SIZE], Video1CompressBufAddr[CRYPTO_MAX_CONTEXT];
+ULONG pCaptureVideo1Buf1Addr[VIDEO_SOURCE_SIZE/4], pCaptureVideo1Buf2Addr[VIDEO_SOURCE_SIZE/4], pVideo1CompressBufAddr[VIDEO_MAX_STREAM_SIZE/4], pVideo1FlagBufAddr[VIDEO_FLAG_SIZE];
+ULONG pCaptureVideo2Buf1Addr[VIDEO_SOURCE_SIZE/4], pCaptureVideo2Buf2Addr[VIDEO_SOURCE_SIZE/4], pVideo2CompressBufAddr[VIDEO_MAX_STREAM_SIZE/4], pVideo2FlagBufAddr[VIDEO_FLAG_SIZE];
+
+ULONG pVHashDstBuffer[VHASH_MAX_DST/4];
+
+ULONG pVideo1DecAddr[VIDEO_SOURCE_SIZE/4];
+ULONG pCrt1Addr[VIDEO_SOURCE_SIZE/4];
+//ULONG pCap1Addr[VIDEO_SOURCE_SIZE/4];
+
+BOOL AllocateEncodeBufHost(ULONG MMIOBase, int nVideo)
+{
+    //ULONG     Addr;
+    //ULONG     dwRegOffset = nVideo * 0x100;
+
+    if (VIDEO1 == nVideo)
+    {
+        
+        //Addr = (ULONG)malloc(pVideoInfo->SrcWidth * pVideoInfo->SrcHeight * 4);
+        //pCaptureVideo1Buf1Addr = malloc(VIDEO_SOURCE_SIZE);
+
+        g_CAPTURE_VIDEO1_BUF1_ADDR = vBufAlign((ULONG)pCaptureVideo1Buf1Addr);
+        WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_BUF_1_ADDR_REG, g_CAPTURE_VIDEO1_BUF1_ADDR, BUF_1_ADDR_MASK);
+        
+        //Addr = (ULONG)malloc(pVideoInfo->SrcWidth * pVideoInfo->SrcHeight * 4);
+        //pCaptureVideo1Buf2Addr = malloc(VIDEO_SOURCE_SIZE);
+
+        g_CAPTURE_VIDEO1_BUF2_ADDR = vBufAlign((ULONG)pCaptureVideo1Buf2Addr);
+        WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_BUF_2_ADDR_REG, g_CAPTURE_VIDEO1_BUF2_ADDR, BUF_2_ADDR_MASK);
+        
+        //Addr = (ULONG)malloc(pVideoInfo->uStreamBufSize.StreamBufSize.RingBufNum * pVideoInfo->uStreamBufSize.StreamBufSize.PacketSize)
+        //pVideo1CompressBufAddr = malloc(VIDEO_MAX_STREAM_SIZE);
+        g_VIDEO1_COMPRESS_BUF_ADDR = vBufAlign((ULONG)pVideo1CompressBufAddr);
+        WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_COMPRESS_BUF_ADDR_REG, g_VIDEO1_COMPRESS_BUF_ADDR, BUF_2_ADDR_MASK);
+        
+        //Addr = (ULONG)malloc((pVideoInfo->SrcHeigh/64) * pVideoInfo->SrcWidth * 8);
+        //g_VIDEO1_CRC_BUF_ADDR = vBufAlign((ULONG)malloc(VIDEO_MAX_STREAM_SIZE));
+        //WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_CRC_BUF_ADDR_REG, g_VIDEO1_CRC_BUF_ADDR, BUF_2_ADDR_MASK);
+        
+
+        //Addr = (ULONG)malloc(pVideoInfo->SrcHeigh * pVideoInfo->SrcWidth  / 128 (/64*4/8));
+        //pVideo1FlagBufAddr = malloc(VIDEO_FLAG_SIZE);
+        g_VIDEO1_FLAG_BUF_ADDR = vBufAlign((ULONG)pVideo1FlagBufAddr);
+        WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_FLAG_BUF_ADDR_REG, g_VIDEO1_FLAG_BUF_ADDR, BUF_2_ADDR_MASK);
+    }
+    else if (VIDEO2 == nVideo)
+    {
+        //Addr = (ULONG)malloc(pVideoInfo->SrcWidth * pVideoInfo->SrcHeight * 4);
+        //pCaptureVideo2Buf1Addr = malloc(VIDEO_SOURCE_SIZE);
+        g_CAPTURE_VIDEO2_BUF1_ADDR = vBufAlign((ULONG)pCaptureVideo2Buf1Addr);
+        WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO2_BUF_1_ADDR_REG, g_CAPTURE_VIDEO2_BUF1_ADDR, BUF_1_ADDR_MASK);
+        
+        //Addr = (ULONG)malloc(pVideoInfo->SrcWidth * pVideoInfo->SrcHeight * 4);
+        //pCaptureVideo2Buf2Addr = malloc(VIDEO_SOURCE_SIZE);
+        g_CAPTURE_VIDEO2_BUF2_ADDR = vBufAlign((ULONG)pCaptureVideo2Buf2Addr);
+        WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO2_BUF_2_ADDR_REG, g_CAPTURE_VIDEO2_BUF2_ADDR, BUF_2_ADDR_MASK);
+        
+        //Addr = (ULONG)malloc(pVideoInfo->uStreamBufSize.StreamBufSize.RingBufNum * pVideoInfo->uStreamBufSize.StreamBufSize.PacketSize)
+        //pVideo2CompressBufAddr = malloc(VIDEO_MAX_STREAM_SIZE);
+        g_VIDEO2_COMPRESS_BUF_ADDR = vBufAlign((ULONG)pVideo2CompressBufAddr);
+        WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO2_COMPRESS_BUF_ADDR_REG, g_VIDEO2_COMPRESS_BUF_ADDR, BUF_2_ADDR_MASK);
+        
+        //Addr = (ULONG)malloc((pVideoInfo->SrcHeigh/64) * pVideoInfo->SrcWidth * 8);
+        //g_VIDEO1_CRC_BUF_ADDR = vBufAlign((ULONG)malloc(VIDEO_MAX_STREAM_SIZE));
+        //WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_CRC_BUF_ADDR_REG, g_VIDEO1_CRC_BUF_ADDR, BUF_2_ADDR_MASK);
+        
+
+        //Addr = (ULONG)malloc(pVideoInfo->SrcHeigh * pVideoInfo->SrcWidth  / 128 (/64*4/8));
+        //pVideo2FlagBufAddr = malloc(VIDEO_FLAG_SIZE);
+        g_VIDEO2_FLAG_BUF_ADDR = vBufAlign((ULONG)pVideo2FlagBufAddr);
+        WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO2_FLAG_BUF_ADDR_REG, g_VIDEO2_FLAG_BUF_ADDR, BUF_2_ADDR_MASK);
+    }
+  
+}
+
+/********************************************************/
+/* 1. product random data to encode                     */
+/* 2. use hash to verify encode function                */
+/* 3. use encode stream to decompress original data     */
+/********************************************************/
+int CodecTest(void)
+{
+    int	  num, i=0, j=0;
+    ULONG ulTemp = 0, ulTemp2;
+    int   dwValue;
+    ULONG ulHWWp;
+    ULONG ulHWPt;
+
+    //max size
+    ULONG tArray[32/4];
+    
+    //mode detection
+    BOOL	bExternal = TRUE;
+    BOOL	bAnalog = TRUE;
+    ULONG	Status;	    
+
+#if defined(CONFIG_AST2300)
+    ULONG ulHashSha1[5]  = {0x3f0c2ad6,0xc8eb7074,0xa9929352,0xfcd5b8b0,0x76fa8461};
+    ULONG aHashDecode[5] = {0xb23b62bb,0xd22a602b,0x113038a0,0x7217c6ab,0xcb156f06};
+#else
+    ULONG ulHashSha1[5] = {0x2a19e99f,0x99b1bb2d,0x9ac82862,0x49205e43,0x6bc4b4d7};
+    ULONG aHashDecode[5] = {0x2907a827,0xaf337079,0x47817f1f,0xb0b7cd68,0x8d33bd2};
+#endif
+
+    //Load pattern to src1 & src2 buffer
+    srand(1);
+
+    //Total size : DefWidth*DeHeight*4
+    //rand function: 16 bits one time is equal to 2 bytes
+    //OutdwmBankMode: 32 bits one time is equal to 4 bytes
+    for (i=0; i<g_DefWidth*g_DefHeight*2; i++)
+    {
+	if (i%2)
+	{
+	    ulTemp2 = rand();
+	    ulTemp = (ulTemp2 << 16) | ulTemp;
+	    //WriteMemoryLongHost(DRAM_BASE, g_CAPTURE_VIDEO1_BUF1_ADDR + ((i-1)/2)*4, ulTemp);
+	    *(((ULONG *)g_CAPTURE_VIDEO1_BUF1_ADDR) + (i-1)/2) = ulTemp;
+	    ulTemp = 0;
+	}
+	else
+	{
+	    ulTemp = rand();
+	}
+    }
+
+    /* init encoder engine */
+    InitializeVideoEngineHost (0,
+			       VIDEO1,
+			       vModeTable[2].HorPolarity,
+			       vModeTable[2].VerPolarity);
+
+    /* reset offset pointer register*/    
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_ENGINE_SEQUENCE_CONTROL_REG, 0, VIDEO_CODEC_TRIGGER | VIDEO_CAPTURE_TRIGGER);
+
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_COMPRESS_BUF_READ_OFFSET_REG, 0, COMPRESS_BUF_READ_OFFSET_MASK);
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_BUF_CODEC_OFFSET_READ, 0, BUF_CODEC_OFFSET_MASK);
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_COMPRESS_BUF_PROCESS_OFFSET_REG, 0, COMPRESS_BUF_PROCESS_OFFSET_MASK);
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_COMPRESS_FRAME_END_READ, 0, COMPRESS_FRAME_END_READ_MASK);
+
+    /* start compress stream */
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_ENGINE_SEQUENCE_CONTROL_REG, MODE_DETECTION_TRIGGER, MODE_DETECTION_TRIGGER);
+    //Stream mode: set CODEC trigger first
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_ENGINE_SEQUENCE_CONTROL_REG, VIDEO_CODEC_TRIGGER, VIDEO_CODEC_TRIGGER);
+
+    //Stream mode: start trigger (only trigger capture bit)
+    StartVideoCaptureTriggerHost(0, VIDEO1_ENGINE_SEQUENCE_CONTROL_REG);
+
+    //stop engine
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_ENGINE_SEQUENCE_CONTROL_REG, 0, 0xFF);    
+#if defined(CONFIG_AST2300)
+    do {	/* wait compress engine idle */
+	ulTemp = ReadMemoryLongHost(VIDEO_REG_BASE, VIDEO1_ENGINE_SEQUENCE_CONTROL_REG);    	
+    } while (!(ulTemp & 0x40000));	
+#endif
+
+    //read 30 times to get HW write pointer
+    for (i=0; i<30000; i++)
+	ulHWWp = ReadMemoryLongHost(VIDEO_REG_BASE, VIDEO1_BUF_CODEC_OFFSET_READ);
+
+    g_HashSrcBuffer = g_VIDEO1_COMPRESS_BUF_ADDR + 128; //skip encode data 128 byte	
+    g_HashDstBuffer = v16byteAlign((unsigned long)pVHashDstBuffer);
+    ulTemp = 300;
+
+    //Enable hash clock
+    WriteMemoryLongWithMASKHost(SCU_BASE, SCU_CLOCK_STOP_REG, EN_HACE, STOP_HACE_MASK);
+    g_HashMethod.HashMode = VHASHMODE_SHA1;
+    g_HashMethod.DigestLen = 20;
+    HashAst3000(ulTemp, tArray, g_HashMethod.HashMode);
+
+    if (strncmp((const char *)tArray, (const char *)ulHashSha1, g_HashMethod.DigestLen))
+    {
+	printf("[VIDEO] Encoder Test: Wrong\n");
+        //ExitVideoTest();
+        return VIDEO_ENCODE_FAIL;
+    }
+    else
+    {    
+	printf("[VIDEO] Encoder Test: Pass\n");
+    }
+
+#if 0
+    /******** prepare for next decoding test at the same chip ***********/
+    ResetVideoHost();
+
+    dwValue=0;
+
+    do
+    {
+	dwValue = UnlockVideoRegHost(0, VIDEO_UNLOCK_KEY);
+	i++;
+    }
+    while ((VIDEO_UNLOCK != dwValue) && (i<10));
+
+    if (VIDEO_UNLOCK != dwValue)
+    {
+	printf("[VIDEO] Video register is locked");
+	return VIDEO_UNLOCK_FAIL;
+    }
+
+    // allocate decoding buffer
+    //Use Compress buffer last time, and Don't need to allocate
+    g_VIDEO1_DECODE_BUF_1_ADDR = g_VIDEO1_COMPRESS_BUF_ADDR;
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_BUF_1_ADDR_REG, g_VIDEO1_DECODE_BUF_1_ADDR, BUF_1_ADDR_MASK);
+    
+    //	pVideo1DecAddr = malloc(VIDEO_SOURCE_SIZE);
+    g_VIDEO1_DECOMPRESS_BUF_ADDR = vBufAlign((unsigned long)pVideo1DecAddr);    
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_COMPRESS_BUF_ADDR_REG, g_VIDEO1_DECOMPRESS_BUF_ADDR, COMPRESS_BUF_ADDR_MASK);
+    
+    //Addr = (ULONG)malloc(256);
+    //g_VIDEO1_RC4_BUF_ADDR = Addr;
+    //g_VIDEO1_DECODE_RC4_BUF_ADDR = g_VIDEO1_DECOMPRESS_BUF_ADDR + 0x800000; //assume video size is 8MB for umcompressed buf;
+    //WriteMemoryLongWithMASKClient(VIDEO_REG_BASE, VIDEO1_RC4_TABLE_ADDR, g_VIDEO1_DECODE_RC4_BUF_ADDR, RC4_TABLE_ADDR_MASK);
+
+    //HW recommanded value
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_BUF_2_ADDR_REG, g_VIDEO1_DECOMPRESS_BUF_ADDR, BUF_2_ADDR_MASK);
+    //WriteMemoryLongWithMASKClient(VIDEO_REG_BASE, VIDEO1_BUF_2_ADDR_REG, 0, BUF_2_ADDR_MASK);
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_CRC_BUF_ADDR_REG, 0, BUF_2_ADDR_MASK);            
+
+    /* init encoder engine */
+    InitializeVideoEngineClient (0, VIDEO1);
+
+    /* reset offset pointer register*/    
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_ENGINE_SEQUENCE_CONTROL_REG, 0, VIDEO_CODEC_TRIGGER | VIDEO_CAPTURE_TRIGGER);
+
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_COMPRESS_BUF_READ_OFFSET_REG, 0, COMPRESS_BUF_READ_OFFSET_MASK);
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_BUF_CODEC_OFFSET_READ, 0, BUF_CODEC_OFFSET_MASK);
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_COMPRESS_BUF_PROCESS_OFFSET_REG, 0, COMPRESS_BUF_PROCESS_OFFSET_MASK);
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_COMPRESS_FRAME_END_READ, 0, COMPRESS_FRAME_END_READ_MASK);
+
+    StartVideoCodecTriggerHost(0, VIDEO1_ENGINE_SEQUENCE_CONTROL_REG);
+
+    //wrtie SW write pointer
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_DECOMPRESS_BUF_PROCESS_OFFSET_REG, ulHWWp, COMPRESS_BUF_READ_OFFSET_MASK);
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_DECOMPRESS_BUF_WRITE_OFFSET_REG, ulHWWp, COMPRESS_BUF_READ_OFFSET_MASK);
+
+    i = 0;
+
+    do
+    {
+        ulHWPt = ReadMemoryLongHost(VIDEO_REG_BASE, VIDEO1_BUF_CODEC_OFFSET_READ);
+        i++;
+    }while((ulHWPt != ulHWWp) && (i<10000));
+
+    if (10000 > i)
+    {
+ 	printf("[VIDEO] Decoder Pointer cannot move!!! /n");
+        //ExitVideoTest();
+	return VIDEO_DECODE_FAIL;       
+    }
+        
+    //8*8 YUVA block
+    for (i=24; i<g_DefWidth*g_DefHeight; i=i+32)
+    {
+        *(((ULONG *)g_VIDEO1_DECOMPRESS_BUF_ADDR) + i) = 0x0;
+	*(((ULONG *)g_VIDEO1_DECOMPRESS_BUF_ADDR) + i+1) = 0x0;
+    }
+
+    g_HashSrcBuffer = g_VIDEO1_DECOMPRESS_BUF_ADDR;
+    //g_HashDstBuffer = VIDEO1_EN_BASE + VIDEO_ALL_SIZE; //config forward
+
+    ulTemp = 300;
+
+    //Enable hash clock
+    WriteMemoryLongWithMASKHost(SCU_BASE, SCU_CLOCK_STOP_REG, EN_HACE, STOP_HACE_MASK);
+    g_HashMethod.HashMode = VHASHMODE_SHA1;
+    g_HashMethod.DigestLen = 20;
+    HashAst3000(ulTemp, tArray, g_HashMethod.HashMode);
+
+    if (strncmp((const char *)tArray, (const char *)aHashDecode, g_HashMethod.DigestLen))
+    {
+	printf("[VIDEO] Decoder Test: Wrong\n");
+        //ExitVideoTest();
+        return VIDEO_DECODE_FAIL;
+    }
+    else
+    {
+	printf("[VIDEO] Decoder Test: Pass\n");
+    }
+#endif
+
+    return VIDEO_TEST_OK;
+}
+
+/********************************************************/
+/*  Only used in the host                               */
+/*  test function: Mode detection and Capture pattern   */
+/********************************************************/
+int CapTest(void)
+{
+    ULONG   dwValue, Status;
+    int     i;
+    BOOL    bAnalog;
+    ULONG	HStart, HEnd, VStart, VEnd;
+    USHORT	usCRTHor, usCRTVer;
+    ULONG   ulHor, ulVer;
+    ULONG   ulVGABaseAddr, ulCapAddr;
+    ULONG   ulFlag;
+    
+    printf("\n --------- Mode Detection Test --------- \n");
+    //clear clear register
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_CONTROL_REG, 0);
+    dwValue = ReadMemoryLongHost(VIDEO_REG_BASE, VIDEO1_CONTROL_REG);
+
+    //  Note: Current mode detection procedure has to set signal input 1st
+    //Note: Clear and enable interrupt Encode
+    ClearVideoInterruptHost(0, VIDEO1_MODE_DETECTION_READY_CLEAR);
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO_INT_CONTROL_EN_REG, VIDEO1_MODE_DETECTION_READY_INT_EN, VIDEO1_MODE_DETECTION_READY_INT_EN);
+    //  Set input signal
+    dwValue |= EXTERNAL_VGA_SOURCE;
+    
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_CONTROL_REG, (dwValue <<EXTERNAL_SOURCE_BIT), EXTERNAL_SOURCE_MASK);
+
+//  Set H/V stable maximum
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO_MODE_DETECTION_PARAM_REG, (MODEDETECTION_VERTICAL_STABLE_MAXIMUM << VER_STABLE_MAX_BIT), 0x000F0000);
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO_MODE_DETECTION_PARAM_REG, (MODEDETECTION_HORIZONTAL_STABLE_MAXIMUM << HOR_STABLE_MAX_BIT), HOR_STABLE_MAX_BIT_MASK);
+//  Set H/V stable threshold
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO_MODE_DETECTION_PARAM_REG, (MODEDETECTION_VERTICAL_STABLE_THRESHOLD << VER_STABLE_THRES_BIT), VER_STABLE_THRES_BIT_MASK);
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO_MODE_DETECTION_PARAM_REG, (MODEDETECTION_HORIZONTAL_STABLE_THRESHOLD << HOR_STABLE_THRES_BIT), HOR_STABLE_THRES_BIT_MASK);
+    
+    //Trigger mode detection
+    // turn off WATCH_DOG first
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_ENGINE_SEQUENCE_CONTROL_REG, (WATCH_DOG_OFF << WATCH_DOG_ENABLE_BIT), WATCH_DOG_EN_MASK);
+        
+    //  Note: Clear mode detection ready interrupt
+    //ClearVideoInterrupt(MMIOBase, MODE_DETECTION_READY_CLEAR);
+    StartModeDetectionTriggerHost(0, VIDEO1_ENGINE_SEQUENCE_CONTROL_REG);
+
+
+//  Note: Polling mode detection ready interrupt
+    //it sometime take a long time, especially during change mode, 
+    //so the loop count must be big, or you can't pull it by timer
+    i = 0;
+    do {
+
+		Status = ReadVideoInterruptHost(0, VIDEO1_MODE_DETECTION_READY_READ);
+		i++;
+    } while ((!Status) & (i<500000));
+
+    if (!Status)
+    {
+	printf("[VIDEO] Mode detection error\n");
+        //ExitVideoTest();
+	return VIDEO_TEST_FAIL;
+    }
+
+    HStart	= (ReadMemoryLongHost(VIDEO_REG_BASE, VIDE1_MODE_DETECTION_EDGE_H_REG) & LEFT_EDGE_LOCATION_MASK) >> LEFT_EDGE_LOCATION_BIT;
+    HEnd	= (ReadMemoryLongHost(VIDEO_REG_BASE, VIDE1_MODE_DETECTION_EDGE_H_REG) & RIGHT_EDGE_LOCATION_MASK) >> RIGHT_EDGE_LOCATION_BIT;
+
+    VStart	= (ReadMemoryLongHost(VIDEO_REG_BASE, VIDE1_MODE_DETECTION_EDGE_V_REG) & TOP_EDGE_LOCATION_MASK) >> TOP_EDGE_LOCATION_BIT;
+    VEnd	= (ReadMemoryLongHost(VIDEO_REG_BASE, VIDE1_MODE_DETECTION_EDGE_V_REG) & BOTTOM_EDGE_LOCATION_MASK) >> BOTTOM_EDGE_LOCATION_BIT;
+
+    ulHor = HEnd-HStart+1;
+    ulVer = VEnd-VStart+1;
+
+    printf("[VIDEO] Resolution: H[%d] * V[%d]\n", ulHor, ulVer);
+
+    if ((g_DefWidth == ulHor) & (g_DefHeight == ulVer))
+    {
+    	printf("[VIDEO] Mode detection PASS\n");
+    }
+    else
+    {
+	printf("[VIDEO] Mode detection FAIL\n");
+	return VIDEO_TEST_FAIL;
+    }
+
+    if(!((ReadMemoryLongHost(VIDEO_REG_BASE, VIDEO1_MODE_DETECTION_STATUS_READ_REG) & ANALONG_DIGITAL_READ) >> ANALONG_DIGITAL_READ_BIT))
+	bAnalog = FALSE;
+    else
+	bAnalog = TRUE;
+
+    //  Note: Clear mode detection ready interrupt
+    ClearVideoInterruptHost(0, VIDEO1_MODE_DETECTION_READY_CLEAR);
+
+    printf("\n --------- Capture Test --------- \n");
+
+    //capture engine
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_TIMEING_GEN_HOR_REG, (HEnd << VIDEO_HDE_END_BIT), VIDEO_HDE_END_MASK);
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_TIMEING_GEN_HOR_REG, (HStart << VIDEO_HDE_START_BIT), VIDEO_HDE_START_MASK);
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_TIMEING_GEN_V_REG, (VEnd << VIDEO_VDE_END_BIT), VIDEO_VDE_END_MASK);
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_TIMEING_GEN_V_REG, (VStart << VIDEO_VDE_START_BIT), VIDEO_VDE_START_MASK);
+	
+    ulCapAddr = vBufAlign2((ULONG)pCaptureVideo1Buf1Addr);    
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_BUF_1_ADDR_REG, ulCapAddr, BUF_1_ADDR_MASK);
+    
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_BUF_2_ADDR_REG, 0, BUF_2_ADDR_MASK);
+
+    InitializeVideoEngineHost (0,
+			       VIDEO1,
+		               vModeTable[2].HorPolarity,
+			       vModeTable[2].VerPolarity);
+
+    WriteMemoryLongHost(VIDEO_REG_BASE, 0x04, 0x01);
+    WriteMemoryLongHost(VIDEO_REG_BASE, 0x300, 0x0);
+#if defined(CONFIG_AST2300)
+	WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, 0x8, 0x0880, 0x0ec0);
+#elif defined(CONFIG_AST3000)
+	WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, 0x8, 0x2800, 0x2800);	
+#else
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, 0x8, 0xa00, 0x2a80); //tile mode
+#endif
+
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_TIMEING_GEN_HOR_REG, 0xa0000000, 0xa0000000);
+   
+    //only trigger capture, in source buffer (vr44), the front of data is correct.
+    //StartVideoCaptureTriggerHost(0, VIDEO1_ENGINE_SEQUENCE_CONTROL_REG);
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_ENGINE_SEQUENCE_CONTROL_REG, VIDEO_CAPTURE_TRIGGER);
+
+    i = 0;
+    do {
+        Status = ReadMemoryLongHost(VIDEO_REG_BASE, VIDEO1_ENGINE_SEQUENCE_CONTROL_REG) & CAPTURE_READY_MASK;
+	i++;
+    } while ((!Status) & (i<500000));
+
+    if (!Status)
+    {
+	printf("[VIDEO] Capture is not READY\n");
+	return VIDEO_TEST_FAIL;
+    }  
+
+#if !defined(CONFIG_AST2300)	
+    ulVGABaseAddr = ulCapAddr + 0x1000;
+
+    /* check pattern */
+    ulFlag = 0; //no 0 is error
+
+    for (i=0; i<100; i++)
+    {
+        dwValue = *(ULONG *)(ulVGABaseAddr + i*32);
+	if (0x32323232 != dwValue)
+	{
+	    printf("[VIDEO] Capture Test fail -- capture data doesn't match source \n");
+	    printf("[VIDEO]1 i=%d value=%x\n", i, dwValue);
+            ulFlag = 1;
+            break;
+	}
+
+	dwValue = *(ULONG *)(ulVGABaseAddr + i*32 + 4);
+	if (0x32323232 != dwValue)
+	{
+	    printf("[VIDEO] Capture Test fail -- capture data doesn't match source \n");
+	    printf("[VIDEO]2 i=%d value=%x\n", i, dwValue);
+	    ulFlag = 1;
+	    break;
+	}
+
+	dwValue = *(ULONG *)(ulVGABaseAddr + i*32 + 8);
+	if (0x80808080 != dwValue)
+	{
+	    printf("[VIDEO] Capture Test fail -- capture data doesn't match source \n");
+	    printf("[VIDEO]3 i=%d value=%x\n", i, dwValue);
+	    ulFlag = 1;
+	    break;
+	}
+
+	dwValue = *(ULONG *)(ulVGABaseAddr + i*32 + 12);
+	if (0x80808080 != dwValue)
+	{
+	    printf("[VIDEO] Capture Test fail -- capture data doesn't match source \n");
+	    printf("4 i=%d value=%x\n", i, dwValue);
+	    ulFlag = 1;
+	    break;
+	}
+
+	dwValue = *(ULONG *)(ulVGABaseAddr + i*32 + 16);
+	if (0x80808080 != dwValue)
+	{
+	   printf("[VIDEO] Capture Test fail -- capture data doesn't match source \n");
+	   printf("5 i=%d value=%x\n", i, dwValue);
+	   ulFlag = 1;
+	   break;
+	}
+
+	dwValue = *(ULONG *)(ulVGABaseAddr + i*32 + 20);
+	if (0x80808080 != dwValue)
+	{
+	   printf("[VIDEO] Capture Test fail -- capture data doesn't match source \n");
+	   printf("6 i=%d value=%x\n", i, dwValue);
+	   ulFlag = 1;
+	   break;
+	  }
+    }
+#endif
+
+    if (!ulFlag)
+    {
+        printf("[VIDEO] Capture Test OK\n");
+    }
+    else
+    {
+	printf("[VIDEO] Capture Test FAIL\n");
+	return VIDEO_TEST_FAIL;
+    }
+	
+    return VIDEO_TEST_OK;
+}
+
+/********************************************************/
+/*  Only used in the station                            */
+/********************************************************/
+int CRTTest(void)
+{
+    ULONG   ulVGABaseAddr;
+    BYTE    btCRTCenterMode, btCRTColorFmt;
+    USHORT  usCRTHor, usCRTVer;
+    ULONG   ulData;
+
+    int i,j;
+
+    //printf("\n --------- Turn on CRT --------- \n");
+    
+    //Enable CRT1 first
+    ulVGABaseAddr = vBufAlign((unsigned long)pCrt1Addr);
+    
+    btCRTCenterMode     = 0;
+    btCRTColorFmt	= YUV_444;
+    usCRTHor		= g_DefWidth;
+    usCRTVer		= g_DefHeight;	
+
+    CheckOnStartClient();
+
+    /* Fill Pattern */
+    for (i=0; i<usCRTHor; i++)
+    {
+	for (j=0; j<usCRTVer/8; j++)
+	{
+	    //Y
+	    //ulData = 0x10101010;
+	    ulData = 0x32323232;
+	    *(ULONG *)(ulVGABaseAddr + (i*usCRTVer*4+j*32)) = ulData;
+	    //ulData = 0x10101010;
+	    ulData = 0x32323232;
+	    *(ULONG *)(ulVGABaseAddr + (i*usCRTVer*4+j*32) +4) = ulData;
+	    //U
+	    ulData = 0x80808080;
+	    //ulData = 0x77777777;
+	    *(ULONG *)(ulVGABaseAddr + (i*usCRTVer*4+j*32) +8) = ulData;
+	    ulData = 0x80808080;
+	    //ulData = 0x77777777;
+	    *(ULONG *)(ulVGABaseAddr + (i*usCRTVer*4+j*32) +12) = ulData;
+	    //V
+	    ulData = 0x80808080;
+	    //ulData = 0x11111111;
+	    *(ULONG *)(ulVGABaseAddr + (i*usCRTVer*4+j*32) +16) = ulData;
+	    ulData = 0x80808080;
+	    //ulData = 0x11111111;
+	    *(ULONG *)(ulVGABaseAddr + (i*usCRTVer*4+j*32) +20) = ulData;
+	    //A
+	    ulData = 0xFFFFFFFFF;
+	    *(ULONG *)(ulVGABaseAddr + (i*usCRTVer*4+j*32) +24) = ulData;
+	    ulData = 0xFFFFFFFFF;
+	    *(ULONG *)(ulVGABaseAddr + (i*usCRTVer*4+j*32) +28) = ulData;
+	}
+    }  /* ~Fill Pattern */
+
+#if defined(CONFIG_AST2300)       
+    if(!ASTSetModeV (0, CRT_2, ulVGABaseAddr, usCRTHor, usCRTVer, btCRTColorFmt, btCRTCenterMode))
+#else
+    if(!ASTSetModeV (0, CRT_1, ulVGABaseAddr, usCRTHor, usCRTVer, btCRTColorFmt, btCRTCenterMode))
+#endif    
+    {   
+        printf("[VIDEO] The resolution is not in mode table list\n");
+        return CRT_FAIL;
+    }
+    
+    //printf("[VIDEO] CRT turn on\n");
+
+    return VIDEO_TEST_OK;
+}
+
+int do_videotest (void)
+{
+    int dwValue=0;
+    int i = 0;
+    int iRet;    
+    ULONG   ulRestore1, ulTemp;
+    BOOL    bClient;
+
+
+    //InitVideoTest();
+    g_DefWidth = 640; 
+    g_DefHeight= 480;
+
+    printf("\n --------- Codec Test --------- \n");
+
+#if defined(CONFIG_AST2300)
+    WriteMemoryLongWithMASKHost(SCU_BASE, SCU_CONTROL_REG, 0x00002000, 0x00002000);
+#endif
+
+    CheckOnStartHost();
+    
+    do
+    {
+        dwValue = UnlockVideoRegHost(0, VIDEO_UNLOCK_KEY);
+	i++;
+    }
+    while ((VIDEO_UNLOCK != dwValue) && (i<1000));
+
+    if (VIDEO_UNLOCK != dwValue)
+    {
+	printf("[VIDEO] Video register is locked \n");
+	return VIDEO_TEST_FAIL;
+    }
+    AllocateEncodeBufHost(0, VIDEO1);
+
+    iRet = CodecTest();	
+    if (iRet)
+        return VIDEO_TEST_FAIL;
+
+#if defined(CONFIG_AST2300)
+    /* Init SCU */ 
+    WriteMemoryLongWithMASKHost(SCU_BASE, (0x2c + SCU_OFFSET), 0x00040000, 0x00040010);	/* Enable D2-PLL */
+    WriteMemoryLongWithMASKHost(SCU_BASE, SCU_CLOCK_STOP_REG, 0, 0x00000400);		/* Enable D2CLK */
+    udelay(10);
+    WriteMemoryLongWithMASKHost(SCU_BASE, SCU_CONTROL_REG, 0, 0x00002000);
+    
+    WriteMemoryLongWithMASKHost(SCU_BASE, (0x90 + SCU_OFFSET), 0x20, 0x00000030); 	/* enable video mode single edge */
+    WriteMemoryLongWithMASKHost(SCU_BASE, (0x84 + SCU_OFFSET), 0xfffe0000, 0xfffe0000); /* multi-pins */
+    WriteMemoryLongWithMASKHost(SCU_BASE, (0x88 + SCU_OFFSET), 0x000fffff, 0x000fffff); /* multi-pins */    
+    
+    iRet = CRTTest();
+    if (iRet)
+    {
+    	printf("[VIDEO] CRT Test Failed \n");
+        return VIDEO_TEST_FAIL;
+    }
+
+    iRet = CapTest();		
+    if (iRet)
+    {
+    	printf("[VIDEO] Capture Test Failed \n");
+        return VIDEO_TEST_FAIL;
+    }
+#else
+    //Host or Client
+    bClient = ((ReadMemoryLong(SCU_BASE, SCU_HW_TRAPPING_REG) & CLIENT_MODE_EN_MASK)?TRUE:FALSE);
+    //reset video for another testing
+    ResetVideoHost();
+    dwValue=0;
+    i = 0;
+    do
+    {
+	dwValue = UnlockVideoRegHost(0, VIDEO_UNLOCK_KEY);
+	i++;
+    }
+    while ((VIDEO_UNLOCK != dwValue) && (i<10));
+
+    if (VIDEO_UNLOCK != dwValue)
+    {
+	printf("[VIDEO] Video register is locked");
+	return VIDEO_UNLOCK_FAIL;
+    }
+
+    //check if 1e6e0008[3,0] is 0
+    ulRestore1 = ReadMemoryLongHost(0x1e6e0000, 8);
+    dwValue = ReadMemoryLongHost(0x1e6e0000, 8)&0xF;
+
+    //set 1e6e0008[3,0] to 0
+    if (dwValue)
+    {
+        WriteMemoryLongHost(0x1e6e0000, 0, 0xfc600309);
+        
+        i=0;
+        do
+        {
+            i++;
+            dwValue = ReadMemoryLongHost(0x1e6e0000,0);
+        }while((1 != dwValue)&& (i<10));
+        
+        if (1 != dwValue)
+    	{
+    		printf("0x1e6e0000 is locked");
+    		return VIDEO_UNLOCK_FAIL;
+    	}
+    }
+
+    //only clear 1e6e0008[3,0]
+    WriteMemoryLongWithMASKHost(0x1e6e0000, 8, 0, 0xf);
+    
+    bClient = 0;
+    if (!bClient)
+    {
+        //To turn on crt, must be the client mode
+        WriteMemoryLongWithMASKHost(SCU_BASE, SCU_HW_TRAPPING_REG, (BE_CLIENT_CHIP << CLIENT_MODE_EN_BIT), CLIENT_MODE_EN_MASK);
+            
+        iRet = CRTTest();
+
+        if (iRet)
+        {
+            //trapping to host, the Vsync of CRT can't output and the host doesn't have video sync input
+            WriteMemoryLongWithMASKHost(SCU_BASE, SCU_HW_TRAPPING_REG, (BE_HOST_CHIP << CLIENT_MODE_EN_BIT), CLIENT_MODE_EN_MASK);
+            //restore value
+            WriteMemoryLongHost(0x1e6e0000, 8, ulRestore1);
+            //lock register
+            WriteMemoryLongHost(0x1e6e0000, 0, 0x12345678); 
+            return VIDEO_TEST_FAIL;
+        }
+        
+        iRet = CapTest();
+		
+        if (iRet)
+        {
+            //trapping to host, the Vsync of CRT can't output and the host doesn't have video sync input
+            WriteMemoryLongWithMASKHost(SCU_BASE, SCU_HW_TRAPPING_REG, (BE_HOST_CHIP << CLIENT_MODE_EN_BIT), CLIENT_MODE_EN_MASK);
+            //restore value
+            WriteMemoryLongHost(0x1e6e0000, 8, ulRestore1);
+            //lock register
+            WriteMemoryLongHost(0x1e6e0000, 0, 0x12345678); 
+
+            return VIDEO_TEST_FAIL;
+        }
+		//WriteMemoryLongWithMASKHost(SCU_BASE, SCU_HW_TRAPPING_REG, (BE_HOST_CHIP << CLIENT_MODE_EN_BIT), CLIENT_MODE_EN_MASK);
+    }
+    //trapping to host, the Vsync of CRT can't output and the host doesn't have video sync input
+    WriteMemoryLongWithMASKHost(SCU_BASE, SCU_HW_TRAPPING_REG, (BE_HOST_CHIP << CLIENT_MODE_EN_BIT), CLIENT_MODE_EN_MASK);
+    //restore value
+    WriteMemoryLongHost(0x1e6e0000, 8, ulRestore1);
+    //lock register
+    WriteMemoryLongHost(0x1e6e0000, 0, 0x12345678); 
+#endif
+
+    return VIDEO_TEST_OK;	
+}
+#endif /* CONFIG_SLT */
diff --git a/board/aspeed/ast2300/videotest.h b/board/aspeed/ast2300/videotest.h
new file mode 100755
index 0000000..79b8dd9
--- /dev/null
+++ b/board/aspeed/ast2300/videotest.h
@@ -0,0 +1,24 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* VideoTest.h */
+#ifndef _VIDEOTEST_H_
+#define _VIDEOTEST_H_
+
+#define VIDEO_TEST_OK       0
+#define VIDEO_TEST_FAIL     1
+
+#define VIDEO_UNLOCK_FAIL   1
+#define VIDEO_ENCODE_FAIL   2
+#define VIDEO_DECODE_FAIL   3
+#define CRT_FAIL            4
+
+#endif /* _VIDEOTEST_H_ */
+
diff --git a/board/aspeed/ast2300/vreg.h b/board/aspeed/ast2300/vreg.h
new file mode 100755
index 0000000..9738548
--- /dev/null
+++ b/board/aspeed/ast2300/vreg.h
@@ -0,0 +1,845 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef _VREG_H_
+#define _VREG_H_
+
+/********************************************************/
+/*    CRT register                                      */
+/********************************************************/
+#define    CRT_BASE_ADDRESS                    0x000400
+#define    VGA_GRAPH_BASE_ADDRESS              0x600000
+#define    VGA_CURSOR_BASE_ADDRESS             0x300000
+#define    VGA_OSD_BASE_ADDRESS                0x300000
+#define    RGB_565                             0x0
+#define    RGB_888                             0x1
+#define    YUV_444                             0x2
+#define	   NO_SUPPORTED_CRT_FMT				   0x3
+#define    CRT_LOW_THRESHOLD_VALUE             0x12
+#define    CRT_HIGH_THRESHOLD_VALUE            0x1E
+
+// AST3000's Registers 
+#ifdef Watcom
+#define     VIDEOBASE_OFFSET                            0x10000
+#else
+#define     VIDEOBASE_OFFSET                            0x0
+#endif
+
+#define     KEY_CONTROL_REG                             0x00 + VIDEOBASE_OFFSET
+    #define     VIDEO_LOCKED                            0
+    #define     VIDEO_UNLOCK                            1
+
+// Registers for video1 and video2
+#define     VIDEO1_ENGINE_SEQUENCE_CONTROL_REG          0x04 + VIDEOBASE_OFFSET
+#define     VIDEO2_ENGINE_SEQUENCE_CONTROL_REG          0x104 + VIDEOBASE_OFFSET
+    #define     MODE_DETECTION_TRIGGER                  0x00000001  //Bit[0] trigger HW auto mode detection
+    #define     VIDEO_CAPTURE_TRIGGER                   0x00000002  //Bit[1] trigger HW to capture video
+	#define		FORCE_HW_IDLE_MASK						(1<<2)		//Bit[2] Force engine into ready(idle) state
+		#define		ENGINE_RESET						(0<<2)
+		#define		ENGINE_IDLE							(1<<2)
+    #define     VIDEO_CAPTURE_AUTO_MODE                 0x00000008  //Bit[3]
+        #define     CAPTURE_FRAME_MODE                  0
+        #define     CAPTURE_AUTO_MODE                   1
+		#define		CAPTURE_AUTO_MODE_BIT				3
+		#define		CAPTURE_AUTO_MODE_MASK				0x00000008
+    #define     VIDEO_CODEC_TRIGGER                     0x00000010  //Bit[4] trigger HW to compress or decompress video
+        #define     CODEC_TRIGGER_BIT                   4
+        #define     CODEC_TRIGGER_MASK                  0x00000010
+        #define     CLEAR_CODEC_TRIGGER                 0
+        #define     EN_CODEC_TRIGGER                    1
+    #define     VIDEO_CODEC_AUTO_MODE                   0x00000020  //Bit[5]
+        #define     CODEC_FRAME_MODE                    0
+        #define     CODEC_AUTO_MODE                     1
+		#define		CODEC_AUTO_MODE_BIT					5
+        #define     CODEC_AUTO_MODE_MASK                0x00000020
+	#define		INSERT_FULL_FRAME_MASK					(1<<6)		//Bit[6] Insert full frame compression
+		#define		INSERT_FULL_FRAME_EN				(1<<6)
+		#define		INSERT_FULL_FRAME_OFF				(0<<6)
+    #define     WATCH_DOG_ENABLE                        0x00000080  //Bit[7] Video Enable watch dog for mode change detection
+        #define     WATCH_DOG_ENABLE_BIT                7
+        #define     WATCH_DOG_OFF                       0
+        #define     WATCH_DOG_EN                        1
+        #define     WATCH_DOG_EN_MASK                   0x00000080
+    #define     VIDEO_CRT_SELECTION                     0x00000100  //Bit[8]
+        #define     CRT1                                0
+        #define     CRT2                                1
+    #define     ANTI_TEARING_ENABLE                     0x00000200  //Bit[9] Anti-tearing mode enable for decoding
+        #define     ANTI_TEARING_EN                     1
+    #define     STREAM_DATA_MODE                        0x00000400  //Bit[11:10] Buffer and Stream Data type
+        #define     STREAM_DATA_MODE_BIT                10
+        #define     STREAM_DATA_MODE_MASK               0x00000C00
+        #define     YUV444_MODE                         0
+        #define     YUV420_MODE                         1
+        #define     YUV420_MODE_WITH_AST2000            2 //AST2000 compatible
+    #define     VIDEO_CAPTURE_READY                     0x00010000  //Bit[16] Video capture ready status read back(read only)
+		#define		CAPTURE_READY_MASK                  0x00010000  
+        #define     HW_BUSY                             0
+        #define     HW_IDLE                             1
+    #define     VIDEO_CODEC_READY                       0x00040000  //Bit[18] Video codec ready status read back(read only)
+		#define		CODEC_READY_MASK					0x00040000
+        //#define     HW_BUSY                             0
+        //#define     HW_IDLE                             1
+    
+#define    VIDEO1_CONTROL_REG                           0x08 + VIDEOBASE_OFFSET
+#define    VIDEO2_CONTROL_REG                           0x108 + VIDEOBASE_OFFSET
+    #define     VIDEO_HSYNC_POLARITY                    0x00000001  //Bit[0] Video source hsync polarity
+        #define     VIDEO_HSYNC_POLARITY_BIT            0
+        #define     NO_INVERSE_POL                      0
+        #define     INVERSE_POL							1
+    #define     VIDEO_VSYNC_POLARITY                    0x00000002  //Bit[1] Video source vsync polarity
+        #define     VIDEO_VSYNC_POLARITY_BIT            1        
+        //Setting defination the same as VIDEO_HSYNC_POLARITY
+    #define     VIDEO_EXTERNAL_SOURCE                   0x00000004  //Bit[2] Video external source
+        #define     EXTERNAL_SOURCE_BIT                 2
+        #define     INTERNAL_VGA_SOURCE                 0
+        #define     EXTERNAL_VGA_SOURCE                 1
+        #define     EXTERNAL_SOURCE_MASK                0x00000004                     
+    #define     VIDEO_ANALONG_EXTERNAL_SOURCE           0x00000008  //Bit[3] Video Analog external source
+        #define     ANALONG_EXTERNAL_SOURCE_BIT         3
+        #define     DVI_SOURCE                          0
+        #define     ANALOG_RGB_SOURCE                   1
+    #define     VIDEO_INTERNAL_TIMING_GEN               0x00000010  //Bit[4] Video Use internal timing generator
+        #define     INTERNAL_TIMING_GEN_BIT             4
+        #define     EXTERNAL_DE_SIGNAL                  0 //DVI only
+        #define     VR0C_VR10_DE_SINGAL                 1 //use VR0C and VR10 for generate VDE signal
+    /******     Video2 Only from DAC    ******/        
+    #define     VIDEO1_CAPTURE_FROM                     0x00000020  //Bit[5] Video1 capture data direct from VGA frame buffer(internal VGA only)  
+        #define     FROM_DAC_PORT                       0
+        #define     FROM_FRAME_BUFFER                   1     
+    #define     WRITE_DATA_FORMAT                       0x00000040  //Bit[7:6] Write data format
+        #define     WRITE_DATA_FORMAT_BIT               6
+        #define     WRTIE_DATA_FORMAT_MASK              0x000000C0
+        #define     CCIR601_2_YUV_FORMAT                0
+        #define     FULL_YUV_FORMAT                     1
+        #define     RGB_FORMAT                          2
+		#define     VGA_CURSOR_DISABLE                      0x00000100  //Bit[8] External video port slection
+        #define     VGA_CURSOR_NORMAL                   0
+        #define     VGA_CURSOR_OFF                      1    
+    #define     VIDEO_CAPTURE_LINEAR_MODE               0x00000200  //Bit[9] VIDEO_CAPTURE_LINEAR_MODE
+        #define     LINEAR_MODE                         0
+        #define     TILE_MODE		                    1		
+    #define     VIDEO_CLOCK_DELAY                       0x00000400  //Bit[11:10] Video clock delay control
+        #define     VIDEO_CLOCK_DELAY_BIT               10
+        #define     VIDEO_CLOCK_DELAY_MASK              0x00000C00
+        #define     DELAY_0_NS                          0
+        #define     DELAY_1_NS                          1
+        #define     INV_AND_DELAY_0_NS                  2
+        #define     INV_AND_DELAY_1_NS                  3
+    #define     VIDEO_CCIR656_SOURCE_MODE               0x00001000  //Bit[12] Video CCIR656 source mode
+        #define     RGB_SOURCE_MODE                     0
+        #define     CCIR656_SOURCE_MODE                 1
+    #define     SOURCE_PORT_CLOCK_MODE                  0x00002000  //Bit[13] Video Source port clock mode
+        #define     SINGLE_EDGE_MODE                    0
+        #define     DUAL_EDGE_MODE                      1
+    #define     EXTERNAL_PORT_SELECTION                 0x00004000  //Bit[14] External video port slection
+        #define     VIDEO_PORT_A                        0
+        #define     VIDEO_PORT_B                        1
+    #define     VIDEO_CAPTURE_FRAME_RATE                0x00010000  //Bit[23:16] Video capture frame rate control
+        #define     VIDEO_CAPTURE_FRAME_RATE_BIT        16
+        #define     VIDEO_CAPTURE_FRAME_RATE_MASK       0x00FF0000  //Maximum frame rate = XX * SourceFPS / 60
+
+#define    VIDEO1_TIMEING_GEN_HOR_REG                   0x0C + VIDEOBASE_OFFSET
+#define    VIDEO2_TIMEING_GEN_HOR_REG                   0x10C + VIDEOBASE_OFFSET
+    #define     VIDEO_HDE_END                           0x00000000  //Bit[12:0] Video HDE End timing generator
+    #define     VIDEO_HDE_END_BIT                       0  //Number of pixels from rising edge of Hsync for first active pixel
+    #define     VIDEO_HDE_END_MASK                      0x00001FFF
+    #define     VIDEO_HDE_START                         0x00010000  //Bit[28:16] Video HDE Start timing generator
+    #define     VIDEO_HDE_START_BIT                     16 //Number of pixels from rising edge of Hsync for last active pixel
+    #define     VIDEO_HDE_START_MASK                    0x1FFF0000
+        #define     FRAME_RATE_OFF                      0    
+    
+#define    VIDEO1_TIMEING_GEN_V_REG                     0x10 + VIDEOBASE_OFFSET
+#define    VIDEO2_TIMEING_GEN_V_REG                     0x110 + VIDEOBASE_OFFSET
+    #define     VIDEO_VDE_END                           0x00000001  //Bit[11:0] Video VDE End timing generator
+    #define     VIDEO_VDE_END_BIT                       0  //Number of pixels from rising edge of Vsync for first active pixel
+    #define     VIDEO_VDE_END_MASK                      0x00000FFF
+    #define     VIDEO_VDE_START                         0x00010000  //Bit[27:16] Video VDE Start timing generator
+    #define     VIDEO_VDE_START_BIT                     16 //Number of pixels from rising edge of Vsync for last active pixel
+    #define     VIDEO_VDE_START_MASK                    0x0FFF0000
+
+#define    VIDEO1_SCALE_FACTOR_REG                      0x14 + VIDEOBASE_OFFSET
+#define    VIDEO2_SCALE_FACTOR_REG                      0x114 + VIDEOBASE_OFFSET
+    #define     HOR_SCALING_FACTOR                      0x00000001  //Bit[15:0] Video Horizontal scaling factor
+    #define     HOR_SCALING_FACTOR_BIT                  0   //The formula=4096/(Horizontal scaling facotr)
+    #define     HOR_SCALING_FACTOR_MASK                 0x0000FFFF
+    #define     VER_SCALING_FACTOR                      0x00000000  //Bit[31:16] Video Vertical scaling factor
+    #define     VER_SCALING_FACTOR_BIT                  16   //The formula=4096/(Vertical scaling facotr)
+    #define     VER_SCALING_FACTOR_MASK                 0xFFFF0000
+
+#define    VIDEO1_SCALE_FACTOR_PARAMETER0_REG           0x18 + VIDEOBASE_OFFSET  //Scaling Parameters F00, F01, F02, F03
+#define    VIDEO2_SCALE_FACTOR_PARAMETER0_REG           0x118 + VIDEOBASE_OFFSET   
+
+#define    VIDEO1_SCALE_FACTOR_PARAMETER1_REG           0x1C + VIDEOBASE_OFFSET  //Scaling Parameters F10, F11, F12, F13
+#define    VIDEO2_SCALE_FACTOR_PARAMETER1_REG           0x11C + VIDEOBASE_OFFSET   
+
+#define    VIDEO1_SCALE_FACTOR_PARAMETER2_REG           0x20 + VIDEOBASE_OFFSET  //Scaling Parameters F20, F21, F22, F23
+#define    VIDEO2_SCALE_FACTOR_PARAMETER2_REG           0x120 + VIDEOBASE_OFFSET   
+
+#define    VIDEO1_SCALE_FACTOR_PARAMETER3_REG           0x24 + VIDEOBASE_OFFSET  //Scaling Parameters F30, F31, F32, F33
+#define    VIDEO2_SCALE_FACTOR_PARAMETER3_REG           0x124 + VIDEOBASE_OFFSET
+
+#define    VIDEO1_BCD_CONTROL_REG                       0x2C + VIDEOBASE_OFFSET
+#define    VIDEO2_BCD_CONTROL_REG                       0x12C + VIDEOBASE_OFFSET
+    #define     BCD_ENABLE                              0x00000001  //Bit[0] Enable block change detection(BCD)
+        #define     BCD_ENABLE_BIT                      0
+        #define     BCD_ENABLE_MASK                     0x00000001
+    #define     BCD_TOLERANCE                           0x00010000  //Bit[23:16]
+        #define     BCD_TOLERANCE_BIT                   16 //flag as changed block when the video data difference greater
+        #define     BCD_TOLERANCE_MASK                  0x00FF0000
+
+#define     VIDEO1_CAPTURE_WINDOWS_REG                  0x30 + VIDEOBASE_OFFSET
+#define     VIDEO2_CAPTURE_WINDOWS_REG                  0x130 + VIDEOBASE_OFFSET
+    #define     CAPTURE_VER_LINE						0x00000001  //Bit[10:0] Video compression vertical line total
+    #define     CAPTURE_VER_LINE_BIT					0
+    #define     CAPTURE_VER_LINE_MASK					0x000007FF
+    #define     CAPTURE_HOR_PIXEL						0x00010000  //Bit[26:16] Video compression vertical line total
+    #define     CAPTURE_HOR_PIXEL_BIT					16
+    #define     CAPTURE_HOR_PIXEL_MASK					0x07FF0000
+
+#define     VIDEO1_COMPRESS_WINDOWS_REG                 0x34 + VIDEOBASE_OFFSET
+#define     VIDEO2_COMPRESS_WINDOWS_REG                 0x134 + VIDEOBASE_OFFSET
+    #define     COMPRESS_VER_LINE                       0x00000001  //Bit[10:0] Video compression vertical line total
+    #define     COMPRESS_VER_LINE_BIT                   0
+    #define     COMPRESS_VER_LINE_MASK                  0x000007FF
+    #define     COMPRESS_HOR_PIXEL                      0x00010000  //Bit[26:16] Video compression vertical line total
+    #define     COMPRESS_HOR_PIXEL_BIT                  16
+    #define     COMPRESS_HOR_PIXEL_MASK                 0x07FF0000
+
+#define     VIDEO1_COMPRESS_BUF_PROCESS_OFFSET_REG      0x38
+#define     VIDEO2_COMPRESS_BUF_PROCESS_OFFSET_REG      0x138
+    #define     COMPRESS_BUF_PROCESS_OFFSET_ALIGN       127 //128 byte alignment
+    #define     COMPRESS_BUF_PROCESS_OFFSET_MASK        0xFFFFFF
+
+#define     VIDEO1_DECOMPRESS_BUF_PROCESS_OFFSET_REG    0x38
+#define     VIDEO2_DECOMPRESS_BUF_PROCESS_OFFSET_REG    0x138
+    #define     DECOMPRESS_BUF_PROCESS_OFFSET_ALIGN     127 //128 byte alignment
+    #define     DECOMPRESS_BUF_PROCESS_OFFSET_MASK      0xFFFFFF
+
+
+//For Compression
+#define     VIDEO1_COMPRESS_BUF_READ_OFFSET_REG         0x3C + VIDEOBASE_OFFSET     //For stream mode
+#define     VIDEO2_COMPRESS_BUF_READ_OFFSET_REG         0x13C + VIDEOBASE_OFFSET
+    #define     COMPRESS_BUF_READ_OFFSET_ALIGN          127 //128 byte alignment
+    #define     COMPRESS_BUF_READ_OFFSET_MASK           0x00FFFFFF
+//For Decompression
+#define     VIDEO1_DECOMPRESS_BUF_WRITE_OFFSET_REG      0x3C + VIDEOBASE_OFFSET     //For stream mode 
+#define     VIDEO2_DECOMPRESS_BUF_WRITE_OFFSET_REG      0x13C + VIDEOBASE_OFFSET
+    #define     DECOMPRESS_BUF_WRITE_OFFSET_ALIGN       127 //128 byte alignment
+    #define     DECOMPRESS_BUF_WRITE_OFFSET_MASK        0x00FFFFFF
+
+#define     VIDEO1_CRC_BUF_ADDR_REG                     0x40 + VIDEOBASE_OFFSET
+#define     VIDEO2_CRC_BUF_ADDR_REG                     0x140 + VIDEOBASE_OFFSET
+    #define     CRC_BUF_ADDR_ALIGN                      7   //8 byte alignment
+    #define     CRC_BUF_ADDR_MASK                       0x0FFFFFFF
+
+#define     VIDEO1_BUF_1_ADDR_REG                       0x44 + VIDEOBASE_OFFSET     //For Source Buffer in frame mode
+#define     VIDEO2_BUF_1_ADDR_REG                       0x144 + VIDEOBASE_OFFSET
+    #define     BUF_1_ADDR_ALIGN                        255 //256 byte alignment
+    #define     BUF_1_ADDR_MASK                         0x1FFFFFFF
+
+#define     VIDEO1_BUF_LINE_OFFSET_REG                  0x48 + VIDEOBASE_OFFSET     //Must set both in Frame/Stream mode
+#define     VIDEO2_BUF_LINE_OFFSET_REG                  0x148 + VIDEOBASE_OFFSET
+    #define     BUF_LINE_OFFSET_ALIGN                   7 //8 byte alignment
+    #define     BUF_LINE_OFFSET_MASK                    0x00003FFF
+
+#define     VIDEO1_BUF_2_ADDR_REG                       0x4C + VIDEOBASE_OFFSET     //For BCD Buffer in frame mode
+#define     VIDEO2_BUF_2_ADDR_REG                       0x14C + VIDEOBASE_OFFSET     
+    #define     BUF_2_ADDR_ALIGN                        255 //256 byte alignment
+    #define     BUF_2_ADDR_MASK                         0x1FFFFFFF
+
+#define     VIDEO1_FLAG_BUF_ADDR_REG                    0x50 + VIDEOBASE_OFFSET     //For block change flag buffer
+#define     VIDEO2_FLAG_BUF_ADDR_REG                    0x150 + VIDEOBASE_OFFSET     
+    #define     FLAG_BUF_ADDR_ALIGN                     7 //8 byte alignment
+    #define     FLAG_BUF_ADDR_MASK                      0x1FFFFFFF
+
+#define     VIDEO1_COMPRESS_BUF_ADDR_REG                0x54 + VIDEOBASE_OFFSET     //For stream mode
+#define     VIDEO2_COMPRESS_BUF_ADDR_REG                0x154 + VIDEOBASE_OFFSET     
+    #define     COMPRESS_BUF_ADDR_ALIGN                 127 //128 byte alignment
+    #define     COMPRESS_BUF_ADDR_MASK                  0x1FFFFFFF
+
+#define     VIDEO1_STREAM_BUF_SIZE                      0x58 + VIDEOBASE_OFFSET     //For stream mode 
+#define     VIDEO2_STREAM_BUF_SIZE                      0x158 + VIDEOBASE_OFFSET
+    #define     STREAM_PACKET_SIZE                      0x00000001
+        #define     STREAM_PACKET_SIZE_BIT              0
+        #define     STREAM_PACKET_SIZE_MASK             0x00000007
+        #define     PACKET_SIZE_1KB                     0
+        #define     PACKET_SIZE_2KB                     1
+        #define     PACKET_SIZE_4KB                     2
+        #define     PACKET_SIZE_8KB                     3
+        #define     PACKET_SIZE_16KB                    4
+        #define     PACKET_SIZE_32KB                    5
+        #define     PACKET_SIZE_64KB                    6
+        #define     PACKET_SIZE_128KB                   7
+    #define     RING_BUF_PACKET_NUM                     0x00000008
+        #define     RING_BUF_PACKET_NUM_BIT             3
+        #define     RING_BUF_PACKET_NUM_MASK            0x00000018
+        #define     PACKETS_4                           0
+        #define     PACKETS_8                           1
+        #define     PACKETS_16                          2
+        #define     PACKETS_32                          3
+    #define     SKIP_HIGH_MB_THRES                      0x00010000  //Bit[22:16] Skip high quality macro block threshold
+        #define     SKIP_HIGH_MB_THRES_BIT              16
+        #define     SKIP_HIGH_MB_THRES_MASK             0x007F0000
+    #define     SKIP_TEST_MODE                          0x00800000  //Bit[24:23] Skip test mode
+        #define     SKIP_TEST_MODE_BIT                  23
+        #define     SKIP_TEST_MODE_MASK                 0x01800000
+        #define     YUV_TEST                            2   //recommend
+
+#define     VIDEO1_BUF_CODEC_OFFSET_READ                0x5C + VIDEOBASE_OFFSET     //For stream mode,         
+#define     VIDEO2_BUF_CODEC_OFFSET_READ                0x15C + VIDEOBASE_OFFSET    //Video stream buffer offset read back(HW)
+    #define     BUF_CODEC_OFFSET_ALIGN                  255 //256 byte alignment
+    #define     BUF_CODEC_OFFSET_MASK                   0x00FFFFFF
+
+#define     VIDEO1_COMPRESS_CONTROL_REG                 0x60 + VIDEOBASE_OFFSET
+#define     VIDEO2_COMPRESS_CONTROL_REG                 0x160 + VIDEOBASE_OFFSET
+    #define     JPEG_ONLY_ENCODE                        0x00000001  //Bit[0] JPEG only encoding
+        #define     JPEG_ONLY_BIT                       0
+        #define     JPEG_MIX_MODE                       0   //Enable JPEG/VQ mix mode encoding
+        #define     JPEG_ONLY_MODE                      1   //JPEG encoding mode only
+    #define     VQ_4_COLOR_ENCODE                       0x00000002  //Bit[1] Enable 4 color VQ encoding
+        #define     VQ_4_COLOR_BIT                      1
+        #define     VQ_1_2_COLOR_MODE                   0   //1 and 2 color mode VQ encoding
+        #define     VQ_4_COLOR_MODE                     1   //1, 2 and 4 color VQ encoding
+    #define     QUALITY_CODEC_SETTING                   0x00000004  //Bit[2] High and best video quality codec mode setting
+        #define     QUALITY_CODEC_SETTING_BIT           2
+        #define     JPEG_CODEC_MODE                     0   //not supported in best video quality mode
+        #define     QUANTI_CODEC_MODE                   1
+    #define     JPEG_DUAL_QUALITY_EN                    0x00000008  //Bit[3] JPEG dual quality mode
+        #define     EN_JPEG_DUAL_QUALITY                1   //enable(only for normal video quality mode)
+    #define     BEST_QUALITY_EN                         0x00000010  //Bit[4] Best quality video mode enable
+        #define     BEST_QUALITY_EN_BIT                 4
+        #define     EN_BEST_QUALITY                     1   //enable(only for quantization codec mode)
+    #define     RC4_CRYPT_EN                            0x00000020  //Bit[5] Enable RC4 encryption/decryption
+		#define		RC4_CRYPT_EN_BIT					5
+		#define     RC4_CRYPT_EN_MASK                   0x00000020
+        #define     RC4_CRYPT_ON                        1   //enable
+    #define     NORMAL_QUANTI_CHROMI_TABLE              0x00000040  //Bit[10:6] Normal video quality mode JPEG DCT chromi quantination table
+        #define     NORMAL_QUANTI_CHROMI_TABLE_BIT      6
+        #define     NORMAL_QUANTI_CHROMI_TABLE_MASK     0x000007C0
+    #define     NORMAL_QUANTI_LUMI_TABLE                0x00000800  //Bit[15:11] Normal video quality mode JPEG DCT lumi quantination table
+        #define     NORMAL_QUANTI_LUMI_TABLE_BIT        11
+        #define     NORMAL_QUANTI_LUMI_TABLE_MASK       0x0000F800
+    #define     HIGH_QUALITY_EN                         0x00010000  //Bit[16] High video quality mode enable
+        #define     HIGH_QUALITY_EN_BIT                 16
+        #define     EN_HIGH_QUALITY                     1   //Enable
+    #define     UV_CIR656_FORMAT                        0x00080000  //Bit[19] UV fromat
+        #define     UV_CIR656_FORMAT_BIT                19
+        #define     USE_UV_CIR656                       1   //recommand
+    #define     HUFFMAN_TABLE_SELECT                    0x00100000  //Bit[20] JPEG Huffman table combination
+        #define     DUAL_TABLE                          0   //Dual Y, UV table
+        #define     SINGLE_TABLE                        1   //Single Y table
+        #define     SINGLE_UV_TABLE                     0x00200000  //1x: Single UV table
+    #define     HIGH_QUANTI_CHROMI_TABLE                0x00400000  //Bit[26:22] High quality JPEG DCT chromi quantization table
+        #define     HIGH_QUANTI_CHROMI_TABLE_BIT        22
+        #define     HIGH_QUANTI_CHROMI_TABLE_MASK       0x07C00000                
+    #define     HIGH_DEQUANTI_VALUE                     0x00400000  //Bit[26:22] High quality de-quantization value
+        #define     HIGH_DEQUANTI_VALUE_BIT             22
+        #define     HIGH_DEQUANTI_VALUE_MASK            0x07C00000        
+    #define     HIGH_QUANTI_LUMI_TABLE                  0x08000000  //Bit[31:27] High quality JPEG DCT lumi quantization table
+        #define     HIGH_QUANTI_LUMI_TABLE_BIT          27
+        #define     HIGH_QUANTI_LUMI_TABLE_MASK         0xF8000000
+    #define     BEST_DEQUANTI_VALUE                     0x08000000  //Bit[31:27] Best quality de-quantization value
+        #define     BEST_DEQUANTI_VALUE_BIT             27
+        #define     BEST_DEQUANTI_VALUE_MASK            0xF8000000
+        
+
+#define     VIDEO1_QUANTI_TABLE_LOW_REG                 0x64 + VIDEOBASE_OFFSET     //Match with 0x60 Bit[10:6], Bit[15:11]
+#define     VIDEO2_QUANTI_TABLE_LOW_REG                 0x164 + VIDEOBASE_OFFSET
+    #define     QUANTI_CHROMI_TABLE_LOW                 0x00000001  //Bit[4:0] Normal video low quality block chromi quantization table
+        #define     QUANTI_CHROMI_TABLE_LOW_BIT         0
+        #define     QUANTI_CHROMI_TABLE_LOW_MASK        0x0000001F
+    #define     QUANTI_LUMI_TABLE_LOW                   0x00000020  //Bit[9:5] Normal video low quality block lumi quantization table
+        #define     QUANTI_LUMI_TABLE_LOW_BIT           5
+        #define     QUANTI_LUMI_TABLE_LOW_MASK          0x000003E0
+
+#define     VIDEO1_QUANTI_VALUE_REG                     0x68 + VIDEOBASE_OFFSET     //Match with 0x60 Bit[26:22],Bit[31:27]
+#define     VIDEO2_QUANTI_VALUE_REG                     0x168 + VIDEOBASE_OFFSET
+    #define     HIGH_QUANTI_VALUE                       0x00000001  //Bit[14:0] High quality quantization value. Format is 1.14
+        #define     HIGH_QUANTI_VALUE_BIT               0
+        #define     HIGH_QUANTI_VALUE_MASK              0x00007FFF
+    #define     BEST_QUANTI_VALUE                       0x00010000  //Bit[30:16] Best quality quantization value. Format is 1.14
+        #define     BEST_QUANTI_VALUE_BIT               16
+        #define     BEST_QUANTI_VALUE_MASK              0x7FFF0000
+    
+#define     VIDEO1_BSD_PARA_REG                         0x6C + VIDEOBASE_OFFSET    //Video BSD Parameters Register    
+#define     VIDEO2_BSD_PARA_REG                         0x16C + VIDEOBASE_OFFSET
+    #define     BSD_HIGH_THRES                          0x00000001  //Bit[7:0] Block sharpness detection high threshold
+    #define     BSD_HIGH_THRES_BIT                      0
+    #define     BSD_HIGH_THRES_MASK                     0x000000FF
+    #define     BSD_LOW_THRES                           0x00000100  //Bit[15:8] Block shaprpness detection low threshold
+    #define     BSD_LOW_THRES_BIT                       8
+    #define     BSD_LOW_THRES_MASK                      0x0000FF00
+    #define     BSD_HIGH_COUNTS                         0x00010000  //Bit[21:16] Block sharpness detection high counts threshold
+    #define     BSD_HIGH_COUNTS_BIT                     16
+    #define     BSD_HIGH_COUNTS_MASK                    0x003F0000
+    #define     BSD_LOW_COUNTS                          0x00400000  //Bit[27:22] Block sharpness detection low counts threshold
+    #define     BSD_LOW_COUNTS_BIT                      22
+    #define     BSD_LOW_COUNTS_MASK                     0x0FC00000
+
+#define VIDEO1_COMPRESS_FRAME_SIZE_REG                  0x70 + VIDEOBASE_OFFSET
+#define VIDEO2_COMPRESS_FRAME_SIZE_REG                  0x170 + VIDEOBASE_OFFSET
+    #define     COMPRESS_FRAME_SIZE_READ                0x00000001  //Bit[19:0] Video compression frame size read back(number of DW)
+    #define     COMPRESS_FRAME_SIZE_READ_BIT            0
+    #define     COMPRESS_FRAME_SIZE_READ_MASK           0x003FFFFF
+
+#define     VIDEO1_COMPRESS_BLOCK_COUNT_REG             0x74 + VIDEOBASE_OFFSET
+#define     VIDEO2_COMPRESS_BLOCK_COUNT_REG             0x174 + VIDEOBASE_OFFSET
+    #define     PROCESS_BLOCK_COUNT_READ_BIT            0
+    #define     PROCESS_BLOCK_COUNT_READ_MASK			0x00003FFF	//Bit[13:0] Video processed total block counter read back(number of blocks)
+    #define     COMPRESS_BLOCK_COUNT_READ_BIT           16
+    #define     COMPRESS_BLOCK_COUNT_READ_MASK          0xFFFF0000	//Bit[29:16] Video processed total block counter read back(number of blocks)
+
+#define     VIDEO1_COMPRESS_FRAME_END_READ              0x78 + VIDEOBASE_OFFSET     //Video compression stream frame end pointer    
+#define     VIDEO2_COMPRESS_FRAME_END_READ              0x178 + VIDEOBASE_OFFSET
+    #define     COMPRESS_FRAME_END_READ_ALIGN           7
+    #define     COMPRESS_FRAME_END_READ_MASK            0x00FFFFFF
+
+#define     VIDEO1_COMPRESS_FRAME_COUNT_READ            0x7C + VIDEOBASE_OFFSET     
+#define     VIDEO2_COMPRESS_FRAME_COUNT_READ            0x17C + VIDEOBASE_OFFSET 
+    #define     COMPRESS_FRAME_COUNT_READ               0x00000001  //Bit[15:0] Video compression frame count read back(number of frame)
+    #define     COMPRESS_FRAME_COUNT_READ_BIT           0
+    #define     COMPRESS_FRAME_COUNT_READ_MASK          0xFFFFFFFF
+
+#define     VIDEO1_USER_DEFINE_HEADER                   0x80 + VIDEOBASE_OFFSET
+#define     VIDEO2_USER_DEFINE_HEADER                   0x180 + VIDEOBASE_OFFSET
+    #define     USER_DEFINE_HEADER                      0x00000001  //Bit[15:0] Video user defined header parameter
+    #define     USER_DEFINE_HEADER_BIT                  0
+    #define     USER_DEFINE_HEADER_MASK                 0x0000FFFF
+    
+#define     VIDE1_MODE_DETECTION_EDGE_H_REG             0x90 + VIDEOBASE_OFFSET
+#define     VIDE2_MODE_DETECTION_EDGE_H_REG             0x190 + VIDEOBASE_OFFSET
+    #define     LEFT_EDGE_LOCATION                      0x00000001  //Bit[11:0] Video source left edge location from sync rising edge
+    #define     LEFT_EDGE_LOCATION_BIT                  0
+    #define     LEFT_EDGE_LOCATION_MASK                 0x00000FFF
+	#define		NO_VER_SYNC								(1 << 12)		//Bit[12] No Vertical sync detected
+	#define		NO_HOR_SYNC								(1 << 13)		//Bit[13] No horizontal sync detected
+	#define		NO_ACTIVE_DISP							(1 << 14)		//Bit[14] No active display detected
+	#define		NO_DISP_CLOCK							(1 << 15)		
+    #define     RIGHT_EDGE_LOCATION                     0x00010000  //Bit[27:16] Video source right edge location from sync rising edge
+    #define     RIGHT_EDGE_LOCATION_BIT                 16
+    #define     RIGHT_EDGE_LOCATION_MASK                0x0FFF0000
+
+#define     VIDE1_MODE_DETECTION_EDGE_V_REG             0x94 + VIDEOBASE_OFFSET
+#define     VIDE2_MODE_DETECTION_EDGE_V_REG             0x194 + VIDEOBASE_OFFSET
+    #define     TOP_EDGE_LOCATION                       0x00000001  //Bit[11:0] Video source top edge location from sync rising edge
+    #define     TOP_EDGE_LOCATION_BIT                   0
+    #define     TOP_EDGE_LOCATION_MASK                  0x00000FFF
+    #define     BOTTOM_EDGE_LOCATION                    0x00010000  //Bit[27:16] Video source bottom edge location from sync rising edge
+    #define     BOTTOM_EDGE_LOCATION_BIT                16
+    #define     BOTTOM_EDGE_LOCATION_MASK               0x0FFF0000
+
+#define VIDEO1_MODE_DETECTION_STATUS_READ_REG           0x98 + VIDEOBASE_OFFSET
+#define VIDEO2_MODE_DETECTION_STATUS_READ_REG           0x198 + VIDEOBASE_OFFSET    
+    #define     MODE_DETECTION_HOR_TIME_READ            0x00000001  //Bit[11:0] Mode detection Horizontal time read back (read only)
+    #define     MODE_DETECTION_HOR_TIME_READ_BIT        0
+    #define     MODE_DETECTION_HOR_TIME_READ_MASK       0x00000FFF
+    #define     ANALONG_DIGITAL_READ                    0x00001000  //Bit[12] Auto detection for external analog or digital source read back
+        #define     ANALONG_DIGITAL_READ_BIT            12
+        #define     DVI_SIGNAL                          0
+        #define     ADC_SIGNAL                          1
+    #define     MODE_DETECTION_HOR_STABLE_READ          0x00002000  //Bit[13] Mode detection horizontal stable read back
+        #define     HOR_STABLE                          1
+    #define     MODE_DETECTION_VER_STABLE_READ          0x00004000  //Bit[14] Mode detection vertical stable read back
+        #define     VER_STABLE                          1
+    #define     OUT_LOCK_READ                           0x00008000  //Bit[15] Mode detection out of lock read back
+        #define     SIGNAL_OUT_LOCK                     1
+    #define     MODE_DETECTION_VER_LINE_READ            0x00010000  //Bit[27:16] Mode detection Vertical lines read back
+    #define     MODE_DETECTION_VER_LINE_READ_BIT        16
+    #define     MODE_DETECTION_VER_LINE_READ_MASK       0x0FFF0000
+    #define     VSYNC_POLARITY_READ                     0x10000000  //Bit[28] Vsync polarity read back
+    #define     HSYNC_POLARITY_READ                     0x20000000  //Bit[29] Hsync polarity read back
+    #define     MODE_DETECTION_VSYNC_READY              0x40000000  //Bit[30] Mode detection Vsync ready
+    #define     MODE_DETECTION_HSYNC_READY              0x80000000  //Bit[31] Mode detection Hsync ready
+
+/******     VIDEO MEMAGER SETTING               ******/
+#define     VIDEOM_ENGINE_SEQUENCE_CONTROL_REG          0x204 + VIDEOBASE_OFFSET
+    #define     VIDEOM_CAPTURE_TRIGGER                  0x00000002  //Bit[1] trigger HW to capture video
+    #define     VIDEOM_AUTO_MODE						0x00000008  //Bit[3]
+        #define     DISABLE_AUTO_MODE                   0
+        #define     AUTO_COMPRESS						1
+    #define     VIDEOM_CODEC_TRIGGER                    0x00000010  //Bit[4] trigger HW to compress or decompress video
+    #define     VIDEOM_SOURCE_SELECTION                 0x00000100  //Bit[8]
+        #define     VIDEO1                              0
+        #define     VIDEO2                              1
+    //#define     STREAM_DATA_MODE                        0x00000400  //Bit[11:10] Buffer and Stream Data type
+    //    #define     STREAM_DATA_MODE_BIT                10
+    //    #define     STREAM_DATA_MODE_MASK               0x00000C00
+    //    #define     YUV444_MODE                         0
+    //    #define     YUV420_MODE                         1
+    //    #define     YUV420_MODE_WITH_AST2000            2 //AST2000 compatible
+    #define     VIDEOM_CAPTURE_READY                    0x00010000  //Bit[16] Video capture ready status read back(read only)
+        //#define     HW_BUSY                             0
+        //#define     HW_IDLE                             1
+    #define     VIDEOM_CODEC_READY                      0x00040000  //Bit[18] Video codec ready status read back(read only)
+        //#define     HW_BUSY                             0
+        //#define     HW_IDLE                             1
+
+#define    VIDEOM_SCALE_FACTOR_REG                      0x214 + VIDEOBASE_OFFSET
+//    #define     HOR_SCALING_FACTOR                      0x00000001  //Bit[15:0] Video Horizontal scaling factor
+//    #define     HOR_SCALING_FACTOR_BIT                  0   //The formula=4096/(Horizontal scaling facotr)
+//    #define     HOR_SCALING_FACTOR_MASK                 0x0000FFFF
+//    #define     VER_SCALING_FACTOR                      0x00000000  //Bit[31:16] Video Vertical scaling factor
+//    #define     VER_SCALING_FACTOR_BIT                  16   //The formula=4096/(Vertical scaling facotr)
+//    #define     VER_SCALING_FACTOR_MASK                 0xFFFF0000
+
+#define    VIDEOM_SCALE_FACTOR_PARAMETER0_REG           0x218 + VIDEOBASE_OFFSET  //Scaling Parameters F00, F01, F02, F03
+
+#define    VIDEOM_SCALE_FACTOR_PARAMETER1_REG           0x21C + VIDEOBASE_OFFSET  //Scaling Parameters F10, F11, F12, F13
+
+#define    VIDEOM_SCALE_FACTOR_PARAMETER2_REG           0x220 + VIDEOBASE_OFFSET  //Scaling Parameters F20, F21, F22, F23
+
+#define    VIDEOM_SCALE_FACTOR_PARAMETER3_REG           0x224 + VIDEOBASE_OFFSET  //Scaling Parameters F30, F31, F32, F33
+
+#define    VIDEOM_BCD_CONTROL_REG                       0x22C + VIDEOBASE_OFFSET
+    //#define     BCD_ENABLE                              0x00000001  //Bit[0] Enable block change detection(BCD)
+    //#define     BCD_TOLERANCE                           0x00010000  //Bit[23:16]
+    //    #define     BCD_TOLERANCE_BIT                   16 //flag as changed block when the video data difference greater
+    //    #define     BCD_TOLERANCE_MASK                  0x00FF0000
+
+#define     VIDEOM_CAPTURE_WINDOWS_REG                  0x230 + VIDEOBASE_OFFSET
+    //#define     RC4_TABLE_ADDR_ALIGN                    7   //8 byte alignment
+    //#define     RC4_TABLE_ADDR_MASK                     0x0FFFFFFF
+
+#define     VIDEOM_COMPRESS_WINDOWS_REG                 0x234 + VIDEOBASE_OFFSET
+    //#define     COMPRESS_VER_LINE                       0x00000001  //Bit[12:0] Video compression vertical line total
+    //#define     COMPRESS_VER_LINE_BIT                   0
+    //#define     COMPRESS_VER_LINE_MASK                  0x00001FFF
+    //#define     COMPRESS_HOR_PIXEL                      0x00010000  //Bit[12:0] Video compression vertical line total
+    //#define     COMPRESS_HOR_PIXEL_BIT                  16
+    //#define     COMPRESS_HOR_PIXEL_MASK                 0x1FFF0000
+
+#define     VIDEOM_COMPRESS_BUF_PROCESS_OFFSET_REG      0x238
+    //#define     COMPRESS_BUF_PROCESS_OFFSET_ALIGN       127 //128 byte alignment
+    //#define     COMPRESS_BUF_PROCESS_OFFSET_MASK        0x3FFFFF
+
+
+//For Compression
+#define     VIDEOM_COMPRESS_BUF_READ_OFFSET_REG         0x23C + VIDEOBASE_OFFSET     //For stream mode
+    //#define     COMPRESS_BUF_READ_OFFSET_ALIGN          127 //128 byte alignment
+    //#define     COMPRESS_BUF_READ_OFFSET_MASK           0x003FFFFF
+//For Decompression
+#define     VIDEOM_DECOMPRESS_BUF_WRITE_OFFSET_REG      0x23C + VIDEOBASE_OFFSET     //For stream mode 
+    //#define     DECOMPRESS_BUF_WRITE_OFFSET_ALIGN       127 //128 byte alignment
+    //#define     DECOMPRESS_BUF_WRITE_OFFSET_MASK        0x003FFFFF
+    
+#define     VIDEOM_BUF_1_ADDR_REG                       0x244 + VIDEOBASE_OFFSET     //For Source Buffer in frame mode
+    //#define     BUF_1_ADDR_ALIGN                        255 //256 byte alignment
+    //#define     BUF_1_ADDR_MASK                         0x0FFFFFFF
+
+#define     VIDEOM_BUF_LINE_OFFSET_REG                  0x248 + VIDEOBASE_OFFSET     //Must set both in Frame/Stream mode
+    //#define     BUF_LINE_OFFSET_ALIGN                   7 //8 byte alignment
+    //#define     BUF_LINE_OFFSET_MASK                    0x00003FFF
+
+#define     VIDEOM_BUF_2_ADDR_REG                       0x24C + VIDEOBASE_OFFSET     //For BCD Buffer in frame mode
+    //#define     BUF_2_ADDR_ALIGN                        255 //256 byte alignment
+    //#define     BUF_2_ADDR_MASK                         0x0FFFFFFF
+
+#define     VIDEOM_FLAG_BUF_ADDR_REG                    0x250 + VIDEOBASE_OFFSET     //For block change flag buffer
+    //#define     FLAG_BUF_ADDR_ALIGN                     7 //8 byte alignment
+    //#define     FLAG_BUF_ADDR_MASK                      0x0FFFFFFF
+
+#define     VIDEOM_COMPRESS_BUF_ADDR_REG                0x254 + VIDEOBASE_OFFSET     //For stream mode
+    //#define     FLAG_BUF_ADDR_ALIGN                     7 //8 byte alignment
+    //#define     FLAG_BUF_ADDR_MASK                      0x0FFFFFFF
+    
+#define     VIDEOM_BUF_CODEC_OFFSET_READ                0x25C + VIDEOBASE_OFFSET     //For stream mode,         
+    //#define     BUF_CODEC_OFFSET_ALIGN                  255 //256 byte alignment
+    //#define     BUF_CODEC_OFFSET_MASK                   0x003FFFFF
+    
+#define     VIDEOM_COMPRESS_CONTROL_REG                 0x260 + VIDEOBASE_OFFSET
+    //#define     JPEG_ONLY_ENCODE                        0x00000001  //Bit[0] JPEG only encoding
+    //    #define     JPEG_MIX_MODE                       0   //Enable JPEG/VQ mix mode encoding
+    //    #define     JPEG_ONLY_MODE                      1   //JPEG encoding mode only
+    //#define     VQ_4_COLOR_ENCODE                       0x00000002  //Bit[1] Enable 4 color VQ encoding
+    //    #define     VQ_1_2_COLOR_MODE                   0   //1 and 2 color mode VQ encoding
+    //    #define     VQ_4_COLOR_MODE                     1   //1, 2 and 4 color VQ encoding
+    //#define     QUALITY_CODEC_SETTING                   0x00000004  //Bit[2] High and best video quality codec mode setting
+    //    #define     JPEG_CODEC_MODE                     0   //not supported in best video quality mode
+    //    #define     QUANTI_CODEC_MODE                   1
+    //#define     JPEG_DUAL_QUALITY_EN                    0x00000008  //Bit[3] JPEG dual quality mode
+    //    #define     EN_JPEG_DUAL_QUALITY                1   //enable(only for normal video quality mode)
+    //#define     BEST_QUALITY_EN                         0x00000010  //Bit[4] Best quality video mode enable
+    //    #define     EN_BEST_QUALITY                     1   //enable(only for quantization codec mode)
+    //#define     RC4_CRYPT_EN                            0x00000020  //Bit[5] Enable RC4 encryption/decryption
+    //    #define     EN_RC4_CRYPT                        1   //enable
+    //#define     NORMAL_QUANTI_CHROMI_TABLE              0x00000040  //Bit[10:6] Normal video quality mode JPEG DCT chromi quantination table
+    //    #define     NORMAL_QUANTI_CHROMI_TABLE_BIT      6
+    //    #define     NORMAL_QUANTI_CHROMI_TABLE_MASK     0x000007C0
+    //#define     NORMAL_QUANTI_LUMI_TABLE                0x00000800  //Bit[15:11] Normal video quality mode JPEG DCT lumi quantination table
+    //    #define     NORMAL_QUANTI_LUMI_TABLE_BIT        11
+    //    #define     NORMAL_QUANTI_LUMI_TABLE_MASK       0x0000F800
+    //#define     HIGH_QUALITY_EN                         0x00010000  //Bit[16] High video quality mode enable
+    //    #define     EN_HIGH_QUALITY                     1   //Enable
+    //#define     UV_CIR656_FORMAT                        0x00080000  //Bit[19] UV fromat
+    //    #define     USE_UV_CIR656                       1   //recommand
+    //#define     HUFFMAN_TABLE_SELECT                    0x00100000  //Bit[20] JPEG Huffman table combination
+    //    #define     DUAL_TABLE                          0   //Dual Y, UV table
+    //    #define     SINGLE_TABLE                        1   //Single Y table
+    //    #define     SINGLE_UV_TABLE                     0x00200000  //1x: Single UV table
+    //#define     HIGH_QUANTI_CHROMI_TABLE                0x00400000  //Bit[26:22] High quality JPEG DCT chromi quantization table
+    //    #define     HIGH_QUANTI_CHROMI_TABLE_BIT        22
+    //    #define     HIGH_QUANTI_CHROMI_TABLE_MASK       0x07C00000                
+    //#define     HIGH_DEQUANTI_VALUE                     0x00400000  //Bit[26:22] High quality de-quantization value
+    //    #define     HIGH_DEQUANTI_VALUE_BIT             22
+    //    #define     HIGH_DEQUANTI_VALUE_MASK            0x07C00000        
+    //#define     HIGH_QUANTI_LUMI_TABLE                  0x08000000  //Bit[31:27] High quality JPEG DCT lumi quantization table
+    //    #define     HIGH_QUANTI_LUMI_TABLE_BIT          27
+    //    #define     HIGH_QUANTI_LUMI_TABLE_MASK         0xF8000000
+    //#define     BEST_DEQUANTI_VALUE                     0x08000000  //Bit[31:27] Best quality de-quantization value
+    //    #define     BEST_QUANTI_VALUE_BIT               27
+    //    #define     BEST_QUANTI_VALUE_MASK              0xF8000000
+    
+#define     VIDEOM_QUANTI_TABLE_LOW_REG                 0x264 + VIDEOBASE_OFFSET     //Match with 0x60 Bit[10:6], Bit[15:11]
+//    #define     QUANTI_CHROMI_TABLE_LOW                 0x00000001  //Bit[4:0] Normal video low quality block chromi quantization table
+//        #define     QUANTI_CHROMI_TABLE_LOW_BIT         0
+//        #define     QUANTI_CHROMI_TABLE_LOW_MASK        0x0000001F
+//    #define     QUANTI_LUMI_TABLE_LOW                   0x00000020  //Bit[9:5] Normal video low quality block lumi quantization table
+//        #define     QUANTI_CHROMI_TABLE_LOW_BIT         5
+//        #define     QUANTI_CHROMI_TABLE_LOW_MASK        0x000003E0
+
+#define     VIDEOM_QUANTI_VALUE_REG                     0x268 + VIDEOBASE_OFFSET     //Match with 0x60 Bit[26:22],Bit[31:27]
+//    #define     HIGH_QUANTI_VALUE                       0x00000001  //Bit[14:0] High quality quantization value. Format is 1.14
+//        #define     HIGH_QUANTI_VALUE_BIT               0
+//        #define     HIGH_QUANTI_VALUE_MASK              0x00007FFF
+//    #define     BEST_QUANTI_VALUE                       0x00010000  //Bit[30:16] Best quality quantization value. Format is 1.14
+//        #define     BEST_QUANTI_VALUE_BIT               16
+//        #define     BEST_QUANTI_VALUE_MASK              0x7FFF0000
+    
+#define     VIDEOM_BSD_PARA_REG                         0x26C + VIDEOBASE_OFFSET    //Video BSD Parameters Register    
+//    #define     BSD_HIGH_THRES                          0x00000001  //Bit[7:0] Block sharpness detection high threshold
+//    #define     BSD_HIGH_THRES_BIT                      0
+//    #define     BSD_HIGH_THRES_MASK                     0x000000FF
+//    #define     BSD_LOW_THRES                           0x00000100  //Bit[15:8] Block shaprpness detection low threshold
+//    #define     BSD_LOW_THRES_BIT                       8
+//    #define     BSD_LOW_THRES_MASK                      0x0000FF00
+//    #define     BSD_HIGH_COUNTS                         0x00010000  //Bit[21:16] Block sharpness detection high counts threshold
+//    #define     BSD_HIGH_COUNTS_BIT                     16
+//    #define     BSD_HIGH_COUNTS_MASK                    0x003F0000
+//    #define     BSD_LOW_COUNTS                          0x01000000  //Bit[27:24] Block sharpness detection low counts threshold
+//    #define     BSD_LOW_COUNTS_BIT                      24
+//    #define     BSD_LOW_COUNTS_MASK                     0x3F000000
+
+#define VIDEOM_COMPRESS_FRAME_SIZE_REG					  0x270 + VIDEOBASE_OFFSET
+//    #define     COMPRESS_FRAME_SIZE_READ                0x00000001  //Bit[19:0] Video compression frame size read back(number of DW)
+//    #define     COMPRESS_FRAME_SIZE_READ_BIT            0
+//    #define     COMPRESS_FRAME_SIZE_READ_MASK           0x000FFFFF
+
+#define     VIDEOM_COMPRESS_BLOCK_COUNT_REG				  0x274 + VIDEOBASE_OFFSET
+//    #define     COMPRESS_BLOCK_COUNT_READ               0x00000001  //Bit[15:0] Video compress block counter read back(number of blocks)
+//    #define     COMPRESS_BLOCK_COUNT_READ_BIT           0
+//    #define     COMPRESS_BLOCK_COUNT_READ_MASK          0x0000FFFF
+
+#define     VIDEOM_COMPRESS_FRAME_END_READ              0x278 + VIDEOBASE_OFFSET     //Video compression stream frame end pointer    
+    //#define     COMPRESS_FRAME_END_READ_ALIGN           7
+    //#define     COMPRESS_FRAME_END_READ_MASK            0x003FFFFF
+    
+#define     VIDEOM_USER_DEFINE_HEADER_REG			      0x280 + VIDEOBASE_OFFSET
+//    #define     USER_DEFINE_HEADER                      0x00000001  //Bit[15:0] Video user defined header parameter
+//    #define     USER_DEFINE_HEADER_BIT                  0
+//    #define     USER_DEFINE_HEADER_MASK                 0x0000FFFF
+
+/******  VR300-VR3FC: General Control registers  *****/
+#define     VIDEO_CONTROL_REG                           0x300 + VIDEOBASE_OFFSET
+    #define     CODEC_DECOMPRESS_MODE                   0x00000001  //Bit[0] Codec in de-compression mode
+        #define     CODEC_DECOMPRESS_MODE_BIT           0
+        #define     CODEC_DECOMPRESS_MODE_MASK          0x00000001 
+        #define     COMPRESS_MODE                       0
+        #define     DECOMPRESS_MODE                     1
+    #define     VIDEO_SAFE_MODE							0x00000002  //Bit[1] VIDEO SAFE MODE
+		#define     VIDEO_SAFE_MODE_BIT					1
+		#define     VIDEO_SAFE_MODE_OFF		            0
+        #define     VIDEO_SAFE_MODE_ON		            1
+    #define     DELAY_VSYNC								0x00000004  //Bit[2] Delay Internal VSYNC
+        #define     DELAY_VSYNC_BIT                     2
+        #define     DELAY_VSYNC_MASK                    (1<<2)
+		#define		DELAY_VSYNC_OFF						(0<<2)
+		#define		DELAY_VSYNC_EN						(1<<2)
+    #define     VER_DOWNSCALING_LINE_BUFFER_EN          0x00000010  //Bit[5:4] Video vertical downscaling line buffer enable
+		#define		VER_LINE_BUFFER_MASK				(3<<4)
+        #define     LINE_BUFFER_OFF                     (0<<4)
+        #define     LINE_BUFFER_VIDEO1                  1
+        #define     LINE_BUFFER_VIDEO2                  2
+        #define     LINE_BUFFER_VIDEOM                  3
+    #define     RC4_KEY_BUFFER_SELECTION				(1UL<<6)  //Bit[7:6] RC4 Key Buffer Selection
+		#define		RC4_KEY_BUFFER_SELECTION_BIT		6
+		#define		RC4_KEY_BUFFER_SELECTION_MASK		(3UL<<6)
+        #define     RC4_KEY_BUFFER_VIDEO1               0
+        #define     RC4_KEY_BUFFER_VIDEO2               1
+        #define     RC4_KEY_BUFFER_VIDEOM               2
+    #define     RC4_INIT_RESET							(1UL<<8)  //Bit[8] RC4 initial reset
+		#define     RC4_INIT_RESET_BIT					8
+		#define     RC4_INIT_RESET_MASK					(1UL<<8)
+		#define     RC4_NORMAL_MODE						0
+		#define     RC4_RESET_COUNTER					1
+    #define     RC4_TEST_MODE							(1UL<<9)  //Bit[9] RC4 test mode
+		#define     RC4_TEST_MODE_BIT					9
+		#define     RC4_TEST_OFF						0
+		#define     RC4_TEST_ON							1
+    #define     RC4_SAVE_MODE							(1UL<<14)  //Bit[14] RC4 save mode
+		#define     RC4_SAVE_MODE_BIT					14
+		#define     RC4_SAVE_MODE_MASK					(1UL<<14)
+		#define     RC4_SAVE_MODE_OFF					0
+		#define     RC4_SAVE_MODE_ON					1
+    #define     RC4_NO_RESET_FRAME						(1UL<<15)  //Bit[15] RC4 no reset when frame completed
+		#define     RC4_NO_RESET_FRAME_BIT				15
+		#define     RC4_NO_RESET_FRAME_MASK				(1UL<<15)
+		#define     RC4_NO_RESET_FRAME_OFF				0		//Always reset
+		#define     RC4_NO_RESET_FRAME_ON				1
+
+#define VIDEO_INT_CONTROL_EN_REG                        0x304 + VIDEOBASE_OFFSET
+    #define     VIDEO1_WATCH_DOG_INT_EN                 0x00000001  //Bit[0] Enable Video1 mode detection watch dog out of lock interrupt
+    #define     VIDEO1_INPUT_COMPLETE_INT_EN            0x00000002  //Bit[1] Enable Video1 video input complete interrupt  (frame complete only for frame mode)
+    #define     VIDEO1_PACKET_READY_INT_EN              0x00000004  //Bit[2] Enable Video1 packet ready interrupt
+    #define     VIDEO1_COMPRESS_COMPLETE_INT_EN         0x00000008  //Bit[3] Enable Video1 compression complete interrupt
+    #define     VIDEO1_MODE_DETECTION_READY_INT_EN      0x00000010  //Bit[4] Enable video1 mode detection ready interrupt
+    #define     VIDEO1_FRAME_COMPLETE_INT_EN            0x00000020  //Bit[5] Enable Video1 frame complete interrupt     (only for stream mode)
+    #define     VIDEO1_STREAM_ERR_INT_EN                0x00000040  //Bit[6] Enable Video1 decode stream error interrupt
+    #define     VIDEO2_WATCH_DOG_INT_EN                 0x00000100  //Bit[8] Enable Video2 mode detection watch dog out of lock interrupt
+    #define     VIDEO2_INPUT_COMPLETE_INT_EN            0x00000200  //Bit[9] Enable Video2 video input complete interrupt  (frame complete only for frame mode)
+    #define     VIDEO2_PACKET_READY_INT_EN              0x00000400  //Bit[10] Enable Video2 packet ready interrupt
+    #define     VIDEO2_COMPRESS_COMPLETE_INT_EN         0x00000800  //Bit[11] Enable Video2 compression complete interrupt
+    #define     VIDEO2_MODE_DETECTION_READY_INT_EN      0x00001000  //Bit[12] Enable video2 mode detection ready interrupt
+    #define     VIDEO2_FRAME_COMPLETE_INT_EN            0x00002000  //Bit[13] Enable Video2 frame complete interrupt    (only for stream mode)
+    #define     VIDEO2_STREAM_ERR_INT_EN                0x00004000  //Bit[14] Enable Video2 decode stream error interrupt
+    #define     VIDEOM_INPUT_COMPLETE_INT_EN            0x00010000  //Bit[16] Enable VideoM video input complete interrupt
+    #define     VIDEOM_COMPRESS_COMPLETE_INT_EN         0x00020000  //Bit[17] Enable VideoM compression complete interrupt
+	#define     VIDEOM_PACKET_READY_INT_EN				0x00040000  //Bit[18] Enable VideoM packet ready interrupt
+	#define     VIDEOM_FRAME_COMPLETE_INT_EN            0x00080000  //Bit[19] Enable VideoM frame complete interrupt    (only for stream mode)
+    
+#define VIDEO_INT_CONTROL_READ_REG                      0x308 + VIDEOBASE_OFFSET //Clear when write 1
+    #define     VIDEO1_WATCH_DOG_READ                   0x00000001  //Bit[0] Video1 mode detection watch dog out of lock interrupt status read back
+        #define     VIDEO1_WATCH_DOG_BIT				0
+        #define     VIDEO1_WATCH_DOG_MASK				0x00000001
+    #define     VIDEO1_INPUT_COMPLETE_READ              0x00000002  //Bit[1] Video1 video input complete interrupt status read back (frame complete only for frame mode)
+        #define     VIDEO1_INPUT_COMPLETE_BIT			1
+        #define     VIDEO1_INPUT_COMPLETE_MASK			0x00000002
+    #define     VIDEO1_PACKET_READY_READ                0x00000004  //Bit[2] Video1 packet ready interrupt status read back
+        #define     VIDEO1_PACKET_READY_BIT		        2
+        #define     VIDEO1_PACKET_READY_MASK		    0x00000004
+    #define     VIDEO1_COMPRESS_COMPLETE_READ           0x00000008  //Bit[3] Video1 compression complete interrupt status read back
+        #define     VIDEO1_COMPRESS_COMPLETE_BIT		3
+        #define     VIDEO1_COMPRESS_COMPLETE_MASK		0x00000008
+    #define     VIDEO1_MODE_DETECTION_READY_READ        0x00000010  //Bit[4] Video1 mode detection ready interrupt status read back
+        #define     VIDEO1_MODE_DETECTION_READY_BIT     4
+    #define     VIDEO1_FRAME_COMPLETE_READ              0x00000020  //Bit[5] Video1 frame complete interrupt status read back
+        #define     VIDEO1_FRAME_COMPLETE_BIT			5
+        #define     VIDEO1_FRAME_COMPLETE_MASK			0x00000020
+    #define     VIDEO1_STREAM_ERR_READ                  0x00000040  //Bit[6] Video1 decode stream error interrupt status read back
+        #define     VIDEO1_STREAM_ERR_BIT				6
+        #define     VIDEO1_STREAM_ERR_MASK				0x00000040
+    #define     VIDEO2_WATCH_DOG_READ                   0x00000100  //Bit[8] Video2 mode detection watch dog out of lock interrupt status read back
+        #define     VIDEO2_WATCH_DOG_BIT				8
+        #define     VIDEO2_WATCH_DOG_MASK				0x00000100
+    #define     VIDEO2_INPUT_COMPLETE_READ              0x00000200  //Bit[9] Video2 video input complete interrupt status read back (frame complete only for frame mode)
+        #define     VIDEO2_INPUT_COMPLETE_BIT			9
+        #define     VIDEO2_INPUT_COMPLETE_MASK			0x00000200
+    #define     VIDEO2_PACKET_READY_READ                0x00000400  //Bit[10] Video2 packet ready interrupt status read back
+        #define     VIDEO2_PACKET_READY_BIT		        10
+        #define     VIDEO2_PACKET_READY_MASK		    0x00000400
+    #define     VIDEO2_COMPRESS_COMPLETE_READ           0x00000800  //Bit[11] Video2 compression complete interrupt status read back 
+        #define     VIDEO2_COMPRESS_COMPLETE_BIT		11
+        #define     VIDEO2_COMPRESS_COMPLETE_MASK		0x00000800      
+		#define     VIDEO2_MODE_DETECTION_READY_READ    0x00001000  //Bit[12] Video2 mode detection ready interrupt status read back
+        #define     VIDEO2_MODE_DETECTION_READY_BIT     12              
+    #define     VIDEO2_FRAME_COMPLETE_READ              0x00002000  //Bit[13] Video2 frame complete interrupt status read back
+        #define     VIDEO2_FRAME_COMPLETE_BIT		    13
+        #define     VIDEO2_FRAME_COMPLETE_MASK			0x00002000
+    #define     VIDEO2_STREAM_ERR_READ                  0x00004000  //Bit[14] Video2 decode stream error interrupt status read back
+        #define     VIDEO2_STREAM_ERR_BIT				14
+        #define     VIDEO2_STREAM_ERR_MASK				0x00004000
+    //need check spec
+    #define     VIDEOM_INPUT_COMPLETE_READ              0x00010000  //Bit[16] VideoM video input complete interrupt status read back
+        #define     VIDEOM_INPUT_COMPLETE_BIT			16
+        #define     VIDEOM_INPUT_COMPLETE_MASK			0x00010000
+    #define     VIDEOM_COMPRESS_COMPLETE_READ           0x00020000  //Bit[17] VideoM compression complete interrupt status read back
+        #define     VIDEOM_COMPRESS_COMPLETE_BIT		17
+        #define     VIDEOM_COMPRESS_COMPLETE_MASK		0x00020000
+    #define     VIDEOM_PACKET_READY_READ                0x00040000  //Bit[18] Clear Packet ready interrupt when write 1
+        #define     VIDEOM_PACKET_READY_BIT             18
+        #define     VIDEOM_PACKET_READY_MASK            0x00040000    
+    #define     VIDEOM_FRAME_COMPLETE_READ              0x00080000  //Bit[19] Clear Frame complete interrupt when write 1
+        #define     VIDEOM_FRAME_COMPLETE_BIT           19
+        #define     VIDEOM_FRAME_COMPLETE_MASK          0x00080000
+   
+#define VIDEO_INT_CONTROL_CLEAR_REG                     0x308 + VIDEOBASE_OFFSET //Clear when write 1
+    //Clear when write 1
+    #define     VIDEO1_WATCH_DOG_CLEAR                  0x00000001  //Bit[0] Clear mode detection watch dog out of lock interrupt when write 1
+    #define     VIDEO1_INPUT_COMPLETE_CLEAR             0x00000002  //Bit[1] Clear video input complete interrupt when write 1 (frame complete only for frame mode)
+    #define     VIDEO1_PACKET_READY_CLEAR               0x00000004  //Bit[2] Clear Packet ready interrupt when write 1
+        #define     VIDEO1_PACKET_READY_CLEAR_BIT       2
+        #define     VIDEO1_PACKET_READY_CLEAR_MASK      0x00000004
+    #define     VIDEO1_COMPRESS_COMPLETE_CLEAR          0x00000008  //Bit[3] Clear video compression interrupt when write 1
+    #define     VIDEO1_MODE_DETECTION_READY_CLEAR       0x00000010  //Bit[4] Clear Video1 Mode detection ready interrupt when write 1
+    #define     VIDEO1_FRAME_COMPLETE_CLEAR             0x00000020  //Bit[5] Clear Frame complete interrupt when write 1
+        #define     VIDEO1_FRAME_COMPLETE_CLEAR_BIT     5
+        #define     VIDEO1_FRAME_COMPLETE_CLEAR_MASK    0x00000020
+    #define     VIDEO1_STREAM_ERR_CLEAR                 0x00000040  //Bit[6] Clear decode stream error interrupt when write 1
+    #define     VIDEO2_WATCH_DOG_CLEAR                  0x00000100  //Bit[8] Clear Mode detection interrupt when write 1
+    #define     VIDEO2_INPUT_COMPLETE_CLEAR             0x00000200  //Bit[9] Clear video input complete interrupt when write 1
+    #define     VIDEO2_PACKET_READY_CLEAR               0x00000400  //Bit[10] Clear packet ready interrupt when write 1
+    #define     VIDEO2_COMPRESS_COMPLETE_CLEAR          0x00000800  //Bit[11] Clear video compression complete interrupt when write 1
+    #define     VIDEO2_MODE_DETECTION_READY_CLEAR       0x00001000  //Bit[12] Clear Video2 Mode detection ready interrupt when write 1
+    #define     VIDEO2_FRAME_COMPLETE_CLEAR             0x00002000  //Bit[13] Clear Frame complete interrupt when write 1 (frame complete only for frame mode)
+    #define     VIDEO2_STREAM_ERR_CLEAR                 0x00004000  //Bit[14] Clear Decode stream error interrupt when write 1
+    //need check spec
+    #define     VIDEOM_INPUT_COMPLETE_CLEAR             0x00010000  //Bit[16] Clear video input complete interrupt when write 1
+    #define     VIDEOM_COMPRESS_COMPLETE_CLEAR          0x00020000  //Bit[17] Clear compression complete interrupt when write 1
+        #define     VIDEOM_COMPRESS_COMPLETE_CLEAR_BIT  17
+        #define     VIDEOM_COMPRESS_COMPLETE_CLEAR_MASK 0x00020000    
+	#define     VIDEOM_PACKET_READY_CLEAR				0x00040000  //Bit[18] Clear compression complete interrupt when write 1
+        #define     VIDEOM_PACKET_READY_CLEAR_BIT       18
+        #define     VIDEOM_PACKET_READY_CLEAR_MASK      0x00040000    
+    #define     VIDEOM_FRAME_COMPLETE_CLEAR             0x00100000  //Bit[20] Clear Frame complete interrupt when write 1
+        #define     VIDEOM_FRAME_COMPLETE_CLEAR_BIT     20
+        #define     VIDEOM_FRAME_COMPLETE_CLEAR_MASK    0x00100000
+    #define     VIDEOM_STREAM_ERR_CLEAR                 0x00200000  //Bit[21] Clear decode stream error interrupt when write 1
+    
+#define VIDEO_MODE_DETECTION_PARAM_REG                  0x30C + VIDEOBASE_OFFSET
+    #define     EDGE_PIXEL_THRES_BIT                    8           //Bit[15:8] Mode detection edge pixel threshold
+    #define     EDGE_PIXEL_THRES_MASK                   0x0000FF00  
+    #define     VER_STABLE_MAX_BIT                      16          //Bit[19:16] Mode detection vertical stable maximum
+    #define     VER_STABLE_MAX_BIT_MASK                 0x000F0000  
+    #define     HOR_STABLE_MAX_BIT                      20          //Bit[23:20] Mode detection horizontal stable maximum
+    #define     HOR_STABLE_MAX_BIT_MASK                 0x00F00000
+    #define     VER_STABLE_THRES_BIT                    24          //Bit[27:24] Mode detection vertical stable threshold
+    #define     VER_STABLE_THRES_BIT_MASK               0x0F000000  
+    #define     HOR_STABLE_THRES_BIT                    28          //Bit[31:28] Mode detection horizontal stable threshold
+    #define     HOR_STABLE_THRES_BIT_MASK               0xF0000000
+    
+#define VIDEO_CRC_PRIMARY_REG                           0x320 + VIDEOBASE_OFFSET
+    #define     CRC_CHECK_EN                            0x00000001  //Bit[0] Video port 1/2 Enable video capture write CRC check
+        #define     CRC_CHECK_EN_BIT                    0
+    #define     CRC_CHECK_HIGH                          0x00000002  //Bit[1] Video port 1/2 CRC check high bit only
+        #define     CRC_CHECK_HIGH_BIT                  1
+    #define     SKIP_COUNT_MAX                          0x00000004  //Bit[7:2] Video port 1/2 Max capture write skip count
+        #define     SKIP_COUNT_MAX_BIT                  2
+        #define     SKIP_COUNT_MAX_MASK                 0x000000FC
+    #define     CRC_PRIMARY_POLY_LOW                    0x00000100  //Bit[15:8] Primary CRC low 8-bit polynomial
+        #define     CRC_RIMARY_POLY_LOW_BIT             8
+        #define     CRC_RIMARY_POLY_LOW_MASK            0x0000FF00
+    #define     CRC_PRIMARY_POLY_HIGH                   0x00010000  //Bit[31:16] Primary CRC high 8-bit polynomial
+        #define     CRC_RIMARY_POLY_HIGH_BIT            16
+        #define     CRC_RIMARY_POLY_HIGH_MASK           0xFFFF0000
+        
+
+#define VIDEO_CRC_SECOND_REG                            0x324 + VIDEOBASE_OFFSET
+    #define     CRC_SECOND_POLY_LOW                     0x00000100  //Bit[15:8] Secondary CRC low 8-bit polynomial
+        #define     CRC_SECOND_POLY_LOW_BIT             8
+        #define     CRC_SECOND_POLY_LOW_MASK            0x0000FF00
+    #define     CRC_SECOND_POLY_HIGH                    0x00010000  //Bit[31:16] Secondary CRC high 8-bit polynomial
+        #define     CRC_SECOND_POLY_HIGH_BIT            16
+        #define     CRC_SECOND_POLY_HIGH_MASK           0xFFFF0000
+
+#define VIDEO1_RC4_KEYS_REG                              0x400 + VIDEOBASE_OFFSET //Total Video1 RC4 Keys     
+#define VIDEO2_RC4_KEYS_REG                              0x500 + VIDEOBASE_OFFSET //Total Video2 RC4 Keys     
+#define VIDEOM_RC4_KEYS_REG                              0x600 + VIDEOBASE_OFFSET //Total VideoM RC4 Keys     
+
+#endif /* end of _VREG_H_ */
+
diff --git a/board/aspeed/ast2400/Makefile b/board/aspeed/ast2400/Makefile
new file mode 100644
index 0000000..1970ea1
--- /dev/null
+++ b/board/aspeed/ast2400/Makefile
@@ -0,0 +1,44 @@
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS   := ast2400.o flash.o flash_spi.o pci.o crc32.o slt.o regtest.o vfun.o vhace.o crt.o videotest.o mactest.o hactest.o mictest.o
+
+ifeq ($(CONFIG_FPGA_ASPEED),y)
+SOBJS   := platform_fpga.o
+else ifeq ($(CONFIG_SLT_ASPEED),y)
+SOBJS	:= platform_slt.o
+else
+SOBJS   := platform.o
+endif
+
+SRCS    := $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS    := $(addprefix $(obj),$(COBJS))
+SOBJS   := $(addprefix $(obj),$(SOBJS))
+
+$(LIB): $(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude .depend
+
+#########################################################################
diff --git a/board/aspeed/ast2400/aes.c b/board/aspeed/ast2400/aes.c
new file mode 100755
index 0000000..76262e7
--- /dev/null
+++ b/board/aspeed/ast2400/aes.c
@@ -0,0 +1,579 @@
+/*
+ *  AES implementation
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* uncomment the following line to run the test suite */
+
+/* #define TEST */
+
+/* uncomment the following line to use pre-computed tables */
+/* otherwise the tables will be generated at the first run */
+
+#define FIXED_TABLES
+
+#ifndef FIXED_TABLES
+
+/* forward S-box & tables */
+
+uint32 FSb[256];
+uint32 FT0[256]; 
+uint32 FT1[256]; 
+uint32 FT2[256]; 
+uint32 FT3[256]; 
+
+/* reverse S-box & tables */
+
+uint32 RSb[256];
+uint32 RT0[256];
+uint32 RT1[256];
+uint32 RT2[256];
+uint32 RT3[256];
+
+/* round constants */
+
+uint32 RCON[10];
+
+/* tables generation flag */
+
+int do_init = 1;
+
+/* tables generation routine */
+
+#define ROTR8(x) ( ( ( x << 24 ) & 0xFFFFFFFF ) | \
+                   ( ( x & 0xFFFFFFFF ) >>  8 ) )
+
+#define XTIME(x) ( ( x <<  1 ) ^ ( ( x & 0x80 ) ? 0x1B : 0x00 ) )
+#define MUL(x,y) ( ( x &&  y ) ? pow[(log[x] + log[y]) % 255] : 0 )
+
+void aes_gen_tables( void )
+{
+    int i;
+    uint8 x, y;
+    uint8 pow[256];
+    uint8 log[256];
+
+    /* compute pow and log tables over GF(2^8) */
+
+    for( i = 0, x = 1; i < 256; i++, x ^= XTIME( x ) )
+    {
+        pow[i] = x;
+        log[x] = i;
+    }
+
+    /* calculate the round constants */
+
+    for( i = 0, x = 1; i < 10; i++, x = XTIME( x ) )
+    {
+        RCON[i] = (uint32) x << 24;
+    }
+
+    /* generate the forward and reverse S-boxes */
+
+    FSb[0x00] = 0x63;
+    RSb[0x63] = 0x00;
+
+    for( i = 1; i < 256; i++ )
+    {
+        x = pow[255 - log[i]];
+
+        y = x;  y = ( y << 1 ) | ( y >> 7 );
+        x ^= y; y = ( y << 1 ) | ( y >> 7 );
+        x ^= y; y = ( y << 1 ) | ( y >> 7 );
+        x ^= y; y = ( y << 1 ) | ( y >> 7 );
+        x ^= y ^ 0x63;
+
+        FSb[i] = x;
+        RSb[x] = i;
+    }
+
+    /* generate the forward and reverse tables */
+
+    for( i = 0; i < 256; i++ )
+    {
+        x = (unsigned char) FSb[i]; y = XTIME( x );
+
+        FT0[i] =   (uint32) ( x ^ y ) ^
+                 ( (uint32) x <<  8 ) ^
+                 ( (uint32) x << 16 ) ^
+                 ( (uint32) y << 24 );
+
+        FT0[i] &= 0xFFFFFFFF;
+
+        FT1[i] = ROTR8( FT0[i] );
+        FT2[i] = ROTR8( FT1[i] );
+        FT3[i] = ROTR8( FT2[i] );
+
+        y = (unsigned char) RSb[i];
+
+        RT0[i] = ( (uint32) MUL( 0x0B, y )       ) ^
+                 ( (uint32) MUL( 0x0D, y ) <<  8 ) ^
+                 ( (uint32) MUL( 0x09, y ) << 16 ) ^
+                 ( (uint32) MUL( 0x0E, y ) << 24 );
+
+        RT0[i] &= 0xFFFFFFFF;
+
+        RT1[i] = ROTR8( RT0[i] );
+        RT2[i] = ROTR8( RT1[i] );
+        RT3[i] = ROTR8( RT2[i] );
+    }
+}
+
+#else
+
+/* forward S-box */
+
+static const uint32 FSb[256] =
+{
+    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5,
+    0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
+    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0,
+    0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
+    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC,
+    0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
+    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A,
+    0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
+    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0,
+    0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
+    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B,
+    0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
+    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85,
+    0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
+    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5,
+    0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
+    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17,
+    0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
+    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88,
+    0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
+    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C,
+    0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
+    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9,
+    0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
+    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6,
+    0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
+    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E,
+    0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
+    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94,
+    0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
+    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68,
+    0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
+};
+
+/* forward tables */
+
+#define FT \
+\
+    V(C6,63,63,A5), V(F8,7C,7C,84), V(EE,77,77,99), V(F6,7B,7B,8D), \
+    V(FF,F2,F2,0D), V(D6,6B,6B,BD), V(DE,6F,6F,B1), V(91,C5,C5,54), \
+    V(60,30,30,50), V(02,01,01,03), V(CE,67,67,A9), V(56,2B,2B,7D), \
+    V(E7,FE,FE,19), V(B5,D7,D7,62), V(4D,AB,AB,E6), V(EC,76,76,9A), \
+    V(8F,CA,CA,45), V(1F,82,82,9D), V(89,C9,C9,40), V(FA,7D,7D,87), \
+    V(EF,FA,FA,15), V(B2,59,59,EB), V(8E,47,47,C9), V(FB,F0,F0,0B), \
+    V(41,AD,AD,EC), V(B3,D4,D4,67), V(5F,A2,A2,FD), V(45,AF,AF,EA), \
+    V(23,9C,9C,BF), V(53,A4,A4,F7), V(E4,72,72,96), V(9B,C0,C0,5B), \
+    V(75,B7,B7,C2), V(E1,FD,FD,1C), V(3D,93,93,AE), V(4C,26,26,6A), \
+    V(6C,36,36,5A), V(7E,3F,3F,41), V(F5,F7,F7,02), V(83,CC,CC,4F), \
+    V(68,34,34,5C), V(51,A5,A5,F4), V(D1,E5,E5,34), V(F9,F1,F1,08), \
+    V(E2,71,71,93), V(AB,D8,D8,73), V(62,31,31,53), V(2A,15,15,3F), \
+    V(08,04,04,0C), V(95,C7,C7,52), V(46,23,23,65), V(9D,C3,C3,5E), \
+    V(30,18,18,28), V(37,96,96,A1), V(0A,05,05,0F), V(2F,9A,9A,B5), \
+    V(0E,07,07,09), V(24,12,12,36), V(1B,80,80,9B), V(DF,E2,E2,3D), \
+    V(CD,EB,EB,26), V(4E,27,27,69), V(7F,B2,B2,CD), V(EA,75,75,9F), \
+    V(12,09,09,1B), V(1D,83,83,9E), V(58,2C,2C,74), V(34,1A,1A,2E), \
+    V(36,1B,1B,2D), V(DC,6E,6E,B2), V(B4,5A,5A,EE), V(5B,A0,A0,FB), \
+    V(A4,52,52,F6), V(76,3B,3B,4D), V(B7,D6,D6,61), V(7D,B3,B3,CE), \
+    V(52,29,29,7B), V(DD,E3,E3,3E), V(5E,2F,2F,71), V(13,84,84,97), \
+    V(A6,53,53,F5), V(B9,D1,D1,68), V(00,00,00,00), V(C1,ED,ED,2C), \
+    V(40,20,20,60), V(E3,FC,FC,1F), V(79,B1,B1,C8), V(B6,5B,5B,ED), \
+    V(D4,6A,6A,BE), V(8D,CB,CB,46), V(67,BE,BE,D9), V(72,39,39,4B), \
+    V(94,4A,4A,DE), V(98,4C,4C,D4), V(B0,58,58,E8), V(85,CF,CF,4A), \
+    V(BB,D0,D0,6B), V(C5,EF,EF,2A), V(4F,AA,AA,E5), V(ED,FB,FB,16), \
+    V(86,43,43,C5), V(9A,4D,4D,D7), V(66,33,33,55), V(11,85,85,94), \
+    V(8A,45,45,CF), V(E9,F9,F9,10), V(04,02,02,06), V(FE,7F,7F,81), \
+    V(A0,50,50,F0), V(78,3C,3C,44), V(25,9F,9F,BA), V(4B,A8,A8,E3), \
+    V(A2,51,51,F3), V(5D,A3,A3,FE), V(80,40,40,C0), V(05,8F,8F,8A), \
+    V(3F,92,92,AD), V(21,9D,9D,BC), V(70,38,38,48), V(F1,F5,F5,04), \
+    V(63,BC,BC,DF), V(77,B6,B6,C1), V(AF,DA,DA,75), V(42,21,21,63), \
+    V(20,10,10,30), V(E5,FF,FF,1A), V(FD,F3,F3,0E), V(BF,D2,D2,6D), \
+    V(81,CD,CD,4C), V(18,0C,0C,14), V(26,13,13,35), V(C3,EC,EC,2F), \
+    V(BE,5F,5F,E1), V(35,97,97,A2), V(88,44,44,CC), V(2E,17,17,39), \
+    V(93,C4,C4,57), V(55,A7,A7,F2), V(FC,7E,7E,82), V(7A,3D,3D,47), \
+    V(C8,64,64,AC), V(BA,5D,5D,E7), V(32,19,19,2B), V(E6,73,73,95), \
+    V(C0,60,60,A0), V(19,81,81,98), V(9E,4F,4F,D1), V(A3,DC,DC,7F), \
+    V(44,22,22,66), V(54,2A,2A,7E), V(3B,90,90,AB), V(0B,88,88,83), \
+    V(8C,46,46,CA), V(C7,EE,EE,29), V(6B,B8,B8,D3), V(28,14,14,3C), \
+    V(A7,DE,DE,79), V(BC,5E,5E,E2), V(16,0B,0B,1D), V(AD,DB,DB,76), \
+    V(DB,E0,E0,3B), V(64,32,32,56), V(74,3A,3A,4E), V(14,0A,0A,1E), \
+    V(92,49,49,DB), V(0C,06,06,0A), V(48,24,24,6C), V(B8,5C,5C,E4), \
+    V(9F,C2,C2,5D), V(BD,D3,D3,6E), V(43,AC,AC,EF), V(C4,62,62,A6), \
+    V(39,91,91,A8), V(31,95,95,A4), V(D3,E4,E4,37), V(F2,79,79,8B), \
+    V(D5,E7,E7,32), V(8B,C8,C8,43), V(6E,37,37,59), V(DA,6D,6D,B7), \
+    V(01,8D,8D,8C), V(B1,D5,D5,64), V(9C,4E,4E,D2), V(49,A9,A9,E0), \
+    V(D8,6C,6C,B4), V(AC,56,56,FA), V(F3,F4,F4,07), V(CF,EA,EA,25), \
+    V(CA,65,65,AF), V(F4,7A,7A,8E), V(47,AE,AE,E9), V(10,08,08,18), \
+    V(6F,BA,BA,D5), V(F0,78,78,88), V(4A,25,25,6F), V(5C,2E,2E,72), \
+    V(38,1C,1C,24), V(57,A6,A6,F1), V(73,B4,B4,C7), V(97,C6,C6,51), \
+    V(CB,E8,E8,23), V(A1,DD,DD,7C), V(E8,74,74,9C), V(3E,1F,1F,21), \
+    V(96,4B,4B,DD), V(61,BD,BD,DC), V(0D,8B,8B,86), V(0F,8A,8A,85), \
+    V(E0,70,70,90), V(7C,3E,3E,42), V(71,B5,B5,C4), V(CC,66,66,AA), \
+    V(90,48,48,D8), V(06,03,03,05), V(F7,F6,F6,01), V(1C,0E,0E,12), \
+    V(C2,61,61,A3), V(6A,35,35,5F), V(AE,57,57,F9), V(69,B9,B9,D0), \
+    V(17,86,86,91), V(99,C1,C1,58), V(3A,1D,1D,27), V(27,9E,9E,B9), \
+    V(D9,E1,E1,38), V(EB,F8,F8,13), V(2B,98,98,B3), V(22,11,11,33), \
+    V(D2,69,69,BB), V(A9,D9,D9,70), V(07,8E,8E,89), V(33,94,94,A7), \
+    V(2D,9B,9B,B6), V(3C,1E,1E,22), V(15,87,87,92), V(C9,E9,E9,20), \
+    V(87,CE,CE,49), V(AA,55,55,FF), V(50,28,28,78), V(A5,DF,DF,7A), \
+    V(03,8C,8C,8F), V(59,A1,A1,F8), V(09,89,89,80), V(1A,0D,0D,17), \
+    V(65,BF,BF,DA), V(D7,E6,E6,31), V(84,42,42,C6), V(D0,68,68,B8), \
+    V(82,41,41,C3), V(29,99,99,B0), V(5A,2D,2D,77), V(1E,0F,0F,11), \
+    V(7B,B0,B0,CB), V(A8,54,54,FC), V(6D,BB,BB,D6), V(2C,16,16,3A)
+
+#define V(a,b,c,d) 0x##a##b##c##d
+static const uint32 FT0[256] = { FT };
+#undef V
+
+#define V(a,b,c,d) 0x##d##a##b##c
+static const uint32 FT1[256] = { FT };
+#undef V
+
+#define V(a,b,c,d) 0x##c##d##a##b
+static const uint32 FT2[256] = { FT };
+#undef V
+
+#define V(a,b,c,d) 0x##b##c##d##a
+static const uint32 FT3[256] = { FT };
+#undef V
+
+#undef FT
+
+/* reverse S-box */
+
+static const uint32 RSb[256] =
+{
+    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38,
+    0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
+    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87,
+    0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
+    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D,
+    0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
+    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2,
+    0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
+    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16,
+    0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
+    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA,
+    0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
+    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A,
+    0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
+    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02,
+    0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
+    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA,
+    0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
+    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85,
+    0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
+    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89,
+    0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
+    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20,
+    0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
+    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31,
+    0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
+    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D,
+    0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
+    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0,
+    0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
+    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26,
+    0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
+};
+
+/* reverse tables */
+
+#define RT \
+\
+    V(51,F4,A7,50), V(7E,41,65,53), V(1A,17,A4,C3), V(3A,27,5E,96), \
+    V(3B,AB,6B,CB), V(1F,9D,45,F1), V(AC,FA,58,AB), V(4B,E3,03,93), \
+    V(20,30,FA,55), V(AD,76,6D,F6), V(88,CC,76,91), V(F5,02,4C,25), \
+    V(4F,E5,D7,FC), V(C5,2A,CB,D7), V(26,35,44,80), V(B5,62,A3,8F), \
+    V(DE,B1,5A,49), V(25,BA,1B,67), V(45,EA,0E,98), V(5D,FE,C0,E1), \
+    V(C3,2F,75,02), V(81,4C,F0,12), V(8D,46,97,A3), V(6B,D3,F9,C6), \
+    V(03,8F,5F,E7), V(15,92,9C,95), V(BF,6D,7A,EB), V(95,52,59,DA), \
+    V(D4,BE,83,2D), V(58,74,21,D3), V(49,E0,69,29), V(8E,C9,C8,44), \
+    V(75,C2,89,6A), V(F4,8E,79,78), V(99,58,3E,6B), V(27,B9,71,DD), \
+    V(BE,E1,4F,B6), V(F0,88,AD,17), V(C9,20,AC,66), V(7D,CE,3A,B4), \
+    V(63,DF,4A,18), V(E5,1A,31,82), V(97,51,33,60), V(62,53,7F,45), \
+    V(B1,64,77,E0), V(BB,6B,AE,84), V(FE,81,A0,1C), V(F9,08,2B,94), \
+    V(70,48,68,58), V(8F,45,FD,19), V(94,DE,6C,87), V(52,7B,F8,B7), \
+    V(AB,73,D3,23), V(72,4B,02,E2), V(E3,1F,8F,57), V(66,55,AB,2A), \
+    V(B2,EB,28,07), V(2F,B5,C2,03), V(86,C5,7B,9A), V(D3,37,08,A5), \
+    V(30,28,87,F2), V(23,BF,A5,B2), V(02,03,6A,BA), V(ED,16,82,5C), \
+    V(8A,CF,1C,2B), V(A7,79,B4,92), V(F3,07,F2,F0), V(4E,69,E2,A1), \
+    V(65,DA,F4,CD), V(06,05,BE,D5), V(D1,34,62,1F), V(C4,A6,FE,8A), \
+    V(34,2E,53,9D), V(A2,F3,55,A0), V(05,8A,E1,32), V(A4,F6,EB,75), \
+    V(0B,83,EC,39), V(40,60,EF,AA), V(5E,71,9F,06), V(BD,6E,10,51), \
+    V(3E,21,8A,F9), V(96,DD,06,3D), V(DD,3E,05,AE), V(4D,E6,BD,46), \
+    V(91,54,8D,B5), V(71,C4,5D,05), V(04,06,D4,6F), V(60,50,15,FF), \
+    V(19,98,FB,24), V(D6,BD,E9,97), V(89,40,43,CC), V(67,D9,9E,77), \
+    V(B0,E8,42,BD), V(07,89,8B,88), V(E7,19,5B,38), V(79,C8,EE,DB), \
+    V(A1,7C,0A,47), V(7C,42,0F,E9), V(F8,84,1E,C9), V(00,00,00,00), \
+    V(09,80,86,83), V(32,2B,ED,48), V(1E,11,70,AC), V(6C,5A,72,4E), \
+    V(FD,0E,FF,FB), V(0F,85,38,56), V(3D,AE,D5,1E), V(36,2D,39,27), \
+    V(0A,0F,D9,64), V(68,5C,A6,21), V(9B,5B,54,D1), V(24,36,2E,3A), \
+    V(0C,0A,67,B1), V(93,57,E7,0F), V(B4,EE,96,D2), V(1B,9B,91,9E), \
+    V(80,C0,C5,4F), V(61,DC,20,A2), V(5A,77,4B,69), V(1C,12,1A,16), \
+    V(E2,93,BA,0A), V(C0,A0,2A,E5), V(3C,22,E0,43), V(12,1B,17,1D), \
+    V(0E,09,0D,0B), V(F2,8B,C7,AD), V(2D,B6,A8,B9), V(14,1E,A9,C8), \
+    V(57,F1,19,85), V(AF,75,07,4C), V(EE,99,DD,BB), V(A3,7F,60,FD), \
+    V(F7,01,26,9F), V(5C,72,F5,BC), V(44,66,3B,C5), V(5B,FB,7E,34), \
+    V(8B,43,29,76), V(CB,23,C6,DC), V(B6,ED,FC,68), V(B8,E4,F1,63), \
+    V(D7,31,DC,CA), V(42,63,85,10), V(13,97,22,40), V(84,C6,11,20), \
+    V(85,4A,24,7D), V(D2,BB,3D,F8), V(AE,F9,32,11), V(C7,29,A1,6D), \
+    V(1D,9E,2F,4B), V(DC,B2,30,F3), V(0D,86,52,EC), V(77,C1,E3,D0), \
+    V(2B,B3,16,6C), V(A9,70,B9,99), V(11,94,48,FA), V(47,E9,64,22), \
+    V(A8,FC,8C,C4), V(A0,F0,3F,1A), V(56,7D,2C,D8), V(22,33,90,EF), \
+    V(87,49,4E,C7), V(D9,38,D1,C1), V(8C,CA,A2,FE), V(98,D4,0B,36), \
+    V(A6,F5,81,CF), V(A5,7A,DE,28), V(DA,B7,8E,26), V(3F,AD,BF,A4), \
+    V(2C,3A,9D,E4), V(50,78,92,0D), V(6A,5F,CC,9B), V(54,7E,46,62), \
+    V(F6,8D,13,C2), V(90,D8,B8,E8), V(2E,39,F7,5E), V(82,C3,AF,F5), \
+    V(9F,5D,80,BE), V(69,D0,93,7C), V(6F,D5,2D,A9), V(CF,25,12,B3), \
+    V(C8,AC,99,3B), V(10,18,7D,A7), V(E8,9C,63,6E), V(DB,3B,BB,7B), \
+    V(CD,26,78,09), V(6E,59,18,F4), V(EC,9A,B7,01), V(83,4F,9A,A8), \
+    V(E6,95,6E,65), V(AA,FF,E6,7E), V(21,BC,CF,08), V(EF,15,E8,E6), \
+    V(BA,E7,9B,D9), V(4A,6F,36,CE), V(EA,9F,09,D4), V(29,B0,7C,D6), \
+    V(31,A4,B2,AF), V(2A,3F,23,31), V(C6,A5,94,30), V(35,A2,66,C0), \
+    V(74,4E,BC,37), V(FC,82,CA,A6), V(E0,90,D0,B0), V(33,A7,D8,15), \
+    V(F1,04,98,4A), V(41,EC,DA,F7), V(7F,CD,50,0E), V(17,91,F6,2F), \
+    V(76,4D,D6,8D), V(43,EF,B0,4D), V(CC,AA,4D,54), V(E4,96,04,DF), \
+    V(9E,D1,B5,E3), V(4C,6A,88,1B), V(C1,2C,1F,B8), V(46,65,51,7F), \
+    V(9D,5E,EA,04), V(01,8C,35,5D), V(FA,87,74,73), V(FB,0B,41,2E), \
+    V(B3,67,1D,5A), V(92,DB,D2,52), V(E9,10,56,33), V(6D,D6,47,13), \
+    V(9A,D7,61,8C), V(37,A1,0C,7A), V(59,F8,14,8E), V(EB,13,3C,89), \
+    V(CE,A9,27,EE), V(B7,61,C9,35), V(E1,1C,E5,ED), V(7A,47,B1,3C), \
+    V(9C,D2,DF,59), V(55,F2,73,3F), V(18,14,CE,79), V(73,C7,37,BF), \
+    V(53,F7,CD,EA), V(5F,FD,AA,5B), V(DF,3D,6F,14), V(78,44,DB,86), \
+    V(CA,AF,F3,81), V(B9,68,C4,3E), V(38,24,34,2C), V(C2,A3,40,5F), \
+    V(16,1D,C3,72), V(BC,E2,25,0C), V(28,3C,49,8B), V(FF,0D,95,41), \
+    V(39,A8,01,71), V(08,0C,B3,DE), V(D8,B4,E4,9C), V(64,56,C1,90), \
+    V(7B,CB,84,61), V(D5,32,B6,70), V(48,6C,5C,74), V(D0,B8,57,42)
+
+#define V(a,b,c,d) 0x##a##b##c##d
+static const uint32 RT0[256] = { RT };
+#undef V
+
+#define V(a,b,c,d) 0x##d##a##b##c
+static const uint32 RT1[256] = { RT };
+#undef V
+
+#define V(a,b,c,d) 0x##c##d##a##b
+static const uint32 RT2[256] = { RT };
+#undef V
+
+#define V(a,b,c,d) 0x##b##c##d##a
+static const uint32 RT3[256] = { RT };
+#undef V
+
+#undef RT
+
+/* round constants */
+
+static const uint32 RCON[10] =
+{
+    0x01000000, 0x02000000, 0x04000000, 0x08000000,
+    0x10000000, 0x20000000, 0x40000000, 0x80000000,
+    0x1B000000, 0x36000000
+};
+
+int do_init = 0;
+
+void aes_gen_tables( void )
+{
+}
+
+#endif
+
+/* platform-independant 32-bit integer manipulation macros */
+
+#define GET_UINT32_aes(n,b,i)                       \
+{                                               \
+    (n) = ( (uint32) (b)[(i)    ] << 24 )       \
+        | ( (uint32) (b)[(i) + 1] << 16 )       \
+        | ( (uint32) (b)[(i) + 2] <<  8 )       \
+        | ( (uint32) (b)[(i) + 3]       );      \
+}
+
+#define PUT_UINT32_aes(n,b,i)                       \
+{                                               \
+    (b)[(i)    ] = (uint8) ( (n) >> 24 );       \
+    (b)[(i) + 1] = (uint8) ( (n) >> 16 );       \
+    (b)[(i) + 2] = (uint8) ( (n) >>  8 );       \
+    (b)[(i) + 3] = (uint8) ( (n)       );       \
+}
+
+/* decryption key schedule tables */
+
+int KT_init = 1;
+
+uint32 KT0[256];
+uint32 KT1[256];
+uint32 KT2[256];
+uint32 KT3[256];
+
+/* AES key scheduling routine */
+int aes_set_key( aes_context *ctx, uint8 *key, int nbits )
+{
+    int i;
+    uint32 *RK, *SK;
+
+    if( do_init )
+    {
+        aes_gen_tables();
+
+        do_init = 0;
+    }
+
+    switch( nbits )
+    {
+        case 128: ctx->nr = 10; break;
+        case 192: ctx->nr = 12; break;
+        case 256: ctx->nr = 14; break;
+        default : return( 1 );
+    }
+
+    RK = ctx->erk;
+
+    for( i = 0; i < (nbits >> 5); i++ )
+    {
+        GET_UINT32_aes( RK[i], key, i * 4 );
+    }
+
+    /* setup encryption round keys */
+
+    switch( nbits )
+    {
+    case 128:
+
+        for( i = 0; i < 10; i++, RK += 4 )
+        {
+            RK[4]  = RK[0] ^ RCON[i] ^
+                        ( FSb[ (uint8) ( RK[3] >> 16 ) ] << 24 ) ^
+                        ( FSb[ (uint8) ( RK[3] >>  8 ) ] << 16 ) ^
+                        ( FSb[ (uint8) ( RK[3]       ) ] <<  8 ) ^
+                        ( FSb[ (uint8) ( RK[3] >> 24 ) ]       );
+
+            RK[5]  = RK[1] ^ RK[4];
+            RK[6]  = RK[2] ^ RK[5];
+            RK[7]  = RK[3] ^ RK[6];
+        }
+        break;
+
+    case 192:
+
+        for( i = 0; i < 8; i++, RK += 6 )
+        {
+            RK[6]  = RK[0] ^ RCON[i] ^
+                        ( FSb[ (uint8) ( RK[5] >> 16 ) ] << 24 ) ^
+                        ( FSb[ (uint8) ( RK[5] >>  8 ) ] << 16 ) ^
+                        ( FSb[ (uint8) ( RK[5]       ) ] <<  8 ) ^
+                        ( FSb[ (uint8) ( RK[5] >> 24 ) ]       );
+
+            RK[7]  = RK[1] ^ RK[6];
+            RK[8]  = RK[2] ^ RK[7];
+            RK[9]  = RK[3] ^ RK[8];
+            RK[10] = RK[4] ^ RK[9];
+            RK[11] = RK[5] ^ RK[10];
+        }
+        break;
+
+    case 256:
+
+        for( i = 0; i < 7; i++, RK += 8 )
+        {
+            RK[8]  = RK[0] ^ RCON[i] ^
+                        ( FSb[ (uint8) ( RK[7] >> 16 ) ] << 24 ) ^
+                        ( FSb[ (uint8) ( RK[7] >>  8 ) ] << 16 ) ^
+                        ( FSb[ (uint8) ( RK[7]       ) ] <<  8 ) ^
+                        ( FSb[ (uint8) ( RK[7] >> 24 ) ]       );
+
+            RK[9]  = RK[1] ^ RK[8];
+            RK[10] = RK[2] ^ RK[9];
+            RK[11] = RK[3] ^ RK[10];
+
+            RK[12] = RK[4] ^
+                        ( FSb[ (uint8) ( RK[11] >> 24 ) ] << 24 ) ^
+                        ( FSb[ (uint8) ( RK[11] >> 16 ) ] << 16 ) ^
+                        ( FSb[ (uint8) ( RK[11] >>  8 ) ] <<  8 ) ^
+                        ( FSb[ (uint8) ( RK[11]       ) ]       );
+
+            RK[13] = RK[5] ^ RK[12];
+            RK[14] = RK[6] ^ RK[13];
+            RK[15] = RK[7] ^ RK[14];
+        }
+        break;
+    }
+
+    /* setup decryption round keys */
+
+    if( KT_init )
+    {
+        for( i = 0; i < 256; i++ )
+        {
+            KT0[i] = RT0[ FSb[i] ];
+            KT1[i] = RT1[ FSb[i] ];
+            KT2[i] = RT2[ FSb[i] ];
+            KT3[i] = RT3[ FSb[i] ];
+        }
+
+        KT_init = 0;
+    }
+
+    SK = ctx->drk;
+
+    *SK++ = *RK++;
+    *SK++ = *RK++;
+    *SK++ = *RK++;
+    *SK++ = *RK++;
+
+    for( i = 1; i < ctx->nr; i++ )
+    {
+        RK -= 8;
+
+        *SK++ = KT0[ (uint8) ( *RK >> 24 ) ] ^
+                KT1[ (uint8) ( *RK >> 16 ) ] ^
+                KT2[ (uint8) ( *RK >>  8 ) ] ^
+                KT3[ (uint8) ( *RK       ) ]; RK++;
+
+        *SK++ = KT0[ (uint8) ( *RK >> 24 ) ] ^
+                KT1[ (uint8) ( *RK >> 16 ) ] ^
+                KT2[ (uint8) ( *RK >>  8 ) ] ^
+                KT3[ (uint8) ( *RK       ) ]; RK++;
+
+        *SK++ = KT0[ (uint8) ( *RK >> 24 ) ] ^
+                KT1[ (uint8) ( *RK >> 16 ) ] ^
+                KT2[ (uint8) ( *RK >>  8 ) ] ^
+                KT3[ (uint8) ( *RK       ) ]; RK++;
+
+        *SK++ = KT0[ (uint8) ( *RK >> 24 ) ] ^
+                KT1[ (uint8) ( *RK >> 16 ) ] ^
+                KT2[ (uint8) ( *RK >>  8 ) ] ^
+                KT3[ (uint8) ( *RK       ) ]; RK++;
+    }
+
+    RK -= 8;
+
+    *SK++ = *RK++;
+    *SK++ = *RK++;
+    *SK++ = *RK++;
+    *SK++ = *RK++;
+
+    return( 0 );
+}
diff --git a/board/aspeed/ast2400/ast2400.c b/board/aspeed/ast2400/ast2400.c
new file mode 100644
index 0000000..65bccbe
--- /dev/null
+++ b/board/aspeed/ast2400/ast2400.c
@@ -0,0 +1,304 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <pci.h>
+
+int board_init (void)
+{
+    DECLARE_GLOBAL_DATA_PTR;
+	unsigned char data;
+	unsigned long gpio;
+	unsigned long reg;
+
+    /* AHB Controller */
+    *((volatile ulong*) 0x1E600000)  = 0xAEED1A03;	/* unlock AHB controller */
+    *((volatile ulong*) 0x1E60008C) |= 0x01;		/* map DRAM to 0x00000000 */
+
+    /* Flash Controller */
+#ifdef	CONFIG_FLASH_AST2300
+    *((volatile ulong*) 0x1e620000) |= 0x800f0000;	/* enable Flash Write */
+#else
+    *((volatile ulong*) 0x16000000) |= 0x00001c00;	/* enable Flash Write */
+#endif
+
+    /* SCU */
+    *((volatile ulong*) 0x1e6e2000) = 0x1688A8A8;	/* unlock SCU */
+	reg = *((volatile ulong*) 0x1e6e2008);
+	reg &= 0x1c0fffff;
+	reg |= 0x61800000;				/* PCLK  = HPLL/8 */
+#ifdef CONFIG_AST1070
+	//check lpc or lpc+ mode
+////////////////////////////////////////////////////////////////////////
+	gpio = *((volatile ulong*) 0x1e780070);		/* mode check */
+	if(gpio & 0x2)
+		reg |= 0x100000;				/* LHCLK = HPLL/4 */
+	else
+		reg |= 0x300000;				/* LHCLK = HPLL/8 */
+
+	reg |= 0x80000; 				/* enable LPC Host Clock */
+
+    *((volatile ulong*) 0x1e6e2008) = reg;
+
+	reg = *((volatile ulong*) 0x1e6e200c);		/* enable LPC clock */
+	*((volatile ulong*) 0x1e6e200c) &= ~(1 << 28);
+
+	if(gpio & 0x2) {
+
+		//use LPC+ for sys clk
+		// set OSCCLK = VPLL1
+		*((volatile ulong*) 0x1e6e2010) = 0x18;
+
+		// enable OSCCLK
+		reg = *((volatile ulong*) 0x1e6e202c);
+		reg |= 0x00000002;
+		*((volatile ulong*) 0x1e6e202c) = reg;
+	} else {
+		// USE LPC use D2 clk
+		/*set VPPL1 */
+	    *((volatile ulong*) 0x1e6e201c) = 0x6420;
+
+		// set d2-pll & enable d2-pll D[21:20], D[4]
+	    reg = *((volatile ulong*) 0x1e6e202c);
+	    reg &= 0xffcfffef;
+	    reg |= 0x00200010;
+	    *((volatile ulong*) 0x1e6e202c) = reg;
+
+		// set OSCCLK = VPLL1
+	    *((volatile ulong*) 0x1e6e2010) = 0x8;
+
+		// enable OSCCLK
+	    reg = *((volatile ulong*) 0x1e6e202c);
+	    reg &= 0xfffffffd;
+	    reg |= 0x00000002;
+	    *((volatile ulong*) 0x1e6e202c) = reg;
+	}
+#else
+	*((volatile ulong*) 0x1e6e2008) = reg;
+#endif
+    reg = *((volatile ulong*) 0x1e6e200c);		/* enable 2D Clk */
+    *((volatile ulong*) 0x1e6e200c) &= 0xFFFFFFFD;
+/* enable wide screen. If your video driver does not support wide screen, don't
+enable this bit 0x1e6e2040 D[0]*/
+    reg = *((volatile ulong*) 0x1e6e2040);
+    *((volatile ulong*) 0x1e6e2040) |= 0x01;
+
+    /* arch number */
+    gd->bd->bi_arch_number = MACH_TYPE_ASPEED;
+
+    /* adress of boot parameters */
+    gd->bd->bi_boot_params = 0x40000100;
+
+    return 0;
+}
+
+int dram_init (void)
+{
+    DECLARE_GLOBAL_DATA_PTR;
+
+    gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+    gd->bd->bi_dram[0].size  = PHYS_SDRAM_1_SIZE;
+
+    return 0;
+}
+
+/*
+SCU7C: Silicon Revision ID Register
+D[31:24]: Chip ID
+0: AST2050/AST2100/AST2150/AST2200/AST3000
+1: AST2300
+
+D[23:16] Silicon revision ID for AST2300 generation and later
+0: A0
+1: A1
+2: A2
+.
+.
+.
+FPGA revision starts from 0x80
+
+
+D[11:8] Bounding option
+
+D[7:0] Silicon revision ID for AST2050/AST2100 generation (for software compatible)
+0: A0
+1: A1
+2: A2
+3: A3
+.
+.
+FPGA revision starts from 0x08, 8~10 means A0, 11+ means A1, AST2300 should be assigned to 3
+*/
+int wait_calibration_done()
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	unsigned char data;
+	unsigned long reg, count = 0;
+
+	do {
+		udelay(1000);
+		count++;
+		if (count >= 1000) {
+
+			return 1;
+		}
+	} while ((*(volatile ulong*) 0x1e6ec000) & 0xf00);
+
+//	printf ("count = %d\n", count);
+
+	return 0;
+}
+
+/* AST1070 Calibration
+Program 0x101 to 0x1e6ec000
+Wait till 1e6ec000 [8] = 0
+Check 0x1e6ec004 = 0x5a5a5a5a
+*/
+int ast1070_calibration()
+{
+	DECLARE_GLOBAL_DATA_PTR;
+	unsigned char data;
+	unsigned long reg, i, j;
+
+	//only for 2 chip
+	for (i = 0; i < 2; i++) {
+		for (j = 0; j < 4; j++) {
+//			printf ("chip = %d, delay = %d\n", i, j);
+			*((volatile ulong*) 0x1e6ec000) = (j << (12 + i * 2)) + (1 << (8 + i)) + 0x01;
+//			printf ("1e6ec000 = %x\n", *(volatile ulong*)0x1e6ec000);
+			if (!wait_calibration_done()) {
+				if ((*(volatile ulong*) 0x1e6ec004) == 0x5a5a5a5a) {
+//					printf ("calibration result: chip %d pass, timing = %d\n", i, j);
+					break;
+				}
+				else {
+//					printf ("calibration result: chip %d fail, timing = %d\n", i, j);
+				}
+			}
+		}
+	}
+
+	return 0;
+}
+
+int misc_init_r(void)
+{
+    unsigned int reg, reg1, revision, chip_id, lpc_plus;
+
+#ifdef CONFIG_AST1070
+	//Reset AST1070 and AST2400 engine [bit 23:15]
+	reg = *((volatile ulong*) 0x1e7890a0);
+	reg &= ~0x808000;
+	*((volatile ulong*) 0x1e7890a0) = reg;
+
+	udelay(5000);
+
+	lpc_plus = (*((volatile ulong*) 0x1e780070)) & 0x2;
+
+	reg = *((volatile ulong*) 0x1e7890a0);
+	reg |= 0x800000;
+	*((volatile ulong*) 0x1e7890a0) = reg;
+
+	udelay(1000);
+
+	reg = *((volatile ulong*) 0x1e7890a0);
+	reg |= 0x008000;
+	*((volatile ulong*) 0x1e7890a0) = reg;
+
+
+	if(lpc_plus) {
+		*((volatile ulong*) 0x1E60008C) |= 0x011;		/* map DRAM to 0x00000000 and LPC+ 0x70000000*/
+
+		//SCU multi-Function pin
+		reg = *((volatile ulong*) 0x1e6e2090);
+		reg |= (1 << 30);
+		*((volatile ulong*) 0x1e6e2090) = reg;
+		//LPC+ Engine Enable
+		reg = *((volatile ulong*) 0x1e6ec000);
+		reg |= 1;
+		*((volatile ulong*) 0x1e6ec000) = reg;
+
+		ast1070_calibration();
+
+	} else {
+		// enable AST1050's LPC master
+		reg = *((volatile ulong*) 0x1e7890a0);
+		*((volatile ulong*) 0x1e7890a0) |= 0x11;
+
+	}
+
+#endif
+    /* Show H/W Version */
+    reg1 = (unsigned int) (*((ulong*) 0x1e6e207c));
+    chip_id = (reg1 & 0xff000000) >> 24;
+    revision = (reg1 & 0xff0000) >> 16;
+
+    puts ("H/W:   ");
+    if (chip_id == 1) {
+    	if (revision >= 0x80) {
+    		printf("AST2300 series FPGA Rev. %02x \n", revision);
+    	}
+    	else {
+    		printf("AST2300 series chip Rev. %02x \n", revision);
+    	}
+    }
+    else if (chip_id == 2) {
+    	printf("AST2400 series chip Rev. %02x \n", revision);
+    }
+    else if (chip_id == 0) {
+		printf("AST2050/AST2150 series chip\n");
+    }
+
+#ifdef CONFIG_AST1070
+	if(lpc_plus) {
+		puts ("C/C:   LPC+ :");
+		revision = (unsigned int) (*((ulong*) 0x70002034));
+		printf("AST1070 ID [%08x] ", revision);
+
+		if((*((volatile ulong*) 0x1e780070)) & 0x4) {
+			if((unsigned int) (*((ulong*) 0x70012034)) == 0x10700001)
+				printf(", 2nd : AST1070 ID [%08x] \n", (unsigned int) (*((ulong*) 0x70012034)));
+			else
+				printf("\n");
+		} else {
+			printf("\n");
+		}
+	} else {
+		puts ("C/C:   LPC  :");
+		revision = (unsigned int) (*((ulong*) 0x60002034));
+		printf("LPC : AST1070 ID [%08x] \n", revision);
+
+	}
+#endif
+
+#ifdef	CONFIG_PCI
+    pci_init ();
+#endif
+
+    if (getenv ("verify") == NULL) {
+	setenv ("verify", "n");
+    }
+    if (getenv ("eeprom") == NULL) {
+	setenv ("eeprom", "y");
+    }
+}
+
+#ifdef	CONFIG_PCI
+static struct pci_controller hose;
+
+extern void aspeed_init_pci (struct pci_controller *hose);
+
+void pci_init_board(void)
+{
+    aspeed_init_pci(&hose);
+}
+#endif
diff --git a/board/aspeed/ast2400/config.mk b/board/aspeed/ast2400/config.mk
new file mode 100755
index 0000000..24ca09b
--- /dev/null
+++ b/board/aspeed/ast2400/config.mk
@@ -0,0 +1,18 @@
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+# ROM version
+#TEXT_BASE = 0xBFC00000
+
+# RAM version
+TEXT_BASE = 0x40500000
+#TEXT_BASE = 0x00000000
+#TEXT_BASE = 0x00400000
diff --git a/board/aspeed/ast2400/crc32.c b/board/aspeed/ast2400/crc32.c
new file mode 100755
index 0000000..cc8d2ac
--- /dev/null
+++ b/board/aspeed/ast2400/crc32.c
@@ -0,0 +1,127 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <common.h>
+#include <asm/processor.h>
+#include <asm/byteorder.h>
+#include <environment.h>
+
+#ifdef CONFIG_2SPIFLASH
+
+extern flash_info_t flash_info[CFG_MAX_FLASH_BANKS];
+
+/* ========================================================================
+ * Table of CRC-32's of all single-byte values (made by make_aspeed_crc_table)
+ */
+unsigned long aspeed_crc_table[256] = {
+  0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
+  0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
+  0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
+  0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
+  0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
+  0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
+  0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
+  0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
+  0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
+  0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
+  0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
+  0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
+  0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
+  0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
+  0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
+  0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
+  0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
+  0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
+  0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
+  0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
+  0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
+  0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
+  0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
+  0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
+  0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
+  0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
+  0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
+  0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
+  0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
+  0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
+  0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
+  0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
+  0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
+  0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
+  0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
+  0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
+  0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
+  0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
+  0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
+  0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
+  0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
+  0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
+  0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
+  0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
+  0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
+  0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
+  0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
+  0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
+  0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
+  0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
+  0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
+  0x2d02ef8dL
+};
+
+/* ========================================================================= */
+#define ASPEED_DO1(buf)  crc = aspeed_crc_table[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);
+#define ASPEED_DO2(buf)  ASPEED_DO1(buf); ASPEED_DO1(buf);
+#define ASPEED_DO4(buf)  ASPEED_DO2(buf); ASPEED_DO2(buf);
+#define ASPEED_DO8(buf)  ASPEED_DO4(buf); ASPEED_DO4(buf);
+
+/* ========================================================================= */
+unsigned long spi2_crc32(crc, buf, len)
+    unsigned long crc;
+    unsigned char *buf;
+    unsigned long len;
+{
+
+    size_t len1, len2;
+    char *s;
+
+    len1 = len2 = 0;
+    if ( (ulong)(buf) <= (flash_info[0].start[0] + flash_info[0].size) )
+        len1 = (flash_info[0].start[0] + flash_info[0].size) - (ulong)(buf);
+    
+    len1 = (len < len1) ? len:len1;
+    len2 = (len < len1) ? 0: (len - len1);
+
+    crc = crc ^ 0xffffffffL;
+    while (len1 >= 8)
+    {
+      ASPEED_DO8(buf);
+      len1 -= 8;
+    }
+    if (len1) do {
+      ASPEED_DO1(buf);
+    } while (--len1);
+    
+    //s = (char *) flash_info[1].start[0];
+    s= (char *) flash_make_addr (&flash_info[1], 0, 0);
+    while (len2 >= 8)
+    {
+      ASPEED_DO8(s);
+      len2 -= 8;
+    }
+    if (len2) do {
+      ASPEED_DO1(s);
+    } while (--len2);   
+
+    return crc ^ 0xffffffffL;
+    
+}
+
+#endif /* CONFIG_2SPIFLASH */
+
diff --git a/board/aspeed/ast2400/crt.c b/board/aspeed/ast2400/crt.c
new file mode 100755
index 0000000..b67f669
--- /dev/null
+++ b/board/aspeed/ast2400/crt.c
@@ -0,0 +1,322 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <common.h>
+#include <command.h>
+
+#include "type.h"
+#include "vesa.h"
+#include "vdef.h"
+#include "vfun.h"
+#include "vreg.h"
+#include "crt.h"
+
+ULONG AST3000DCLKTableV [] = {
+    0x00046515,     /* 00: VCLK25_175 */  
+    0x00047255,     /* 01: VCLK28_322 */
+    0x0004682a,     /* 02: VCLK31_5         */
+    0x0004672a,     /* 03: VCLK36          */
+    0x00046c50,     /* 04: VCLK40           */
+    0x00046842,     /* 05: VCLK49_5         */
+    0x00006c32,     /* 06: VCLK50           */
+    0x00006a2f,     /* 07: VCLK56_25        */
+    0x00006c41,     /* 08: VCLK65  */
+    0x00006832,     /* 09: VCLK75         */
+    0x0000672e,     /* 0A: VCLK78_75        */
+    0x0000683f,     /* 0B: VCLK94_5         */
+    0x00004824,     /* 0C: VCLK108          */
+	0x00004723,		/* 0D: VCLK119			*/
+    0x0000482d,     /* 0E: VCLK135          */
+	0x00004B37,		/* 0F: VCLK146_25		*/
+    0x0000472e,     /* 10: VCLK157_5        */
+    0x00004836,     /* 11: VCLK162          */
+
+};
+
+BOOL CheckDAC(int nCRTIndex)
+{
+	BYTE	btValue;	
+	BOOL	bValue;
+
+	BYTE btDeviceSelect;
+
+	switch (nCRTIndex)
+	{
+	case CRT_1:
+		btDeviceSelect = DEVICE_ADDRESS_CH7301_CRT1;
+		break;
+	case CRT_2:
+		btDeviceSelect = DEVICE_ADDRESS_CH7301_CRT2;
+		break;
+	default:
+		printf("CRTIndex is not 1 or 2");
+		return FALSE;
+		break;
+	}
+
+	//Enable all DAC's and set register 21h[0] = '0'
+	//DVIP and DVIL disable for DAC
+	SetI2CRegClient(0, DEVICE_SELECT_CH7301, btDeviceSelect, CH7301_PM_REG, 0x00);
+
+	btValue = GetI2CRegClient(0, DEVICE_SELECT_CH7301, btDeviceSelect, CH7301_DC_REG);
+	btValue = btValue & 0xFE;
+	SetI2CRegClient(0, DEVICE_SELECT_CH7301, btDeviceSelect, CH7301_DC_REG, btValue);
+
+	//Set SENSE bit to 1
+	btValue = GetI2CRegClient(0, DEVICE_SELECT_CH7301, btDeviceSelect, CH7301_CD_REG);
+	btValue = btValue | 0x01;
+	SetI2CRegClient(0, DEVICE_SELECT_CH7301, btDeviceSelect, CH7301_CD_REG, btValue);
+
+	//Reset SENSE bit to 0
+	btValue = GetI2CRegClient(0, DEVICE_SELECT_CH7301, btDeviceSelect, CH7301_CD_REG);
+	btValue = btValue & 0xFE;
+	SetI2CRegClient(0, DEVICE_SELECT_CH7301, btDeviceSelect, CH7301_CD_REG, btValue);
+
+	bValue = (GetI2CRegClient(0, DEVICE_SELECT_CH7301, btDeviceSelect, CH7301_CD_REG) & CD_DACT) ? TRUE : FALSE;
+
+	return bValue;
+}
+
+VOID  SetCH7301C(ULONG	MMIOBase,
+				 int	nCRTIndex,
+                 int	inFreqRange,
+				 int	inOperating)
+{
+	BYTE btDeviceSelect;
+	BYTE btValue;
+
+//#ifdef EVB_CLIENT
+	//output RGB doesn't need to set CH7301
+	//if (1 == inOperating)
+	//	return;
+//#endif
+
+	switch (nCRTIndex)
+	{
+	case CRT_1:
+		btDeviceSelect = 0xEA;
+
+		break;
+	case CRT_2:
+		btDeviceSelect = 0xEC;
+
+		break;
+	default:
+		printf("CRTIndex is not 1 or 2");
+		return;
+		break;
+	}
+
+	if (inFreqRange <= VCLK65)
+	{
+	  printf("ch7301: low f \n");
+		SetI2CRegClient(MMIOBase, 0x3, btDeviceSelect, 0x33, 0x08);
+		SetI2CRegClient(MMIOBase, 0x3, btDeviceSelect, 0x34, 0x16);
+		SetI2CRegClient(MMIOBase, 0x3, btDeviceSelect, 0x36, 0x60);
+	}
+	else
+	{
+		SetI2CRegClient(MMIOBase, 0x3, btDeviceSelect, 0x33, 0x06);
+		SetI2CRegClient(MMIOBase, 0x3, btDeviceSelect, 0x34, 0x26);
+		SetI2CRegClient(MMIOBase, 0x3, btDeviceSelect, 0x36, 0xA0);
+	}
+
+	switch (inOperating)
+	{
+	case 0:
+		//DVI is normal function
+		 SetI2CRegClient(MMIOBase, 0x3, btDeviceSelect, 0x49, 0xC0);
+		 SetI2CRegClient(MMIOBase, 0x3, btDeviceSelect, 0x1D, 0x47);
+		break;
+	case 1:
+		//RGB
+		SetI2CRegClient(MMIOBase, 0x3, btDeviceSelect, 0x48, 0x18);
+		SetI2CRegClient(MMIOBase, 0x3, btDeviceSelect, 0x49, 0x0);
+		SetI2CRegClient(MMIOBase, 0x3, btDeviceSelect, 0x56, 0x0);
+		SetI2CRegClient(MMIOBase, 0x3, btDeviceSelect, 0x21, 0x9);
+		SetI2CRegClient(MMIOBase, 0x3, btDeviceSelect, 0x1D, 0x48);
+		SetI2CRegClient(MMIOBase, 0x3, btDeviceSelect, 0x1C, 0x00);
+		break;
+	default:
+		break;
+	};
+}
+
+void SetASTModeTiming (ULONG MMIOBase, int nCRTIndex, BYTE ModeIndex, BYTE ColorDepth)
+{
+    ULONG    temp, RetraceStart, RetraceEnd, DisplayOffset, TerminalCount, bpp;
+
+//  Access CRT Engine
+	//  SetPolarity
+    WriteMemoryLongWithMASKClient(SCU_BASE, CRT1_CONTROL_REG + nCRTIndex*0x60, ((vModeTable[ModeIndex].HorPolarity << HOR_SYNC_SELECT_BIT) | (vModeTable[ModeIndex].VerPolarity << VER_SYNC_SELECT_BIT)), (HOR_SYNC_SELECT_MASK|VER_SYNC_SELECT_MASK));
+
+#if CONFIG_AST3000
+	WriteMemoryLongClient(SCU_BASE, CRT1_CONTROL2_REG + nCRTIndex*0x60, 0xc0);
+#else
+    //2100 is single edge
+	WriteMemoryLongClient(SCU_BASE, CRT1_CONTROL2_REG + nCRTIndex*0x60, 0x80);
+#endif    
+	//  Horizontal Timing
+	temp = 0;
+    temp = ((vModeTable[ModeIndex].HorizontalActive - 1) << HOR_ENABLE_END_BIT) | ((vModeTable[ModeIndex].HorizontalTotal - 1) << HOR_TOTAL_BIT);
+    WriteMemoryLongClient(SCU_BASE, CRT1_HOR_TOTAL_END_REG  + nCRTIndex*0x60, temp);
+
+    RetraceStart = vModeTable[ModeIndex].HorizontalTotal - vModeTable[ModeIndex].HBackPorch - vModeTable[ModeIndex].HSyncTime - vModeTable[ModeIndex].HLeftBorder - 1;
+    RetraceEnd = (RetraceStart + vModeTable[ModeIndex].HSyncTime);
+	temp = 0;
+    temp = (RetraceEnd << HOR_RETRACE_END_BIT) | (RetraceStart << HOR_RETRACE_START_BIT);
+    WriteMemoryLongClient(SCU_BASE, CRT1_HOR_RETRACE_REG  + nCRTIndex*0x60, temp);
+
+	//  Vertical Timing
+	temp = 0;
+    temp = ((vModeTable[ModeIndex].VerticalActive - 1) << VER_ENABLE_END_BIT) | ((vModeTable[ModeIndex].VerticalTotal - 1) << VER_TOTAL_BIT);
+    WriteMemoryLongClient(SCU_BASE, CRT1_VER_TOTAL_END_REG  + nCRTIndex*0x60, temp);
+
+	temp = 0;
+    RetraceStart = vModeTable[ModeIndex].VerticalTotal - vModeTable[ModeIndex].VBackPorch - vModeTable[ModeIndex].VSyncTime - vModeTable[ModeIndex].VTopBorder - 1;
+    RetraceEnd = (RetraceStart + vModeTable[ModeIndex].VSyncTime);
+    temp = (RetraceEnd << VER_RETRACE_END_BIT) | (RetraceStart << VER_RETRACE_START_BIT);
+    WriteMemoryLongClient(SCU_BASE, CRT1_VER_RETRACE_REG  + nCRTIndex*0x60, temp);
+
+	//  Set CRT Display Offset and Terminal Count
+    if (ColorDepth == RGB_565) {
+        bpp = 16;
+    }
+    else {
+        bpp = 32;
+    }
+
+    DisplayOffset = vModeTable[ModeIndex].HorizontalActive * bpp / 8;
+    TerminalCount = vModeTable[ModeIndex].HorizontalActive * bpp / 64;
+    if (ColorDepth == YUV_444) {
+        TerminalCount = TerminalCount * 3 / 4;
+    }
+    if (((vModeTable[ModeIndex].HorizontalActive * bpp) % 64) != 0) {
+        TerminalCount++;
+    }
+
+    WriteMemoryLongClient(SCU_BASE, CRT1_DISPLAY_OFFSET + nCRTIndex*0x60, ((TerminalCount << TERMINAL_COUNT_BIT) | DisplayOffset));
+
+	//  Set Color Format
+    WriteMemoryLongWithMASKClient(SCU_BASE, CRT1_CONTROL_REG + nCRTIndex*0x60, (ColorDepth << FORMAT_SELECT_BIT), FORMAT_SELECT_MASK);
+
+	//  Set Threshold
+	temp = 0;
+    temp = (CRT_HIGH_THRESHOLD_VALUE << THRES_HIGHT_BIT) | (CRT_LOW_THRESHOLD_VALUE << THRES_LOW_BIT);
+    WriteMemoryLongClient(SCU_BASE, CRT1_THRESHOLD_REG + nCRTIndex*0x60, temp);
+
+	WriteMemoryLongClient(SCU_BASE, CRT1_VIDEO_PLL_REG + nCRTIndex*0x60, AST3000DCLKTableV[vModeTable[ModeIndex].PixelClock]);
+}
+
+void SetASTCenter1024ModeTiming (ULONG MMIOBase, int nCRTIndex, BYTE ModeIndex, BYTE ColorDepth)
+{
+    ULONG    temp, RetraceStart, RetraceEnd, DisplayOffset, TerminalCount, bpp;
+
+	//  Access CRT Engine
+	//  SetPolarity
+    WriteMemoryLongWithMASKClient(SCU_BASE, CRT1_CONTROL_REG + nCRTIndex*0x60, (HOR_NEGATIVE << HOR_SYNC_SELECT_BIT) | (VER_NEGATIVE << VER_SYNC_SELECT_BIT), HOR_SYNC_SELECT_MASK|VER_SYNC_SELECT_MASK);
+
+	WriteMemoryLongClient(SCU_BASE, CRT1_CONTROL2_REG + nCRTIndex*0x60, 0xC0);
+
+	//  Horizontal Timing
+	temp = 0;
+    temp = ((vModeTable[ModeIndex].HorizontalActive - 1) << HOR_ENABLE_END_BIT) | ((vModeTable[10].HorizontalTotal - 1) << HOR_TOTAL_BIT);
+    WriteMemoryLongClient(SCU_BASE, CRT1_HOR_TOTAL_END_REG + nCRTIndex*0x60, temp);
+
+    RetraceStart = vModeTable[10].HorizontalTotal - vModeTable[10].HBackPorch - vModeTable[10].HSyncTime - vModeTable[10].HLeftBorder - 1;
+    RetraceStart = RetraceStart - (vModeTable[10].HorizontalActive - vModeTable[ModeIndex].HorizontalActive) / 2 - 1;
+    RetraceEnd = (RetraceStart + vModeTable[10].HSyncTime);
+	temp = 0;
+    temp = (RetraceEnd << HOR_RETRACE_END_BIT) | (RetraceStart << HOR_RETRACE_START_BIT);
+    WriteMemoryLongClient(SCU_BASE, CRT1_HOR_RETRACE_REG + nCRTIndex*0x60, temp);
+
+	//  Vertical Timing
+	temp = 0;
+    temp = ((vModeTable[ModeIndex].VerticalActive - 1) << VER_ENABLE_END_BIT) | ((vModeTable[10].VerticalTotal - 1) << VER_TOTAL_BIT);
+    WriteMemoryLongClient(SCU_BASE, CRT1_VER_TOTAL_END_REG + nCRTIndex*0x60, temp);
+
+    RetraceStart = vModeTable[10].VerticalTotal - vModeTable[10].VBackPorch - vModeTable[10].VSyncTime - vModeTable[10].VTopBorder - 1;
+    RetraceStart = RetraceStart - (vModeTable[10].VerticalActive - vModeTable[ModeIndex].VerticalActive) / 2 - 1;
+    RetraceEnd = (RetraceStart + vModeTable[10].VSyncTime);
+    temp = (RetraceEnd << VER_RETRACE_END_BIT) | (RetraceStart << VER_RETRACE_START_BIT);
+    WriteMemoryLongClient(SCU_BASE, CRT1_VER_RETRACE_REG + nCRTIndex*0x60, temp);
+
+	//  Set CRT Display Offset and Terminal Count
+    if (ColorDepth == RGB_565) {
+        bpp = 16;
+    }
+    else {
+        bpp = 32;
+    }
+    DisplayOffset = vModeTable[ModeIndex].HorizontalActive * bpp / 8;
+    TerminalCount = vModeTable[ModeIndex].HorizontalActive * bpp / 64;
+    if (ColorDepth == YUV_444) {
+        TerminalCount = TerminalCount * 3 / 4;
+    }
+    if (((vModeTable[ModeIndex].HorizontalActive * bpp) % 64) != 0) {
+        TerminalCount++;
+    }
+
+    WriteMemoryLongClient(SCU_BASE, CRT1_DISPLAY_OFFSET + nCRTIndex*0x60, (TerminalCount << TERMINAL_COUNT_BIT) | DisplayOffset);
+
+	//  Set Color Format
+    WriteMemoryLongWithMASKClient(SCU_BASE, CRT1_CONTROL_REG + nCRTIndex*0x60, (ColorDepth << FORMAT_SELECT_BIT), FORMAT_SELECT_MASK);
+
+	//  Set Threshold
+	temp = 0;
+    temp = (CRT_HIGH_THRESHOLD_VALUE << THRES_HIGHT_BIT) | (CRT_LOW_THRESHOLD_VALUE << THRES_LOW_BIT);
+    WriteMemoryLongClient(SCU_BASE, CRT1_THRESHOLD_REG + nCRTIndex*0x60, temp);
+    
+	// Set DCLK
+	WriteMemoryLongClient(SCU_BASE, CRT1_VIDEO_PLL_REG + nCRTIndex*0x60, AST3000DCLKTableV[vModeTable[ModeIndex].PixelClock]);
+
+}
+
+BOOL  ASTSetModeV (ULONG MMIOBase, int nCRTIndex, ULONG VGABaseAddr, USHORT Horizontal, USHORT Vertical, BYTE ColorFormat, BYTE CenterMode)
+{
+    BYTE    i, ModeIndex;
+    BOOL	bDAC;	
+    ULONG   ulTemp;
+
+    //  Access CRT Engine
+    //Enable CRT1 graph
+    WriteMemoryLongWithMASKClient(SCU_BASE, CRT1_CONTROL_REG + 0x60*nCRTIndex, GRAPH_DISPLAY_ON, GRAPH_DISPLAY_MASK);
+    
+    //  Set CRT Display Start Address
+    WriteMemoryLongWithMASKClient(SCU_BASE, CRT1_DISPLAY_ADDRESS + 0x60*nCRTIndex, VGABaseAddr, DISPLAY_ADDRESS_MASK);
+
+    for (i = 0; i < Mode60HZCount; i++) {
+        if ((vModeTable[i].HorizontalActive == Horizontal) && (vModeTable[i].VerticalActive == Vertical)) {
+
+	    ModeIndex = i;
+
+            if (CenterMode != 1) {
+                SetASTModeTiming(MMIOBase, nCRTIndex, i, ColorFormat);
+            }
+            else {
+                SetASTCenter1024ModeTiming (MMIOBase, nCRTIndex, i, ColorFormat);
+            }
+
+            //use internal video out sigal and don't need use 7301
+            /*
+			bDAC = CheckDAC(nCRTIndex);
+            
+			SetCH7301C(0,
+				nCRTIndex,
+				vModeTable[ModeIndex].PixelClock,
+				bDAC);		//For RGB
+			*/	
+			return TRUE;
+        }
+    }
+
+    return FALSE;
+}
+
diff --git a/board/aspeed/ast2400/crt.h b/board/aspeed/ast2400/crt.h
new file mode 100755
index 0000000..e7483be
--- /dev/null
+++ b/board/aspeed/ast2400/crt.h
@@ -0,0 +1,121 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef _CRT_H_
+#define _CRT_H_
+
+#ifdef Watcom
+#define		CRT_REMAP_OFFSET	0x10000
+#else
+#define		CRT_REMAP_OFFSET	0x0
+#endif
+
+/********************************************************/
+/*    CRT register                                      */
+/********************************************************/
+#define		CRT_BASE_OFFSET						0x6000+CRT_REMAP_OFFSET
+
+#define		CRT1_CONTROL_REG					0x00 + CRT_BASE_OFFSET
+	#define		GRAPH_DISPLAY_BIT				0
+	#define     GRAPH_DISPLAY_MASK				(1<<0)
+		#define		GRAPH_DISPLAY_ON			1
+		#define		GRAPH_DISPLAY_OFF			0
+    #define     FORMAT_SELECT_BIT               8
+    #define     FORMAT_SELECT_MASK              (3<<8)   
+	#define		HOR_SYNC_SELECT_BIT				16
+    #define		HOR_SYNC_SELECT_MASK			(1<<16)	
+		#define		HOR_NEGATIVE				1
+		#define		HOR_POSITIVE				0
+	#define		VER_SYNC_SELECT_BIT				17
+    #define		VER_SYNC_SELECT_MASK			(1<<17)	
+		#define		VER_NEGATIVE				1
+		#define		VER_POSITIVE				0
+
+#define		CRT1_CONTROL2_REG					0x04 + CRT_BASE_OFFSET
+        
+#define     CRT1_VIDEO_PLL_REG                  0x0C + CRT_BASE_OFFSET
+    #define     POST_DIV_BIT                    18
+    #define     POST_DIV_MASK                   3<<18
+        #define     DIV_1_1                     0
+        //#define     DIV_1_2                     1
+        #define     DIV_1_2                     2
+        #define     DIV_1_4                     3
+        
+#define     CRT1_HOR_TOTAL_END_REG              0x10 + CRT_BASE_OFFSET
+    #define     HOR_TOTAL_BIT                   0
+    #define     HOR_ENABLE_END_BIT              16
+
+#define     CRT1_HOR_RETRACE_REG                0x14 + CRT_BASE_OFFSET
+    #define     HOR_RETRACE_START_BIT           0
+    #define     HOR_RETRACE_END_BIT             16
+
+#define     CRT1_VER_TOTAL_END_REG              0x18 + CRT_BASE_OFFSET
+    #define     VER_TOTAL_BIT                   0
+    #define     VER_ENABLE_END_BIT              16
+
+#define     CRT1_VER_RETRACE_REG                0x1C + CRT_BASE_OFFSET
+    #define     VER_RETRACE_START_BIT           0
+    #define     VER_RETRACE_END_BIT             16
+
+#define     CRT1_DISPLAY_ADDRESS				0x20 + CRT_BASE_OFFSET
+	#define		DISPLAY_ADDRESS_MASK			0x0FFFFFFF
+
+#define     CRT1_DISPLAY_OFFSET                 0x24 + CRT_BASE_OFFSET
+    #define     DISPLAY_OFFSET_ALIGN            7 /* 8 byte alignment*/
+    #define     TERMINAL_COUNT_BIT              16    
+
+#define     CRT1_THRESHOLD_REG                  0x28 + CRT_BASE_OFFSET
+    #define     THRES_LOW_BIT                   0
+    #define     THRES_HIGHT_BIT                 8
+
+#define    CURSOR_POSITION                  0x30 + OFFSET
+#define    CURSOR_OFFSET                    0x34 + OFFSET
+#define    CURSOR_PATTERN                   0x38 + OFFSET
+#define    OSD_HORIZONTAL                   0x40 + OFFSET
+#define    OSD_VERTICAL                     0x44 + OFFSET
+#define    OSD_PATTERN                      0x48 + OFFSET
+#define    OSD_OFFSET                       0x4C + OFFSET
+#define    OSD_THRESHOLD                    0x50 + OFFSET
+
+//Ch7301c
+#define		DEVICE_ADDRESS_CH7301_CRT1	0xEA
+#define		DEVICE_ADDRESS_CH7301_CRT2	0xEC
+
+
+#define		DEVICE_SELECT_CH7301		0x3
+
+/* CH7301 Register Definition */
+#define     CH7301_CD_REG				0x20
+	#define     CD_DACT					0x0E
+	#define		CD_DVIT					1 << 5
+#define     CH7301_DC_REG				0x21
+#define     CH7301_PM_REG				0x49
+
+BOOL CheckHotPlug(int nCRTIndex);
+BOOL CheckDAC(int nCRTIndex);
+
+BOOL  ASTSetModeV (ULONG MMIOBase, 
+                int nCRTIndex, 
+                ULONG VGABaseAddr, 
+                USHORT Horizontal, 
+                USHORT Vertical, 
+                BYTE ColorFormat, 
+                BYTE CenterMode);
+                
+BOOL  SelCRTClock(ULONG MMIOBase,
+				  int	nCRTIndex,
+				  USHORT Horizontal, 
+				  USHORT Vertical);
+
+void DisableCRT(ULONG MMIOBase, int nCRTIndex);
+void ClearCRTWithBlack(ULONG ulCRTAddr, int iWidth, int iHeight);
+
+#endif /* _CRT_H_ */
+
diff --git a/board/aspeed/ast2400/flash.c b/board/aspeed/ast2400/flash.c
new file mode 100755
index 0000000..d611d0d
--- /dev/null
+++ b/board/aspeed/ast2400/flash.c
@@ -0,0 +1,1651 @@
+/*
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * History
+ * 01/20/2004 - combined variants of original driver.
+ * 01/22/2004 - Write performance enhancements for parallel chips (Tolunay)
+ * 01/23/2004 - Support for x8/x16 chips (Rune Raknerud)
+ * 01/27/2004 - Little endian support Ed Okerson
+ *
+ * Tested Architectures
+ * Port Width  Chip Width    # of banks	   Flash Chip  Board
+ * 32	       16	     1		   28F128J3    seranoa/eagle
+ * 64	       16	     1		   28F128J3    seranoa/falcon
+ */
+// (Sun) This CFI driver is written for fixed-width flash chips.
+// It was not designed for flexible 8-bit/16-bit chips, which are the norm.
+// When those chips are connected to a bus in 8-bit mode, the address wires
+// right-shifted by 1.
+//FIXME: Fix the driver to auto-detect "16-bit flash wired in 8-bit mode".
+// Left-shift CFI offsets by 1 bit instead of doubling the #define values.
+
+/* The DEBUG define must be before common to enable debugging */
+// (Sun) Changed to DEBUG_FLASH because flash debug()s are too numerous.
+// #define DEBUG
+
+#include <common.h>
+#include <asm/processor.h>
+#include <asm/byteorder.h>
+#include <environment.h>
+#ifdef	CONFIG_SYS_FLASH_CFI
+
+/*
+ * This file implements a Common Flash Interface (CFI) driver for U-Boot.
+ * The width of the port and the width of the chips are determined at initialization.
+ * These widths are used to calculate the address for access CFI data structures.
+ * It has been tested on an Intel Strataflash implementation and AMD 29F016D.
+ *
+ * References
+ * JEDEC Standard JESD68 - Common Flash Interface (CFI)
+ * JEDEC Standard JEP137-A Common Flash Interface (CFI) ID Codes
+ * Intel Application Note 646 Common Flash Interface (CFI) and Command Sets
+ * Intel 290667-008 3 Volt Intel StrataFlash Memory datasheet
+ *
+ * TODO
+ *
+ * Use Primary Extended Query table (PRI) and Alternate Algorithm Query
+ * Table (ALT) to determine if protection is available
+ *
+ * Add support for other command sets Use the PRI and ALT to determine command set
+ * Verify erase and program timeouts.
+ */
+
+#ifndef CONFIG_FLASH_BANKS_LIST
+#define CONFIG_FLASH_BANKS_LIST { CONFIG_SYS_FLASH_BASE }
+#endif
+
+#define FLASH_CMD_CFI			0x98
+#define FLASH_CMD_READ_ID		0x90
+#define FLASH_CMD_RESET			0xff
+#define FLASH_CMD_BLOCK_ERASE		0x20
+#define FLASH_CMD_ERASE_CONFIRM		0xD0
+#define FLASH_CMD_WRITE			0x40
+#define FLASH_CMD_PROTECT		0x60
+#define FLASH_CMD_PROTECT_SET		0x01
+#define FLASH_CMD_PROTECT_CLEAR		0xD0
+#define FLASH_CMD_CLEAR_STATUS		0x50
+#define FLASH_CMD_WRITE_TO_BUFFER	0xE8
+#define FLASH_CMD_WRITE_BUFFER_CONFIRM	0xD0
+
+#define FLASH_STATUS_DONE		0x80
+#define FLASH_STATUS_ESS		0x40
+#define FLASH_STATUS_ECLBS		0x20
+#define FLASH_STATUS_PSLBS		0x10
+#define FLASH_STATUS_VPENS		0x08
+#define FLASH_STATUS_PSS		0x04
+#define FLASH_STATUS_DPS		0x02
+#define FLASH_STATUS_R			0x01
+#define FLASH_STATUS_PROTECT		0x01
+
+#define AMD_CMD_RESET			0xF0
+#define AMD_CMD_WRITE			0xA0
+#define AMD_CMD_ERASE_START		0x80
+#define AMD_CMD_ERASE_SECTOR		0x30
+#define AMD_CMD_UNLOCK_START		0xAA
+#define AMD_CMD_UNLOCK_ACK		0x55
+#define AMD_CMD_WRITE_TO_BUFFER		0x25
+#define AMD_CMD_BUFFER_TO_FLASH		0x29
+
+#define AMD_STATUS_TOGGLE		0x40
+#define AMD_STATUS_ERROR		0x20
+//FIXME: These 3 were also changed for 8-bit/16-bit flash chips.
+#define AMD_ADDR_ERASE_START		(0xAAA/info->portwidth)
+#define AMD_ADDR_START			(0xAAA/info->portwidth)
+#define AMD_ADDR_ACK			(0x555/info->portwidth)
+
+//FIXME: Fix the driver to auto-detect "16-bit flash wired in 8-bit mode".
+// Left-shift CFI offsets by 1 bit instead of doubling the #define values.
+#define FLASH_OFFSET_CFI		(0xAA/info->portwidth)
+#define FLASH_OFFSET_CFI_RESP		(0x20/info->portwidth)
+#define FLASH_OFFSET_CFI_RESP1		(0x22/info->portwidth)
+#define FLASH_OFFSET_CFI_RESP2		(0x24/info->portwidth)
+#define FLASH_OFFSET_PRIMARY_VENDOR	(0x26/info->portwidth)
+#define FLASH_OFFSET_WTOUT		(0x3E/info->portwidth)
+#define FLASH_OFFSET_WBTOUT		(0x40/info->portwidth)
+#define FLASH_OFFSET_ETOUT		(0x42/info->portwidth)
+#define FLASH_OFFSET_CETOUT		(0x44/info->portwidth)
+#define FLASH_OFFSET_WMAX_TOUT		(0x46/info->portwidth)
+#define FLASH_OFFSET_WBMAX_TOUT		(0x48/info->portwidth)
+#define FLASH_OFFSET_EMAX_TOUT		(0x4A/info->portwidth)
+#define FLASH_OFFSET_CEMAX_TOUT		(0x4C/info->portwidth)
+#define FLASH_OFFSET_SIZE		(0x4E/info->portwidth)
+#define FLASH_OFFSET_INTERFACE		(0x50/info->portwidth)
+#define FLASH_OFFSET_BUFFER_SIZE	(0x54/info->portwidth)
+#define FLASH_OFFSET_NUM_ERASE_REGIONS	(0x58/info->portwidth)
+#define FLASH_OFFSET_ERASE_REGIONS	(0x5A/info->portwidth)
+#define FLASH_OFFSET_PROTECT		(0x02/info->portwidth)
+#define FLASH_OFFSET_USER_PROTECTION	(0x85/info->portwidth)
+#define FLASH_OFFSET_INTEL_PROTECTION	(0x81/info->portwidth)
+
+#define MAX_NUM_ERASE_REGIONS		4
+
+#define FLASH_MAN_CFI			0x01000000
+
+#define CFI_CMDSET_NONE		    0
+#define CFI_CMDSET_INTEL_EXTENDED   1
+#define CFI_CMDSET_AMD_STANDARD	    2
+#define CFI_CMDSET_INTEL_STANDARD   3
+#define CFI_CMDSET_AMD_EXTENDED	    4
+#define CFI_CMDSET_MITSU_STANDARD   256
+#define CFI_CMDSET_MITSU_EXTENDED   257
+#define CFI_CMDSET_SST		    258
+
+
+#ifdef CONFIG_SYS_FLASH_CFI_AMD_RESET /* needed for STM_ID_29W320DB on UC100 */
+# undef  FLASH_CMD_RESET
+# define FLASH_CMD_RESET                AMD_CMD_RESET /* use AMD-Reset instead */
+#endif
+
+
+typedef union {
+	unsigned char c;
+	unsigned short w;
+	unsigned long l;
+	unsigned long long ll;
+} cfiword_t;
+
+typedef union {
+	volatile unsigned char *cp;
+	volatile unsigned short *wp;
+	volatile unsigned long *lp;
+	volatile unsigned long long *llp;
+} cfiptr_t;
+
+/* use CFG_MAX_FLASH_BANKS_DETECT if defined */
+#ifdef CONFIG_SYS_MAX_FLASH_BANKS_DETECT
+static ulong bank_base[CONFIG_SYS_MAX_FLASH_BANKS_DETECT] = CONFIG_FLASH_BANKS_LIST;
+flash_info_t flash_info[CFG_MAX_FLASH_BANKS_DETECT];	/* FLASH chips info */
+#else
+static ulong bank_base[CONFIG_SYS_MAX_FLASH_BANKS] = CONFIG_FLASH_BANKS_LIST;
+flash_info_t flash_info[CONFIG_SYS_MAX_FLASH_BANKS];		/* FLASH chips info */
+#endif
+
+
+/*-----------------------------------------------------------------------
+ * Functions
+ */
+static void flash_add_byte (flash_info_t * info, cfiword_t * cword, uchar c);
+static void flash_make_cmd (flash_info_t * info, uchar cmd, void *cmdbuf);
+static void flash_write_cmd (flash_info_t * info, flash_sect_t sect, uint offset, uchar cmd);
+static void flash_write_cmd_nodbg (flash_info_t * info, flash_sect_t sect, uint offset, uchar cmd);
+static void flash_write_cmd_int (flash_info_t * info, flash_sect_t sect, uint offset, uchar cmd, int noDebug);
+static void flash_unlock_seq (flash_info_t * info, flash_sect_t sect);
+static int flash_isequal (flash_info_t * info, flash_sect_t sect, uint offset, uchar cmd);
+static int flash_isset (flash_info_t * info, flash_sect_t sect, uint offset, uchar cmd);
+static int flash_toggle (flash_info_t * info, flash_sect_t sect, uint offset, uchar cmd);
+static int flash_detect_cfi (flash_info_t * info);
+ulong flash_get_size (ulong base, int banknum);
+static int flash_write_cfiword (flash_info_t * info, ulong dest, cfiword_t cword);
+static int flash_full_status_check (flash_info_t * info, flash_sect_t sector,
+				    ulong tout, char *prompt);
+static void write_buffer_abort_reset(flash_info_t * info, flash_sect_t sector);				    
+#if defined(CFG_ENV_IS_IN_FLASH) || defined(CFG_ENV_ADDR_REDUND) || (CFG_MONITOR_BASE >= CFG_FLASH_BASE)
+static flash_info_t *flash_get_info(ulong base);
+#endif
+#ifdef CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+static int flash_write_cfibuffer (flash_info_t * info, ulong dest, uchar * cp, int len);
+static int flash_write_cfibuffer_amd (flash_info_t * info, ulong dest, uchar * cp, int len);
+#endif
+
+/*-----------------------------------------------------------------------
+ * create an address based on the offset and the port width
+ */
+inline uchar *flash_make_addr (flash_info_t * info, flash_sect_t sect, uint offset)
+{
+	return ((uchar *) (info->start[sect] + (offset * info->portwidth)));
+}
+
+/*-----------------------------------------------------------------------
+ * Debug support
+ */
+#ifdef DEBUG_FLASH
+static void print_longlong (char *str, unsigned long long data)
+{
+	int i;
+	char *cp;
+
+	cp = (unsigned char *) &data;
+	for (i = 0; i < 8; i++)
+		sprintf (&str[i * 2], "%2.2x", *cp++);
+}
+#endif
+
+#if defined(DEBUG_FLASH)
+static void flash_printqry (flash_info_t * info, flash_sect_t sect)
+{
+	cfiptr_t cptr;
+	int x, y;
+
+	for (x = 0; x < 0x40; x += 16U / info->portwidth) {
+		cptr.cp =
+			flash_make_addr (info, sect,
+					 x + FLASH_OFFSET_CFI_RESP);
+		debug ("%p : ", cptr.cp);
+		for (y = 0; y < 16; y++) {
+			debug ("%2.2x ", cptr.cp[y]);
+		}
+		debug (" ");
+		for (y = 0; y < 16; y++) {
+			if (cptr.cp[y] >= 0x20 && cptr.cp[y] <= 0x7e) {
+				debug ("%c", cptr.cp[y]);
+			} else {
+				debug (".");
+			}
+		}
+		debug ("\n");
+	}
+}
+#endif
+
+/*-----------------------------------------------------------------------
+ * read a character at a port width address
+ */
+inline uchar flash_read_uchar (flash_info_t * info, uint offset)
+{
+	uchar *cp;
+
+	cp = flash_make_addr (info, 0, offset);
+#if defined(__LITTLE_ENDIAN)
+	return (cp[0]);
+#else
+	return (cp[info->portwidth - 1]);
+#endif
+}
+
+/*-----------------------------------------------------------------------
+ * read a short word by swapping for ppc format.
+ */
+#if 0
+static ushort flash_read_ushort (flash_info_t * info, flash_sect_t sect, uint offset)
+{
+	uchar *addr;
+	ushort retval;
+
+#ifdef DEBUG_FLASH
+	int x;
+#endif
+	addr = flash_make_addr (info, sect, offset);
+
+#ifdef DEBUG_FLASH
+	debug ("ushort addr is at %p info->portwidth = %d\n", addr,
+	       info->portwidth);
+	for (x = 0; x < 2 * info->portwidth; x++) {
+		debug ("addr[%x] = 0x%x\n", x, addr[x]);
+	}
+#endif
+#if defined(__LITTLE_ENDIAN)
+	if (info->interface == FLASH_CFI_X8X16) {
+	    retval = (addr[0] | (addr[2] << 8));
+	} else {
+	    retval = (addr[0] | (addr[(info->portwidth)] << 8));
+	}
+#else
+	retval = ((addr[(2 * info->portwidth) - 1] << 8) |
+		  addr[info->portwidth - 1]);
+#endif
+
+	debug ("retval = 0x%x\n", retval);
+	return retval;
+}
+#endif
+
+/*-----------------------------------------------------------------------
+ * read a long word by picking the least significant byte of each maximum
+ * port size word. Swap for ppc format.
+ */
+static ulong flash_read_long (flash_info_t * info, flash_sect_t sect, uint offset)
+{
+	uchar *addr;
+	ulong retval;
+#ifdef DEBUG_FLASH
+	int x;
+#endif
+#if 0
+	switch (info->interface) {
+	case FLASH_CFI_X8:
+	case FLASH_CFI_X16:
+	    break;
+	case FLASH_CFI_X8X16:
+	    offset <<= 1;
+	}
+#endif	
+	// flash_make_addr() multiplies offset by info->portwidth.
+	addr = flash_make_addr (info, sect, offset);
+
+#ifdef DEBUG_FLASH
+	debug ("long addr is at %p info->portwidth = %d\n", addr,
+	       info->portwidth);
+	for (x = 0; x < 4 * info->portwidth; x++) {
+		debug ("addr[%x] = 0x%x\n", x, addr[x]);
+	}
+#endif
+#if defined(__LITTLE_ENDIAN)
+	if (info->interface == FLASH_CFI_X8X16) {
+	    retval = (addr[0] | (addr[2] << 8) | (addr[4] << 16) | (addr[6] << 24));
+	} else {
+	    retval = (addr[0] | (addr[(info->portwidth)] << 8) |
+		      (addr[(2 * info->portwidth)] << 16) |
+		      (addr[(3 * info->portwidth)] << 24));
+	}
+#else
+	//FIXME: This undocumented code appears to match broken bus wiring.
+	retval = (addr[(2 * info->portwidth) - 1] << 24) |
+		(addr[(info->portwidth) - 1] << 16) |
+		(addr[(4 * info->portwidth) - 1] << 8) |
+		addr[(3 * info->portwidth) - 1];
+#endif
+	return retval;
+}
+
+/*-----------------------------------------------------------------------
+ */
+unsigned long flash_init (void)
+{
+	unsigned long size = 0;
+	int i;
+
+	/* Init: no FLASHes known */
+	for (i = 0; i < CONFIG_SYS_MAX_FLASH_BANKS; ++i) {
+		flash_info[i].flash_id = FLASH_UNKNOWN;
+		size += flash_info[i].size = flash_get_size (bank_base[i], i);
+		if (flash_info[i].flash_id == FLASH_UNKNOWN) {
+#ifndef CFG_FLASH_QUIET_TEST
+			printf ("## Unknown FLASH on Bank %d - Size = 0x%08lx = %ld MB\n",
+				i, flash_info[i].size, flash_info[i].size << 20);
+#endif /* CFG_FLASH_QUIET_TEST */
+		}
+	}
+
+	/* Monitor protection ON by default */
+#if (CONFIG_MONITOR_BASE >= CONFIG_SYS_FLASH_BASE)
+	flash_protect (FLAG_PROTECT_SET,
+		       CONFIG_MONITOR_BASE,
+		       CONFIG_MONITOR_BASE + monitor_flash_len  - 1,
+		       flash_get_info(CONFIG_MONITOR_BASE));
+#endif
+
+	/* Environment protection ON by default */
+#ifdef CONFIG_ENV_IS_IN_FLASH
+	flash_protect (FLAG_PROTECT_SET,
+		       CONFIG_ENV_ADDR,
+		       CONFIG_ENV_ADDR + CONFIG_ENV_SECT_SIZE - 1,
+		       flash_get_info(CONFIG_ENV_ADDR));
+#endif
+
+	/* Redundant environment protection ON by default */
+#ifdef CONFIG_ENV_ADDR_REDUND
+	flash_protect (FLAG_PROTECT_SET,
+		       CONFIG_ENV_ADDR_REDUND,
+		       CONFIG_ENV_ADDR_REDUND + CONFIG_ENV_SIZE_REDUND - 1,
+		       flash_get_info(CONFIG_ENV_ADDR_REDUND));
+#endif
+	return (size);
+}
+
+/*-----------------------------------------------------------------------
+ */
+#if defined(CONFIG_ENV_IS_IN_FLASH) || defined(CONFIG_ENV_ADDR_REDUND) || (CONFIG_MONITOR_BASE >= CONFIG_SYS_FLASH_BASE)
+static flash_info_t *flash_get_info(ulong base)
+{
+	int i;
+	flash_info_t * info = 0;
+
+	for (i = 0; i < CONFIG_SYS_MAX_FLASH_BANKS; i ++) {
+		info = & flash_info[i];
+		if (info->size && info->start[0] <= base &&
+		    base <= info->start[0] + info->size - 1)
+			break;
+	}
+
+	return i == CONFIG_SYS_MAX_FLASH_BANKS ? 0 : info;
+}
+#endif
+
+/*-----------------------------------------------------------------------
+ */
+int flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+	int rcode = 0;
+	int prot;
+	flash_sect_t sect;
+        uchar ch;
+	uchar *addr;
+  
+	if (info->flash_id != FLASH_MAN_CFI) {
+		puts ("Can't erase unknown flash type - aborted\n");
+		return 1;
+	}
+	if ((s_first < 0) || (s_first > s_last)) {
+		puts ("- no sectors to erase\n");
+		return 1;
+	}
+
+	prot = 0;
+	for (sect = s_first; sect <= s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+	if (prot) {
+		printf ("- Warning: %d protected sectors will not be erased!\n", prot);
+	} else {
+		putc ('\n');
+	}
+
+
+	for (sect = s_first; sect <= s_last; sect++) {
+		if (info->protect[sect] == 0) { /* not protected */
+			switch (info->vendor) {
+			case CFI_CMDSET_INTEL_STANDARD:
+			case CFI_CMDSET_INTEL_EXTENDED:
+				flash_write_cmd (info, sect, 0, FLASH_CMD_CLEAR_STATUS);
+				flash_write_cmd (info, sect, 0, FLASH_CMD_BLOCK_ERASE);
+				flash_write_cmd (info, sect, 0, FLASH_CMD_ERASE_CONFIRM);
+				break;
+			case CFI_CMDSET_AMD_STANDARD:
+			case CFI_CMDSET_AMD_EXTENDED:
+				flash_unlock_seq (info, sect);
+				flash_write_cmd (info, sect, AMD_ADDR_ERASE_START,
+							AMD_CMD_ERASE_START);
+				flash_unlock_seq (info, sect);
+				flash_write_cmd (info, sect, 0, AMD_CMD_ERASE_SECTOR);
+				
+				/* toggle */
+	                        addr = flash_make_addr (info, sect, 0);				
+				do {
+				    ch = *(volatile uchar *)(addr);
+                                } while ( ((ch & 0x80) == 0) || (ch != 0xFF) );
+				break;
+			default:
+				debug ("Unkown flash vendor %d\n",
+				       info->vendor);
+				break;
+			}
+
+			if (flash_full_status_check
+			    (info, sect, info->erase_blk_tout, "erase")) {
+				rcode = 1;
+			} else
+				putc ('.');
+		}
+	}
+	puts (" done\n");
+	return rcode;
+}
+
+/*-----------------------------------------------------------------------
+ */
+void flash_print_info (flash_info_t * info)
+{
+	int i;
+
+	if (info->flash_id != FLASH_MAN_CFI) {
+		puts ("missing or unknown FLASH type\n");
+		return;
+	}
+
+	printf ("CFI conformant FLASH (%d x %d)",
+		(info->portwidth << 3), (info->chipwidth << 3));
+	printf ("  Size: %ld MB in %d Sectors\n",
+		info->size >> 20, info->sector_count);
+	printf (" Erase timeout %ld ms, write timeout %ld ms, buffer write timeout %ld ms, buffer size %d\n",
+		info->erase_blk_tout,
+		info->write_tout,
+		info->buffer_write_tout,
+		info->buffer_size);
+
+	puts ("  Sector Start Addresses:");
+	for (i = 0; i < info->sector_count; ++i) {
+#ifdef CFG_FLASH_EMPTY_INFO
+		int k;
+		int size;
+		int erased;
+		volatile unsigned long *flash;
+
+		/*
+		 * Check if whole sector is erased
+		 */
+		if (i != (info->sector_count - 1))
+			size = info->start[i + 1] - info->start[i];
+		else
+			size = info->start[0] + info->size - info->start[i];
+		erased = 1;
+		flash = (volatile unsigned long *) info->start[i];
+		size = size >> 2;	/* divide by 4 for longword access */
+		for (k = 0; k < size; k++) {
+			if (*flash++ != 0xffffffff) {
+				erased = 0;
+				break;
+			}
+		}
+
+		if ((i % 5) == 0)
+			printf ("\n");
+		/* print empty and read-only info */
+		printf (" %08lX%s%s",
+			info->start[i],
+			erased ? " E" : "  ",
+			info->protect[i] ? "RO " : "   ");
+#else	/* ! CFG_FLASH_EMPTY_INFO */
+		if ((i % 5) == 0)
+			printf ("\n   ");
+		printf (" %08lX%s",
+			info->start[i], info->protect[i] ? " (RO)" : "     ");
+#endif
+	}
+	putc ('\n');
+	return;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash, returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ */
+int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+	ulong wp;
+	ulong cp;
+	int aln;
+	cfiword_t cword;
+	int i, rc;
+
+#ifdef CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+	unsigned char pat[] = {'|', '-', '/', '\\'};
+       	int patcnt = 0;
+	int buffered_size;
+#endif
+	/* get lower aligned address */
+	/* get lower aligned address */
+	wp = (addr & ~(info->portwidth - 1));
+
+	/* handle unaligned start */
+	if ((aln = addr - wp) != 0) {
+		cword.l = 0;
+		cp = wp;
+		for (i = 0; i < aln; ++i, ++cp)
+			flash_add_byte (info, &cword, (*(uchar *) cp));
+
+		for (; (i < info->portwidth) && (cnt > 0); i++) {
+			flash_add_byte (info, &cword, *src++);
+			cnt--;
+			cp++;
+		}
+		for (; (cnt == 0) && (i < info->portwidth); ++i, ++cp)
+			flash_add_byte (info, &cword, (*(uchar *) cp));
+		if ((rc = flash_write_cfiword (info, wp, cword)) != 0)
+			return rc;
+		wp = cp;
+	}
+
+	/* handle the aligned part */
+#ifdef CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+	buffered_size = (info->portwidth / info->chipwidth);
+	buffered_size *= info->buffer_size;
+	while (cnt >= info->portwidth) {
+		/* Show processing */
+		if ((++patcnt % 256) == 0)
+		    printf("%c\b", pat[(patcnt / 256) & 0x03]);
+
+		i = buffered_size > cnt ? cnt : buffered_size;
+		if ((rc = flash_write_cfibuffer (info, wp, src, i)) != ERR_OK)
+			return rc;
+		i -= i & (info->portwidth - 1);
+		wp += i;
+		src += i;
+		cnt -= i;
+	}
+#else
+	while (cnt >= info->portwidth) {
+		cword.l = 0;
+		for (i = 0; i < info->portwidth; i++) {
+			flash_add_byte (info, &cword, *src++);
+		}
+		if ((rc = flash_write_cfiword (info, wp, cword)) != 0)
+			return rc;
+		wp += info->portwidth;
+		cnt -= info->portwidth;
+	}
+#endif /* CONFIG_SYS_FLASH_USE_BUFFER_WRITE */
+	if (cnt == 0) {
+		return (0);
+	}
+
+	/*
+	 * handle unaligned tail bytes
+	 */
+	cword.l = 0;
+	for (i = 0, cp = wp; (i < info->portwidth) && (cnt > 0); ++i, ++cp) {
+		flash_add_byte (info, &cword, *src++);
+		--cnt;
+	}
+	for (; i < info->portwidth; ++i, ++cp) {
+		flash_add_byte (info, &cword, (*(uchar *) cp));
+	}
+
+	return flash_write_cfiword (info, wp, cword);
+}
+
+/*-----------------------------------------------------------------------
+ */
+#ifdef CFG_FLASH_PROTECTION
+
+int flash_real_protect (flash_info_t * info, long sector, int prot)
+{
+	int retcode = 0;
+
+	flash_write_cmd (info, sector, 0, FLASH_CMD_CLEAR_STATUS);
+	flash_write_cmd (info, sector, 0, FLASH_CMD_PROTECT);
+	if (prot)
+		flash_write_cmd (info, sector, 0, FLASH_CMD_PROTECT_SET);
+	else
+		flash_write_cmd (info, sector, 0, FLASH_CMD_PROTECT_CLEAR);
+
+	if ((retcode =
+	     flash_full_status_check (info, sector, info->erase_blk_tout,
+				      prot ? "protect" : "unprotect")) == 0) {
+
+		info->protect[sector] = prot;
+		/* Intel's unprotect unprotects all locking */
+		if (prot == 0) {
+			flash_sect_t i;
+
+			for (i = 0; i < info->sector_count; i++) {
+				if (info->protect[i])
+					flash_real_protect (info, i, 1);
+			}
+		}
+	}
+	return retcode;
+}
+
+/*-----------------------------------------------------------------------
+ * flash_read_user_serial - read the OneTimeProgramming cells
+ */
+void flash_read_user_serial (flash_info_t * info, void *buffer, int offset,
+			     int len)
+{
+	uchar *src;
+	uchar *dst;
+
+	dst = buffer;
+	src = flash_make_addr (info, 0, FLASH_OFFSET_USER_PROTECTION);
+	flash_write_cmd (info, 0, 0, FLASH_CMD_READ_ID);
+	memcpy (dst, src + offset, len);
+	flash_write_cmd (info, 0, 0, info->cmd_reset);
+}
+
+/*
+ * flash_read_factory_serial - read the device Id from the protection area
+ */
+void flash_read_factory_serial (flash_info_t * info, void *buffer, int offset,
+				int len)
+{
+	uchar *src;
+
+	src = flash_make_addr (info, 0, FLASH_OFFSET_INTEL_PROTECTION);
+	flash_write_cmd (info, 0, 0, FLASH_CMD_READ_ID);
+	memcpy (buffer, src + offset, len);
+	flash_write_cmd (info, 0, 0, info->cmd_reset);
+}
+
+#endif /* CFG_FLASH_PROTECTION */
+
+/*
+ * flash_is_busy - check to see if the flash is busy
+ * This routine checks the status of the chip and returns true if the chip is busy
+ */
+static int flash_is_busy (flash_info_t * info, flash_sect_t sect)
+{
+	int retval;
+
+	switch (info->vendor) {
+	case CFI_CMDSET_INTEL_STANDARD:
+	case CFI_CMDSET_INTEL_EXTENDED:
+		retval = !flash_isset (info, sect, 0, FLASH_STATUS_DONE);
+		break;
+	case CFI_CMDSET_AMD_STANDARD:
+	case CFI_CMDSET_AMD_EXTENDED:
+		retval = flash_toggle (info, sect, 0, AMD_STATUS_TOGGLE);
+		break;
+	default:
+		retval = 0;
+	}
+#ifdef DEBUG_FLASH
+	if (retval)
+	    debug ("flash_is_busy: %d\n", retval);
+#endif
+	return retval;
+}
+
+/*-----------------------------------------------------------------------
+ *  wait for XSR.7 to be set. Time out with an error if it does not.
+ *  This routine does not set the flash to read-array mode.
+ */
+static int flash_status_check (flash_info_t * info, flash_sect_t sector,
+			       ulong tout, char *prompt)
+{
+	ulong start, now;
+
+	/* Wait for command completion */
+	// (Sun) Fix order of checking time so it works when the CPU is very
+	// slow, e.g., single-stepping or emulation.
+	start = get_timer (0);
+	while (now = get_timer(start),
+	       flash_is_busy (info, sector))
+	{
+		if (now > info->erase_blk_tout) {
+			printf ("Flash %s timeout at address %lx data %lx\n",
+				prompt, info->start[sector],
+				flash_read_long (info, sector, 0));
+			flash_write_cmd (info, sector, 0, info->cmd_reset);
+			return ERR_TIMOUT;
+		}
+	}
+	return ERR_OK;
+}
+
+/*-----------------------------------------------------------------------
+ * Wait for XSR.7 to be set, if it times out print an error, otherwise do a full status check.
+ * This routine sets the flash to read-array mode.
+ */
+static int flash_full_status_check (flash_info_t * info, flash_sect_t sector,
+				    ulong tout, char *prompt)
+{
+	int retcode;
+
+	retcode = flash_status_check (info, sector, tout, prompt);
+	switch (info->vendor) {
+	case CFI_CMDSET_INTEL_EXTENDED:
+	case CFI_CMDSET_INTEL_STANDARD:
+		if ((retcode != ERR_OK)
+		    && !flash_isequal (info, sector, 0, FLASH_STATUS_DONE)) {
+			retcode = ERR_INVAL;
+			printf ("Flash %s error at address %lx\n", prompt,
+				info->start[sector]);
+			if (flash_isset (info, sector, 0, FLASH_STATUS_ECLBS | FLASH_STATUS_PSLBS)) {
+				puts ("Command Sequence Error.\n");
+			} else if (flash_isset (info, sector, 0, FLASH_STATUS_ECLBS)) {
+				puts ("Block Erase Error.\n");
+				retcode = ERR_NOT_ERASED;
+			} else if (flash_isset (info, sector, 0, FLASH_STATUS_PSLBS)) {
+				puts ("Locking Error\n");
+			}
+			if (flash_isset (info, sector, 0, FLASH_STATUS_DPS)) {
+				puts ("Block locked.\n");
+				retcode = ERR_PROTECTED;
+			}
+			if (flash_isset (info, sector, 0, FLASH_STATUS_VPENS))
+				puts ("Vpp Low Error.\n");
+		}
+		flash_write_cmd (info, sector, 0, info->cmd_reset);
+		break;
+	default:
+		break;
+	}
+	return retcode;
+}
+
+static void write_buffer_abort_reset(flash_info_t * info, flash_sect_t sector)
+{
+     flash_write_cmd (info, sector, 0xaaa, 0xaa);
+     flash_write_cmd (info, sector, 0x555, 0x55);
+     flash_write_cmd (info, sector, 0xaaa, 0xf0);    	
+}	
+
+/*-----------------------------------------------------------------------
+ */
+static void flash_add_byte (flash_info_t * info, cfiword_t * cword, uchar c)
+{
+#if defined(__LITTLE_ENDIAN)
+	unsigned short	w;
+	unsigned int	l;
+	unsigned long long ll;
+#endif
+
+	switch (info->portwidth) {
+	case FLASH_CFI_8BIT:
+		cword->c = c;
+		break;
+	case FLASH_CFI_16BIT:
+#if defined(__LITTLE_ENDIAN)
+		w = c;
+		w <<= 8;
+		cword->w = (cword->w >> 8) | w;
+#else
+		cword->w = (cword->w << 8) | c;
+#endif
+		break;
+	case FLASH_CFI_32BIT:
+#if defined(__LITTLE_ENDIAN)
+		l = c;
+		l <<= 24;
+		cword->l = (cword->l >> 8) | l;
+#else
+		cword->l = (cword->l << 8) | c;
+#endif
+		break;
+	case FLASH_CFI_64BIT:
+#if defined(__LITTLE_ENDIAN)
+		ll = c;
+		ll <<= 56;
+		cword->ll = (cword->ll >> 8) | ll;
+#else
+		cword->ll = (cword->ll << 8) | c;
+#endif
+		break;
+	}
+}
+
+
+/*-----------------------------------------------------------------------
+ * make a proper sized command based on the port and chip widths
+ */
+static void flash_make_cmd (flash_info_t * info, uchar cmd, void *cmdbuf)
+{
+	int i;
+	uchar *cp = (uchar *) cmdbuf;
+
+#if defined(__LITTLE_ENDIAN)
+	for (i = info->portwidth; i > 0; i--)
+#else
+	for (i = 1; i <= info->portwidth; i++)
+#endif
+		*cp++ = (i & (info->chipwidth - 1)) ? '\0' : cmd;
+}
+
+/*
+ * Write a proper sized command to the correct address
+ */
+static void
+flash_write_cmd (flash_info_t * info, flash_sect_t sect, uint offset,
+		 uchar cmd)
+{
+#ifdef DEBUG_FLASH
+    const int noDebug = 0;
+#else
+    const int noDebug = 1;
+#endif
+    return flash_write_cmd_int(info, sect, offset, cmd, noDebug);
+}
+static void
+flash_write_cmd_nodbg (flash_info_t * info, flash_sect_t sect, uint offset,
+		       uchar cmd)
+{
+    return flash_write_cmd_int(info, sect, offset, cmd, 1);
+}
+
+static void
+flash_write_cmd_int (flash_info_t * info, flash_sect_t sect, uint offset,
+		     uchar cmd, int noDebug)
+{
+
+	volatile cfiptr_t addr;
+	cfiword_t cword;
+
+	addr.cp = flash_make_addr (info, sect, offset);
+	flash_make_cmd (info, cmd, &cword);
+	switch (info->portwidth) {
+	case FLASH_CFI_8BIT:
+		if (noDebug == 0)
+		debug ("fwc addr %p cmd %x %x 8bit x %d bit\n", addr.cp, cmd,
+		       cword.c, info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
+		*addr.cp = cword.c;
+		break;
+	case FLASH_CFI_16BIT:
+		if (noDebug == 0)
+		debug ("fwc addr %p cmd %x %4.4x 16bit x %d bit\n", addr.wp,
+		       cmd, cword.w,
+		       info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
+		*addr.wp = cword.w;
+		break;
+	case FLASH_CFI_32BIT:
+		if (noDebug == 0)
+		debug ("fwc addr %p cmd %x %8.8lx 32bit x %d bit\n", addr.lp,
+		       cmd, cword.l,
+		       info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
+		*addr.lp = cword.l;
+		break;
+	case FLASH_CFI_64BIT:
+#ifdef DEBUG_FLASH
+		if (noDebug == 0)
+		{
+			char str[20];
+
+			print_longlong (str, cword.ll);
+
+			debug ("fwrite addr %p cmd %x %s 64 bit x %d bit\n",
+			       addr.llp, cmd, str,
+			       info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
+		}
+#endif
+		*addr.llp = cword.ll;
+		break;
+	}
+}
+
+static void flash_unlock_seq (flash_info_t * info, flash_sect_t sect)
+{
+	flash_write_cmd_nodbg (info, sect, AMD_ADDR_START, AMD_CMD_UNLOCK_START);
+	flash_write_cmd_nodbg (info, sect, AMD_ADDR_ACK, AMD_CMD_UNLOCK_ACK);
+}
+
+/*-----------------------------------------------------------------------
+ */
+static int flash_isequal (flash_info_t * info, flash_sect_t sect, uint offset, uchar cmd)
+{
+	cfiptr_t cptr;
+	cfiword_t cword;
+	int retval;
+#ifdef DEBUG_FLASH
+	const int dbg = 1;
+#else
+	const int dbg = 0;
+#endif
+	cptr.cp = flash_make_addr (info, sect, offset);
+	flash_make_cmd (info, cmd, &cword);
+
+	if (dbg)
+	    debug ("is= cmd %x(%c) addr %p ", cmd, cmd, cptr.cp);
+	switch (info->portwidth) {
+	case FLASH_CFI_8BIT:
+		if (dbg)
+		    debug ("is= %x %x\n", cptr.cp[0], cword.c);
+		retval = (cptr.cp[0] == cword.c);
+		break;
+	case FLASH_CFI_16BIT:
+		if (dbg)
+		    debug ("is= %4.4x %4.4x\n", cptr.wp[0], cword.w);
+		retval = (cptr.wp[0] == cword.w);
+		break;
+	case FLASH_CFI_32BIT:
+		if (dbg)
+		    debug ("is= %8.8lx %8.8lx\n", cptr.lp[0], cword.l);
+		retval = (cptr.lp[0] == cword.l);
+		break;
+	case FLASH_CFI_64BIT:
+#ifdef DEBUG_FLASH
+		{
+			char str1[20];
+			char str2[20];
+
+			print_longlong (str1, cptr.llp[0]);
+			print_longlong (str2, cword.ll);
+			debug ("is= %s %s\n", str1, str2);
+		}
+#endif
+		retval = (cptr.llp[0] == cword.ll);
+		break;
+	default:
+		retval = 0;
+		break;
+	}
+	return retval;
+}
+
+/*-----------------------------------------------------------------------
+ */
+static int flash_isset (flash_info_t * info, flash_sect_t sect, uint offset, uchar cmd)
+{
+	cfiptr_t cptr;
+	cfiword_t cword;
+	int retval;
+
+	cptr.cp = flash_make_addr (info, sect, offset);
+	flash_make_cmd (info, cmd, &cword);
+	switch (info->portwidth) {
+	case FLASH_CFI_8BIT:
+		retval = ((cptr.cp[0] & cword.c) == cword.c);
+		break;
+	case FLASH_CFI_16BIT:
+		retval = ((cptr.wp[0] & cword.w) == cword.w);
+		break;
+	case FLASH_CFI_32BIT:
+		retval = ((cptr.lp[0] & cword.l) == cword.l);
+		break;
+	case FLASH_CFI_64BIT:
+		retval = ((cptr.llp[0] & cword.ll) == cword.ll);
+		break;
+	default:
+		retval = 0;
+		break;
+	}
+	return retval;
+}
+
+/*-----------------------------------------------------------------------
+ */
+static int flash_toggle (flash_info_t * info, flash_sect_t sect, uint offset, uchar cmd)
+{
+	cfiptr_t cptr;
+	cfiword_t cword;
+	int retval;
+
+	cptr.cp = flash_make_addr (info, sect, offset);
+	flash_make_cmd (info, cmd, &cword);
+	switch (info->portwidth) {
+	case FLASH_CFI_8BIT:
+		retval = ((cptr.cp[0] & cword.c) != (cptr.cp[0] & cword.c));
+		break;
+	case FLASH_CFI_16BIT:
+		retval = ((cptr.wp[0] & cword.w) != (cptr.wp[0] & cword.w));
+		break;
+	case FLASH_CFI_32BIT:
+		retval = ((cptr.lp[0] & cword.l) != (cptr.lp[0] & cword.l));
+		break;
+	case FLASH_CFI_64BIT:
+		retval = ((cptr.llp[0] & cword.ll) !=
+			  (cptr.llp[0] & cword.ll));
+		break;
+	default:
+		retval = 0;
+		break;
+	}
+	return retval;
+}
+
+/*-----------------------------------------------------------------------
+ * detect if flash is compatible with the Common Flash Interface (CFI)
+ * http://www.jedec.org/download/search/jesd68.pdf
+ *
+*/
+static int flash_detect_cfi (flash_info_t * info)
+{
+        ulong data;
+        	
+	debug ("flash_detect_cfi()... ");
+
+#if     defined(CONFIG_FLASH_AST2300)
+        data = *(ulong *)(0x1e6e2070);		/* hardware traping */
+        if (data & 0x10)			/* D[4]: 0/1 (8/16) */
+            info->portwidth = FLASH_CFI_16BIT;
+        else
+            info->portwidth = FLASH_CFI_8BIT;            
+#else
+        info->portwidth = FLASH_CFI_8BIT;
+#endif
+
+	{     	
+		for (info->chipwidth = FLASH_CFI_BY8;
+		     info->chipwidth <= info->portwidth;
+		     info->chipwidth <<= 1) {
+			flash_write_cmd (info, 0, 0, FLASH_CMD_RESET);
+			flash_write_cmd (info, 0, FLASH_OFFSET_CFI, FLASH_CMD_CFI);
+			if (flash_isequal (info, 0, FLASH_OFFSET_CFI_RESP, 'Q')
+			    //FIXME: Next 3 lines were changed for 8-bit/16-bit flash chips.
+			    && flash_isequal (info, 0, FLASH_OFFSET_CFI_RESP1, 'R')
+			    && flash_isequal (info, 0, FLASH_OFFSET_CFI_RESP2, 'Y')) {
+				info->interface = flash_read_uchar (info, FLASH_OFFSET_INTERFACE);
+				debug ("device interface is %d\n",
+				       info->interface);
+				debug ("found port %d chip %d ",
+				       info->portwidth, info->chipwidth);
+				debug ("port %d bits chip %d bits\n",
+				       info->portwidth << CFI_FLASH_SHIFT_WIDTH,
+				       info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
+				return 1;
+			}
+		}
+	}
+	debug ("not found\n");
+	return 0;
+}
+
+/*
+ * The following code cannot be run from FLASH!
+ *
+ */
+ulong flash_get_size (ulong base, int banknum)
+{
+	flash_info_t *info = &flash_info[banknum];
+	int i, j;
+	flash_sect_t sect_cnt;
+	unsigned long sector;
+	unsigned long tmp;
+	int size_ratio;
+	uchar num_erase_regions;
+	int erase_region_size;
+	int erase_region_count;
+
+	info->start[0] = base;
+
+	if (flash_detect_cfi (info)) {
+		info->vendor = flash_read_uchar (info, FLASH_OFFSET_PRIMARY_VENDOR);
+#if defined(DEBUG_FLASH)
+		flash_printqry (info, 0);
+#endif
+		switch (info->vendor) {
+		case CFI_CMDSET_INTEL_STANDARD:
+		case CFI_CMDSET_INTEL_EXTENDED:
+		default:
+			info->cmd_reset = FLASH_CMD_RESET;
+			break;
+		case CFI_CMDSET_AMD_STANDARD:
+		case CFI_CMDSET_AMD_EXTENDED:
+			info->cmd_reset = AMD_CMD_RESET;
+			break;
+		}
+
+		debugX(2, "manufacturer is %d\n", info->vendor);
+		size_ratio = info->portwidth / info->chipwidth;
+		/* if the chip is x8/x16 reduce the ratio by half */
+#if 0
+		if ((info->interface == FLASH_CFI_X8X16)
+		    && (info->chipwidth == FLASH_CFI_BY8)) {
+			size_ratio >>= 1;
+		}
+#endif
+		num_erase_regions = flash_read_uchar (info, FLASH_OFFSET_NUM_ERASE_REGIONS);
+		debugX(2, "size_ratio %d port %d bits chip %d bits\n",
+		       size_ratio, info->portwidth << CFI_FLASH_SHIFT_WIDTH,
+		       info->chipwidth << CFI_FLASH_SHIFT_WIDTH);
+		debugX(2, "found %d erase regions\n", num_erase_regions);
+		sect_cnt = 0;
+		sector = base;
+		for (i = 0; i < num_erase_regions; i++) {
+			if (i > MAX_NUM_ERASE_REGIONS) {
+				printf ("%d erase regions found, only %d used\n",
+					num_erase_regions, MAX_NUM_ERASE_REGIONS);
+				break;
+			}
+			// CFI Erase Block Region Information:
+			// Bits[31:16] = sect_size/256, 0 means 128-byte
+			// Bits[15:0]  = num_sectors - 1
+			tmp = flash_read_long(info, 0,
+					      FLASH_OFFSET_ERASE_REGIONS + i * 4);
+			debug("CFI erase block region info[%d]: 0x%08x, ",
+			      i, tmp);
+			erase_region_count = (tmp & 0xffff) + 1;
+			tmp >>= 16;
+			erase_region_size = (tmp ? tmp * 256 : 128);
+			debug ("erase_region_count=%d erase_region_size=%d\n",
+				erase_region_count, erase_region_size);
+#if 0
+                        erase_region_size  = CFG_FLASH_SECTOR_SIZE;	// Commented out
+                        erase_region_count = CFG_FLASH_SECTOR_COUNT;	// Commented out
+#endif
+			if (sect_cnt + erase_region_count > CONFIG_SYS_MAX_FLASH_SECT) {
+			    printf("Warning: Erase region %d adds too many flash sectors"
+				   " %d+%d; reducing to fit total limit of %d\n",
+				   i, sect_cnt, erase_region_count, CONFIG_SYS_MAX_FLASH_SECT);
+			    erase_region_count = CONFIG_SYS_MAX_FLASH_SECT - sect_cnt;
+			}
+			for (j = 0; j < erase_region_count; j++) {
+				info->start[sect_cnt] = sector;
+				sector += (erase_region_size * size_ratio);
+
+				/*
+				 * Only read protection status from supported devices (intel...)
+				 */
+				switch (info->vendor) {
+				case CFI_CMDSET_INTEL_EXTENDED:
+				case CFI_CMDSET_INTEL_STANDARD:
+					info->protect[sect_cnt] =
+						flash_isset (info, sect_cnt,
+							     FLASH_OFFSET_PROTECT,
+							     FLASH_STATUS_PROTECT);
+					break;
+				default:
+					info->protect[sect_cnt] = 0; /* default: not protected */
+				}
+
+				sect_cnt++;
+			}
+		}
+
+		info->sector_count = sect_cnt;
+		/* multiply the size by the number of chips */
+		// info->size = (1 << flash_read_uchar (info, FLASH_OFFSET_SIZE)) * size_ratio;
+		// Use only the sectors that fit within the flash_info array size.
+		info->size = sector - base;
+		printf("Flash bank %d at %08x has 0x%x bytes in %d sectors"
+		       " (chipSize 1<<%d, size_ratio %d).\n",
+		       banknum, base, info->size, info->sector_count,
+		       flash_read_uchar(info, FLASH_OFFSET_SIZE), size_ratio);
+
+		info->buffer_size = (1 << flash_read_uchar (info, FLASH_OFFSET_BUFFER_SIZE));		
+		/* Limit the buffer size to 32bytes to meet most of AMD-styles flash's minimum requirement */
+		if (info->buffer_size > 32)
+		    info->buffer_size = 32;    
+		tmp = 1 << flash_read_uchar (info, FLASH_OFFSET_ETOUT);
+		info->erase_blk_tout = (tmp * (1 << flash_read_uchar (info, FLASH_OFFSET_EMAX_TOUT)));
+		tmp = 1 << flash_read_uchar (info, FLASH_OFFSET_WBTOUT);
+		info->buffer_write_tout = (tmp * (1 << flash_read_uchar (info, FLASH_OFFSET_WBMAX_TOUT)));
+		tmp = 1 << flash_read_uchar (info, FLASH_OFFSET_WTOUT);
+		info->write_tout = (tmp * (1 << flash_read_uchar (info, FLASH_OFFSET_WMAX_TOUT))) / 1000;
+		info->flash_id = FLASH_MAN_CFI;
+#if 0
+		if ((info->interface == FLASH_CFI_X8X16) && (info->chipwidth == FLASH_CFI_BY8)) {
+			info->portwidth >>= 1;	/* XXX - Need to test on x8/x16 in parallel. */
+		}
+#endif
+	}
+
+	flash_write_cmd (info, 0, 0, info->cmd_reset);
+	return (info->size);
+}
+
+
+/*-----------------------------------------------------------------------
+ */
+static int flash_write_cfiword (flash_info_t * info, ulong dest,
+				cfiword_t cword)
+{
+
+	cfiptr_t ctladdr;
+	cfiptr_t cptr;
+	int flag;
+
+	ctladdr.cp = flash_make_addr (info, 0, 0);
+	cptr.cp = (uchar *) dest;
+
+
+	/* Check if Flash is (sufficiently) erased */
+	switch (info->portwidth) {
+	case FLASH_CFI_8BIT:
+		flag = ((cptr.cp[0] & cword.c) == cword.c);
+		break;
+	case FLASH_CFI_16BIT:
+		flag = ((cptr.wp[0] & cword.w) == cword.w);
+		break;
+	case FLASH_CFI_32BIT:
+		flag = ((cptr.lp[0] & cword.l) == cword.l);
+		break;
+	case FLASH_CFI_64BIT:
+		flag = ((cptr.llp[0] & cword.ll) == cword.ll);
+		break;
+	default:
+		return 2;
+	}
+	if (!flag)
+		return 2;
+
+	/* Disable interrupts which might cause a timeout here */
+	flag = disable_interrupts ();
+
+	switch (info->vendor) {
+	case CFI_CMDSET_INTEL_EXTENDED:
+	case CFI_CMDSET_INTEL_STANDARD:
+		flash_write_cmd_nodbg (info, 0, 0, FLASH_CMD_CLEAR_STATUS);
+		flash_write_cmd_nodbg (info, 0, 0, FLASH_CMD_WRITE);
+		break;
+	case CFI_CMDSET_AMD_EXTENDED:
+	case CFI_CMDSET_AMD_STANDARD:
+		flash_unlock_seq (info, 0);
+		flash_write_cmd_nodbg (info, 0, AMD_ADDR_START, AMD_CMD_WRITE);
+		break;
+	}
+
+	switch (info->portwidth) {
+	case FLASH_CFI_8BIT:
+		cptr.cp[0] = cword.c;
+		break;
+	case FLASH_CFI_16BIT:
+		cptr.wp[0] = cword.w;
+		break;
+	case FLASH_CFI_32BIT:
+		cptr.lp[0] = cword.l;
+		break;
+	case FLASH_CFI_64BIT:
+		cptr.llp[0] = cword.ll;
+		break;
+	}
+
+	/* re-enable interrupts if necessary */
+	if (flag)
+		enable_interrupts ();
+
+	return flash_full_status_check (info, 0, info->write_tout, "write");
+}
+
+#ifdef CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+
+/* loop through the sectors from the highest address
+ * when the passed address is greater or equal to the sector address
+ * we have a match
+ */
+static flash_sect_t find_sector (flash_info_t * info, ulong addr)
+{
+	flash_sect_t sector;
+
+	for (sector = info->sector_count - 1; sector >= 0; sector--) {
+		if (addr >= info->start[sector])
+			break;
+	}
+	return sector;
+}
+
+static int flash_write_cfibuffer (flash_info_t * info, ulong dest, uchar * cp,
+				  int len)
+{
+	flash_sect_t sector;
+	int cnt;
+	int retcode;
+	volatile cfiptr_t src;
+	volatile cfiptr_t dst;
+
+/* Add AMD write buffer mode support, ycchen@102006 */
+#if 0
+	/* buffered writes in the AMD chip set is not supported yet */
+	if((info->vendor ==  CFI_CMDSET_AMD_STANDARD) ||
+		(info->vendor == CFI_CMDSET_AMD_EXTENDED))
+		return ERR_INVAL;
+#endif
+	if((info->vendor ==  CFI_CMDSET_AMD_STANDARD) ||
+		(info->vendor == CFI_CMDSET_AMD_EXTENDED))
+	{
+		retcode = flash_write_cfibuffer_amd(info, dest, cp, len);
+                return retcode;
+        }
+
+	src.cp = cp;
+	dst.cp = (uchar *) dest;
+	sector = find_sector (info, dest);
+	flash_write_cmd (info, sector, 0, FLASH_CMD_CLEAR_STATUS);
+	flash_write_cmd (info, sector, 0, FLASH_CMD_WRITE_TO_BUFFER);
+	if ((retcode =
+	     flash_status_check (info, sector, info->buffer_write_tout,
+				 "write to buffer")) == ERR_OK) {
+		/* reduce the number of loops by the width of the port	*/
+		switch (info->portwidth) {
+		case FLASH_CFI_8BIT:
+			cnt = len;
+			break;
+		case FLASH_CFI_16BIT:
+			cnt = len >> 1;
+			break;
+		case FLASH_CFI_32BIT:
+			cnt = len >> 2;
+			break;
+		case FLASH_CFI_64BIT:
+			cnt = len >> 3;
+			break;
+		default:
+			return ERR_INVAL;
+			break;
+		}
+		flash_write_cmd (info, sector, 0, (uchar) cnt - 1);
+		while (cnt-- > 0) {
+			switch (info->portwidth) {
+			case FLASH_CFI_8BIT:
+				*dst.cp++ = *src.cp++;
+				break;
+			case FLASH_CFI_16BIT:
+				*dst.wp++ = *src.wp++;
+				break;
+			case FLASH_CFI_32BIT:
+				*dst.lp++ = *src.lp++;
+				break;
+			case FLASH_CFI_64BIT:
+				*dst.llp++ = *src.llp++;
+				break;
+			default:
+				return ERR_INVAL;
+				break;
+			}
+		}
+		flash_write_cmd (info, sector, 0,
+				 FLASH_CMD_WRITE_BUFFER_CONFIRM);
+		retcode =
+			flash_full_status_check (info, sector,
+						 info->buffer_write_tout,
+						 "buffer write");
+	}
+	flash_write_cmd (info, sector, 0, FLASH_CMD_CLEAR_STATUS);
+	return retcode;
+}
+
+
+static int flash_write_cfibuffer_amd (flash_info_t * info, ulong dest, uchar * cp,
+				  int len)
+{
+	flash_sect_t sector;
+	int cnt;
+	int retcode;
+	volatile cfiptr_t src;
+	volatile cfiptr_t dst;
+	volatile cfiword_t tmpsrc, tmpdst;
+
+	src.cp = cp;
+	dst.cp = (uchar *) dest;
+	sector = find_sector (info, dest);
+	flash_unlock_seq (info, 0);
+	if ((retcode =
+	     flash_status_check (info, sector, info->buffer_write_tout,
+				 "write to buffer")) == ERR_OK) {
+		/* reduce the number of loops by the width of the port	*/
+		switch (info->portwidth) {
+		case FLASH_CFI_8BIT:
+			cnt = len;
+			*dst.cp = (uchar) (AMD_CMD_WRITE_TO_BUFFER);
+			*dst.cp = (uchar) (cnt -1);
+			break;
+		case FLASH_CFI_16BIT:
+			cnt = len >> 1;
+			*dst.wp = (unsigned short) (AMD_CMD_WRITE_TO_BUFFER);
+			*dst.wp = (unsigned short) (cnt -1);
+			break;
+		case FLASH_CFI_32BIT:
+			cnt = len >> 2;
+			*dst.lp = (unsigned long) (AMD_CMD_WRITE_TO_BUFFER);
+			*dst.lp = (unsigned long) (cnt -1);
+			break;
+		case FLASH_CFI_64BIT:
+			cnt = len >> 3;
+			*dst.llp = (unsigned long long) (AMD_CMD_WRITE_TO_BUFFER);
+			*dst.llp = (unsigned long long) (cnt -1);
+			break;
+		default:
+			return ERR_INVAL;
+			break;
+		}
+		while (cnt-- > 0) {
+			switch (info->portwidth) {
+			case FLASH_CFI_8BIT:
+				*dst.cp++ = *src.cp++;
+				break;
+			case FLASH_CFI_16BIT:
+				*dst.wp++ = *src.wp++;
+				break;
+			case FLASH_CFI_32BIT:
+				*dst.lp++ = *src.lp++;
+				break;
+			case FLASH_CFI_64BIT:
+				*dst.llp++ = *src.llp++;
+				break;
+			default:
+				return ERR_INVAL;
+				break;
+			}
+		}				
+		switch (info->portwidth) {
+		case FLASH_CFI_8BIT:
+		        src.cp--;
+		        dst.cp--;
+			*dst.cp = (unsigned char) (AMD_CMD_BUFFER_TO_FLASH);
+		        tmpsrc.c = *src.cp & 0x80;
+		        
+		        do {
+		            tmpdst.c = *(volatile uchar *)(dst.cp);		        
+		        	
+		            if (tmpdst.c & 0x20) {	/* toggle DQ5 */
+		                 tmpdst.c = *(volatile uchar *)(dst.cp);		        
+		                 if ((tmpdst.c & 0x80) != tmpsrc.c)
+		                 {
+		                     printf("program error occurred\n");
+			             flash_write_cmd (info, sector, 0, info->cmd_reset);		            
+			             return ERR_PROG_ERROR;			             
+			         }    
+		            }
+		            else if (tmpdst.c & 0x02) {	/* toggle DQ1 */
+		                 tmpdst.c = *(volatile uchar *)(dst.cp);		        
+		                 if ((tmpdst.c & 0x80) != tmpsrc.c)
+		                 {
+		                     printf("write buffer error occurred \n");
+		                     write_buffer_abort_reset(info, sector);
+			             return ERR_PROG_ERROR;			             
+			         } 		            
+		            }	
+		            		                	
+		        } while ((tmpdst.c & 0x80) != tmpsrc.c);
+		        			        
+			break;
+		case FLASH_CFI_16BIT:
+		        src.wp--;
+		        dst.wp--;
+			*dst.wp = (unsigned short) (AMD_CMD_BUFFER_TO_FLASH);
+		        tmpsrc.w = *src.wp & 0x80;
+
+		        do {
+		            tmpdst.w = *(volatile short *)(dst.wp);		        
+		        	
+		            if (tmpdst.w & 0x20) {	/* toggle DQ5 */
+		                 tmpdst.w = *(volatile ushort *)(dst.wp);		        
+		                 if ((tmpdst.w & 0x80) != tmpsrc.w)
+		                 {
+		                     printf("program error occurred\n");
+			             flash_write_cmd (info, sector, 0, info->cmd_reset);		            
+			             return ERR_PROG_ERROR;			             
+			         }    
+		            }
+		            else if (tmpdst.w & 0x02) {	/* toggle DQ1 */
+		                 tmpdst.w = *(volatile ushort *)(dst.wp);		        
+		                 if ((tmpdst.w & 0x80) != tmpsrc.w)
+		                 {
+		                     printf("write buffer error occurred \n");
+		                     write_buffer_abort_reset(info, sector);
+			             return ERR_PROG_ERROR;			             
+			         } 		            
+		            }	
+		            		                	
+		        } while ((tmpdst.w & 0x80) != tmpsrc.w);
+		        
+			break;
+		case FLASH_CFI_32BIT:
+		        src.lp--;
+		        dst.lp--;
+			*dst.lp = (unsigned long) (AMD_CMD_BUFFER_TO_FLASH);
+		        tmpsrc.l = *src.lp & 0x80;
+		        
+		        do {
+		            tmpdst.l = *(volatile ulong *)(dst.lp);		        
+		        	
+		            if (tmpdst.l & 0x20) {	/* toggle DQ5 */
+		                 tmpdst.l = *(volatile ulong *)(dst.lp);		        
+		                 if ((tmpdst.l & 0x80) != tmpsrc.l)
+		                 {
+		                     printf("program error occurred\n");
+			             flash_write_cmd (info, sector, 0, info->cmd_reset);		            
+			             return ERR_PROG_ERROR;			             
+			         }    
+		            }
+		            else if (tmpdst.l & 0x02) {	/* toggle DQ1 */
+		                 tmpdst.l = *(volatile ulong *)(dst.lp);		        
+		                 if ((tmpdst.l & 0x80) != tmpsrc.l)
+		                 {
+		                     printf("write buffer error occurred \n");
+		                     write_buffer_abort_reset(info, sector);
+			             return ERR_PROG_ERROR;			             
+			         } 		            
+		            }	
+		            		                	
+		        } while ((tmpdst.l & 0x80) != tmpsrc.l);
+		        
+			break;
+		case FLASH_CFI_64BIT:
+		        src.llp--;
+		        dst.llp--;
+			*dst.llp = (unsigned long long) (AMD_CMD_BUFFER_TO_FLASH);
+		        tmpsrc.ll = *src.llp & 0x80;
+		        
+		        do {
+		            tmpdst.ll = *(volatile unsigned long long *)(dst.llp);		        
+		        	
+		            if (tmpdst.ll & 0x20) {	/* toggle DQ5 */
+		                 tmpdst.ll = *(volatile unsigned long long *)(dst.llp);		        
+		                 if ((tmpdst.ll & 0x80) != tmpsrc.ll)
+		                 {
+		                     printf("program error occurred\n");
+			             flash_write_cmd (info, sector, 0, info->cmd_reset);		            
+			             return ERR_PROG_ERROR;			             
+			         }    
+		            }
+		            else if (tmpdst.ll & 0x02) {	/* toggle DQ1 */
+		                 tmpdst.ll = *(volatile unsigned long long *)(dst.llp);		        
+		                 if ((tmpdst.ll & 0x80) != tmpsrc.ll)
+		                 {
+		                     printf("write buffer error occurred \n");
+		                     write_buffer_abort_reset(info, sector);
+			             return ERR_PROG_ERROR;			             
+			         } 		            
+		            }	
+		            		                	
+		        } while ((tmpdst.ll & 0x80) != tmpsrc.ll);
+		        
+			break;
+		default:
+			return ERR_INVAL;
+			break;
+		}
+
+		retcode =
+			flash_full_status_check (info, sector,
+						 info->buffer_write_tout,
+						 "buffer write");
+	}
+
+	return retcode;
+}
+#endif /* CONFIG_SYS_FLASH_USE_BUFFER_WRITE */
+
+#ifdef	CONFIG_FLASH_AST2300_DMA
+#define STCBaseAddress			0x1e620000
+
+/* for DMA */
+#define REG_FLASH_INTERRUPT_STATUS	0x08
+#define REG_FLASH_DMA_CONTROL		0x80
+#define REG_FLASH_DMA_FLASH_BASE	0x84
+#define REG_FLASH_DMA_DRAM_BASE		0x88
+#define REG_FLASH_DMA_LENGTH		0x8c
+
+#define FLASH_STATUS_DMA_BUSY		0x0000
+#define FLASH_STATUS_DMA_READY		0x0800
+#define FLASH_STATUS_DMA_CLEAR		0x0800
+
+#define FLASH_DMA_ENABLE		0x01
+
+void * memmove_dma(void * dest,const void *src,size_t count)
+{
+	ulong count_align, poll_time, data;
+	
+	count_align = (count + 3) & 0xFFFFFFFC;	/* 4-bytes align */
+        poll_time = 100;			/* set 100 us as default */
+
+	*(ulong *) (STCBaseAddress + REG_FLASH_DMA_CONTROL) = (ulong) (~FLASH_DMA_ENABLE);
+	
+	*(ulong *) (STCBaseAddress + REG_FLASH_DMA_FLASH_BASE) = (ulong *) (src);
+	*(ulong *) (STCBaseAddress + REG_FLASH_DMA_DRAM_BASE) = (ulong *) (dest);
+	*(ulong *) (STCBaseAddress + REG_FLASH_DMA_LENGTH) = (ulong) (count_align);
+        udelay(10);
+	*(ulong *) (STCBaseAddress + REG_FLASH_DMA_CONTROL) = (ulong) (FLASH_DMA_ENABLE);
+	
+	/* wait poll */
+	do {
+	    udelay(poll_time);	
+	    data = *(ulong *) (STCBaseAddress + REG_FLASH_INTERRUPT_STATUS);
+	} while (!(data & FLASH_STATUS_DMA_READY));
+	
+	/* clear status */
+	*(ulong *) (STCBaseAddress + REG_FLASH_INTERRUPT_STATUS) |= FLASH_STATUS_DMA_CLEAR;
+}	
+#endif
+#endif /* CFG_FLASH_CFI */
diff --git a/board/aspeed/ast2400/flash_spi.c b/board/aspeed/ast2400/flash_spi.c
new file mode 100755
index 0000000..ad89254
--- /dev/null
+++ b/board/aspeed/ast2400/flash_spi.c
@@ -0,0 +1,1634 @@
+/*
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * History
+ * 01/20/2004 - combined variants of original driver.
+ * 01/22/2004 - Write performance enhancements for parallel chips (Tolunay)
+ * 01/23/2004 - Support for x8/x16 chips (Rune Raknerud)
+ * 01/27/2004 - Little endian support Ed Okerson
+ *
+ * Tested Architectures
+ * Port Width  Chip Width    # of banks	   Flash Chip  Board
+ * 32	       16	     1		   28F128J3    seranoa/eagle
+ * 64	       16	     1		   28F128J3    seranoa/falcon
+ *
+ */
+
+/* The DEBUG define must be before common to enable debugging */
+/* #define DEBUG	*/
+
+#include <common.h>
+#include <asm/processor.h>
+#include <asm/byteorder.h>
+#include <environment.h>
+#ifdef	CONFIG_FLASH_SPI
+
+/*
+ * This file implements a Common Flash Interface (CFI) driver for U-Boot.
+ * The width of the port and the width of the chips are determined at initialization.
+ * These widths are used to calculate the address for access CFI data structures.
+ * It has been tested on an Intel Strataflash implementation and AMD 29F016D.
+ *
+ * References
+ * JEDEC Standard JESD68 - Common Flash Interface (CFI)
+ * JEDEC Standard JEP137-A Common Flash Interface (CFI) ID Codes
+ * Intel Application Note 646 Common Flash Interface (CFI) and Command Sets
+ * Intel 290667-008 3 Volt Intel StrataFlash Memory datasheet
+ *
+ * TODO
+ *
+ * Use Primary Extended Query table (PRI) and Alternate Algorithm Query
+ * Table (ALT) to determine if protection is available
+ *
+ * Add support for other command sets Use the PRI and ALT to determine command set
+ * Verify erase and program timeouts.
+ */
+
+#ifndef CONFIG_FLASH_BANKS_LIST
+#define CONFIG_FLASH_BANKS_LIST { CONFIG_SYS_FLASH_BASE }
+#endif
+
+/* use CFG_MAX_FLASH_BANKS_DETECT if defined */
+#ifdef CONFIG_SYS_MAX_FLASH_BANKS_DETECT
+static ulong bank_base[CONFIG_SYS_MAX_FLASH_BANKS_DETECT] = CONFIG_FLASH_BANKS_LIST;
+flash_info_t flash_info[CONFIG_SYS_MAX_FLASH_BANKS_DETECT];	/* FLASH chips info */
+#else
+static ulong bank_base[CONFIG_SYS_MAX_FLASH_BANKS] = CONFIG_FLASH_BANKS_LIST;
+flash_info_t flash_info[CONFIG_SYS_MAX_FLASH_BANKS];		/* FLASH chips info */
+#endif
+
+/* Support Flash ID */
+#define STM25P64		0x172020
+#define STM25P128		0x182020
+#define N25Q256			0x19ba20
+#define N25Q512			0x20ba20
+#define S25FL064A		0x160201
+#define S25FL128P		0x182001
+#define S25FL256S		0x190201
+#define W25X16			0x1530ef
+#define W25X64			0x1730ef
+#define W25Q64BV		0x1740ef
+#define W25Q128BV		0x1840ef
+#define W25Q256FV		0x1940ef
+#define MX25L1605D		0x1520C2
+#define MX25L12805D		0x1820C2
+#define MX25L25635E		0x1920C2
+#define SST25VF016B             0x4125bf
+#define SST25VF064C             0x4b25bf
+#define AT25DF161		0x02461F
+#define AT25DF321		0x01471F
+
+/* SPI Define */
+#if	defined(CONFIG_FLASH_AST2300) || defined(CONFIG_AST1300)
+#if	defined(CONFIG_AST1300)
+#define STCBaseAddress			0x00620000
+#else
+#define STCBaseAddress			0x1e620000
+#endif
+#define SCU_REVISION_REGISTER		0x1e6e207c
+#define SCU_CACHE_CTRL_REGISTER		0x1e6e2118
+
+#define SPICtrlRegOffset		0x10
+#define SPICtrlRegOffset2		0x14
+
+#define SPIMiscCtrlRegOffset		0x54
+
+/* for DMA */
+#define REG_FLASH_INTERRUPT_STATUS	0x08
+#define REG_FLASH_DMA_CONTROL		0x80
+#define REG_FLASH_DMA_FLASH_BASE	0x84
+#define REG_FLASH_DMA_DRAM_BASE		0x88
+#define REG_FLASH_DMA_LENGTH		0x8c
+
+#define FLASH_STATUS_DMA_BUSY		0x0000
+#define FLASH_STATUS_DMA_READY		0x0800
+#define FLASH_STATUS_DMA_CLEAR		0x0800
+
+#define FLASH_DMA_ENABLE		0x01
+#else
+#define STCBaseAddress			0x16000000
+
+#define SPICtrlRegOffset		0x04
+#define SPICtrlRegOffset2		0x0C
+#endif	/* CONFIG_FLASH_AST2300 */
+
+#define CMD_MASK		0xFFFFFFF8
+
+#define NORMALREAD		0x00
+#define	FASTREAD		0x01
+#define NORMALWRITE		0x02
+#define USERMODE		0x03
+
+#define CE_LOW			0x00
+#define CE_HIGH			0x04
+
+/* AST2300 only */
+#define IOMODEx1		0x00000000
+#define IOMODEx2		0x20000000
+#define IOMODEx2_dummy		0x30000000
+#define IOMODEx4		0x40000000
+#define IOMODEx4_dummy		0x50000000
+
+#define DUMMY_COMMAND_OUT	0x00008000
+/* ~AST2300 only */
+
+/* specificspi */
+#define SpecificSPI_N25Q512	0x00000001		
+
+static ulong AST2300_SPICLK_DIV[16] = {0x0F, 0x07, 0x0E, 0x06, 0x0D, 0x05, 0x0C, 0x04, \
+                                       0x0B, 0x03, 0x0A, 0x02, 0x09, 0x01, 0x08, 0x00 };
+
+/*-----------------------------------------------------------------------
+ * Functions
+ */
+static void reset_flash (flash_info_t * info);
+static void enable_write (flash_info_t * info);
+static void write_status_register (flash_info_t * info, uchar data);
+static void enable4b (flash_info_t * info);
+static void enable4b_spansion (flash_info_t * info);
+static void enable4b_numonyx (flash_info_t * info);
+static ulong flash_get_size (ulong base, int banknum);
+static int flash_write_buffer (flash_info_t *info, uchar *src, ulong addr, int len);
+#if defined(CFG_ENV_IS_IN_FLASH) || defined(CFG_ENV_ADDR_REDUND) || (CFG_MONITOR_BASE >= CFG_FLASH_BASE)
+static flash_info_t *flash_get_info(ulong base);
+#endif
+
+
+/*-----------------------------------------------------------------------
+ * create an address based on the offset and the port width
+ */
+inline uchar *flash_make_addr (flash_info_t * info, flash_sect_t sect, uint offset)
+{
+#ifdef CONFIG_2SPIFLASH
+        if (info->start[0] >= PHYS_FLASH_2)
+	    return ((uchar *) (info->start[sect] + (offset * 1) - (PHYS_FLASH_2 - PHYS_FLASH_2_BASE) ));        
+        else
+	    return ((uchar *) (info->start[sect] + (offset * 1)));
+#else
+	return ((uchar *) (info->start[sect] + (offset * 1)));
+#endif	
+}
+
+/*-----------------------------------------------------------------------
+ * read a character at a port width address
+ */
+inline uchar flash_read_uchar (flash_info_t * info, uint offset)
+{
+	uchar *cp;
+
+	cp = flash_make_addr (info, 0, offset);
+#if defined(__LITTLE_ENDIAN)
+	return (cp[0]);
+#else
+	return (cp[1 - 1]);
+#endif
+}
+
+/*-----------------------------------------------------------------------
+ * read a short word by swapping for ppc format.
+ */
+ushort flash_read_ushort (flash_info_t * info, flash_sect_t sect, uint offset)
+{
+	uchar *addr;
+	ushort retval;
+
+#ifdef DEBUG
+	int x;
+#endif
+	addr = flash_make_addr (info, sect, offset);
+
+#ifdef DEBUG
+	debug ("ushort addr is at %p 1 = %d\n", addr,
+	       1);
+	for (x = 0; x < 2 * 1; x++) {
+		debug ("addr[%x] = 0x%x\n", x, addr[x]);
+	}
+#endif
+#if defined(__LITTLE_ENDIAN)
+	retval = ((addr[(1)] << 8) | addr[0]);
+#else
+	retval = ((addr[(2 * 1) - 1] << 8) |
+		  addr[1 - 1]);
+#endif
+
+	debug ("retval = 0x%x\n", retval);
+	return retval;
+}
+
+/*-----------------------------------------------------------------------
+ * read a long word by picking the least significant byte of each maiximum
+ * port size word. Swap for ppc format.
+ */
+ulong flash_read_long (flash_info_t * info, flash_sect_t sect, uint offset)
+{
+	uchar *addr;
+	ulong retval;
+
+#ifdef DEBUG
+	int x;
+#endif
+	addr = flash_make_addr (info, sect, offset);
+
+#ifdef DEBUG
+	debug ("long addr is at %p 1 = %d\n", addr,
+	       1);
+	for (x = 0; x < 4 * 1; x++) {
+		debug ("addr[%x] = 0x%x\n", x, addr[x]);
+	}
+#endif
+#if defined(__LITTLE_ENDIAN)
+	retval = (addr[0] << 16) | (addr[(1)] << 24) |
+		(addr[(2 * 1)]) | (addr[(3 * 1)] << 8);
+#else
+	retval = (addr[(2 * 1) - 1] << 24) |
+		(addr[(1) - 1] << 16) |
+		(addr[(4 * 1) - 1] << 8) |
+		addr[(3 * 1) - 1];
+#endif
+	return retval;
+}
+
+/*-----------------------------------------------------------------------
+ */
+static void disable_cache(void)
+{
+#if	defined(AST1300_CPU_CACHE_ENABLE)
+        ulong uldata;
+        
+        uldata  = *(volatile ulong *) (SCU_CACHE_CTRL_REGISTER);
+        uldata &= 0xfffffffd;
+        *(ulong *) (SCU_CACHE_CTRL_REGISTER) = uldata;        
+#endif
+}	
+
+static void enable_cache(void)
+{
+#if	defined(AST1300_CPU_CACHE_ENABLE)
+        ulong uldata;
+        
+        uldata  = *(volatile ulong *) (SCU_CACHE_CTRL_REGISTER);
+        uldata |= 0x00000002;
+        *(ulong *) (SCU_CACHE_CTRL_REGISTER) = uldata;        
+#endif
+}
+	 
+static void reset_flash (flash_info_t * info)
+{
+        ulong ulCtrlData, CtrlOffset, MiscCtrlOffset;
+        
+        if (info->CE == 2)
+        {
+            CtrlOffset = SPICtrlRegOffset2;
+        }    
+        else
+        {
+            CtrlOffset = SPICtrlRegOffset;
+        }    
+
+#if    defined(CONFIG_FLASH_AST2300) || defined(CONFIG_AST1300)
+        ulCtrlData = info->iomode | (info->readcmd << 16) | (info->tCK_Read << 8) | (info->dummybyte << 6) | FASTREAD;
+#if 0        
+        if (info->quadport)
+        {        	
+            MiscCtrlOffset = SPIMiscCtrlRegOffset;
+            *(ulong *) (STCBaseAddress + MiscCtrlOffset) = info->dummydata;                	                   
+            ulCtrlData |= DUMMY_COMMAND_OUT;
+        }
+#endif        
+#else      
+        ulCtrlData  = (info->readcmd << 16) | (info->tCK_Read << 8) | (info->dummybyte << 6) | FASTREAD;         
+        if (info->dualport)
+            ulCtrlData  |= 0x08;        
+#endif        
+        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;        
+        
+        enable_cache();    
+}
+	 
+static void enable_write (flash_info_t * info)
+{
+	ulong base;
+        ulong ulCtrlData, CtrlOffset;
+        uchar jReg;
+        
+        if (info->CE == 2)
+        {
+            CtrlOffset = SPICtrlRegOffset2;
+        }    
+        else
+        {
+            CtrlOffset = SPICtrlRegOffset;
+        }    
+                  
+	//base = info->start[0];
+	base = flash_make_addr (info, 0, 0);
+
+        ulCtrlData  = (info->tCK_Write << 8);        
+        ulCtrlData |= CE_LOW | USERMODE;
+        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+        udelay(200);
+        *(uchar *) (base) = (uchar) (0x06);
+        udelay(10);
+        ulCtrlData &= CMD_MASK;
+        ulCtrlData |= CE_HIGH | USERMODE;
+        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+        udelay(200);
+
+        ulCtrlData &= CMD_MASK;
+        ulCtrlData |= CE_LOW | USERMODE;
+        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+        udelay(200);
+        *(uchar *) (base) = (uchar) (0x05);
+        udelay(10);
+        do {                                
+            jReg = *(volatile uchar *) (base);
+        } while (!(jReg & 0x02));                  	                
+        ulCtrlData &= CMD_MASK;
+        ulCtrlData |= CE_HIGH | USERMODE;
+        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+        udelay(200);
+
+}
+		
+static void write_status_register (flash_info_t * info, uchar data)
+{
+	ulong base;
+        ulong ulSMMBase, ulCtrlData, CtrlOffset;
+        uchar jReg;
+        
+        if (info->CE == 2)
+        {
+            CtrlOffset = SPICtrlRegOffset2;
+        }    
+        else
+        {
+            CtrlOffset = SPICtrlRegOffset;
+        }    
+    
+	//base = info->start[0];
+	base = flash_make_addr (info, 0, 0);
+
+        enable_write (info);
+
+        ulCtrlData  = (info->tCK_Write << 8);
+        ulCtrlData |= CE_LOW | USERMODE;
+        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+        udelay(200);
+        *(uchar *) (base) = (uchar) (0x01);
+        udelay(10);
+        *(uchar *) (base) = (uchar) (data);                
+        ulCtrlData &= CMD_MASK;
+        ulCtrlData |= CE_HIGH | USERMODE;
+        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+        udelay(200);
+
+        ulCtrlData &= CMD_MASK;
+        ulCtrlData |= CE_LOW | USERMODE;
+        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+        udelay(200);
+        *(uchar *) (base) = (uchar) (0x05);
+        udelay(10);
+        do {                                
+            jReg = *(volatile uchar *) (base);
+        } while (jReg & 0x01);
+        ulCtrlData &= CMD_MASK;                          	                
+        ulCtrlData |= CE_HIGH | USERMODE;
+        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+        udelay(200);
+
+}
+
+static void enable4b (flash_info_t * info)
+{
+	ulong base;
+        ulong ulSMMBase, ulCtrlData, CtrlOffset;
+        uchar jReg;
+        
+        if (info->CE == 2)
+        {
+            CtrlOffset = SPICtrlRegOffset2;
+        }    
+        else
+        {
+            CtrlOffset = SPICtrlRegOffset;
+        }    
+    
+	//base = info->start[0];
+	base = flash_make_addr (info, 0, 0);
+
+        ulCtrlData  = (info->tCK_Write << 8);
+        ulCtrlData |= CE_LOW | USERMODE;
+        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+        udelay(200);
+        *(uchar *) (base) = (uchar) (0xb7);
+        ulCtrlData &= CMD_MASK;                          	                
+        ulCtrlData |= CE_HIGH | USERMODE;
+        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+        udelay(200);
+ 
+} /* enable4b */
+
+static void enable4b_spansion (flash_info_t * info)
+{
+	ulong base;
+    	ulong ulSMMBase, ulCtrlData, CtrlOffset;
+    	uchar jReg;
+        
+    	if (info->CE == 2)
+    	{
+            CtrlOffset = SPICtrlRegOffset2;
+    	}    
+    	else
+    	{
+            CtrlOffset = SPICtrlRegOffset;
+    	}    
+    
+	//base = info->start[0];
+	base = flash_make_addr (info, 0, 0);
+
+	/* Enable 4B: BAR0 D[7] = 1 */
+    	ulCtrlData  = (info->tCK_Write << 8);
+    	ulCtrlData |= CE_LOW | USERMODE;
+    	*(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+    	udelay(200);
+    	*(uchar *) (base) = (uchar) (0x17);
+    	udelay(10);
+    	*(uchar *) (base) = (uchar) (0x80);    
+    	ulCtrlData &= CMD_MASK;                          	                
+    	ulCtrlData |= CE_HIGH | USERMODE;
+    	*(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+    	udelay(200);
+
+    	ulCtrlData &= CMD_MASK;                          	                
+    	ulCtrlData |= CE_LOW | USERMODE;
+    	*(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+    	udelay(200);
+    	*(uchar *) (base) = (uchar) (0x16);
+    	udelay(10);
+    	do {                                
+            jReg = *(volatile uchar *) (base);
+    	} while (!(jReg & 0x80));
+    	ulCtrlData &= CMD_MASK;                          	                                          	                
+    	ulCtrlData |= CE_HIGH | USERMODE;
+   	 *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+    	udelay(200);
+	
+} /* enable4b_spansion */
+
+static void enable4b_numonyx (flash_info_t * info)
+{
+	ulong base;
+    	ulong ulSMMBase, ulCtrlData, CtrlOffset;
+    	uchar jReg;
+        
+    	if (info->CE == 2)
+    	{
+            CtrlOffset = SPICtrlRegOffset2;
+    	}    
+    	else
+    	{
+            CtrlOffset = SPICtrlRegOffset;
+    	}    
+    
+	//base = info->start[0];
+	base = flash_make_addr (info, 0, 0);
+
+	/* Enable Write */
+	enable_write (info);
+	
+	/* Enable 4B: CMD:0xB7 */
+    	ulCtrlData  = (info->tCK_Write << 8);
+    	ulCtrlData |= CE_LOW | USERMODE;
+    	*(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+    	udelay(200);
+    	*(uchar *) (base) = (uchar) (0xB7);
+    	udelay(10);
+    	ulCtrlData &= CMD_MASK;                          	                
+    	ulCtrlData |= CE_HIGH | USERMODE;
+    	*(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+    	udelay(200);
+
+} /* enable4b_numonyx */
+
+/*
+ *
+ */
+static ulong flash_get_size (ulong base, int banknum)
+{
+	flash_info_t *info = &flash_info[banknum];
+	int j;
+	unsigned long sector;
+	int erase_region_size;
+        ulong ulCtrlData, CtrlOffset;
+        ulong ulID;
+        uchar ch[3];
+        ulong cpuclk, div, reg;
+        ulong WriteClk, EraseClk, ReadClk;
+        ulong vbase;
+        ulong SCURevision;
+
+        ulong ulRefPLL;
+        ulong ulDeNumerator;
+        ulong ulNumerator;
+        ulong ulOD;                    
+                  
+        disable_cache();
+        
+	info->start[0] = base;
+	vbase = flash_make_addr (info, 0, 0);
+
+#if	defined(CONFIG_FLASH_AST2300) || defined(CONFIG_AST1300)
+        CtrlOffset = SPICtrlRegOffset;        	
+        info->CE = 0;                	
+#else
+        if (vbase == PHYS_FLASH_1)
+        {
+            CtrlOffset = SPICtrlRegOffset2;
+            info->CE = 2;
+        }    
+        else
+        {
+            CtrlOffset = SPICtrlRegOffset;        	
+            info->CE = 0;        	
+        }    
+#endif
+            
+        /* Get Flash ID */
+        ulCtrlData  = *(ulong *) (STCBaseAddress + CtrlOffset) & CMD_MASK;        
+        ulCtrlData |= CE_LOW | USERMODE;
+        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+        udelay(200);
+        *(uchar *) (vbase) = (uchar) (0x9F);
+        udelay(10);
+        ch[0] = *(volatile uchar *)(vbase);
+        udelay(10);
+        ch[1] = *(volatile uchar *)(vbase);
+        udelay(10);
+        ch[2] = *(volatile uchar *)(vbase);
+        udelay(10);               
+        ulCtrlData  = *(ulong *) (STCBaseAddress + CtrlOffset) & CMD_MASK;        
+        ulCtrlData |= CE_HIGH | USERMODE;
+        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+        udelay(200);
+        ulID = ((ulong)ch[0]) | ((ulong)ch[1] << 8) | ((ulong)ch[2] << 16) ;        
+        info->flash_id = ulID;
+        
+        //printf("SPI Flash ID: %x \n", ulID);
+
+        /* init default */        
+        info->iomode = IOMODEx1;
+        info->address32 = 0;
+        info->quadport = 0;
+        info->specificspi = 0;
+
+        switch (info->flash_id)
+        {
+        case STM25P64:
+	    info->sector_count = 128;
+	    info->size = 0x800000;        	
+            erase_region_size  = 0x10000;
+            info->readcmd = 0x0b;
+            info->dualport = 0;
+            info->dummybyte = 1;
+            info->buffersize = 256;
+            WriteClk = 40;
+            EraseClk = 20;
+            ReadClk  = 40;
+            break;
+
+        case STM25P128:
+	    info->sector_count = 64;
+	    info->size = 0x1000000;        	
+            erase_region_size  = 0x40000;
+            info->readcmd = 0x0b;            
+            info->dualport = 0;
+            info->dummybyte = 1;
+            info->buffersize = 256;            
+            WriteClk = 50;
+            EraseClk = 20;
+            ReadClk  = 50;
+            break;
+            
+        case N25Q256:
+	    info->sector_count = 256;
+	    info->size = 0x1000000;        	
+            erase_region_size  = 0x10000;
+            info->readcmd = 0x0b;            
+            info->dualport = 0;
+            info->dummybyte = 1;
+            info->buffersize = 256;            
+            WriteClk = 50;
+            EraseClk = 20;
+            ReadClk  = 50;
+#if	defined(CONFIG_FLASH_AST2300) || defined(CONFIG_AST1300)
+	    info->sector_count = 512;
+	    info->size = 0x2000000;
+	    info->address32 = 1;        	
+#endif
+	    break;
+
+        case N25Q512:
+	    info->sector_count = 256;
+	    info->size = 0x1000000;        	
+            erase_region_size  = 0x10000;
+            info->readcmd = 0x0b;            
+            info->dualport = 0;
+            info->dummybyte = 1;
+            info->buffersize = 256; 
+            info->specificspi = SpecificSPI_N25Q512;           
+            WriteClk = 50;
+            EraseClk = 20;
+            ReadClk  = 50;
+#if	defined(CONFIG_FLASH_AST2300) || defined(CONFIG_AST1300)
+	    info->sector_count = 1024;
+	    info->size = 0x4000000;
+	    info->address32 = 1;        	
+#endif
+	    break;
+	    	    	                            
+        case W25X16:
+	    info->sector_count = 32;
+	    info->size = 0x200000;        	
+            erase_region_size  = 0x10000;
+            info->readcmd = 0x3b;            
+            info->dualport = 1;            
+            info->dummybyte = 1;
+            info->iomode = IOMODEx2; 
+            info->buffersize = 256;                                   
+            WriteClk = 50;
+            EraseClk = 25;
+            ReadClk  = 50;            
+            break;
+            
+        case W25X64:
+	    info->sector_count = 128;
+	    info->size = 0x800000;        	
+            erase_region_size  = 0x10000;
+            info->readcmd = 0x3b;            
+            info->dualport = 1;            
+            info->dummybyte = 1;
+            info->iomode = IOMODEx2;
+            info->buffersize = 256;                                    
+            WriteClk = 50;
+            EraseClk = 25;
+            ReadClk  = 50;            
+            break;
+
+        case W25Q64BV:
+	    info->sector_count = 128;
+	    info->size = 0x800000;        	
+            erase_region_size  = 0x10000;
+            info->readcmd = 0x3b;            
+            info->dualport = 1;            
+            info->dummybyte = 1;
+            info->iomode = IOMODEx2; 
+            info->buffersize = 256;                                   
+            WriteClk = 80;
+            EraseClk = 40;
+            ReadClk  = 80;
+            break;
+            
+        case W25Q128BV:
+	    info->sector_count = 256;
+	    info->size = 0x1000000;        	
+            erase_region_size  = 0x10000;
+            info->readcmd = 0x3b;            
+            info->dualport = 1;            
+            info->dummybyte = 1;
+            info->iomode = IOMODEx2; 
+            info->buffersize = 256;                                   
+            WriteClk = 104;
+            EraseClk = 50;
+            ReadClk  = 104;
+            break;
+
+        case W25Q256FV:
+	    info->sector_count = 256;
+	    info->size = 0x1000000;        	
+            erase_region_size  = 0x10000;
+            info->readcmd = 0x0b;            
+            info->dualport = 0;
+            info->dummybyte = 1;
+            info->buffersize = 256;            
+            WriteClk = 50;
+            EraseClk = 20;
+            ReadClk  = 50;
+#if	defined(CONFIG_FLASH_AST2300) || defined(CONFIG_AST1300)
+	    info->sector_count = 512;
+	    info->size = 0x2000000;
+	    info->address32 = 1;        	
+#endif
+	    break;
+	                
+        case S25FL064A:
+	    info->sector_count = 128;
+	    info->size = 0x800000;        	
+            erase_region_size  = 0x10000;
+            info->readcmd = 0x0b;            
+            info->dualport = 0;            
+            info->dummybyte = 1;
+            info->buffersize = 256;            
+            WriteClk = 50;
+            EraseClk = 25;
+            ReadClk  = 50;            
+            break;
+
+        case S25FL128P:
+	    info->sector_count = 256;
+	    info->size = 0x1000000;        	
+            erase_region_size  = 0x10000;
+            info->readcmd = 0x0b;            
+            info->dualport = 0;            
+            info->dummybyte = 1;
+            info->buffersize = 256;            
+            WriteClk = 100;
+            EraseClk = 40;
+            ReadClk  = 100;            
+            break;
+
+        case S25FL256S:
+	    info->sector_count = 256;
+	    info->size = 0x1000000;        	
+            erase_region_size  = 0x10000;
+            info->readcmd = 0x0b;            
+            info->dualport = 0;
+            info->dummybyte = 1;
+            info->buffersize = 256;            
+            WriteClk = 50;
+            EraseClk = 20;
+            ReadClk  = 50;
+#if	defined(CONFIG_FLASH_AST2300) || defined(CONFIG_AST1300)
+	    info->sector_count = 512;
+	    info->size = 0x2000000;
+	    info->address32 = 1;        	
+#endif
+	    break;
+
+        case MX25L25635E:
+	    info->sector_count = 256;
+	    info->size = 0x1000000;        	
+            erase_region_size  = 0x10000;
+            info->readcmd = 0x0b;            
+            info->dualport = 0;
+            info->dummybyte = 1;
+            info->buffersize = 256;            
+            WriteClk = 50;
+            EraseClk = 20;
+            ReadClk  = 50;
+#if	defined(CONFIG_FLASH_AST2300) || defined(CONFIG_AST1300)
+	    info->sector_count = 512;
+	    info->size = 0x2000000;
+	    info->address32 = 1;        	
+#if	defined(CONFIG_FLASH_SPIx2_Dummy)
+            info->readcmd = 0xbb;            
+            info->dummybyte = 1;
+            info->dualport = 1;            
+            info->iomode = IOMODEx2_dummy;
+#elif	defined(CONFIG_FLASH_SPIx4_Dummy)
+            info->readcmd = 0xeb;            
+            info->dummybyte = 3;
+            info->dualport = 0;            
+            info->iomode = IOMODEx4_dummy;
+            info->quadport = 1;
+            info->dummydata = 0xaa;            
+#endif            
+#endif             
+            break;
+
+        case MX25L12805D:
+	    info->sector_count = 256;
+	    info->size = 0x1000000;        	
+            erase_region_size  = 0x10000;
+            info->readcmd = 0x0b;            
+            info->dualport = 0;
+            info->dummybyte = 1;
+            info->buffersize = 256;            
+/*
+SCU7C: Silicon Revision ID Register
+D[31:24]: Chip ID
+0: AST2050/AST2100/AST2150/AST2200/AST3000
+1: AST2300
+
+D[23:16] Silicon revision ID for AST2300 generation and later
+0: A0
+1: A1
+2: A2
+.
+.
+.
+FPGA revision starts from 0x80
+
+AST2300 A0 SPI can't run faster than 50Mhz
+*/
+            WriteClk = 50;
+            EraseClk = 20;
+            ReadClk  = 50;
+
+            SCURevision = *(ulong *) (SCU_REVISION_REGISTER);
+            if (((SCURevision >> 24) & 0xff) == 0x01) { //AST2300
+            	if (((SCURevision >> 16) & 0xff) == 0x00) { //A0
+            		WriteClk = 25;
+            		EraseClk = 20;
+            		ReadClk  = 25;
+            	}
+            }
+#if	defined(CONFIG_FLASH_AST2300) || defined(CONFIG_AST1300)
+#if	defined(CONFIG_FLASH_SPIx2_Dummy)
+            info->readcmd = 0xbb;            
+            info->dummybyte = 1;
+            info->dualport = 1;            
+            info->iomode = IOMODEx2_dummy;
+#elif	defined(CONFIG_FLASH_SPIx4_Dummy)
+            info->readcmd = 0xeb;            
+            info->dummybyte = 3;
+            info->dualport = 0;            
+            info->iomode = IOMODEx4_dummy;
+            info->quadport = 1;
+            info->dummydata = 0xaa;            
+#endif            
+#endif             
+            break;
+
+        case MX25L1605D:
+	    info->sector_count = 32;
+	    info->size = 0x200000;        	
+            erase_region_size  = 0x10000;
+            info->readcmd = 0x0b;            
+            info->dualport = 0;
+            info->dummybyte = 1;
+            info->buffersize = 256;            
+            WriteClk = 50;
+            EraseClk = 20;
+            ReadClk  = 50;
+            break;
+
+        case SST25VF016B:
+	    info->sector_count = 32;
+	    info->size = 0x200000;        	
+            erase_region_size  = 0x10000;
+            info->readcmd = 0x0b;            
+            info->dualport = 0;            
+            info->dummybyte = 1;
+            info->buffersize = 1;            
+            WriteClk = 50;
+            EraseClk = 25;
+            ReadClk  = 50;            
+            break;
+
+        case SST25VF064C:
+	    info->sector_count = 128;
+	    info->size = 0x800000;        	
+            erase_region_size  = 0x10000;
+            info->readcmd = 0x0b;            
+            info->dualport = 0;            
+            info->dummybyte = 1;
+            info->buffersize = 1;            
+            WriteClk = 50;
+            EraseClk = 25;
+            ReadClk  = 50;            
+            break;
+
+        case AT25DF161:
+	    info->sector_count = 32;
+	    info->size = 0x200000;        	
+            erase_region_size  = 0x10000;
+            info->readcmd = 0x0b;            
+            info->dualport = 0;            
+            info->dummybyte = 1;
+            info->buffersize = 1;            
+            WriteClk = 50;
+            EraseClk = 25;
+            ReadClk  = 50;            
+            break;
+ 
+        case AT25DF321:
+	    info->sector_count = 32;
+	    info->size = 0x400000;        	
+            erase_region_size  = 0x10000;
+            info->readcmd = 0x0b;            
+            info->dualport = 0;            
+            info->dummybyte = 1;
+            info->buffersize = 1;            
+            WriteClk = 50;
+            EraseClk = 25;
+            ReadClk  = 50;            
+            break;
+                                                                      
+        default:	/* use JEDEC ID */
+            erase_region_size  = 0x10000;
+            info->readcmd = 0x0b;                        
+            info->dualport  = 0;            
+            info->dummybyte = 1;
+            info->buffersize = 1;            
+            WriteClk = 50;
+            EraseClk = 25;
+            ReadClk  = 50;  
+            if ((info->flash_id & 0xFF) == 0x1F)	/* Atmel */
+            {
+                switch (info->flash_id & 0x001F00)
+                {
+                case 0x000400:	
+        	    info->sector_count = 8;
+    	            info->size = 0x80000;        	
+	            break;	            	                
+                case 0x000500:	
+        	    info->sector_count = 16;
+    	            info->size = 0x100000;        	
+	            break;	            	                
+                case 0x000600:	
+        	    info->sector_count = 32;
+    	            info->size = 0x200000;        	
+	            break;
+                case 0x000700:	
+        	    info->sector_count = 64;
+    	            info->size = 0x400000;        	
+	            break;
+                case 0x000800:	
+        	    info->sector_count = 128;
+    	            info->size = 0x800000;        	
+	            break;	            
+                case 0x000900:	
+        	    info->sector_count = 256;
+    	            info->size = 0x1000000;        	
+	            break;	            	            
+                default:
+                    printf("Can't support this SPI Flash!! \n");
+                    return 0;	            
+                }   	            
+            } /* Atmel JDEC */        
+            else	/* JDEC */				
+            {
+                switch (info->flash_id & 0xFF0000)
+                {
+                case 0x120000:	
+        	    info->sector_count = 4;
+    	            info->size = 0x40000;        	
+	            break;
+                case 0x130000:	
+	            info->sector_count = 8;
+	            info->size = 0x80000;        	
+	            break;
+                case 0x140000:	
+	            info->sector_count =16;
+	            info->size = 0x100000;        	
+	            break;
+                case 0x150000:	
+	            info->sector_count =32;
+	            info->size = 0x200000;        	
+	            break;
+                case 0x160000:	
+	            info->sector_count =64;
+	            info->size = 0x400000;        	
+	            break;
+                case 0x170000:	
+	            info->sector_count =128;
+	            info->size = 0x800000;        	
+	            break;
+                case 0x180000:	
+	            info->sector_count =256;
+	            info->size = 0x1000000;        	
+	            break;
+                case 0x190000:	
+	            info->sector_count =256;
+	            info->size = 0x1000000;
+#if	defined(CONFIG_FLASH_AST2300) || defined(CONFIG_AST1300)
+	            info->sector_count = 512;
+	            info->size = 0x2000000;
+	            info->address32 = 1;        	
+#if	defined(CONFIG_FLASH_SPIx2_Dummy)
+                    info->readcmd = 0xbb;            
+                    info->dummybyte = 1;
+                    info->dualport = 1;            
+                    info->iomode = IOMODEx2_dummy;
+#elif	defined(CONFIG_FLASH_SPIx4_Dummy)
+                    info->readcmd = 0xeb;            
+                    info->dummybyte = 3;
+                    info->dualport = 0;            
+                    info->iomode = IOMODEx4_dummy;
+                    info->quadport = 1;
+                    info->dummydata = 0xaa;            
+#endif            
+#endif             	                	
+	            break;
+	            
+                case 0x200000:	
+	            info->sector_count =256;
+	            info->size = 0x1000000;
+                    if ((info->flash_id & 0xFF) == 0x20)	/* numonyx */
+                        info->specificspi = SpecificSPI_N25Q512;
+#if	defined(CONFIG_FLASH_AST2300) || defined(CONFIG_AST1300)
+	            info->sector_count = 1024;
+	            info->size = 0x4000000;
+	            info->address32 = 1;        	
+#if	defined(CONFIG_FLASH_SPIx2_Dummy)
+                    info->readcmd = 0xbb;            
+                    info->dummybyte = 1;
+                    info->dualport = 1;            
+                    info->iomode = IOMODEx2_dummy;
+#elif	defined(CONFIG_FLASH_SPIx4_Dummy)
+                    info->readcmd = 0xeb;            
+                    info->dummybyte = 3;
+                    info->dualport = 0;            
+                    info->iomode = IOMODEx4_dummy;
+                    info->quadport = 1;
+                    info->dummydata = 0xaa;            
+#endif            
+#endif             	                	
+	            break;
+	            	        	            	        
+                default:
+                    printf("Can't support this SPI Flash!! \n");
+                    return 0;
+                }    
+            } /* JDEC */        
+        }
+        				
+        debug ("erase_region_count = %d erase_region_size = %d\n",
+		erase_region_count, erase_region_size);
+
+	sector = base;			
+	for (j = 0; j < info->sector_count; j++) {
+		
+		info->start[j] = sector;
+		sector += erase_region_size;
+		info->protect[j] = 0; /* default: not protected */
+	}
+
+        /* set SPI flash extended info */
+#if 	defined(CONFIG_AST1300)
+	if (info->size > 0x200000)	/* limit MAX Flash to 2MB for AST1300 */
+	    info->size = 0x200000;
+#endif
+#if	defined(CONFIG_AST2400) || defined(CONFIG_AST2300) || defined(CONFIG_AST2300_FPGA_1) || defined(CONFIG_AST2300_FPGA_2) || defined(CONFIG_AST1300)
+        reg = *((volatile ulong*) 0x1e6e2024);
+        if (reg & 0x40000)
+        {
+            reg = *((volatile ulong*) 0x1e6e2070);	        
+	        
+            ulRefPLL = 24;
+            ulDeNumerator = reg & 0x0F;
+            ulNumerator = (reg & 0x07E0) >> 5;
+            ulOD = (reg & 0x10) ? 1:2;                    
+     	    
+            cpuclk = ulRefPLL * ulOD * (ulNumerator + 2) / (ulDeNumerator + 1);    
+        }        
+        else
+        {
+            reg = *((volatile ulong*) 0x1e6e2070);	        
+#if	defined(CONFIG_AST2400)
+            if (reg & 0x00800000)	//ref. clk:25MHz
+            {
+                switch (reg & 0x300)
+                {
+                case 0x000:
+                    cpuclk = 400;
+                    break;
+                case 0x100:
+                    cpuclk = 375;
+                    break;        
+                case 0x200:
+                    cpuclk = 350;
+                    break;        
+                case 0x300:
+                    cpuclk = 325;
+                    break;
+                }	            	            
+            }        
+            else
+            {
+                switch (reg & 0x300)	//ref. clk:24MHz
+                {
+                case 0x000:
+                    cpuclk = 384;
+                    break;
+                case 0x100:
+                    cpuclk = 360;
+                    break;        
+                case 0x200:
+                    cpuclk = 336;
+                    break;        
+                case 0x300:
+                    cpuclk = 312;
+                    break;
+                }	            
+            }
+#else	        
+            switch (reg & 0x300)
+            {
+            case 0x000:
+                 cpuclk = 384;
+                 break;
+            case 0x100:
+                 cpuclk = 360;
+                 break;        
+            case 0x200:
+                 cpuclk = 336;
+                 break;        
+            case 0x300:
+                 cpuclk = 408;
+                 break;
+            }
+#endif            
+        }	
+        
+        reg = *((volatile ulong*) 0x1e6e2070);        
+        switch (reg & 0xc00)
+        {
+        case 0x000:
+                 cpuclk /= 1;
+                 break;
+        case 0x400:
+                 cpuclk /= 2;
+                 break;        
+        case 0x800:	
+                 cpuclk /= 4;
+                 break;
+        case 0xC00:	
+                 cpuclk /= 3;
+                 break;                                 
+        }
+#else	/* AST2100 */        
+        reg = *((volatile ulong*) 0x1e6e2070);
+        switch (reg & 0xe00)
+        {
+        case 0x000:
+                 cpuclk = 266;
+                 break;
+        case 0x200:
+                 cpuclk = 233;
+                 break;        
+        case 0x400:
+                 cpuclk = 200;
+                 break;        
+        case 0x600:
+                 cpuclk = 166;
+                 break;        
+        case 0x800:
+                 cpuclk = 133;
+                 break;        
+        case 0xA00:
+                 cpuclk = 100;
+                 break;        
+        case 0xC00:
+                 cpuclk = 300;
+                 break;        
+        case 0xE00:	
+                 cpuclk = 24;
+                 break;        
+        }	
+        switch (reg & 0x3000)
+        {
+        case 0x1000:
+                 cpuclk /= 2;
+                 break;
+        case 0x2000:
+                 cpuclk /= 4;
+                 break;        
+        case 0x3000:	
+                 cpuclk /= 3;
+                 break;        
+        }
+#endif
+
+#if	defined(CONFIG_AST2400) || defined(CONFIG_AST2300) || defined(CONFIG_AST2300_FPGA_1) || defined(CONFIG_AST2300_FPGA_2) || defined(CONFIG_AST1300)
+
+#if     defined(CONFIG_AST2300) || defined(CONFIG_AST1300)
+        /* limit Max SPI CLK to 50MHz (Datasheet v1.2) */
+        if (WriteClk > 50) WriteClk = 50;
+        if (EraseClk > 50) EraseClk = 50;
+        if (ReadClk > 50)  ReadClk  = 50;
+#endif
+
+        div = 1;
+        while ( ((cpuclk/div) > WriteClk) && (div < 16) )
+        {
+            div++;	
+        }
+        info->tCK_Write = AST2300_SPICLK_DIV[div-1];
+        
+        div = 1;
+        while ( ((cpuclk/div) > EraseClk) && (div < 16) )
+        {
+            div++;	
+        }        
+        info->tCK_Erase = AST2300_SPICLK_DIV[div-1];
+
+        div = 1;
+        while ( ((cpuclk/div) > ReadClk) && (div < 16) )
+        {
+            div++;	
+        }        
+        info->tCK_Read = AST2300_SPICLK_DIV[div-1];
+#else        	
+        div = 2;
+        info->tCK_Write = 7;
+        while ( (cpuclk/div) > WriteClk )
+        {
+            info->tCK_Write--;	
+            div +=2;	
+        }
+        div = 2;
+        info->tCK_Erase = 7;
+        while ( (cpuclk/div) > EraseClk )
+        {
+            info->tCK_Erase--;	
+            div +=2;	
+        }
+        div = 2;
+        info->tCK_Read = 7;
+        while ( (cpuclk/div) > ReadClk )
+        {
+            info->tCK_Read--;	
+            div +=2;	
+        }
+#endif
+	
+	/* unprotect flash */	
+        write_status_register(info, 0);
+
+        if (info->quadport)
+            write_status_register(info, 0x40);	/* enable QE */
+
+        if (info->address32)	 
+        {          
+            reg = *((volatile ulong*) 0x1e6e2070);	/* set H/W Trappings */
+            reg |= 0x10;
+            *((volatile ulong*) 0x1e6e2070) = reg;
+            
+            reg  = *((volatile ulong*) 0x1e620004);	/* enable 32b control bit*/
+            reg |= (0x01 << info->CE);
+            *((volatile ulong*) 0x1e620004) = reg;
+            
+            /* set flash chips to 32bits addressing mode */
+            if ((info->flash_id & 0xFF) == 0x01)	/* Spansion */
+                enable4b_spansion(info);
+            else if ((info->flash_id & 0xFF) == 0x20)	/* Numonyx */
+                enable4b_numonyx(info);                
+            else /* MXIC, Winbond */
+                enable4b(info);                
+                
+        }    
+                    
+        reset_flash(info);
+        
+	return (info->size);
+}
+
+
+/*-----------------------------------------------------------------------
+ */
+static int flash_write_buffer (flash_info_t *info, uchar *src, ulong addr, int len)
+{
+        ulong j, base, offset;
+        ulong ulSMMBase, ulCtrlData, CtrlOffset;
+        uchar jReg;
+
+        if (info->CE == 2)
+        {
+            CtrlOffset = SPICtrlRegOffset2;
+        }    
+        else
+        {
+            CtrlOffset = SPICtrlRegOffset;
+        }    
+            
+	base = info->start[0];
+	offset = addr - base;
+	base = flash_make_addr (info, 0, 0);
+	
+        enable_write (info);
+
+        ulCtrlData  = (info->tCK_Write << 8);
+
+        ulCtrlData &= CMD_MASK;
+        ulCtrlData |= CE_LOW | USERMODE;
+        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+        udelay(200);
+        *(uchar *) (base) = (uchar) (0x02);
+        udelay(10);
+        if (info->address32)
+        {
+            *(uchar *) (base) = (uchar) ((offset & 0xff000000) >> 24);
+            udelay(10);
+        }
+        *(uchar *) (base) = (uchar) ((offset & 0xff0000) >> 16);
+        udelay(10);
+        *(uchar *) (base) = (uchar) ((offset & 0x00ff00) >> 8);
+        udelay(10);
+        *(uchar *) (base) = (uchar) ((offset & 0x0000ff));
+        udelay(10);
+
+        for (j=0; j<len; j++)
+        {
+            *(uchar *) (base) = *(uchar *) (src++);
+            udelay(10);
+        }    
+                 
+        ulCtrlData &= CMD_MASK;
+        ulCtrlData |= CE_HIGH | USERMODE;
+        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+        udelay(200);
+
+        ulCtrlData &= CMD_MASK;
+        ulCtrlData |= CE_LOW | USERMODE;
+        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+        udelay(200);
+        *(uchar *) (base) = (uchar) (0x05);
+        udelay(10);
+        do {                             
+            jReg = *(volatile uchar *) (base);
+        } while ((jReg & 0x01));
+        ulCtrlData &= CMD_MASK;
+        ulCtrlData |= CE_HIGH | USERMODE;
+        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+        udelay(200);
+
+        /* RFSR */
+        if (info->specificspi == SpecificSPI_N25Q512)
+        {
+            ulCtrlData &= CMD_MASK;
+            ulCtrlData |= CE_LOW | USERMODE;
+            *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+            udelay(200);
+            *(uchar *) (base) = (uchar) (0x70);
+            udelay(10);
+            do {                                                            
+                jReg = *(volatile uchar *) (base);
+            } while (!(jReg & 0x80));
+            ulCtrlData &= CMD_MASK;
+            ulCtrlData |= CE_HIGH | USERMODE;
+            *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+            udelay(200);
+        }           
+}	
+
+/*-----------------------------------------------------------------------
+ *
+ * export functions
+ *  
+ */
+ 
+/*-----------------------------------------------------------------------
+ * 
+ */
+unsigned long flash_init (void)
+{
+	unsigned long size = 0;
+	int i;
+
+	/* Init: no FLASHes known */
+	for (i = 0; i < CONFIG_SYS_MAX_FLASH_BANKS; ++i) {
+		flash_info[i].flash_id = FLASH_UNKNOWN;
+		size += flash_info[i].size = flash_get_size (bank_base[i], i);
+		if (flash_info[i].flash_id == FLASH_UNKNOWN) {
+#ifndef CFG_FLASH_QUIET_TEST
+			printf ("## Unknown FLASH on Bank %d - Size = 0x%08lx = %ld MB\n",
+				i, flash_info[i].size, flash_info[i].size << 20);
+#endif /* CFG_FLASH_QUIET_TEST */
+		}
+	}
+
+	/* Monitor protection ON by default */
+#if (CONFIG_MONITOR_BASE >= CONFIG_SYS_FLASH_BASE)
+	flash_protect (FLAG_PROTECT_SET,
+		       CONFIG_MONITOR_BASE,
+		       CONFIG_MONITOR_BASE + monitor_flash_len  - 1,
+		       flash_get_info(CONFIG_MONITOR_BASE));
+#endif
+
+	/* Environment protection ON by default */
+#ifdef CONFIG_ENV_IS_IN_FLASH
+	flash_protect (FLAG_PROTECT_SET,
+		       CONFIG_ENV_ADDR,
+		       CONFIG_ENV_ADDR + CONFIG_ENV_SECT_SIZE - 1,
+		       flash_get_info(CONFIG_ENV_ADDR));
+#endif
+
+	/* Redundant environment protection ON by default */
+#ifdef CONFIG_ENV_ADDR_REDUND
+	flash_protect (FLAG_PROTECT_SET,
+		       CONFIG_ENV_ADDR_REDUND,
+		       CONFIG_ENV_ADDR_REDUND + CONFIG_ENV_SIZE_REDUND - 1,
+		       flash_get_info(CONFIG_ENV_ADDR_REDUND));
+#endif
+	return (size);
+}
+
+/*-----------------------------------------------------------------------
+ */
+#if defined(CONFIG_ENV_IS_IN_FLASH) || defined(CONFIG_ENV_ADDR_REDUND) || (CONFIG_MONITOR_BASE >= CONFIG_SYS_FLASH_BASE)
+static flash_info_t *flash_get_info(ulong base)
+{
+	int i;
+	flash_info_t * info = 0;
+
+	for (i = 0; i < CONFIG_SYS_MAX_FLASH_BANKS; i ++) {
+		info = & flash_info[i];
+		if (info->size && info->start[0] <= base &&
+		    base <= info->start[0] + info->size - 1)
+			break;
+	}
+
+	return i == CONFIG_SYS_MAX_FLASH_BANKS ? 0 : info;
+}
+#endif
+
+/*-----------------------------------------------------------------------
+ */
+int flash_erase (flash_info_t * info, int s_first, int s_last)
+{
+	int rcode = 0;
+	int prot;
+	flash_sect_t sect;
+
+        ulong base, offset;
+        ulong ulSMMBase, ulCtrlData, CtrlOffset;
+        uchar jReg;
+        
+        disable_cache();
+        
+        if (info->CE == 2)
+        {
+            CtrlOffset = SPICtrlRegOffset2;
+        }    
+        else
+        {
+            CtrlOffset = SPICtrlRegOffset;
+        }    
+                    
+	if ((s_first < 0) || (s_first > s_last)) {
+		puts ("- no sectors to erase\n");
+		return 1;
+	}
+
+	prot = 0;
+	for (sect = s_first; sect <= s_last; ++sect) {
+		if (info->protect[sect]) {
+			prot++;
+		}
+	}
+	if (prot) {
+		printf ("- Warning: %d protected sectors will not be erased!\n", prot);
+	} else {
+		putc ('\n');
+	}
+
+        ulCtrlData  = (info->tCK_Erase << 8);
+	for (sect = s_first; sect <= s_last; sect++) {
+		if (info->protect[sect] == 0) { /* not protected */
+                        /* start erasing */
+                        enable_write(info);
+
+	                base = info->start[0];
+                        offset = info->start[sect] - base;
+	                base = flash_make_addr (info, 0, 0);
+
+                        ulCtrlData &= CMD_MASK;
+                        ulCtrlData |= CE_LOW | USERMODE;
+                        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+                        udelay(200);
+                        *(uchar *) (base) = (uchar) (0xd8);
+                        udelay(10);
+                        if (info->address32)
+                        { 
+                            *(uchar *) (base) = (uchar) ((offset & 0xff000000) >> 24);
+                            udelay(10);
+                        }                        
+                        *(uchar *) (base) = (uchar) ((offset & 0xff0000) >> 16);
+                        udelay(10);
+                        *(uchar *) (base) = (uchar) ((offset & 0x00ff00) >> 8);
+                        udelay(10);
+                        *(uchar *) (base) = (uchar) ((offset & 0x0000ff));
+                        udelay(10);
+
+                        ulCtrlData &= CMD_MASK;
+                        ulCtrlData |= CE_HIGH | USERMODE;
+                        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+                        udelay(200);
+
+                        ulCtrlData &= CMD_MASK;
+                        ulCtrlData |= CE_LOW | USERMODE;
+                        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+                        udelay(200);
+                        *(uchar *) (base) = (uchar) (0x05);
+                        udelay(10);
+                        do {                                                            
+                            jReg = *(volatile uchar *) (base);
+                        } while ((jReg & 0x01));
+                        ulCtrlData &= CMD_MASK;
+                        ulCtrlData |= CE_HIGH | USERMODE;
+                        *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+                        udelay(200);
+
+                        /* RFSR */
+                        if (info->specificspi == SpecificSPI_N25Q512)
+                        {
+                            ulCtrlData &= CMD_MASK;
+                            ulCtrlData |= CE_LOW | USERMODE;
+                            *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+                            udelay(200);
+                            *(uchar *) (base) = (uchar) (0x70);
+                            udelay(10);
+                            do {                                                            
+                                jReg = *(volatile uchar *) (base);
+                            } while (!(jReg & 0x80));
+                            ulCtrlData &= CMD_MASK;
+                            ulCtrlData |= CE_HIGH | USERMODE;
+                            *(ulong *) (STCBaseAddress + CtrlOffset) = ulCtrlData;
+                            udelay(200);
+                        }   
+                        
+			putc ('.');
+		}
+	}
+	puts (" done\n");
+	
+	reset_flash(info);
+	
+	return rcode;
+}
+
+/*-----------------------------------------------------------------------
+ */
+void flash_print_info (flash_info_t * info)
+{
+	putc ('\n');
+	return;
+}
+
+/*-----------------------------------------------------------------------
+ * Copy memory to flash, returns:
+ * 0 - OK
+ * 1 - write timeout
+ * 2 - Flash not erased
+ */
+int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
+{
+	int count;
+	unsigned char pat[] = {'|', '-', '/', '\\'};
+	int patcnt;
+	
+        disable_cache();	
+        
+	/* get lower aligned address */	
+        if (addr & (info->buffersize - 1))
+        {
+            count = cnt >= info->buffersize ? (info->buffersize - (addr & 0xff)):cnt;	
+            flash_write_buffer (info, src, addr, count);
+            addr+= count;
+            src += count;
+            cnt -= count;	
+        }
+	
+	/* prog */		
+	while (cnt > 0) {				
+	    count = cnt >= info->buffersize ? info->buffersize:cnt;
+            flash_write_buffer (info, src, addr, count);
+            addr+= count;
+            src += count;
+            cnt -= count;
+            printf("%c\b", pat[(patcnt++) & 0x03]);            	     	
+	} 		
+
+	reset_flash(info);
+
+        return (0);
+}
+
+#ifdef	CONFIG_FLASH_AST2300_DMA
+void * memmove_dma(void * dest,const void *src,size_t count)
+{
+	ulong count_align, poll_time, data;
+	
+	count_align = (count + 3) & 0xFFFFFFFC;	/* 4-bytes align */
+        poll_time = 100;			/* set 100 us as default */
+
+        /* force end of burst read */
+	*(volatile ulong *) (STCBaseAddress + SPICtrlRegOffset) |= CE_HIGH;
+	*(volatile ulong *) (STCBaseAddress + SPICtrlRegOffset) &= ~CE_HIGH;
+          
+	*(ulong *) (STCBaseAddress + REG_FLASH_DMA_CONTROL) = (ulong) (~FLASH_DMA_ENABLE);	
+	*(ulong *) (STCBaseAddress + REG_FLASH_DMA_FLASH_BASE) = (ulong *) (src);
+	*(ulong *) (STCBaseAddress + REG_FLASH_DMA_DRAM_BASE) = (ulong *) (dest);
+	*(ulong *) (STCBaseAddress + REG_FLASH_DMA_LENGTH) = (ulong) (count_align);
+	*(ulong *) (STCBaseAddress + REG_FLASH_DMA_CONTROL) = (ulong) (FLASH_DMA_ENABLE);
+	
+	/* wait poll */
+	do {
+	    udelay(poll_time);	
+	    data = *(ulong *) (STCBaseAddress + REG_FLASH_INTERRUPT_STATUS);
+	} while (!(data & FLASH_STATUS_DMA_READY));
+	
+	/* clear status */
+	*(ulong *) (STCBaseAddress + REG_FLASH_INTERRUPT_STATUS) |= FLASH_STATUS_DMA_CLEAR;
+}	
+#endif
+#endif /* CONFIG_FLASH_SPI */
diff --git a/board/aspeed/ast2400/hactest.c b/board/aspeed/ast2400/hactest.c
new file mode 100755
index 0000000..bfa87d5
--- /dev/null
+++ b/board/aspeed/ast2400/hactest.c
@@ -0,0 +1,762 @@
+/*
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Diagnostics support
+ */
+#include <common.h>
+#include <command.h>
+#include <post.h>
+#include "slt.h"
+
+#if ((CFG_CMD_SLT & CFG_CMD_HACTEST) && defined(CONFIG_SLT))
+#include "hactest.h"
+
+#include "aes.c"
+#include "rc4.c"
+
+static unsigned char crypto_src[CRYPTO_MAX_SRC], crypto_dst[CRYPTO_MAX_DST], crypto_context[CRYPTO_MAX_CONTEXT];
+static unsigned char hash_src[HASH_MAX_SRC], hash_dst[HASH_MAX_DST], hmac_key[HMAC_MAX_KEY];
+
+/*
+ * table 
+ */
+static aes_test aestest[] = {
+    { CRYPTOMODE_ECB, 128,
+     {0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c, '\0'},
+     {0x32, 0x43, 0xf6, 0xa8, 0x88, 0x5a, 0x30, 0x8d, 0x31, 0x31, 0x98, 0xa2, 0xe0, 0x37, 0x07, 0x34, '\0'},
+     {0x39, 0x25, 0x84, 0x1d, 0x02, 0xdc, 0x09, 0xfb, 0xdc, 0x11, 0x85, 0x97, 0x19, 0x6a, 0x0b, 0x32, '\0'} },
+    {0xFF, 0xFF, "", "", ""},		/* End Mark */
+};
+
+static rc4_test rc4test[] = {
+    {{0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, '\0'},
+     {0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, '\0'}}, 	
+    {{0xff}, {0xff}},				/* End Mark */	
+};
+
+static hash_test hashtest[] = {
+    {HASHMODE_SHA1, 20,
+     "abc",
+     {0x53, 0x20, 0xb0, 0x8c, 0xa1, 0xf5, 0x74, 0x62, 0x50, 0x71, 0x89, 0x41, 0xc5, 0x0a, 0xdf, 0x4e, 0xbb, 0x55, 0x76, 0x06, '\0'}},
+    {0xFF, 0xFF, "", ""},			/* End Mark */ 
+};
+
+static hmac_test hmactest[] = {
+    {HASHMODE_SHA1, 64, 20,
+     {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16,0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, '\0' },
+     "Sample #1",
+     {0xbf, 0x39, 0xda, 0xb1, 0x7d, 0xc2, 0xe1, 0x23, 0x0d, 0x28, 0x35, 0x3b, 0x8c, 0xcb, 0x14, 0xb6, 0x22, 0x02, 0x65, 0xb3, '\0'}},
+    {0xFF, 0xFF, 0xFF, "", "", ""},			/* End Mark */ 
+};
+
+void EnableHMAC(void)
+{
+    unsigned long ulData;
+    	
+    /* init SCU */
+    *(unsigned long *) (0x1e6e2000) = 0x1688a8a8;
+    
+    ulData = *(volatile unsigned long *) (0x1e6e200c);
+    ulData &= 0xfdfff;
+    *(unsigned long *) (0x1e6e200c) = ulData;
+    udelay(100);
+    ulData = *(volatile unsigned long *) (0x1e6e2004);
+    ulData &= 0xfffef;
+    *(unsigned long *) (0x1e6e2004) = ulData;
+    
+}
+
+/* AES */
+void aes_enc_ast3000(aes_context *ctx, uint8 *input, uint8 *iv, uint8 *output, uint32 ulMsgLength , uint32 ulAESMode)
+{
+
+    unsigned long i, ulTemp, ulCommand;
+    unsigned char ch;
+    unsigned char *pjsrc, *pjdst, *pjcontext;
+    
+    ulCommand = CRYPTO_ENABLE_RW | CRYPTO_ENABLE_CONTEXT_LOAD | CRYPTO_ENABLE_CONTEXT_SAVE | \
+                CRYPTO_AES | CRYPTO_ENCRYPTO | CRYPTO_SYNC_MODE_ASYNC;
+
+    switch (ctx->nr)
+    {
+    case 10:
+        ulCommand |= CRYPTO_AES128;
+        break;
+    case 12:
+        ulCommand |= CRYPTO_AES192;
+        break;    
+    case 14:
+        ulCommand |= CRYPTO_AES256;
+        break;    
+    }
+
+    switch (ulAESMode)
+    {
+    case CRYPTOMODE_ECB:
+        ulCommand |= CRYPTO_AES_ECB;
+        break;
+    case CRYPTOMODE_CBC:
+        ulCommand |= CRYPTO_AES_CBC;
+        break;
+    case CRYPTOMODE_CFB:
+        ulCommand |= CRYPTO_AES_CFB;
+        break;
+    case CRYPTOMODE_OFB:
+        ulCommand |= CRYPTO_AES_OFB;
+        break;
+    case CRYPTOMODE_CTR:
+        ulCommand |= CRYPTO_AES_CTR;
+        break;                
+    }
+
+    pjsrc = (unsigned char *) m16byteAlignment((unsigned long) crypto_src);
+    pjdst = (unsigned char *) m16byteAlignment((unsigned long) crypto_dst);
+    pjcontext = (unsigned char *) m16byteAlignment((unsigned long) crypto_context);
+    	
+    /* Init HW */
+    *(unsigned long *) (HAC_REG_BASE + REG_CRYPTO_SRC_BASE_OFFSET) = (unsigned long) pjsrc;
+    *(unsigned long *) (HAC_REG_BASE + REG_CRYPTO_DST_BASE_OFFSET) = (unsigned long) pjdst;
+    *(unsigned long *) (HAC_REG_BASE + REG_CRYPTO_CONTEXT_BASE_OFFSET) = (unsigned long) pjcontext;
+    *(unsigned long *) (HAC_REG_BASE + REG_CRYPTO_LEN_OFFSET) = ulMsgLength;
+
+    /* Set source */
+    for (i=0; i< ulMsgLength; i++)
+    {
+    	ch = *(uint8 *)(input + i);    	
+    	*(uint8 *) (pjsrc + i) = ch;
+    }
+     
+    /* Set Context */
+    /* Set IV */
+    for (i=0; i<16; i++)
+    {
+        ch = *(uint8 *) (iv + i);
+    	*(uint8 *) (pjcontext + i) = ch;
+    }
+       
+    /* Set Expansion Key */   
+    for (i=0; i<(4*(ctx->nr+1)); i++)
+    {
+        ulTemp = ((ctx->erk[i] & 0xFF) << 24) + ((ctx->erk[i] & 0xFF00) << 8) + ((ctx->erk[i] & 0xFF0000) >> 8) + ((ctx->erk[i] & 0xFF000000) >> 24);
+    	*(uint32 *) (pjcontext + i*4 + 16) = ulTemp;
+    }
+
+    /* fire cmd */
+    *(unsigned long *) (HAC_REG_BASE + REG_CRYPTO_CMD_BASE_OFFSET) = ulCommand;
+    do {
+        ulTemp = *(volatile unsigned long *) (HAC_REG_BASE + REG_CRYPTO_STATUS_OFFSET);
+    } while (ulTemp & CRYPTO_BUSY);	
+    
+    /* Output */
+    for (i=0; i<ulMsgLength; i++)
+    {
+        ch = *(uint8 *) (pjdst + i);        
+        *(uint8 *) (output + i) = ch;    
+    }
+    
+} /* aes_enc_ast3000 */
+
+
+void aes_dec_ast3000(aes_context *ctx, uint8 *input, uint8 *iv, uint8 *output, uint32 ulMsgLength , uint32 ulAESMode)
+{
+    unsigned long i, ulTemp, ulCommand;
+    unsigned char ch;
+    unsigned char *pjsrc, *pjdst, *pjcontext;
+    
+    ulCommand = CRYPTO_ENABLE_RW | CRYPTO_ENABLE_CONTEXT_LOAD | CRYPTO_ENABLE_CONTEXT_SAVE | \
+                CRYPTO_AES | CRYPTO_DECRYPTO | CRYPTO_SYNC_MODE_ASYNC;
+
+    switch (ctx->nr)
+    {
+    case 10:
+        ulCommand |= CRYPTO_AES128;
+        break;
+    case 12:
+        ulCommand |= CRYPTO_AES192;
+        break;    
+    case 14:
+        ulCommand |= CRYPTO_AES256;
+        break;    
+    }
+
+    switch (ulAESMode)
+    {
+    case CRYPTOMODE_ECB:
+        ulCommand |= CRYPTO_AES_ECB;
+        break;
+    case CRYPTOMODE_CBC:
+        ulCommand |= CRYPTO_AES_CBC;
+        break;
+    case CRYPTOMODE_CFB:
+        ulCommand |= CRYPTO_AES_CFB;
+        break;
+    case CRYPTOMODE_OFB:
+        ulCommand |= CRYPTO_AES_OFB;
+        break;
+    case CRYPTOMODE_CTR:
+        ulCommand |= CRYPTO_AES_CTR;
+        break;                
+    }
+
+    pjsrc = (unsigned char *) m16byteAlignment((unsigned long) crypto_src);
+    pjdst = (unsigned char *) m16byteAlignment((unsigned long) crypto_dst);
+    pjcontext = (unsigned char *) m16byteAlignment((unsigned long) crypto_context);
+	
+    /* Init HW */
+    *(unsigned long *) (HAC_REG_BASE + REG_CRYPTO_SRC_BASE_OFFSET) = (unsigned long) pjsrc;
+    *(unsigned long *) (HAC_REG_BASE + REG_CRYPTO_DST_BASE_OFFSET) = (unsigned long) pjdst;
+    *(unsigned long *) (HAC_REG_BASE + REG_CRYPTO_CONTEXT_BASE_OFFSET) = (unsigned long) pjcontext;
+    *(unsigned long *) (HAC_REG_BASE + REG_CRYPTO_LEN_OFFSET) = ulMsgLength;
+
+    /* Set source */
+    for (i=0; i< ulMsgLength; i++)
+    {
+    	ch = *(uint8 *)(input + i);    	
+    	*(uint8 *) (pjsrc + i) = ch;
+    }
+     
+    /* Set Context */
+    /* Set IV */
+    for (i=0; i<16; i++)
+    {
+        ch = *(uint8 *) (iv + i);
+    	*(uint8 *) (pjcontext + i) = ch;
+    }
+       
+    /* Set Expansion Key */   
+    for (i=0; i<(4*(ctx->nr+1)); i++)
+    {
+        ulTemp = ((ctx->erk[i] & 0xFF) << 24) + ((ctx->erk[i] & 0xFF00) << 8) + ((ctx->erk[i] & 0xFF0000) >> 8) + ((ctx->erk[i] & 0xFF000000) >> 24);
+    	*(uint32 *) (pjcontext + i*4 + 16) = ulTemp;
+    }
+
+    /* fire cmd */
+    *(unsigned long *) (HAC_REG_BASE + REG_CRYPTO_CMD_BASE_OFFSET) = ulCommand;
+    do {
+        ulTemp = *(volatile unsigned long *) (HAC_REG_BASE + REG_CRYPTO_STATUS_OFFSET);
+    } while (ulTemp & CRYPTO_BUSY);	
+    
+    /* Output */
+    for (i=0; i<ulMsgLength; i++)
+    {
+        ch = *(uint8 *) (pjdst + i);        
+        *(uint8 *) (output + i) = ch;    
+    }
+
+} /* aes_dec_ast3000 */
+
+void rc4_crypt_ast3000(uint8 *data, int ulMsgLength, uint8 *rc4_key, uint32 ulKeyLength)
+{
+    struct rc4_state s;
+    unsigned long i, ulTemp, ulCommand;
+    unsigned char ch;
+    unsigned char *pjsrc, *pjdst, *pjcontext;
+
+    ulCommand = CRYPTO_ENABLE_RW | CRYPTO_ENABLE_CONTEXT_LOAD | CRYPTO_ENABLE_CONTEXT_SAVE | \
+                CRYPTO_RC4 | CRYPTO_SYNC_MODE_ASYNC;
+
+    rc4_setup( &s, rc4_key, ulKeyLength );
+
+    pjsrc = (unsigned char *) m16byteAlignment((unsigned long) crypto_src);
+    pjdst = (unsigned char *) m16byteAlignment((unsigned long) crypto_dst);
+    pjcontext = (unsigned char *) m16byteAlignment((unsigned long) crypto_context);
+	
+    /* Init HW */
+    *(uint32 *) (HAC_REG_BASE + REG_CRYPTO_SRC_BASE_OFFSET) = (unsigned long) pjsrc;	
+    *(uint32 *) (HAC_REG_BASE + REG_CRYPTO_DST_BASE_OFFSET) = (unsigned long) pjdst;	
+    *(uint32 *) (HAC_REG_BASE + REG_CRYPTO_CONTEXT_BASE_OFFSET) = (unsigned long) pjcontext;	
+    *(uint32 *) (HAC_REG_BASE + REG_CRYPTO_LEN_OFFSET) = ulMsgLength;	
+          	
+
+    /* Set source */
+    for (i=0; i< ulMsgLength; i++)
+    {
+    	ch = *(uint8 *)(data + i);
+    	*(uint8 *) (pjsrc + i) = ch;
+    }
+     
+    /* Set Context */
+    /* Set i, j */
+    *(uint32 *) (pjcontext + 8) = 0x0001;	
+       
+    /* Set Expansion Key */   
+    for (i=0; i<(256/4); i++)
+    {
+       ulTemp = (s.m[i * 4] & 0xFF) + ((s.m[i * 4 + 1] & 0xFF) << 8) + ((s.m[i * 4 + 2] & 0xFF) << 16) + ((s.m[i * 4+ 3] & 0xFF) << 24);
+       *(uint32 *) (pjcontext + i*4 + 16) = ulTemp;	
+    }
+
+    /* fire cmd */
+    *(uint32 *) (HAC_REG_BASE + REG_CRYPTO_CMD_BASE_OFFSET) = ulCommand;    
+    do {
+    	ulTemp = *(volatile uint32 *) (HAC_REG_BASE + REG_CRYPTO_STATUS_OFFSET);
+    } while (ulTemp & CRYPTO_BUSY);	
+
+    /* Output */
+    for (i=0; i<ulMsgLength; i++)
+    {
+        ch = *(volatile uint8 *) (pjdst + i);
+        *(uint8 *) (data + i) = ch;    
+    }
+
+} /* rc4_crypt_ast3000	*/
+
+/* Hash */
+void hash_ast3000(uint8 *msg, uint32 ulLength, unsigned char *output, uint32 ulHashMode)
+{
+   uint32 i, ulTemp, ulCommand, ulDigestLength, ulMyMsgLength;
+   uint8 ch;
+   unsigned char *pjsrc, *pjdst;
+   
+   /* Get Info */
+   switch (ulHashMode)
+   {
+   case HASHMODE_MD5:
+        ulCommand = HASH_ALG_SELECT_MD5;
+        ulDigestLength = 16;
+       break;
+   case HASHMODE_SHA1:
+        ulCommand = HASH_ALG_SELECT_SHA1 | 0x08;
+        ulDigestLength = 20;
+       break;
+   case HASHMODE_SHA256:
+        ulCommand = HASH_ALG_SELECT_SHA256 | 0x08;
+        ulDigestLength = 32;
+       break;
+   case HASHMODE_SHA224:
+        ulCommand = HASH_ALG_SELECT_SHA224 | 0x08;
+        ulDigestLength = 28;
+       break;       	
+   }   	    
+
+    pjsrc = (unsigned char *) m16byteAlignment((unsigned long) hash_src);
+    pjdst = (unsigned char *) m16byteAlignment((unsigned long) hash_dst);
+
+    /* 16byte alignment */
+    ulMyMsgLength = m16byteAlignment(ulLength);
+   	
+   /* Init. HW */
+    *(uint32 *) (HAC_REG_BASE + REG_HASH_SRC_BASE_OFFSET) = (unsigned long) pjsrc;	
+    *(uint32 *) (HAC_REG_BASE + REG_HASH_DST_BASE_OFFSET) = (unsigned long) pjdst;	
+    *(uint32 *) (HAC_REG_BASE + REG_HASH_LEN_OFFSET) = ulMyMsgLength;	
+        
+    /* write src */
+    for (i=0; i<ulLength; i++)
+    {
+    	ch = *(uint8 *)(msg+i);
+    	*(uint8 *) (pjsrc + i) = ch;
+    }    
+    for (i=ulLength; i<ulMyMsgLength; i++)
+        *(uint8 *) (pjsrc + i) = 0;
+        
+    /* fire cmd */
+    *(uint32 *) (HAC_REG_BASE + REG_HASH_CMD_OFFSET) = ulCommand;	
+    
+    /* get digest */
+    do {
+    	ulTemp = *(volatile uint32 *) (HAC_REG_BASE + REG_HASH_STATUS_OFFSET);    	
+    } while (ulTemp & HASH_BUSY);	
+    	
+    for (i=0; i<ulDigestLength; i++)
+    {
+        ch = *(volatile uint8 *) (pjdst + i);
+       *(uint8 *) (output + i) = ch;    
+    }        
+ 
+} /* hash_ast3000 */	
+
+/* HMAC */
+void hmackey_ast3000(uint8 *key, uint32 ulKeyLength, uint32 ulHashMode)
+{
+    uint32 i, ulBlkLength, ulDigestLength, ulTemp, ulCommand;
+    uint8 k0[64], sum[32];
+    uint8 ch;
+    unsigned char *pjsrc, *pjdst, *pjkey;
+
+   /* Get Info */
+   switch (ulHashMode)
+   {
+   case HASHMODE_MD5:
+        ulCommand = HASH_ALG_SELECT_MD5;
+        ulDigestLength = 16;
+       break;
+   case HASHMODE_SHA1:
+        ulCommand = HASH_ALG_SELECT_SHA1 | 0x08;
+        ulDigestLength = 20;
+       break;
+   case HASHMODE_SHA256:
+        ulCommand = HASH_ALG_SELECT_SHA256 | 0x08;
+        ulDigestLength = 32;
+       break;
+   case HASHMODE_SHA224:
+        ulCommand = HASH_ALG_SELECT_SHA224 | 0x08;
+        ulDigestLength = 28;
+       break;       	
+   }   	    
+   ulBlkLength = 64;				/* MD5, SHA1/256/224: 64bytes */
+
+    /* Init */
+    memset( (void *) k0, 0, 64);		/* reset to zero */
+    memset( (void *) sum, 0, 32);		/* reset to zero */
+
+    /* Get k0 */
+    if (ulKeyLength <= ulBlkLength)
+        memcpy( (void *) k0, (void *) key, ulKeyLength );       
+    else /* (ulKeyLength > ulBlkLength) */
+    {
+        hash_ast3000(key, ulKeyLength, sum, ulHashMode);
+        memcpy( (void *) k0, (void *) sum, ulDigestLength );                           
+    }    	
+
+    pjsrc = (unsigned char *) m16byteAlignment((unsigned long) hash_src);
+    pjdst = (unsigned char *) m16byteAlignment((unsigned long) hash_dst);
+    pjkey = (unsigned char *) m64byteAlignment((unsigned long) hmac_key);
+    
+    /* Calculate digest */
+    *(uint32 *) (HAC_REG_BASE + REG_HASH_SRC_BASE_OFFSET) = (unsigned long) pjsrc;
+    *(uint32 *) (HAC_REG_BASE + REG_HASH_DST_BASE_OFFSET) = (unsigned long) pjdst;
+    *(uint32 *) (HAC_REG_BASE + REG_HASH_KEY_BASE_OFFSET) = (unsigned long) pjkey;
+    *(uint32 *) (HAC_REG_BASE + REG_HASH_LEN_OFFSET) = ulBlkLength;
+        
+    /* write key to src */
+    for (i=0; i<ulBlkLength; i++)
+    {
+    	ch = *(uint8 *)(k0+i);
+        *(uint8 *) (pjsrc + i) = ch;
+    }    
+    
+    /* fire cmd for calculate */
+    *(uint32 *) (HAC_REG_BASE + REG_HASH_CMD_OFFSET) = ulCommand | HAC_DIGEST_CAL_ENABLE;    
+    do {
+    	ulTemp = *(volatile uint32 *) (HAC_REG_BASE + REG_HASH_STATUS_OFFSET);    	
+    } while (ulTemp & HASH_BUSY);	
+         
+} /* hmackey_ast3000 */
+
+void hmac_ast3000(uint8 *key, uint32 ulKeyLength, uint8 *msg, uint32 ulMsgLength, uint32 ulHashMode, unsigned char *output)
+{
+    uint32 i, ulTemp, ulCommand, ulDigestLength, ulMyMsgLength;;
+    uint8 ch;
+    unsigned char *pjsrc, *pjdst, *pjkey;
+
+    /* Calculate digest */
+   switch (ulHashMode)
+   {
+   case HASHMODE_MD5:
+        ulCommand = HASH_ALG_SELECT_MD5;
+        ulDigestLength = 16;
+       break;
+   case HASHMODE_SHA1:
+        ulCommand = HASH_ALG_SELECT_SHA1 | 0x08;
+        ulDigestLength = 20;
+       break;
+   case HASHMODE_SHA256:
+        ulCommand = HASH_ALG_SELECT_SHA256 | 0x08;
+        ulDigestLength = 32;
+       break;
+   case HASHMODE_SHA224:
+        ulCommand = HASH_ALG_SELECT_SHA224 | 0x08;
+        ulDigestLength = 28;
+       break;       	
+   }   	    
+ 
+    pjsrc = (unsigned char *) m16byteAlignment((unsigned long) hash_src);
+    pjdst = (unsigned char *) m16byteAlignment((unsigned long) hash_dst);
+    pjkey = (unsigned char *) m64byteAlignment((unsigned long) hmac_key);
+    
+    /* 16byte alignment */
+    ulMyMsgLength = m16byteAlignment(ulMsgLength);
+    		
+    /* Init. HW */
+    *(uint32 *) (HAC_REG_BASE + REG_HASH_SRC_BASE_OFFSET) = (unsigned long) pjsrc;
+    *(uint32 *) (HAC_REG_BASE + REG_HASH_DST_BASE_OFFSET) = (unsigned long) pjdst;
+    *(uint32 *) (HAC_REG_BASE + REG_HASH_KEY_BASE_OFFSET) = (unsigned long) pjkey;
+    *(uint32 *) (HAC_REG_BASE + REG_HASH_LEN_OFFSET) = ulMyMsgLength;
+
+    /* write Text to src */
+    for (i=0; i<ulMsgLength; i++)
+    {
+    	ch = *(uint8 *)(msg+i);
+        *(uint8 *) (pjsrc + i) = ch;
+    }    
+    for (i=ulMsgLength; i<ulMyMsgLength; i++)
+        *(uint8 *) (pjsrc + i) = 0;
+    
+    /* fire cmd */
+    *(uint32 *) (HAC_REG_BASE + REG_HASH_CMD_OFFSET) = ulCommand | HAC_ENABLE;        
+    do {
+    	ulTemp = *(volatile uint32 *) (HAC_REG_BASE + REG_HASH_STATUS_OFFSET);    	
+    } while (ulTemp & HASH_BUSY);
+
+    /* Output Digest */
+    for (i=0; i<ulDigestLength; i++)
+    {
+        ch = *(uint8 *) (pjdst + i);
+        *(uint8 *) (output + i) = ch;    
+    }
+
+} /* hmac_ast3000 */
+
+/* main hactest procedure */
+int do_hactest (void)
+{
+        unsigned long i, j, Flags = 0;
+	aes_test *pjaes_test;
+        aes_context aes_ctx;
+        unsigned char AES_Mode[8], aes_output[64];
+	unsigned long ulAESMsgLength;
+	
+	rc4_test *pjrc4_test;
+	unsigned char rc4_buf_sw[64], rc4_buf_hw[64];
+	unsigned long ulRC4KeyLength, ulRC4MsgLength;
+	
+	hash_test *pjhash_test;
+	unsigned char HASH_Mode[8], hash_out[64];
+
+	hmac_test *pjhmac_test;
+	unsigned char HMAC_Mode[8], hmac_out[64];
+
+	EnableHMAC();
+	
+	/* AES Test */
+	pjaes_test = aestest;
+	while (pjaes_test->aes_mode != 0xFF)
+	{
+
+            if (pjaes_test->aes_mode == CRYPTOMODE_CBC)
+                strcpy (AES_Mode, "CBC");
+            else if (pjaes_test->aes_mode == CRYPTOMODE_CFB)
+                strcpy (AES_Mode, "CFB");
+            else if (pjaes_test->aes_mode == CRYPTOMODE_OFB)
+                strcpy (AES_Mode, "OFB");
+            else if (pjaes_test->aes_mode == CRYPTOMODE_CTR)
+                strcpy (AES_Mode, "CTR");
+            else    
+                strcpy (AES_Mode, "ECB");
+
+            /* Get Msg. Length */
+            ulAESMsgLength = strlen(pjaes_test->plaintext);
+            j = ( (ulAESMsgLength + 15) >> 4) << 4;
+            for (i=ulAESMsgLength; i<j; i++)
+                pjaes_test->plaintext[i] = 0;
+            ulAESMsgLength = j;    
+                		
+            aes_set_key(&aes_ctx, pjaes_test->key, pjaes_test->key_length);
+            
+            /* Encryption Test */
+            aes_enc_ast3000(&aes_ctx, pjaes_test->plaintext, pjaes_test->key, aes_output, ulAESMsgLength, pjaes_test->aes_mode);	    
+	    if (strncmp(aes_output, pjaes_test->ciphertext, ulAESMsgLength))
+	    {
+	    	Flags |= FLAG_AESTEST_FAIL;	    	
+	        printf("[INFO] AES%d %s Mode Encryption Failed \n", pjaes_test->key_length, AES_Mode);
+	        printf("[DBG] Golden Data Dump .... \n");	        
+	        for (i=0; i< ulAESMsgLength; i++)
+	        {
+	            printf("%02x ", pjaes_test->ciphertext[i]);	        	
+	            if (((i+1) % 8) == 0)
+	                printf("\n");        
+	        }        
+	        printf("\n [DBG] Error Data Dump .... \n");
+	        for (i=0; i< ulAESMsgLength; i++)
+	        {
+	            printf("%02x ", aes_output[i]);	        	
+	            if (((i+1) % 8) == 0)
+	                printf("\n");        
+	        }
+	        printf("\n");	                
+	    }
+	    else
+	    {
+	    	/*
+	        printf("[INFO] AES%d %s Mode Encryption Passed \n", pjaes_test->key_length, AES_Mode);
+	        */
+	    }	
+
+            /* Decryption Test */
+            aes_dec_ast3000(&aes_ctx, pjaes_test->ciphertext, pjaes_test->key, aes_output, ulAESMsgLength, pjaes_test->aes_mode);	    
+	    if (strncmp(aes_output, pjaes_test->plaintext, ulAESMsgLength))
+	    {
+	    	Flags |= FLAG_AESTEST_FAIL;
+	        printf("[INFO] AES%d %s Mode Decryption Failed \n", pjaes_test->key_length, AES_Mode);	        
+	        printf("[DBG] Golden Data Dump .... \n");
+	        for (i=0; i< ulAESMsgLength; i++)
+	        {
+	            printf("%02x ", pjaes_test->plaintext[i]);	        	
+	            if (((i+1) % 8) == 0)
+	                printf("\n");        
+	        }        
+	        printf("\n [DBG] Error Data Dump .... \n");
+	        for (i=0; i< ulAESMsgLength; i++)
+	        {
+	            printf("%02x ", aes_output[i]);	        	
+	            if (((i+1) % 8) == 0)
+	                printf("\n");        
+	        }
+	        printf("\n");	                
+	    }
+	    else
+	    {
+	    	/*
+	        printf("[INFO] AES%d %s Mode Decryption Passed \n", pjaes_test->key_length, AES_Mode);
+	        */
+	    }	
+	    
+	    pjaes_test++;
+        } /* AES */
+
+	/* RC4 Test */
+	pjrc4_test = rc4test;
+	while ((pjrc4_test->key[0] != 0xff) && (pjrc4_test->data[0] != 0xff))
+	{
+
+            /* Get Info */
+            ulRC4KeyLength = strlen(pjrc4_test->key);
+            ulRC4MsgLength = strlen(pjrc4_test->data);
+            memcpy( (void *) rc4_buf_sw, (void *) pjrc4_test->data, ulRC4MsgLength );
+            memcpy( (void *) rc4_buf_hw, (void *) pjrc4_test->data, ulRC4MsgLength );                                       
+
+            /* Crypto */
+            rc4_crypt_sw(rc4_buf_sw, ulRC4MsgLength, pjrc4_test->key, ulRC4KeyLength);
+            rc4_crypt_ast3000(rc4_buf_hw, ulRC4MsgLength, pjrc4_test->key, ulRC4KeyLength);
+           
+	    if (strncmp(rc4_buf_hw, rc4_buf_sw, ulRC4MsgLength))
+	    {
+	    	Flags |= FLAG_RC4TEST_FAIL;	    	
+	        printf("[INFO] RC4 Encryption Failed \n");
+	        printf("[DBG] Golden Data Dump .... \n");
+	        for (i=0; i< ulRC4MsgLength; i++)
+	        {
+	            printf("%02x ", rc4_buf_sw[i]);
+	            if (((i+1) % 8) == 0)
+	                printf("\n");        
+	        }
+	        printf("\n [DBG] Error Data Dump .... \n");
+	        for (i=0; i< ulRC4MsgLength; i++)
+	        {
+	            printf("%02x ", rc4_buf_hw[i]);
+	            if (((i+1) % 8) == 0)
+	                printf("\n");        
+	        }
+	        printf("\n");	        
+	    }
+	    else
+	    {
+	    	/*
+	        printf("[INFO] RC4 Encryption Passed \n");
+	        */
+	    }	
+
+	    pjrc4_test++;
+	    
+        } /* RC4 */
+       
+	/* Hash Test */
+	pjhash_test = hashtest;
+	while (pjhash_test->hash_mode != 0xFF)
+	{
+
+            if (pjhash_test->hash_mode == HASHMODE_MD5)
+                strcpy (HASH_Mode, "MD5");
+            else if (pjhash_test->hash_mode == HASHMODE_SHA1)
+                strcpy (HASH_Mode, "SHA1");
+            else if (pjhash_test->hash_mode == HASHMODE_SHA256)
+                strcpy (HASH_Mode, "SHA256");
+            else if (pjhash_test->hash_mode == HASHMODE_SHA224)
+                strcpy (HASH_Mode, "SHA224");
+            
+            /* Hash */   		
+            hash_ast3000(pjhash_test->input, strlen(pjhash_test->input), hash_out, pjhash_test->hash_mode);            
+	    if (strncmp(hash_out, pjhash_test->digest, pjhash_test->digest_length))
+	    {
+	    	Flags |= FLAG_HASHTEST_FAIL;	    	
+	        printf("[INFO] HASH %s Failed \n", HASH_Mode);
+	        printf("[DBG] Golden Data Dump .... \n");	        
+	        for (i=0; i< pjhash_test->digest_length; i++)
+	        {
+	            printf("%02x ",pjhash_test->digest[i]);
+	            if (((i+1) % 8) == 0) 	
+	                printf("\n");        
+	        }        
+	        printf("\n [DBG] Error Data Dump .... \n");
+	        for (i=0; i< pjhash_test->digest_length; i++)
+	        {
+	            printf("%02x ",hash_out[i]);
+	            if (((i+1) % 8) == 0) 	
+	                printf("\n");        
+	        }
+	        printf("\n");
+	    }
+	    else
+	    {
+	    	/*
+	        printf("[INFO] HASH %s Passed \n", HASH_Mode);
+	        */
+	    }	
+
+            pjhash_test++;
+            
+        } /* Hash Test */
+
+	/* HMAC Test */
+	pjhmac_test = hmactest;
+	while (pjhmac_test->hash_mode != 0xFF)
+	{
+
+            if (pjhmac_test->hash_mode == HASHMODE_MD5)
+                strcpy (HMAC_Mode, "MD5");
+            else if (pjhmac_test->hash_mode == HASHMODE_SHA1)
+                strcpy (HMAC_Mode, "SHA1");
+            else if (pjhmac_test->hash_mode == HASHMODE_SHA256)
+                strcpy (HMAC_Mode, "SHA256");
+            else if (pjhmac_test->hash_mode == HASHMODE_SHA224)
+                strcpy (HMAC_Mode, "SHA224");
+            
+            /* HMAC */   		
+            hmackey_ast3000(pjhmac_test->key, pjhmac_test->key_length, pjhmac_test->hash_mode);
+            hmac_ast3000(pjhmac_test->key, pjhmac_test->key_length, pjhmac_test->input, strlen(pjhmac_test->input), pjhmac_test->hash_mode, hmac_out);            
+	    if (strncmp(hmac_out, pjhmac_test->digest, pjhmac_test->digest_length))
+	    {
+	    	Flags |= FLAG_HASHTEST_FAIL;	    	
+	        printf("[INFO] HMAC %s Failed \n", HMAC_Mode);
+	        printf("[DBG] Golden Data Dump .... \n");	        
+	        for (i=0; i< pjhmac_test->digest_length; i++)
+	        {
+	            printf("%02x ",pjhmac_test->digest[i]);
+	            if (((i+1) % 8) == 0) 	
+	                printf("\n");        
+	        }        
+	        printf("\n [DBG] Error Data Dump .... \n");
+	        for (i=0; i< pjhmac_test->digest_length; i++)
+	        {
+	            printf("%02x ",hmac_out[i]);
+	            if (((i+1) % 8) == 0) 	
+	                printf("\n");        
+	        }
+	        printf("\n");
+	    }
+	    else
+	    {
+	    	/*
+	        printf("[INFO] HMAC %s Passed \n", HMAC_Mode);
+	        */
+	    }	
+
+            pjhmac_test++;
+            
+        } /* HMAC Test */
+
+	return Flags;
+	
+}
+
+#endif /* CONFIG_SLT */
diff --git a/board/aspeed/ast2400/hactest.h b/board/aspeed/ast2400/hactest.h
new file mode 100755
index 0000000..fcf2186
--- /dev/null
+++ b/board/aspeed/ast2400/hactest.h
@@ -0,0 +1,194 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* Err Flags */
+#define FLAG_AESTEST_FAIL  		0x00000001
+#define FLAG_RC4TEST_FAIL  		0x00000002
+#define FLAG_HASHTEST_FAIL  		0x00000004
+
+/* Specific */
+/*
+#define DRAM_BASE			0x40000000
+#define	CRYPTO_SRC_BASE			(DRAM_BASE + 0x100000)
+#define	CRYPTO_DST_BASE			(DRAM_BASE + 0x200000)
+#define	CRYPTO_CONTEXT_BASE		(DRAM_BASE + 0x300000)
+
+#define	HASH_SRC_BASE			(DRAM_BASE + 0x400000)
+#define	HASH_DST_BASE			(DRAM_BASE + 0x500000)
+#define	HMAC_KEY_BASE			(DRAM_BASE + 0x600000)
+*/
+#define m08byteAlignment(x)		((x + 0x00000007) & 0xFFFFFFF8)
+#define m16byteAlignment(x)		((x + 0x0000000F) & 0xFFFFFFF0)
+#define m64byteAlignment(x)		((x + 0x0000003F) & 0xFFFFFFC0)
+
+#define CRYPTO_ALIGNMENT		16
+#define CRYPTO_MAX_SRC			(100+CRYPTO_ALIGNMENT)
+#define CRYPTO_MAX_DST			(100+CRYPTO_ALIGNMENT)
+#define CRYPTO_MAX_CONTEXT		(100+CRYPTO_ALIGNMENT)
+
+#define HASH_ALIGNMENT			16
+#define HMAC_KEY_ALIGNMENT	 	64
+#define HASH_MAX_SRC			(100+HASH_ALIGNMENT)
+#define HASH_MAX_DST			(32+HASH_ALIGNMENT)
+#define HMAC_MAX_KEY			(64+HMAC_KEY_ALIGNMENT)
+
+/* General */
+#define HAC_REG_BASE 			0x1e6e3000
+
+#define MAX_KEYLENGTH			100
+#define MAX_TEXTLENGTH			100
+#define MAX_AESTEXTLENGTH		256
+#define MAX_RC4TEXTLENGTH		256
+#define MAX_RC4KEYLENGTH		256
+
+#define CRYPTOMODE_ECB			0x00
+#define CRYPTOMODE_CBC			0x01
+#define CRYPTOMODE_CFB			0x02
+#define CRYPTOMODE_OFB			0x03
+#define CRYPTOMODE_CTR			0x04
+
+#define HASHMODE_MD5			0x00
+#define HASHMODE_SHA1			0x01
+#define HASHMODE_SHA256			0x02
+#define HASHMODE_SHA224			0x03
+
+#define MIXMODE_DISABLE                 0x00
+#define MIXMODE_CRYPTO                  0x02
+#define MIXMODE_HASH                    0x03
+
+#define REG_CRYPTO_SRC_BASE_OFFSET	0x00
+#define REG_CRYPTO_DST_BASE_OFFSET	0x04
+#define REG_CRYPTO_CONTEXT_BASE_OFFSET	0x08
+#define REG_CRYPTO_LEN_OFFSET		0x0C
+#define REG_CRYPTO_CMD_BASE_OFFSET	0x10
+//#define REG_CRYPTO_ENABLE_OFFSET	0x14
+#define REG_CRYPTO_STATUS_OFFSET	0x1C
+
+#define REG_HASH_SRC_BASE_OFFSET	0x20
+#define REG_HASH_DST_BASE_OFFSET	0x24
+#define REG_HASH_KEY_BASE_OFFSET	0x28
+#define REG_HASH_LEN_OFFSET		0x2C
+#define REG_HASH_CMD_OFFSET		0x30
+//#define REG_HASH_ENABLE_OFFSET		0x14
+#define REG_HASH_STATUS_OFFSET		0x1C
+
+#define HASH_BUSY			0x01
+#define CRYPTO_BUSY			0x02
+
+//#define ENABLE_HASH			0x01
+//#define DISABLE_HASH			0x00
+//#define ENABLE_CRYPTO			0x02
+//#define DISABLE_CRYPTO			0x00
+
+#define CRYPTO_SYNC_MODE_MASK		0x03
+#define CRYPTO_SYNC_MODE_ASYNC		0x00
+#define CRYPTO_SYNC_MODE_PASSIVE	0x02
+#define CRYPTO_SYNC_MODE_ACTIVE		0x03
+
+#define CRYPTO_AES128			0x00
+#define CRYPTO_AES192			0x04
+#define CRYPTO_AES256			0x08
+
+#define CRYPTO_AES_ECB			0x00
+#define CRYPTO_AES_CBC			0x10
+#define CRYPTO_AES_CFB			0x20
+#define CRYPTO_AES_OFB			0x30
+#define CRYPTO_AES_CTR			0x40
+
+#define CRYPTO_ENCRYPTO			0x80
+#define CRYPTO_DECRYPTO			0x00
+
+#define CRYPTO_AES			0x000
+#define CRYPTO_RC4			0x100
+
+#define CRYPTO_ENABLE_RW		0x000
+#define CRYPTO_ENABLE_CONTEXT_LOAD	0x000
+#define CRYPTO_ENABLE_CONTEXT_SAVE	0x000
+
+#define HASH_SYNC_MODE_MASK		0x03
+#define HASH_SYNC_MODE_ASYNC		0x00
+#define HASH_SYNC_MODE_PASSIVE		0x02
+#define HASH_SYNC_MODE_ACTIVE		0x03
+
+#define HASH_READ_SWAP_ENABLE		0x04
+#define HMAC_SWAP_CONTROL_ENABLE	0x08
+
+#define HASH_ALG_SELECT_MASK		0x70
+#define HASH_ALG_SELECT_MD5		0x00
+#define HASH_ALG_SELECT_SHA1		0x20
+#define HASH_ALG_SELECT_SHA224		0x40
+#define HASH_ALG_SELECT_SHA256		0x50
+
+#define HAC_ENABLE			0x80
+#define HAC_DIGEST_CAL_ENABLE		0x180
+#define HASH_INT_ENABLE			0x200
+
+/* AES */
+#ifndef uint8
+#define uint8  unsigned char
+#endif
+
+#ifndef uint32
+#define uint32 unsigned long int
+#endif
+
+typedef struct
+{
+    uint32 erk[64];     /* encryption round keys */
+    uint32 drk[64];     /* decryption round keys */
+    int nr;             /* number of rounds */
+}
+aes_context;
+
+typedef struct
+{
+    int	  aes_mode;
+    int	  key_length;
+	
+    uint8 key[32];	/* as iv in CTR mode */
+    uint8 plaintext[64];
+    uint8 ciphertext[64];
+    
+}
+aes_test;
+
+/* RC4 */
+typedef struct
+{
+    uint8 key[32];
+    uint8 data[64];
+}
+rc4_test;
+
+/* Hash */
+typedef struct
+{
+    int	  hash_mode;
+    int	  digest_length;
+	
+    uint8 input[64];
+    uint8 digest[64];
+    
+}
+hash_test;
+	
+/* HMAC */
+typedef struct
+{
+    int	  hash_mode;
+    int	  key_length;
+    int	  digest_length;
+
+    uint8 key[100];	
+    uint8 input[64];
+    uint8 digest[64];
+    
+}
+hmac_test;
diff --git a/board/aspeed/ast2400/mactest.c b/board/aspeed/ast2400/mactest.c
new file mode 100755
index 0000000..22054b9
--- /dev/null
+++ b/board/aspeed/ast2400/mactest.c
@@ -0,0 +1,510 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/*
+ * (C) Copyright 2007 ASPEED Software
+ * MAC Manufacture Test in ASPEED's SDK version 0.20.01
+ *
+ * Release History
+ * 1. First Release, river@20071130
+ * 2. Fix the endless loop when PHY is not ready, river@20071204
+ *
+ * Test items:
+ * 1. Support MARVELL PHY only in this version
+ * 2. MDC/MDIO
+ * 3. GMAC/Duplex TX/RX Full_Size, Packet_Length Test
+ * 4. 100M/Duplex TX/RX Full_Size, Packet_Length Test
+ *
+ *
+ *
+*/
+
+
+/*
+* Diagnostics support
+*/
+#include <common.h>
+#include <command.h>
+#include <post.h>
+#include <malloc.h>
+#include <net.h>
+#include "slt.h"
+
+#if ((CFG_CMD_SLT & CFG_CMD_MACTEST) && defined(CONFIG_SLT))
+#include "mactest.h"
+
+static int INL(u_long base, u_long addr)
+{
+	return le32_to_cpu(*(volatile u_long *)(addr + base));
+}
+
+static void OUTL(u_long base, int command, u_long addr)
+{
+	*(volatile u_long *)(addr + base) = cpu_to_le32(command);
+}
+
+
+static void SCU_MAC1_Enable (u8 enable)
+{
+	unsigned int SCU_Register;
+
+	if(enable) {
+//MAC1 RESET/PHY_LINK in SCU
+        SCU_Register = INL(SCU_BASE, SCU_RESET_CONTROL_REG);
+	OUTL(SCU_BASE, SCU_Register & ~(0x800), SCU_RESET_CONTROL_REG);
+	} else {
+		SCU_Register = INL(SCU_BASE, SCU_RESET_CONTROL_REG);
+		OUTL(SCU_BASE, SCU_Register |(0x800), SCU_RESET_CONTROL_REG);
+	
+}
+}
+
+/*------------------------------------------------------------
+ . Reads a register from the MII Management serial interface
+ .-------------------------------------------------------------*/
+static u16 phy_read_register (u8 PHY_Register, u8 PHY_Address)
+{
+	u32 Data, Status = 0, Loop_Count = 0, PHY_Ready = 1;
+	u16 Return_Data;
+
+	OUTL(MAC1_IO_BASE, (PHY_Register << 21) + (PHY_Address << 16) + MIIRD + MDC_CYCTHR, PHYCR_REG);
+	do {
+		Status = (INL (MAC1_IO_BASE, PHYCR_REG) & MIIRD);
+		Loop_Count++;
+		if (Loop_Count >= PHY_LOOP) {
+			PHY_Ready = 0;
+			break;
+		}
+	} while (Status == MIIRD);
+       
+	if (PHY_Ready == 0) {
+		printf ("PHY NOT REDAY\n");
+		return 0;
+	}
+	
+	udelay(5*1000);
+	Data = INL (MAC1_IO_BASE, PHYDATA_REG);
+	Return_Data = (Data >> 16);
+
+	return Return_Data;
+}
+
+static void phy_write_register (u8 PHY_Register, u8 PHY_Address, u16 PHY_Data)
+{
+	u32 Status = 0, Loop_Count = 0, PHY_Ready = 1;
+
+	OUTL(MAC1_IO_BASE, PHY_Data, PHYDATA_REG);
+	OUTL(MAC1_IO_BASE, (PHY_Register << 21) + (PHY_Address << 16) + MIIWR + MDC_CYCTHR, PHYCR_REG);
+	do {
+		Status = (INL (MAC1_IO_BASE, PHYCR_REG) & MIIWR);
+		Loop_Count++;
+		if (Loop_Count >= PHY_LOOP) {
+			PHY_Ready = 0;
+			break;
+		}
+	} while (Status == MIIWR);
+	if (PHY_Ready == 0) {
+		printf ("PHY NOT REDAY\n");
+	}
+}
+
+static int wait_link_resolve (void)
+{
+	int resolved_status, Loop_Count = 0, PHY_Ready = 1;
+
+        do {
+       		resolved_status = (phy_read_register (0x11, 0) & (PHY_RESOLVED_bit | PHY_LINK_bit));
+               	Loop_Count++;
+               	if (Loop_Count >= PHY_LOOP) {
+                   	PHY_Ready = 0;
+                    	printf ("PHY NOT READY\n");
+                    	break;
+                }
+        } while (resolved_status != (PHY_RESOLVED_bit | PHY_LINK_bit));
+        
+        return PHY_Ready;
+}
+
+static void set_phy_speed (int chip, int speed, int duplex)
+{
+	unsigned short data, status;
+
+
+	if (chip == PHYID_VENDOR_MARVELL) {
+		if ((speed == PHY_SPEED_1G) && (duplex == DUPLEX_FULL)) {
+//Manual Control
+			phy_write_register (18, 0, 0);
+			data = phy_read_register (9, 0);
+			phy_write_register (9, 0, data | 0x1800);
+//PHY Reset
+			phy_write_register (0, 0, 0x0140 | 0x8000);
+			do {
+				status = (phy_read_register (0, 0) & 0x8000); 
+			} while (status != 0);
+	
+//Force 1G
+			phy_write_register (29, 0, 0x07);
+			data = phy_read_register (30, 0);
+			phy_write_register (30, 0, data | 0x08);
+			phy_write_register (29, 0, 0x10);
+			data = phy_read_register (30, 0);
+			phy_write_register (30, 0, data | 0x02);
+			phy_write_register (29, 0, 0x12);
+			data = phy_read_register (30, 0);
+			phy_write_register (30, 0, data | 0x01);
+	
+			printf ("FORCE MARVELL PHY to 1G/DUPLEX DONE\n");
+		}
+		else if ((speed == PHY_SPEED_100M) && (duplex == DUPLEX_FULL)) {
+//PHY Reset
+			phy_write_register (0, 0, 0x2100 | 0x8000);
+			do {
+				status = (phy_read_register (0, 0) & 0x8000); 
+			} while (status != 0);
+	
+//Force 100M
+			data = phy_read_register (0, 0);
+			phy_write_register (0, 0, data | 0x4000 | 0x8000);
+			do {
+				status = (phy_read_register (0, 0) & 0x8000); 
+			} while (status != 0);
+			data = phy_read_register (0, 0);
+
+			printf ("FORCE MARVELL PHY to 100M/DUPLEX DONE\n");
+		}
+	}
+	else if ( (chip == PHYID_VENDOR_RTL8201E) || (chip == PHYID_VENDOR_BROADCOM) ){
+		/* basic setting */
+		data  = phy_read_register (0, 0);
+		data &= 0x7140;
+		data |= 0x4000;
+		if (speed == PHY_SPEED_100M)
+		    data |= 0x2000;
+                if (duplex == DUPLEX_FULL)		    
+                    data |= 0x0100;
+		phy_write_register (0, 0, data);
+
+                /* reset */
+		phy_write_register (0, 0, data | 0x8000);
+		do {
+			status = (phy_read_register (0, 0) & 0x8000); 
+		} while (status != 0);
+	        udelay(100*1000);
+		
+		/* basic setting */
+		phy_write_register (0, 0, data);
+
+                if (chip == PHYID_VENDOR_RTL8201E)
+		    printf ("FORCE RTL8201E PHY to 100M/DUPLEX DONE\n");		
+                else if (chip == PHYID_VENDOR_BROADCOM)
+		    printf ("FORCE Broadcom PHY to 100M/DUPLEX DONE\n");		
+		    
+	}	
+	
+}
+
+static void MAC1_reset (void)
+{
+    OUTL(MAC1_IO_BASE, SW_RST_bit, MACCR_REG);
+    for (; (INL(MAC1_IO_BASE, MACCR_REG ) & SW_RST_bit) != 0; ) {udelay(1000);}
+    OUTL(MAC1_IO_BASE, 0, IER_REG );
+}
+
+static int set_mac1_control_register (int Chip_ID)
+{
+	unsigned long	MAC_CR_Register = 0;
+	int    PHY_Ready = 1;
+	u16    PHY_Status, PHY_Speed, PHY_Duplex, Advertise, Link_Partner;
+
+	MAC_CR_Register = SPEED_100M_MODE_bit | RX_ALLADR_bit | FULLDUP_bit | RXMAC_EN_bit | RXDMA_EN_bit | TXMAC_EN_bit | TXDMA_EN_bit | CRC_APD_bit;
+
+	if ( (Chip_ID == PHYID_VENDOR_BROADCOM) || (Chip_ID == PHYID_VENDOR_RTL8201E)) {
+		Advertise = phy_read_register (0x04, 0);
+		Link_Partner = phy_read_register (0x05, 0);
+		Advertise = (Advertise & PHY_SPEED_DUPLEX_MASK);
+		Link_Partner = (Link_Partner & PHY_SPEED_DUPLEX_MASK);
+		if ((Advertise & Link_Partner) & PHY_100M_DUPLEX) {
+			MAC_CR_Register |= SPEED_100M_MODE_bit;
+			MAC_CR_Register |= FULLDUP_bit;
+		}
+		else if ((Advertise & Link_Partner) & PHY_100M_HALF) {
+			MAC_CR_Register |= SPEED_100M_MODE_bit;
+			MAC_CR_Register &= ~FULLDUP_bit;
+		}
+		else if ((Advertise & Link_Partner) & PHY_10M_DUPLEX) {
+			MAC_CR_Register &= ~SPEED_100M_MODE_bit;
+			MAC_CR_Register |= FULLDUP_bit;
+		}
+		else if ((Advertise & Link_Partner) & PHY_10M_HALF) {
+			MAC_CR_Register &= ~SPEED_100M_MODE_bit;
+			MAC_CR_Register &= ~FULLDUP_bit;
+		}
+	}
+	else if (Chip_ID == PHYID_VENDOR_MARVELL) {
+
+		PHY_Ready = wait_link_resolve ();
+
+		if (PHY_Ready == 1) {
+			PHY_Status = phy_read_register (0x11, 0);
+			PHY_Speed = (PHY_Status & PHY_SPEED_MASK) >> 14;
+			PHY_Duplex = (PHY_Status & PHY_DUPLEX_MASK) >> 13;
+
+			if (PHY_Speed == SPEED_1000M) {
+				MAC_CR_Register |= GMAC_MODE_bit;
+                	}
+			else {
+				MAC_CR_Register &= ~GMAC_MODE_bit;
+				if (PHY_Speed == SPEED_10M) {
+                        		MAC_CR_Register &= ~SPEED_100M_MODE_bit;
+                    		}
+                	}
+                	if (PHY_Duplex == DUPLEX_HALF) {
+				MAC_CR_Register &= ~FULLDUP_bit;
+			}
+		}
+	}
+	OUTL(MAC1_IO_BASE, MAC_CR_Register, MACCR_REG);
+
+	return PHY_Ready;
+}
+
+static void ring_buffer_alloc (void)
+{
+	unsigned int i, j;
+
+//Write data into TX buffer
+	for (i = 0; i < NUM_TX; i++) {
+		for (j = 0; j < TX_BUFF_SZ; j++) {
+			tx_buffer[i][j] = i * 4 + j;
+		}
+	}
+//Initialize RX buffer to 0
+	for (i = 0; i < NUM_RX; i++) {
+		for (j = 0; j < RX_BUFF_SZ; j++) {
+			rx_buffer[i][j] = 0;
+		}
+	}
+//Prepare descriptor
+	for (i = 0; i < NUM_RX; i++) {
+		rx_ring[i].status = cpu_to_le32(RXPKT_RDY + RX_BUFF_SZ);
+		rx_ring[i].buf = ((u32) &rx_buffer[i]);
+		rx_ring[i].reserved = 0;
+	}
+	for (i = 0; i < NUM_TX; i++) {
+		tx_ring[i].status = 0;
+		tx_ring[i].des1 = 0;
+		tx_ring[i].buf = ((u32) &tx_buffer[i]);
+		tx_ring[i].reserved = 0;
+	}
+
+	rx_ring[NUM_RX - 1].status |= cpu_to_le32(EDORR);
+	tx_ring[NUM_TX - 1].status |= cpu_to_le32(EDOTR);
+
+	OUTL(MAC1_IO_BASE, ((u32) &tx_ring), TXR_BADR_REG);
+	OUTL(MAC1_IO_BASE, ((u32) &rx_ring), RXR_BADR_REG);
+	
+	tx_new = 0;
+	rx_new = 0;
+}
+
+static int packet_test (void)
+{
+	unsigned int rx_status, length, i, Loop_Count = 0;
+
+	tx_ring[tx_new].status |= cpu_to_le32(LTS | FTS | TX_BUFF_SZ);
+	tx_ring[tx_new].status |= cpu_to_le32(TXDMA_OWN);
+	OUTL(MAC1_IO_BASE, POLL_DEMAND, TXPD_REG);
+
+//Compare result
+	do {
+		rx_status = rx_ring[rx_new].status;
+		Loop_Count++;
+	} while (!(rx_status & RXPKT_STATUS) && (Loop_Count < PHY_LOOP));
+	if (rx_status & (RX_ERR | CRC_ERR | FTL | RUNT | RX_ODD_NB)) {
+		/* There was an error.*/
+		printf("RX error status = 0x%08X\n", rx_status);
+		return PACKET_TEST_FAIL;
+	} else {
+		length = (rx_status & BYTE_COUNT_MASK);
+		for (i = 0; i < RX_BUFF_SZ / 4; i++) {
+			if (rx_buffer[rx_new][i] != tx_buffer[tx_new][i]) {
+				printf ("ERROR at packet %d, address %x\n", rx_new, i);
+				printf ("Gold = %8x, Real = %8x\n", tx_buffer[tx_new][i], rx_buffer[rx_new][i]);
+				return PACKET_TEST_FAIL;
+			}
+		}
+	}
+    	tx_new = (tx_new + 1) % NUM_TX;
+	rx_new = (rx_new + 1) % NUM_RX;
+
+	return TEST_PASS;
+}
+
+static int packet_length_test (int packet_length)
+{
+	unsigned int rx_status, length, i, Loop_Count = 0;
+
+	tx_ring[tx_new].status &= (~(BYTE_COUNT_MASK));
+	tx_ring[tx_new].status |= cpu_to_le32(LTS | FTS | packet_length);
+	tx_ring[tx_new].status |= cpu_to_le32(TXDMA_OWN);
+	OUTL(MAC1_IO_BASE, POLL_DEMAND, TXPD_REG);
+
+//Compare result
+	do {
+		rx_status = rx_ring[rx_new].status;
+		Loop_Count++;
+	} while (!(rx_status & RXPKT_STATUS) && (Loop_Count < PHY_LOOP));
+	if (rx_status & (RX_ERR | CRC_ERR | FTL | RUNT | RX_ODD_NB)) {
+		/* There was an error.*/
+		printf("RX error status = 0x%08X\n", rx_status);
+		return PACKET_LENGTH_TEST_FAIL;
+	} else {
+		length = (rx_status & BYTE_COUNT_MASK) - 4;
+                if (length != packet_length) {
+			printf ("Received Length ERROR. Gold = %d, Fail = %d\n",packet_length, length);
+			printf ("rx_new = %d, tx_new = %d\n", rx_new, tx_new);
+			return PACKET_LENGTH_TEST_FAIL;
+                }
+		for (i = 0; i < length; i++) {
+		    if (rx_buffer[rx_new][i] != tx_buffer[tx_new][i]) {
+		    	printf ("ERROR at packet %d, address %x\n", rx_new, i);
+		    	printf ("Gold = %8x, Real = %8x\n", tx_buffer[tx_new][i], rx_buffer[rx_new][i]);
+		    	return PACKET_LENGTH_TEST_FAIL;
+		    }
+		}
+	}
+	rx_ring[rx_new].status &= (~(RXPKT_STATUS));
+    	tx_new = (tx_new + 1) % NUM_TX;
+	rx_new = (rx_new + 1) % NUM_RX;
+
+	return TEST_PASS;
+}
+
+static int MAC1_init (int id)
+{
+	int phy_status = 0;
+
+	MAC1_reset ();
+	phy_status = set_mac1_control_register (id);
+       	ring_buffer_alloc ();
+       	
+       	return phy_status;
+}
+
+int do_mactest (void)
+{
+	unsigned int phy_id, i;
+	int test_result = 0, phy_status = 0;
+
+	SCU_MAC1_Enable(1);
+	phy_id = ((phy_read_register (0x02, 0) << 16) + phy_read_register (0x03, 0)) & PHYID_VENDOR_MASK;
+	if (phy_id == PHYID_VENDOR_MARVELL) {
+        	printf ("PHY DETECTED ------> MARVELL\n");
+
+        	set_phy_speed (phy_id, PHY_SPEED_1G, DUPLEX_FULL);
+        	if ((phy_status = MAC1_init (phy_id)) != 0) {
+	        	for (i = 0; i < NUM_TX; i++) {
+				test_result |= packet_test ();
+				if (test_result != 0)
+					break;
+        		}
+        	}
+		else if (phy_status == 0) {
+			printf ("PHY FAIL: Please Check If you are using LOOP BACK Connector\n");
+			test_result = 3;
+			return	test_result;
+		}
+        	if ((phy_status = MAC1_init (phy_id)) != 0) {
+        		for (i = 60; i < TX_BUFF_SZ; i++) {
+				test_result |= packet_length_test (i);
+				if (test_result != 0)
+					break;
+        		}
+        	}
+		else if (phy_status == 0) {
+			printf ("PHY FAIL: Please Check If you are using LOOP BACK Connector\n");
+			test_result = 3;
+			return	test_result;
+		}
+        	set_phy_speed (phy_id, PHY_SPEED_100M, DUPLEX_FULL);
+        	if ((phy_status = MAC1_init (phy_id)) != 0) {
+        		for (i = 0; i < NUM_TX; i++) {
+				test_result |= packet_test ();
+				if (test_result != 0)
+					break;
+        		}
+        	}
+		else if (phy_status == 0) {
+			printf ("PHY FAIL: Please Check If you are using LOOP BACK Connector\n");
+			test_result = 3;
+			return	test_result;
+		}
+
+        	if ((phy_status = MAC1_init (phy_id)) != 0) {
+        		for (i = 60; i < TX_BUFF_SZ; i++) {
+				test_result |= packet_length_test (i);
+        			if (test_result != 0)
+	        	    		break;
+        		}
+        	}
+		else if (phy_status == 0) {
+			printf ("PHY FAIL: Please Check If you are using LOOP BACK Connector\n");
+			test_result = 3;
+			return	test_result;
+		}
+        }
+	else if ( (phy_id == PHYID_VENDOR_RTL8201E) || (phy_id == PHYID_VENDOR_BROADCOM) ){
+		
+        	if (phy_id == PHYID_VENDOR_RTL8201E)
+        	    printf ("PHY DETECTED ------> RTL 8201E \n");
+        	else if (phy_id == PHYID_VENDOR_BROADCOM)
+        	    printf ("PHY DETECTED ------> Broadcom \n");
+        	
+        	set_phy_speed (phy_id, PHY_SPEED_100M, DUPLEX_FULL);
+        	if ((phy_status = MAC1_init (phy_id)) != 0) {
+        		for (i = 0; i < NUM_TX; i++) {
+				test_result |= packet_test ();
+				if (test_result != 0)
+					break;
+        		}
+        	}
+		else if (phy_status == 0) {
+			printf ("PHY FAIL: Please Check If you are using LOOP BACK Connector\n");
+			test_result = 3;
+			return	test_result;
+		}
+
+        	if ((phy_status = MAC1_init (phy_id)) != 0) {
+        		for (i = 60; i < TX_BUFF_SZ; i++) {
+				test_result |= packet_length_test (i);
+        			if (test_result != 0)
+	        	    		break;
+        		}
+        	}
+		else if (phy_status == 0) {
+			printf ("PHY FAIL: Please Check If you are using LOOP BACK Connector\n");
+			test_result = 3;
+			return	test_result;
+		}        	
+        }	
+          
+	if ((phy_status == 0) && (test_result & PACKET_TEST_FAIL)) {
+		printf ("Packet Test FAIL !\n");
+	}
+	else if ((phy_status == 0) && (test_result & PACKET_LENGTH_TEST_FAIL)) {
+		printf ("Packet Length Test FAIL !\n");
+	}
+
+	SCU_MAC1_Enable(0);
+	return test_result;
+	
+}
+
+#endif /* CONFIG_SLT */
diff --git a/board/aspeed/ast2400/mactest.h b/board/aspeed/ast2400/mactest.h
new file mode 100755
index 0000000..e75b7bb
--- /dev/null
+++ b/board/aspeed/ast2400/mactest.h
@@ -0,0 +1,215 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* MACTest.h */
+
+// --------------------------------------------------------------------
+//              General Definition
+// --------------------------------------------------------------------
+#define MAC1_IO_BASE		0x1E660000
+#define PHY_LOOP		100000
+#define NUM_RX			48
+#define NUM_TX			48
+#define RX_BUFF_SZ		1514
+#define TX_BUFF_SZ		1514
+#define TOUT_LOOP		1000000
+#define ETH_ALEN		6
+#define POLL_DEMAND		1
+
+
+// --------------------------------------------------------------------
+//              MAC Register Index
+// --------------------------------------------------------------------
+#define ISR_REG			0x00				// interrups status register
+#define IER_REG			0x04				// interrupt maks register
+#define MAC_MADR_REG		0x08				// MAC address (Most significant)
+#define MAC_LADR_REG		0x0c				// MAC address (Least significant)
+#define MAHT0_REG		0x10				// Multicast Address Hash Table 0 register
+#define MAHT1_REG		0x14				// Multicast Address Hash Table 1 register
+#define TXPD_REG		0x18				// Transmit Poll Demand register
+#define RXPD_REG		0x1c				// Receive Poll Demand register
+#define TXR_BADR_REG		0x20				// Transmit Ring Base Address register
+#define RXR_BADR_REG		0x24				// Receive Ring Base Address register
+#define HPTXPD_REG		0x28
+#define HPTXR_BADR_REG		0x2c
+#define ITC_REG			0x30				// interrupt timer control register
+#define APTC_REG		0x34				// Automatic Polling Timer control register
+#define DBLAC_REG		0x38				// DMA Burst Length and Arbitration control register
+#define DMAFIFOS_REG		0x3c
+#define FEAR_REG		0x44
+#define TPAFCR_REG		0x48
+#define RBSR_REG		0x4c
+#define MACCR_REG		0x50				// MAC control register
+#define MACSR_REG		0x54				// MAC status register
+#define PHYCR_REG		0x60				// PHY control register
+#define PHYDATA_REG		0x64				// PHY Write Data register
+
+// --------------------------------------------------------------------
+//		PHYCR_REG
+// --------------------------------------------------------------------
+#define PHY_RE_AUTO_bit			(1UL<<9)
+#define PHY_READ_bit			(1UL<<26)
+#define PHY_WRITE_bit			(1UL<<27)
+// --------------------------------------------------------------------
+//		PHYCR_REG 
+// --------------------------------------------------------------------
+#define PHY_AUTO_OK_bit			(1UL<<5)
+// --------------------------------------------------------------------
+//		PHY INT_STAT_REG 
+// --------------------------------------------------------------------
+#define PHY_SPEED_CHG_bit		(1UL<<14)
+#define PHY_DUPLEX_CHG_bit		(1UL<<13)
+#define PHY_LINK_CHG_bit		(1UL<<10)
+#define PHY_AUTO_COMP_bit		(1UL<<11)
+// --------------------------------------------------------------------
+//		PHY SPE_STAT_REG 
+// --------------------------------------------------------------------
+#define PHY_RESOLVED_bit		(1UL<<11)
+#define PHY_LINK_bit			(1UL<<10)
+#define PHY_SPEED_mask			0xC000
+#define PHY_SPEED_10M			0x0
+#define PHY_SPEED_100M			0x1
+#define PHY_SPEED_1G			0x2
+#define PHY_DUPLEX_mask                 0x2000
+#define PHY_SPEED_DUPLEX_MASK           0x01E0
+#define PHY_100M_DUPLEX                 0x0100
+#define PHY_100M_HALF                   0x0080
+#define PHY_10M_DUPLEX                  0x0040
+#define PHY_10M_HALF                    0x0020
+#define LINK_STATUS                     0x04
+#define PHYID_VENDOR_MASK		0xfffffc00
+#define PHYID_VENDOR_MARVELL		0x01410c00
+#define PHYID_VENDOR_BROADCOM		0x00406000
+#define PHYID_VENDOR_RTL8201E		0x001cc800
+#define DUPLEX_FULL			0x01
+#define DUPLEX_HALF			0x00
+
+
+
+// --------------------------------------------------------------------
+//		MACCR_REG
+// --------------------------------------------------------------------
+
+#define SW_RST_bit		(1UL<<31)				// software reset/
+#define DIRPATH_bit		(1UL<<21)
+#define RX_IPCS_FAIL_bit	(1UL<<20)
+#define SPEED_100M_MODE_bit		(1UL<<19)
+#define RX_UDPCS_FAIL_bit	(1UL<<18)
+#define RX_BROADPKT_bit		(1UL<<17)				// Receiving broadcast packet
+#define RX_MULTIPKT_bit		(1UL<<16)				// receiving multicast packet
+#define RX_HT_EN_bit		(1UL<<15)
+#define RX_ALLADR_bit		(1UL<<14)				// not check incoming packet's destination address
+#define JUMBO_LF_bit		(1UL<<13)
+#define RX_RUNT_bit		(1UL<<12)				// Store incoming packet even its length is les than 64 byte
+#define CRC_CHK_bit		(1UL<<11)
+#define CRC_APD_bit		(1UL<<10)				// append crc to transmit packet
+#define GMAC_MODE_bit		(1UL<<9)
+#define FULLDUP_bit		(1UL<<8)				// full duplex
+#define ENRX_IN_HALFTX_bit	(1UL<<7)
+#define LOOP_EN_bit		(1UL<<6)				// Internal loop-back
+#define HPTXR_EN_bit		(1UL<<5)
+#define REMOVE_VLAN_bit		(1UL<<4)
+#define RXMAC_EN_bit		(1UL<<3)				// receiver enable
+#define TXMAC_EN_bit		(1UL<<2)				// transmitter enable
+#define RXDMA_EN_bit		(1UL<<1)				// enable DMA receiving channel
+#define TXDMA_EN_bit		(1UL<<0)				// enable DMA transmitting channel
+
+
+// --------------------------------------------------------------------
+//		SCU_REG
+// --------------------------------------------------------------------
+#define  SCU_BASE			0x1E6E2000
+#define  SCU_PROTECT_KEY_REG            0x0
+#define  SCU_PROT_KEY_MAGIC             0x1688a8a8
+#define  SCU_RESET_CONTROL_REG          0x04
+#define  SCU_RESET_MAC1                 (1u << 11)
+#define  SCU_RESET_MAC2                 (1u << 12)
+#define  SCU_HARDWARE_TRAPPING_REG      0x70
+#define  SCU_HT_MAC_INTF_LSBIT          6
+#define  SCU_HT_MAC_INTERFACE           (0x7u << SCU_HT_MAC_INTF_LSBIT)
+#define  MAC_INTF_SINGLE_PORT_MODES     (1u<<0/*GMII*/ | 1u<<3/*MII_ONLY*/ | 1u<<4/*RMII_ONLY*/)
+#define  SCU_HT_MAC_GMII                0x0u
+// MII and MII mode
+#define  SCU_HT_MAC_MII_MII             0x1u
+#define  SCU_HT_MAC_MII_ONLY            0x3u
+#define  SCU_HT_MAC_RMII_ONLY           0x4u
+#define  SCU_MULTIFUNCTION_PIN_REG      0x74
+#define  SCU_MFP_MAC2_PHYLINK           (1u << 26)
+#define  SCU_MFP_MAC1_PHYLINK           (1u << 25)
+#define  SCU_MFP_MAC2_MII_INTF          (1u << 21)
+#define  SCU_MFP_MAC2_MDC_MDIO          (1u << 20)
+#define  SCU_SILICON_REVISION_REG       0x7C
+
+//---------------------------------------------------
+//  PHY R/W Register Bit
+//---------------------------------------------------
+#define MIIWR                   (1UL<<27)
+#define MIIRD                   (1UL<<26)
+#define MDC_CYCTHR              0x34
+#define PHY_SPEED_MASK          0xC000
+#define PHY_DUPLEX_MASK         0x2000
+#define SPEED_1000M             0x02
+#define SPEED_100M              0x01
+#define SPEED_10M               0x00
+#define DUPLEX_FULL             0x01
+#define DUPLEX_HALF             0x00
+#define RESOLVED_BIT            0x800
+
+#define PHY_SPEED_DUPLEX_MASK   0x01E0
+#define PHY_100M_DUPLEX         0x0100
+#define PHY_100M_HALF           0x0080
+#define PHY_10M_DUPLEX          0x0040
+#define PHY_10M_HALF            0x0020
+
+//---------------------------------------------------
+// Descriptor bits.
+//---------------------------------------------------
+#define TXDMA_OWN	0x80000000	/* Own Bit */
+#define RXPKT_RDY       0x00000000      
+#define RXPKT_STATUS    0x80000000
+#define EDORR		0x40000000	/* Receive End Of Ring */
+#define LRS		0x10000000	/* Last Descriptor */
+#define RD_ES		0x00008000	/* Error Summary */
+#define EDOTR		0x40000000	/* Transmit End Of Ring */
+#define T_OWN		0x80000000	/* Own Bit */
+#define LTS		0x10000000	/* Last Segment */
+#define FTS		0x20000000	/* First Segment */
+#define CRC_ERR         0x00080000
+#define TD_ES		0x00008000	/* Error Summary */
+#define TD_SET		0x08000000	/* Setup Packet */
+#define RX_ERR          0x00040000
+#define FTL             0x00100000
+#define RUNT            0x00200000
+#define RX_ODD_NB       0x00400000
+#define BYTE_COUNT_MASK 0x00003FFF
+
+//---------------------------------------------------
+// SPEED/DUPLEX Parameters
+//---------------------------------------------------
+
+//---------------------------------------------------
+// Return Status
+//---------------------------------------------------
+#define TEST_PASS			0
+#define PACKET_TEST_FAIL		1
+#define PACKET_LENGTH_TEST_FAIL		2
+
+struct  mac_desc {
+	volatile s32 status;
+	u32 des1;
+	u32 reserved;
+	u32 buf;	
+};
+static struct mac_desc rx_ring[NUM_RX] __attribute__ ((aligned(32))); /* RX descriptor ring         */
+static struct mac_desc tx_ring[NUM_TX] __attribute__ ((aligned(32))); /* TX descriptor ring         */
+static int rx_new;                             /* RX descriptor ring pointer */
+static int tx_new;                             /* TX descriptor ring pointer */
+static volatile unsigned char rx_buffer[NUM_RX][RX_BUFF_SZ] __attribute__ ((aligned(32))); /* RX buffer         */
+static volatile unsigned char tx_buffer[NUM_TX][TX_BUFF_SZ] __attribute__ ((aligned(32))); /* TX buffer         */
diff --git a/board/aspeed/ast2400/mictest.c b/board/aspeed/ast2400/mictest.c
new file mode 100755
index 0000000..1b2b342
--- /dev/null
+++ b/board/aspeed/ast2400/mictest.c
@@ -0,0 +1,146 @@
+/*
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Diagnostics support
+ */
+#include <common.h>
+#include <command.h>
+#include <post.h>
+#include "slt.h"
+
+#if ((CFG_CMD_SLT & CFG_CMD_MICTEST) && defined(CONFIG_SLT))
+#include "mictest.h"
+
+static unsigned char ctrlbuf[MIC_MAX_CTRL];
+static unsigned char chksumbuf[MIC_MAX_CHKSUM];
+
+void vInitSCU(void)
+{
+    unsigned long ulData;
+
+    *(unsigned long *) (0x1e6e2000) = 0x1688A8A8;
+
+    udelay(100);
+
+    ulData = *(unsigned long *) (0x1e6e2004);
+    ulData &= 0xbffff;
+    *(unsigned long *) (0x1e6e2004) = ulData;
+         	
+}
+
+void vInitMIC(void)
+{
+    unsigned long i, j, ulPageNumber;
+    unsigned char *pjctrl, *pjsum;
+    
+    ulPageNumber = DRAMSIZE >> 12;	
+
+    pjctrl = (unsigned char *)(m16byteAlignment((unsigned long) ctrlbuf));
+    pjsum = (unsigned char *)(m16byteAlignment((unsigned long) chksumbuf));
+    
+    /* init ctrl buffer (2bits for one page) */
+    for (i=0; i< (ulPageNumber/4); i++)
+        *(unsigned char *) (pjctrl + i) = DEFAULT_CTRL;
+      
+    /* init chksum buf (4bytes for one page) */
+    for (i=0; i<ulPageNumber; i++)
+        *(unsigned long *) (pjsum + i*4) = DEFAULT_CHKSUM;
+    
+    *(unsigned long *) (MIC_BASE + MIC_CTRLBUFF_REG)   = (unsigned long) pjctrl;
+    *(unsigned long *) (MIC_BASE + MIC_CHKSUMBUF_REG)  = (unsigned long) pjsum;
+    *(unsigned long *) (MIC_BASE + MIC_RATECTRL_REG)   = (unsigned long) DEFAULT_RATE;
+    *(unsigned long *) (MIC_BASE + MIC_ENGINECTRL_REG) = MIC_ENABLE_MIC | (DRAMSIZE - 0x1000);
+	
+}
+
+void vDisableMIC(void)
+{
+    *(unsigned long *) (MIC_BASE + MIC_ENGINECTRL_REG)   = MIC_RESET_MIC;
+	
+}
+
+int do_chksum(void)
+{
+    unsigned long i, j, k, ulPageNumber;
+    int Status = 0;
+    unsigned short tmp;
+    volatile unsigned long sum1, sum2;
+    unsigned long goldensum, chksum;
+    unsigned long len, tlen;
+    unsigned char *pjsum;
+
+    ulPageNumber = DRAMSIZE >> 12;	
+    pjsum = (unsigned char *)(m16byteAlignment((unsigned long) chksumbuf));
+
+    /* start test */    
+    for (i=0; i<ulPageNumber; i++)
+    {
+    	
+    	sum1 = 0xffff, sum2 = 0xffff;
+    	len = 0x0800;
+    	j = 0;
+    	
+    	while (len)
+    	{
+    	    tlen = len > 360 ? 360 : len;
+    	    len -= tlen;
+    	    do {
+    	       tmp = *(unsigned short *) (DRAM_BASE + ((i << 12) + j));	
+               sum1 += (unsigned long) tmp;   	    	
+    	       sum2 += sum1;
+    	       j+=2;
+    	    } while (--tlen);
+    	    sum1 = (sum1 & 0xffff) + (sum1 >> 16);
+    	    sum2 = (sum2 & 0xffff) + (sum2 >> 16);   	        	
+    	}
+    	
+    	sum1 = (sum1 & 0xffff) + (sum1 >> 16);
+    	sum2 = (sum2 & 0xffff) + (sum2 >> 16);
+    	
+    	goldensum = (sum2 << 16) | sum1;
+        k= 0;
+        do {
+            chksum = *(unsigned long *) (pjsum + i*4);
+            udelay(100);
+            k++;
+    	} while ((chksum == 0) && (k<1000));
+    	
+    	if (chksum != goldensum)
+    	{
+    	        Status = 1;	
+                printf("[FAIL] MIC Chksum Failed at Page %x \n", i);
+    	}
+
+    } /* end of i loop */
+		
+    return (Status);
+    	
+}
+
+int do_mictest (void)
+{
+        unsigned long Flags = 0;
+
+        vInitSCU();
+        vInitMIC();
+        
+        if (do_chksum())
+            Flags = 1;
+            
+        vDisableMIC();
+        
+	return Flags;
+	
+}
+
+#endif /* CONFIG_SLT */
diff --git a/board/aspeed/ast2400/mictest.h b/board/aspeed/ast2400/mictest.h
new file mode 100755
index 0000000..e14bb41
--- /dev/null
+++ b/board/aspeed/ast2400/mictest.h
@@ -0,0 +1,55 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* Macro */
+#define m08byteAlignment(x)		((x + 0x00000007) & 0xFFFFFFF8)
+#define m16byteAlignment(x)		((x + 0x0000000F) & 0xFFFFFFF0)
+#define m64byteAlignment(x)		((x + 0x0000003F) & 0xFFFFFFC0)
+
+/* Options */
+#define MIC_TEST_PAGE		32
+#define DRAMSIZE		(MIC_TEST_PAGE * 0x1000)
+#define MIC_MAX_CTRL		(MIC_TEST_PAGE / 4 + 16)
+#define MIC_MAX_CHKSUM		(MIC_TEST_PAGE * 4 + 16)
+
+/* Default Setting */
+#define DEFAULT_RATE		0x00000000
+#define DEFAULT_CTRL		0xFF
+#define DEFAULT_CHKSUM		0x00000000
+#define DEFAULT_WRITEBACK	0x08880000
+
+/* Reg. Definition */
+#define DRAM_BASE		0x40000000
+#define MIC_BASE		0x1e640000
+#define MIC_CTRLBUFF_REG	0x00
+#define MIC_CHKSUMBUF_REG	0x04
+#define MIC_RATECTRL_REG	0x08
+#define MIC_ENGINECTRL_REG	0x0C
+#define MIC_STOPPAGE_REG	0x10
+#define MIC_STATUS_REG		0x14
+#define MIC_STATUS1_REG		0x18
+#define MIC_STATUS2_REG		0x1C
+
+#define MIC_RESET_MIC		0x00000000
+#define MIC_ENABLE_MIC		0x10000000
+#define MIC_MAXPAGE_MASK	0x0FFFF000
+#define MIC_WRITEBACK_MASK	0xFFFF0000
+#define MIC_STOPPAGE_MASK	0x0000FFFF
+#define MIC_PAGEERROR		0x40000000
+#define MIC_PAGE1ERROR		0x10000000
+#define MIC_PAGE2ERROR		0x20000000
+#define MIC_INTMASK		0x00060000
+#define MIC_ERRPAGENO_MASK	0x0000FFFF
+
+#define MIC_CTRL_MASK		0x03
+#define MIC_CTRL_SKIP		0x00
+#define MIC_CTRL_CHK1		0x01
+#define MIC_CTRL_CHK2		0x02
+#define MIC_CTRL_CHK3		0x03
diff --git a/board/aspeed/ast2400/pci.c b/board/aspeed/ast2400/pci.c
new file mode 100755
index 0000000..5b17466
--- /dev/null
+++ b/board/aspeed/ast2400/pci.c
@@ -0,0 +1,243 @@
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2, or (at
+ * your option) any later version.
+ */
+
+#include <common.h>
+#include <pci.h>
+
+#ifdef CONFIG_PCI
+
+#define PCI_CSR_BASE		0x60000000
+#define ASPEED_PCI_IO_BASE	0x00000000
+#define ASPEED_PCI_IO_SIZE	0x00010000
+#define ASPEED_PCI_MEM_BASE	0x68000000
+#define ASPEED_PCI_MEM_SIZE	0x18000000
+
+#define CSR_CRP_CMD_OFFSET	0x00
+#define CSR_CRP_WRITE_OFFSET    0x04
+#define CSR_CRP_READ_OFFSET	0x08
+#define CSR_PCI_ADDR_OFFSET	0x0C
+#define CSR_PCI_CMD_OFFSET	0x10
+#define CSR_PCI_WRITE_OFFSET	0x14
+#define CSR_PCI_READ_OFFSET	0x18
+#define CSR_PCI_STATUS_OFFSET	0x1C
+
+#define CRP_ADDR_REG		(volatile ulong*) (PCI_CSR_BASE + CSR_CRP_CMD_OFFSET)
+#define CRP_WRITE_REG		(volatile ulong*) (PCI_CSR_BASE + CSR_CRP_WRITE_OFFSET)
+#define CRP_READ_REG		(volatile ulong*) (PCI_CSR_BASE + CSR_CRP_READ_OFFSET)
+#define PCI_ADDR_REG		(volatile ulong*) (PCI_CSR_BASE + CSR_PCI_ADDR_OFFSET)
+#define PCI_CMD_REG		(volatile ulong*) (PCI_CSR_BASE + CSR_PCI_CMD_OFFSET)
+#define PCI_WRITE_REG		(volatile ulong*) (PCI_CSR_BASE + CSR_PCI_WRITE_OFFSET)
+#define PCI_READ_REG		(volatile ulong*) (PCI_CSR_BASE + CSR_PCI_READ_OFFSET)
+
+#define PCI_CMD_READ		0x0A
+#define PCI_CMD_WRITE		0x0B
+
+#define RESET_PCI_STATUS        *(volatile ulong*) (PCI_CSR_BASE + CSR_PCI_STATUS_OFFSET) = 0x01
+#define CHK_PCI_STATUS          (*(volatile ulong*) (PCI_CSR_BASE + CSR_PCI_STATUS_OFFSET) & 0x03)
+
+static int pci_config_access (u8 access_type, u32 dev, u32 reg, u32 * data)
+{
+	u32 bus;
+	u32 device;
+	u32 function;
+
+	bus = ((dev & 0xff0000) >> 16);
+	device = ((dev & 0xf800) >> 11);
+	function = (dev & 0x0700);
+
+	if (bus == 0) {
+		// Type 0 Configuration 		
+		*PCI_ADDR_REG = (u32) (1UL << device | function | (reg & 0xfc));
+	} else {
+		// Type 1 Configuration 
+		*PCI_ADDR_REG = (u32) (dev | ((reg / 4) << 2) | 1);
+	}
+
+        RESET_PCI_STATUS;
+        
+	if (access_type == PCI_CMD_WRITE) {
+		*PCI_CMD_REG = (ulong) PCI_CMD_WRITE;
+		*PCI_WRITE_REG = *data;
+	} else {
+		*PCI_CMD_REG = (ulong) PCI_CMD_READ;		
+		*data = *PCI_READ_REG;
+	}
+            
+	return (CHK_PCI_STATUS);
+}
+
+static int aspeed_pci_read_config_byte (u32 hose, u32 dev, u32 reg, u8 * val)
+{
+	u32 data;
+
+	if (pci_config_access (PCI_CMD_READ, dev, reg, &data)) {
+		*val = 0;
+		return -1;
+	}	
+
+	*val = (data >> ((reg & 3) << 3)) & 0xff;
+
+	return 0;
+}
+
+
+static int aspeed_pci_read_config_word (u32 hose, u32 dev, u32 reg, u16 * val)
+{
+	u32 data;
+
+	if (reg & 1)
+		return -1;
+
+	if (pci_config_access (PCI_CMD_READ, dev, reg, &data)) {
+		*val = 0;
+		return -1;
+	} 		
+
+	*val = (data >> ((reg & 3) << 3)) & 0xffff;
+
+	return 0;
+}
+
+
+static int aspeed_pci_read_config_dword (u32 hose, u32 dev, u32 reg,
+					 u32 * val)
+{
+	u32 data = 0;
+
+	if (reg & 3)
+		return -1;
+
+	if (pci_config_access (PCI_CMD_READ, dev, reg, &data))	{
+		*val = 0;
+		return -1;
+	}		
+
+	*val = data;
+
+	return (0);
+}
+
+static int aspeed_pci_write_config_byte (u32 hose, u32 dev, u32 reg, u8 val)
+{
+	u32 data = 0;
+
+	if (pci_config_access (PCI_CMD_READ, dev, reg, &data))
+		return -1;
+
+	data = (data & ~(0xff << ((reg & 3) << 3))) | (val <<
+						       ((reg & 3) << 3));
+
+	if (pci_config_access (PCI_CMD_WRITE, dev, reg, &data))
+		return -1;
+
+	return 0;
+}
+
+
+static int aspeed_pci_write_config_word (u32 hose, u32 dev, u32 reg, u16 val)
+{
+	u32 data = 0;
+
+	if (reg & 1)
+		return -1;
+
+	if (pci_config_access (PCI_CMD_READ, dev, reg, &data))
+		return -1;
+
+	data = (data & ~(0xffff << ((reg & 3) << 3))) | (val <<
+							 ((reg & 3) << 3));
+
+	if (pci_config_access (PCI_CMD_WRITE, dev, reg, &data))
+		return -1;
+
+	return 0;
+}
+
+static int aspeed_pci_write_config_dword (u32 hose, u32 dev, u32 reg, u32 val)
+{
+	u32 data;
+
+	if (reg & 3) {
+		return -1;
+	}
+
+	data = val;
+
+	if (pci_config_access (PCI_CMD_WRITE, dev, reg, &data))
+		return -1;
+
+	return (0);
+}
+
+/*
+ *	Initialize PCIU
+ */
+aspeed_pciu_init ()
+{
+
+    unsigned long reg;
+
+    /* Reset PCI Host */
+    reg = *((volatile ulong*) 0x1e6e2004);
+    *((volatile ulong*) 0x1e6e2004) = reg | 0x00280000;
+
+    reg = *((volatile ulong*) 0x1e6e2074);		/* REQ2 */    
+    *((volatile ulong*) 0x1e6e2074) = reg | 0x00000010;
+
+    *((volatile ulong*) 0x1e6e2008) |= 0x00080000;        
+    reg = *((volatile ulong*) 0x1e6e200c); 
+    *((volatile ulong*) 0x1e6e200c) = reg & 0xfff7ffff;
+    udelay(1); 
+    *((volatile ulong*) 0x1e6e2004) &= 0xfff7ffff;
+                 
+    /* Initial PCI Host */
+    RESET_PCI_STATUS;
+	
+    *CRP_ADDR_REG = ((ulong)(PCI_CMD_READ) << 16) | 0x04;
+    reg = *CRP_READ_REG;
+    
+    *CRP_ADDR_REG = ((ulong)(PCI_CMD_WRITE) << 16) | 0x04;
+    *CRP_WRITE_REG = reg | 0x07;
+   
+}
+
+/*
+ *	Initialize Module
+ */
+
+void aspeed_init_pci (struct pci_controller *hose)
+{
+	hose->first_busno = 0;
+	hose->last_busno = 0xff;
+
+	aspeed_pciu_init ();			/* Initialize PCIU */
+
+	/* PCI memory space #1 */
+	pci_set_region (hose->regions + 0,
+			ASPEED_PCI_MEM_BASE, ASPEED_PCI_MEM_BASE, ASPEED_PCI_MEM_SIZE, PCI_REGION_MEM);
+
+	/* PCI I/O space */
+	pci_set_region (hose->regions + 1,
+			ASPEED_PCI_IO_BASE, ASPEED_PCI_IO_BASE, ASPEED_PCI_IO_SIZE, PCI_REGION_IO);
+
+	hose->region_count = 2;
+
+	hose->read_byte   = aspeed_pci_read_config_byte;
+	hose->read_word   = aspeed_pci_read_config_word;
+	hose->read_dword  = aspeed_pci_read_config_dword;
+	hose->write_byte  = aspeed_pci_write_config_byte;
+	hose->write_word  = aspeed_pci_write_config_word;
+	hose->write_dword = aspeed_pci_write_config_dword;
+
+	pci_register_hose (hose);
+
+	hose->last_busno = pci_hose_scan (hose);
+
+	return;
+}
+#endif /* CONFIG_PCI */
+
diff --git a/board/aspeed/ast2400/platform.S b/board/aspeed/ast2400/platform.S
new file mode 100644
index 0000000..27e8f26
--- /dev/null
+++ b/board/aspeed/ast2400/platform.S
@@ -0,0 +1,3089 @@
+/*
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/*
+ * Board specific setup info
+ *
+ ******************************************************************************
+ * ASPEED Technology Inc.
+ * AST2300/AST2400 DDR2/DDR3 SDRAM controller initialization and calibration sequence
+ *
+ * Gary Hsu, <gary_hsu@aspeedtech.com>
+ *
+ * Release date: 2014.12.29 formal release for SDK0.60
+ *
+ * Modified list from v0.23
+ * EC1. Modify DQIDLY and DQSI-MCLK2X calibration algorithm
+ * EC2. Remove pass 2 DQIDLY finetune process
+ * EC3. Modify ECC code
+ * EC4. Add AST2400 supporting
+ * EC5. Add SPI timing calibration for AST2400
+ * EC6. Remove AST2300-A0 PCI-e workaround
+ * EC7. Add CK duty calibration for AST2400
+ * EC8. Remove #define CONFIG_DRAM_UART_OUT, default has message output to UART5
+ * EC9. Add DRAM size auto-detection
+ * EC10. Add GPIO register clear when watchdog reboot (only for AST2400)
+ * EC11. Move the "Solve ASPM" code position of AST2300 to avoid watchdog reset
+ *
+ * Modified list from v0.53
+ * EC1. Add solution of LPC lock issue due to watchdog reset. (AP note A2300-11)
+ *
+ * Modified list from v0.56
+ * EC1. Fix read DQS input mask window too late issue if DRAM's t_DQSCK is earlier too much
+ *      (ex. Nanya NT5CB64M16FP)
+ *      1. Change init value of MCR18[4] from '1' to '0'
+ *      2. Add CBR4 code to finetune MCR18[4]
+ *
+ * Modified list from v0.59
+ * EC1. Add DQS input gating window delay tuning (1/2 T) when CBR retry
+ * EC2. Modify DLL1 MAdj = 0x4C
+ *
+ * Optional define variable
+ * 1. DRAM Speed             //
+ *    CONFIG_DRAM_336        // 336MHz (DDR-667)
+ *    CONFIG_DRAM_408        // 408MHz (DDR-800) (default)
+ * 2. ECC Function enable
+ *    CONFIG_DRAM_ECC        // define to enable ECC function
+ *                           // when enabled, must define the ECC protected memory size at 0x1e6e0054
+ * 3. UART5 message output   //
+ *    CONFIG_DRAM_UART_38400 // set the UART baud rate to 38400, default is 115200
+ ******************************************************************************
+ */
+
+#include <config.h>
+#include <version.h>
+/******************************************************************************
+ Calibration Macro Start
+ Usable registers:
+  r0, r1, r2, r3, r5, r6, r7, r8, r9, r10, r11
+ ******************************************************************************/
+/* PATTERN_TABLE,
+   init_delay_timer,
+   check_delay_timer,
+   clear_delay_timer,
+   record_dll2_pass_range,
+   record_dll2_pass_range_h,
+   are for DRAM calibration */
+
+PATTERN_TABLE:
+    .word   0xff00ff00
+    .word   0xcc33cc33
+    .word   0xaa55aa55
+    .word   0x88778877
+    .word   0x92cc4d6e       @ 5
+    .word   0x543d3cde
+    .word   0xf1e843c7
+    .word   0x7c61d253
+    .word   0x00000000       @ 8
+
+    .macro init_delay_timer
+    ldr r0, =0x1e782024                          @ Set Timer3 Reload
+    str r2, [r0]
+
+    ldr r0, =0x1e6c0038                          @ Clear Timer3 ISR
+    ldr r1, =0x00040000
+    str r1, [r0]
+
+    ldr r0, =0x1e782030                          @ Enable Timer3
+    ldr r1, [r0]
+    mov r2, #7
+    orr r1, r1, r2, lsl #8
+    str r1, [r0]
+
+    ldr r0, =0x1e6c0090                          @ Check ISR for Timer3 timeout
+    .endm
+
+    .macro check_delay_timer
+    ldr r1, [r0]
+    bic r1, r1, #0xFFFBFFFF
+    mov r2, r1, lsr #18
+    cmp r2, #0x01
+    .endm
+
+    .macro clear_delay_timer
+    ldr r0, =0x1e782030                          @ Disable Timer3
+    ldr r1, [r0]
+    bic r1, r1, #0x00000F00
+    str r1, [r0]
+
+    ldr r0, =0x1e6c0038                          @ Clear Timer3 ISR
+    ldr r1, =0x00040000
+    str r1, [r0]
+    .endm
+
+    .macro record_dll2_pass_range
+    ldr                 r1, [r0]
+    bic                 r2, r1, #0xFFFFFF00
+    cmp                 r2, r3                   @ record min
+    bicgt               r1, r1, #0x000000FF
+    orrgt               r1, r1, r3
+    bic                 r2, r1, #0xFFFF00FF
+    cmp                 r3, r2, lsr #8           @ record max
+    bicgt               r1, r1, #0x0000FF00
+    orrgt               r1, r1, r3, lsl #8
+    str                 r1, [r0]
+    .endm
+
+    .macro record_dll2_pass_range_h
+    ldr                 r1, [r0]
+    bic                 r2, r1, #0xFF00FFFF
+    mov                 r2, r2, lsr #16
+    cmp                 r2, r3                   @ record min
+    bicgt               r1, r1, #0x00FF0000
+    orrgt               r1, r1, r3, lsl #16
+    bic                 r2, r1, #0x00FFFFFF
+    cmp                 r3, r2, lsr #24          @ record max
+    bicgt               r1, r1, #0xFF000000
+    orrgt               r1, r1, r3, lsl #24
+    str                 r1, [r0]
+    .endm
+
+    .macro init_spi_checksum
+    ldr r0, =0x1e620084
+    ldr r1, =0x20010000
+    str r1, [r0]
+    ldr r0, =0x1e62008C
+    ldr r1, =0x20000200
+    str r1, [r0]
+    ldr r0, =0x1e620080
+    ldr r1, =0x0000000D
+    orr r2, r2, r7
+    orr r1, r1, r2, lsl #8
+    and r2, r6, #0xF
+    orr r1, r1, r2, lsl #4
+    str r1, [r0]
+    ldr r0, =0x1e620008
+    ldr r2, =0x00000800
+    .endm
+
+/******************************************************************************
+ Calibration Macro End
+ ******************************************************************************/
+LPC_Patch:                                       @ load to SRAM base 0x1e720400
+    str   r1, [r0]
+    str   r3, [r2]
+    bic   r1, r1, #0xFF
+LPC_Patch_S1:
+    subs  r5, r5, #0x01
+    moveq pc, r8
+    ldr   r3, [r2]
+    tst   r3, #0x01
+    movne pc, r8
+    mov   pc, r7
+LPC_Patch_S2:                                    @ load to SRAM base 0x1e720480
+    str   r1, [r0]
+    mov   pc, r9
+LPC_Patch_E:
+
+.globl lowlevel_init
+lowlevel_init:
+
+init_dram:
+    /* save lr */
+    mov r4, lr
+/* Test - DRAM initial time */
+    ldr r0, =0x1e782044
+    ldr r1, =0xFFFFFFFF
+    str r1, [r0]
+
+    ldr r0, =0x1e782030
+    ldr r1, [r0]
+    bic r1, r1, #0x0000F000
+    str r1, [r0]
+    mov r2, #3
+    orr r1, r1, r2, lsl #12
+    str r1, [r0]
+/* Test - DRAM initial time */
+
+    /*Set Scratch register Bit 7 before initialize*/
+    ldr r0, =0x1e6e2000
+    ldr r1, =0x1688a8a8
+    str r1, [r0]
+
+    ldr r0, =0x1e6e2040
+    ldr r1, [r0]
+    orr r1, r1, #0x80
+    str r1, [r0]
+
+    /* Fix LPC lock issue for AST2300 */
+    ldr r0, =0x1e6e207c                          @ Check AST2300
+    ldr r1, [r0]
+    mov r1, r1, lsr #24
+    cmp r1, #0x01
+    bne lpc_recover_end                          @ not match AST2300
+
+    mov r3, #0x0
+lpc_recover_check:
+    ldr r0, =0x1e78900c                          @ check HICR3[4]=0x1
+    ldr r1, [r0]
+    tst r1, #0x10
+    beq lpc_recover_end
+    ldr r0, =0x1e789004                          @ check HICR1[7]=0x1
+    ldr r1, [r0]
+    tst r1, #0x80
+    beq lpc_recover_end
+    ldr r0, =0x1e7890a0                          @ check LHCR0[27:24]=0x6
+    ldr r1, [r0]
+    mov r1, r1, lsr #24
+    and r1, r1, #0xF
+    cmp r1, #0x06
+    bne lpc_recover_end
+    add r3, r3, #0x01
+    cmp r3, #0x5                                 @ repeat 5 times
+    ble lpc_recover_check
+
+    mov r3, #0x0
+lpc_recover_init:
+    ldr r0, =0x1e7890a4                          @ set LHCR1[1:0]=0x0
+    ldr r1, =0x00000000
+    str r1, [r0]
+    add r3, r3, #0x01
+    cmp r3, #0x20
+    bge lpc_recover_end
+    ldr r1, [r0]
+    tst r1, #0x01
+    bne lpc_recover_init
+
+    ldr r0, =0x1e7890b0                          @ set LHCR4[7:0]=0xFF
+    ldr r1, =0x000000FF
+    str r1, [r0]
+    ldr r0, =0x1e7890b4                          @ set LHCR5[31:0]=0xFFFFFFFF
+    ldr r1, =0xFFFFFFFF
+    str r1, [r0]
+    ldr r0, =0x1e7890b8                          @ set LHCR6[31:0]=0xFFFFFFFF
+    str r1, [r0]
+
+    adr r6, LPC_Patch
+    adr r7, LPC_Patch_S2
+    ldr r0, =0x1e720400
+copy_lpc_patch_1:
+    ldr r1, [r6]
+    str r1, [r0]
+    add r6, r6, #0x4
+    add r0, r0, #0x4
+    cmp r6, r7
+    bne copy_lpc_patch_1
+
+    adr r6, LPC_Patch_S2
+    adr r7, LPC_Patch_E
+    ldr r0, =0x1e720480
+copy_lpc_patch_2:
+    ldr r1, [r6]
+    str r1, [r0]
+    add r6, r6, #0x4
+    add r0, r0, #0x4
+    cmp r6, r7
+    bne copy_lpc_patch_2
+
+    ldr r0, =0x1e7890a0                          @ set LHCR0[31:0]=0xFFFFFF01
+    ldr r1, =0xFFFFFF01
+    add r2, r0, #0x4
+    mov r3, #0x01
+    mov r5, #0x10
+    adr r9, lpc_recover_end
+    adr r6, LPC_Patch
+    adr r7, LPC_Patch_S1
+    sub r6, r7, r6
+    ldr r7, =0x1e720400
+    add r7, r7, r6
+    ldr r8, =0x1e720480
+    ldr pc, =0x1e720400
+
+lpc_recover_end:
+    ldr r0, =0x1e7890a0                          @ set LHCR0[31:0]=0xFFFFFF00
+    ldr r1, =0xFFFFFF00
+    str r1, [r0]
+    /* <END> Fix LPC lock issue for AST2300 */
+
+    /* Check Scratch Register Bit 6 */
+    ldr r0, =0x1e6e2040
+    ldr r1, [r0]
+    bic r1, r1, #0xFFFFFFBF
+    mov r2, r1, lsr #6
+    cmp r2, #0x01
+    beq platform_exit
+
+    ldr r2, =0x033103F1                          @ load PLL parameter for 24Mhz CLKIN (396:324)
+/*  ldr r2, =0x019001F0                          @ load PLL parameter for 24Mhz CLKIN (408:336) */
+    ldr r0, =0x1e6e207c                          @ Check Revision ID
+    ldr r1, [r0]
+    mov r1, r1, lsr #24
+    cmp r1, #0x02
+    bne set_MPLL                                 @ not match AST2400
+
+    ldr r0, =0x1e6e2070                          @ Check CLKIN freq
+    ldr r1, [r0]
+    mov r1, r1, lsr #23
+    tst r1, #0x01
+    ldrne r2, =0x017001D0                        @ load PLL parameter for 25Mhz CLKIN (400:325)
+
+set_MPLL:
+    ldr r0, =0x1e6e2020                          @ M-PLL (DDR SDRAM) Frequency
+    ldr r1, =0xFFFF
+#if defined(CONFIG_DRAM_336)
+    mov r2, r2, lsr #16
+#endif
+    and r1, r2, r1
+    str r1, [r0]
+
+/* Debug - UART console message */
+    ldr r0, =0x1e78400c
+    mov r1, #0x83
+    str r1, [r0]
+
+    ldr r0, =0x1e6e202c
+    ldr r2, [r0]
+    mov r2, r2, lsr #12
+    tst r2, #0x01
+    ldr r0, =0x1e784000
+    moveq r1, #0x0D                              @ Baudrate 115200
+    movne r1, #0x01                              @ Baudrate 115200, div13
+#if defined(CONFIG_DRAM_UART_38400)
+    moveq r1, #0x27                              @ Baudrate 38400
+    movne r1, #0x03                              @ Baudrate 38400 , div13
+#endif
+    str r1, [r0]
+
+    ldr r0, =0x1e784004
+    mov r1, #0x00
+    str r1, [r0]
+
+    ldr r0, =0x1e78400c
+    mov r1, #0x03
+    str r1, [r0]
+
+    ldr r0, =0x1e784008
+    mov r1, #0x07
+    str r1, [r0]
+
+    ldr r0, =0x1e784000
+    mov r1, #0x0D                                @ '\r'
+    str r1, [r0]
+    mov r1, #0x0A                                @ '\n'
+    str r1, [r0]
+    mov r1, #0x44                                @ 'D'
+    str r1, [r0]
+    mov r1, #0x52                                @ 'R'
+    str r1, [r0]
+    mov r1, #0x41                                @ 'A'
+    str r1, [r0]
+    mov r1, #0x4D                                @ 'M'
+    str r1, [r0]
+    mov r1, #0x20                                @ ' '
+    str r1, [r0]
+    mov r1, #0x49                                @ 'I'
+    str r1, [r0]
+    mov r1, #0x6E                                @ 'n'
+    str r1, [r0]
+    mov r1, #0x69                                @ 'i'
+    str r1, [r0]
+    mov r1, #0x74                                @ 't'
+    str r1, [r0]
+    mov r1, #0x2D                                @ '-'
+    str r1, [r0]
+    mov r1, #0x44                                @ 'D'
+    str r1, [r0]
+    mov r1, #0x44                                @ 'D'
+    str r1, [r0]
+    mov r1, #0x52                                @ 'R'
+    str r1, [r0]
+/* Debug - UART console message */
+
+    /* Delay about 100us */
+    ldr r0, =0x1e782030                          @ Init Timer3 Control
+    ldr r1, [r0]
+    bic r1, r1, #0x00000F00
+    str r1, [r0]
+
+    ldr r2, =0x00000064                          @ Set Timer3 Reload = 100 us
+    init_delay_timer
+delay_0:
+    check_delay_timer
+    bne delay_0
+    clear_delay_timer
+    /* end delay 100us */
+
+/******************************************************************************
+ Init DRAM common registers
+ ******************************************************************************/
+    ldr r0, =0x1e6e0000
+    ldr r1, =0xfc600309
+    str r1, [r0]
+
+    /* Reset MMC */
+    ldr r1, =0x00000000
+    ldr r0, =0x1e6e0034
+    str r1, [r0]
+    ldr r0, =0x1e6e0018
+    str r1, [r0]
+    ldr r0, =0x1e6e0024
+    str r1, [r0]
+    ldr r0, =0x1e6e0064                          @ REG_MADJ, power down DLL
+    str r1, [r0]
+
+    ldr r1, =0x00034C4C                          @ REG_MADJ, reset DLL
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0068                          @ REG_SADJ
+    ldr r1, =0x00001800
+    str r1, [r0]
+
+    /* Delay about 10us */
+    ldr r2, =0x0000000B                          @ Set Timer3 Reload = 10 us
+    init_delay_timer
+delay_1:
+    check_delay_timer
+    bne delay_1
+    clear_delay_timer
+    /* end delay 10us */
+
+    ldr r0, =0x1e6e0064                          @ REG_MADJ | 0xC0000, enable DLL
+    ldr r1, [r0]
+    ldr r2, =0xC0000
+    orr r1, r1, r2
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0008
+    ldr r1, =0x0090040f                          /* VGA */
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0018
+    ldr r1, =0x4000A120
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0018
+    ldr r1, =0x00000120
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0038
+    ldr r1, =0x00000000
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0040
+    ldr r1, =0xFF444444
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0044
+    ldr r1, =0x22222222
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0048
+    ldr r1, =0x22222222
+    str r1, [r0]
+
+    ldr r0, =0x1e6e004c
+    ldr r1, =0x22222222
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0050
+    ldr r1, =0x80000000
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0050
+    ldr r1, =0x00000000
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0054
+    ldr r1, =0x00000000
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0060                          @ REG_DRV
+    ldr r1, =0x000000FA                          @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr r1, =0x000000FA
+#endif
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0070
+    ldr r1, =0x00000000
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0074
+    ldr r1, =0x00000000
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0078
+    ldr r1, =0x00000000
+    str r1, [r0]
+
+    ldr r0, =0x1e6e007c
+    ldr r1, =0x00000000
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0080
+    ldr r1, =0x00000000
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0084
+    ldr r1, =0x00FFFFFF
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0088                          @ REG_DQIDLY
+    ldr r1, =0x00000089                          @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr r1, =0x00000074
+#endif
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0020                          @ REG_DQSIC
+    ldr r1, =0x000000E2                          @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr r1, =0x000000BA
+#endif
+    str r1, [r0]
+
+    /* Delay about 10us */
+    ldr r2, =0x0000000B                          @ Set Timer3 Reload = 10 us
+    init_delay_timer
+delay_2:
+    check_delay_timer
+    bne delay_2
+    clear_delay_timer
+    /* end delay 10us */
+
+    /* Check DRAM Type by H/W Trapping */
+    ldr r0, =0x1e6e2070
+    ldr r1, [r0]
+    bic r1, r1, #0xFEFFFFFF                      @ bit[24]=1 => DDR2
+    mov r2, r1, lsr #24
+    cmp r2, #0x01
+    beq ddr2_init
+    b   ddr3_init
+.LTORG
+
+/******************************************************************************
+ DDR3 Init
+
+ tRCD   = 15     ns
+ tRAS   = 37.5   ns
+ tRRD   = max(4 CK,10 ns)
+ tRP    = 15     ns
+ tRFC   = 110ns/1Gbit, 160ns/2Gbit, 300ns/4Gbit
+ tRTP   = max(4 CK,7.5 ns)
+ tWR    = 15     ns
+ tXSNR  = max(10 CK,200 ns)
+ tWTR   = max(4 CK,7.5 ns)
+ tFAW   = 50     ns
+ tMRD   = max(15 CK,20 ns)
+ ******************************************************************************/
+ddr3_init:
+/* Debug - UART console message */
+    ldr r0, =0x1e784000
+    mov r1, #0x33                                @ '3'
+    str r1, [r0]
+    mov r1, #0x0D                                @ '\r'
+    str r1, [r0]
+    mov r1, #0x0A                                @ '\n'
+    str r1, [r0]
+/* Debug - UART console message */
+
+    ldr r0, =0x1e6e0004
+    ldr r1, =0x00000531                          @ Default set to 1Gbit
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0010                          @ REG_AC1
+    ldr r1, =0x33302825                          @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr r1, =0x22202725
+#endif
+    str r1, [r0]
+
+    /* Check DRAM CL Timing by H/W Trapping */
+    ldr r0, =0x1e6e2070
+    ldr r1, [r0]
+    bic r1, r1, #0xF9FFFFFF
+    mov r2, r1, lsr #9                           @ Set CL
+    ldr r1, =0x00020000
+    add r2, r2, r1
+    ldr r1, [r0]
+    bic r1, r1, #0xFBFFFFFF
+    mov r1, r1, lsr #6                           @ Set CWL
+    orr r2, r2, r1
+    ldr r1, =0x00300000
+    add r2, r2, r1
+
+    ldr r0, =0x1e6e0014                          @ REG_AC2
+    ldr r1, =0xCC00963F                          @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr r1, =0xAA007636
+#endif
+    orr r1, r1, r2
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0004                          @ check 2400 mode
+    ldr r2, [r0]
+    mov r2, r2, lsr #10
+
+    ldr r0, =0x1e6e006c                          @ REG_IOZ
+    ldr r1, =0x00002312                          @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr r1, =0x00002312
+#endif
+    tst r2, #0x01
+    moveq r1, r1, lsr #8
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0120
+    mov r1, #0
+    str r1, [r0]
+    tst r2, #0x01                                @ check AST2300
+    beq CBRDLL1_2300_Start
+    ldr r0, =0x1e6e207c                          @ check AST2400 revision A0
+    ldr r1, [r0]
+    mov r1, r1, lsr #16
+    and r1, r1, #0xFF
+    cmp r1, #0x0
+    beq CBRDLL1_2300_Start
+    b   CBRDLL1_2400_Start
+MCLK2X_Phase_CBR_Done_DDR3:
+    ldr r0, =0x1e6e0018
+    ldr r1, [r0]
+    orr r1, r1, #0x40
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0034
+    ldr r1, =0x00000001
+    str r1, [r0]
+
+    ldr r0, =0x1e6e000c
+    ldr r1, =0x00000040
+    str r1, [r0]
+
+    /* Delay about 400us */
+    ldr r2, =0x00000190                          @ Set Timer3 Reload = 400 us
+    init_delay_timer
+delay3_4:
+    check_delay_timer
+    bne delay3_4
+    clear_delay_timer
+    /* end delay 400us */
+
+    /* Check DRAM CL Timing by H/W Trapping */
+    ldr r0, =0x1e6e2070
+    ldr r1, [r0]
+    bic r1, r1, #0xF9FFFFFF
+    mov r2, r1, lsr #21                          @ Set CL
+    ldr r1, =0x00000010
+    add r2, r2, r1
+    ldr r1, [r0]
+    bic r1, r1, #0xFBFFFFFF
+    mov r1, r1, lsr #7                           @ Set CWL
+    orr r2, r2, r1
+
+    ldr r0, =0x1e6e002c                          @ REG_MRS
+    ldr r1, =0x04001700                          @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr r1, =0x04001500
+#endif
+    orr r1, r1, r2
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0030                          @ REG_EMRS
+    ldr r1, =0x00000000                          @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr r1, =0x00000000
+#endif
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0028                          @ Set EMRS2
+    ldr r1, =0x00000005
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0028                          @ Set EMRS3
+    ldr r1, =0x00000007
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0028                          @ Set EMRS
+    ldr r1, =0x00000003
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0028                          @ Set MRS
+    ldr r1, =0x00000001
+    str r1, [r0]
+
+    ldr r0, =0x1e6e002c                          @ REG_MRS
+    ldr r1, =0x04001600                          @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr r1, =0x04001400
+#endif
+    orr r1, r1, r2
+    str r1, [r0]
+
+    ldr r0, =0x1e6e000c                          @ Refresh 8 times
+    ldr r1, =0x00005C48
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0028                          @ Set MRS
+    ldr r1, =0x00000001
+    str r1, [r0]
+
+    ldr r0, =0x1e6e000c                          @ Set refresh cycle
+    ldr r1, =0x00002001
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0014
+    ldr r1, [r0]
+    bic r1, r1, #0xFFF9FFFF
+    mov r2, r1, lsr #3                           @ get CL
+
+    ldr r0, =0x1e6e0034                          @ REG_PWC
+    ldr r1, =0x00000303                          @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr r1, =0x00000303
+#endif
+    orr r1, r1, r2
+    str r1, [r0]
+
+    b   Calibration_Start
+.LTORG
+/******************************************************************************
+ End DDR3 Init
+ ******************************************************************************/
+
+/******************************************************************************
+ DDR2 Init
+
+ tRCD   = 15    ns
+ tRAS   = 45    ns
+ tRRD   = 10    ns
+ tRP    = 15    ns
+ tRFC   = 105ns/512Mbit, 127.5ns/1Gbit, 197.5ns/2Gbit, 327.5ns/4Gbit
+ tRTP   = 7.5   ns
+ tWR    = 15    ns
+ tXSNR  = 200   ns
+ tWTR   = 7.5   ns
+ tFAW   = 50    ns
+ tMRD   = 4     CK
+ ******************************************************************************/
+ddr2_init:
+/* Debug - UART console message */
+    ldr r0, =0x1e784000
+    mov r1, #0x32                                @ '2'
+    str r1, [r0]
+    mov r1, #0x0D                                @ '\r'
+    str r1, [r0]
+    mov r1, #0x0A                                @ '\n'
+    str r1, [r0]
+/* Debug - UART console message */
+
+    ldr r0, =0x1e6e0004
+    ldr r1, =0x00000510                          @ Default set to 512Mbit
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0010                          @ REG_AC1
+    ldr r1, =0x33302714                          @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr r1, =0x22201613
+#endif
+    str r1, [r0]
+
+    /* Check DRAM CL Timing by H/W Trapping */
+    ldr r0, =0x1e6e2070
+    ldr r1, [r0]
+    bic r1, r1, #0xF9FFFFFF
+    mov r2, r1, lsr #5                           @ Set CL
+    mov r1, r2, lsr #4                           @ Set CWL
+    orr r2, r2, r1
+    ldr r1, =0x00110000
+    add r2, r2, r1
+
+    ldr r0, =0x1e6e0014                          @ REG_AC2
+    ldr r1, =0xCC00B03F                          @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr r1, =0xAA00903B
+#endif
+    orr r1, r1, r2
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0004                          @ check 2400 mode
+    ldr r2, [r0]
+    mov r2, r2, lsr #10
+
+    ldr r0, =0x1e6e006c                          @ REG_IOZ
+    ldr r1, =0x00002312                          @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr r1, =0x00002312
+#endif
+    tst r2, #0x01
+    moveq r1, r1, lsr #8
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0120
+    mov r1, #1
+    str r1, [r0]
+    tst r2, #0x01                                @ check AST2300
+    beq CBRDLL1_2300_Start
+    ldr r0, =0x1e6e207c                          @ check AST2400 revision A0
+    ldr r1, [r0]
+    mov r1, r1, lsr #16
+    and r1, r1, #0xFF
+    cmp r1, #0x0
+    beq CBRDLL1_2300_Start
+    b   CBRDLL1_2400_Start
+MCLK2X_Phase_CBR_Done_DDR2:
+
+    ldr r0, =0x1e6e0034
+    ldr r1, =0x00000001
+    str r1, [r0]
+
+    ldr r0, =0x1e6e000c
+    ldr r1, =0x00000000
+    str r1, [r0]
+
+    /* Delay about 400us */
+    ldr r2, =0x00000190                          @ Set Timer3 Reload = 400 us
+    init_delay_timer
+delay2_4:
+    check_delay_timer
+    bne delay2_4
+    clear_delay_timer
+    /* end delay 400us */
+
+    /* Check DRAM CL Timing by H/W Trapping */
+    ldr r0, =0x1e6e2070
+    ldr r1, [r0]
+    bic r1, r1, #0xF9FFFFFF
+    mov r2, r1, lsr #21                          @ Set CL
+    ldr r1, =0x00000040
+    orr r2, r2, r1
+
+    ldr r0, =0x1e6e002c                          @ REG_MRS
+    ldr r1, =0x00000D03                          @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr r1, =0x00000B03
+#endif
+    orr r1, r1, r2
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0030                          @ REG_EMRS
+    ldr r1, =0x00000040                          @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr r1, =0x00000040
+#endif
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0028                          @ Set EMRS2
+    ldr r1, =0x00000005
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0028                          @ Set EMRS3
+    ldr r1, =0x00000007
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0028                          @ Set EMRS
+    ldr r1, =0x00000003
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0028                          @ Set MRS
+    ldr r1, =0x00000001
+    str r1, [r0]
+
+    ldr r0, =0x1e6e000c                          @ Refresh 8 times
+    ldr r1, =0x00005C08
+    str r1, [r0]
+
+    ldr r0, =0x1e6e002c                          @ REG_MRS
+    ldr r1, =0x00000C03                          @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr r1, =0x00000A03
+#endif
+    orr r1, r1, r2
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0028                          @ Set MRS
+    ldr r1, =0x00000001
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0030                          @ REG_EMRS
+    ldr r1, =0x000003C0                          @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr r1, =0x000003C0
+#endif
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0028                          @ Set EMRS
+    ldr r1, =0x00000003
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0030                          @ REG_EMRS
+    ldr r1, =0x00000040                          @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr r1, =0x00000040
+#endif
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0028                          @ Set EMRS
+    ldr r1, =0x00000003
+    str r1, [r0]
+
+    ldr r0, =0x1e6e000c                          @ Set refresh cycle
+    ldr r1, =0x00002001
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0014
+    ldr r1, [r0]
+    bic r1, r1, #0xFFF9FFFF
+    mov r2, r1, lsr #3                           @ get CL
+
+    ldr r0, =0x1e6e0034                          @ REG_PWC
+    ldr r1, =0x00000503                          @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr r1, =0x00000503
+#endif
+    orr r1, r1, r2
+    str r1, [r0]
+
+    b   Calibration_Start
+.LTORG
+/******************************************************************************
+ End DDR2 Init
+ ******************************************************************************/
+/******************************************************************************
+ DDR CK duty finetune program
+    SRAM buffer definition
+    0x1E720204 : gdll     golden DLL1 record
+    0x1E720208 : gduty    golden duty setting record
+    0x1E72020C : gdutysum golden duty data record
+    0x1E720210 : duty record of delay 0  invert
+    0x1E720214 : duty record of delay 1  invert
+    ....
+    0x1E72024C : duty record of delay 15 invert
+    0x1E720250 : duty record of delay 0
+    0x1E720254 : duty record of delay 1
+    ....
+    0x1E72028C : duty record of delay 15
+
+    Register usage
+    r0 - r3 = free
+    r4  = record the return pc value, do not use
+    r5  = free
+    r6  = free
+    r7  = duty count
+    r8  = gdll
+    r9  = gduty
+    r10 = gdutysum
+ ******************************************************************************/
+CBRDLL1_2400_Start:
+    ldr   r0, =0x1e6e0120
+    ldr   r1, [r0]
+    orr   r1, r1, #0x02
+    str   r1, [r0]
+
+    ldr   r1, =0x00000000
+    ldr   r0, =0x1e720204
+    ldr   r2, =0x1e7202a0
+init_sram_start0:
+    str   r1, [r0]
+    add   r0, r0, #4
+    cmp   r0, r2
+    blt   init_sram_start0
+
+    ldr   r0, =0x1e6e0034
+    mov   r1, #0x20
+    str   r1, [r0]
+
+    ldr   r0, =0x1e6e0060
+    ldr   r1, [r0]
+    mov   r2, #0x01
+    orr   r1, r1, r2, lsl #13
+    str   r1, [r0]
+
+    mov   r7, #0x0                               @ init duty count
+    mov   r8, #0x0                               @ init gdll
+    mov   r9, #0x0                               @ init gduty
+    mov   r10, #0x0                              @ init gdutysum
+cbrdll1_duty_start:
+    cmp   r7, #32
+    bge   cbrdll1_duty_end
+
+    ldr   r0, =0x1e6e0018
+    ldr   r1, =0x00008120
+    str   r1, [r0]
+
+    ldr   r0, =0x1e6e0060
+    ldr   r1, [r0]
+    bic   r1, r1, #0x00001F00
+    orr   r1, r1, r7, lsl #8
+    mov   r2, #0x10
+    eor   r1, r1, r2, lsl #8
+    str   r1, [r0]
+
+    ldr   r0, =0x1e6e0000                        @ dummy read
+    ldr   r1, [r0]
+
+    b     CBRDLL1_2300_Start
+CBRDLL1_2400_Call:
+
+    mov   r5, #0x01                              @ init dqidly count
+    mov   r6, #0x00                              @ init duty sum
+cbrdll1_duty_cal_start:
+    cmp   r5, #0x05
+    bge   cbrdll1_duty_cal_end
+
+    ldr   r0, =0x1e6e0018
+    ldr   r1, =0x00200120
+    orr   r1, r1, r5, lsl #16
+    str   r1, [r0]
+
+    ldr   r0, =0x1e6e0000
+    ldr   r1, [r0]
+
+    ldr   r0, =0x1e6e0018
+    ldr   r1, [r0]
+    mov   r2, #0x10
+    orr   r1, r1, r2, lsl #24
+    str   r1, [r0]
+
+    ldr   r0, =0x1e6e0080
+    ldr   r1, =0x80000000                        @ init duty cal waiting
+cbrdll1_duty_cal_wait:
+    ldr   r2, [r0]
+    tst   r2, r1
+    beq   cbrdll1_duty_cal_wait
+
+    ldr   r0, =0x1e6e008c
+    ldr   r2, [r0]
+
+    ldr   r0, =0x1e720210
+    add   r0, r0, r7, lsl #2
+    str   r2, [r0]
+
+    ldr   r1, =0xFFFF
+    and   r3, r1, r2
+    cmp   r3, r1
+    moveq r2, r2, lsr #16
+    and   r3, r1, r2
+    add   r6, r6, r3
+    ldr   r1, =0xF000
+    cmp   r3, r1
+    blt   cbrdll1_duty_cal_end
+    add   r5, r5, #0x01
+    b     cbrdll1_duty_cal_start
+
+cbrdll1_duty_cal_end:
+    mov   r6, r6, lsr #2                         @ get dutysum
+    cmp   r6, r10                                @ check dutysum > gdutysum
+    ble   cbrdll1_duty_next
+    ldr   r0, =0x1e6e0068
+    ldr   r8, [r0]
+    eor   r9, r7, #0x10
+    mov   r10, r6
+
+cbrdll1_duty_next:
+    add   r7, r7, #0x01
+    cmp   r7, #16                                @ check duty >= 15
+    blt   cbrdll1_duty_start
+    ldr   r0, =0xFA00                            @ check gdutysum > 0xFA00
+    cmp   r10, r0
+    blt   cbrdll1_duty_start
+
+cbrdll1_duty_end:
+    ldr   r0, =0x1e6e0060
+    ldr   r1, [r0]
+    bic   r1, r1, #0x00001F00
+    orr   r1, r1, r9, lsl #8
+    str   r1, [r0]
+
+    ldr   r0, =0x1e6e0068
+    bic   r8, r8, #0xFF000000
+    bic   r8, r8, #0x00FF0000
+    str   r8, [r0]
+
+    ldr   r0, =0x1e720204                        @ record result
+    str   r8, [r0]
+    add   r0, r0, #0x04
+    str   r9, [r0]
+    add   r0, r0, #0x04
+    str   r10, [r0]
+
+    ldr   r0, =0x1e6e0018
+    ldr   r1, =0x00008120
+    str   r1, [r0]
+    ldr   r0, =0x1e6e0000                        @ dummy read
+    ldr   r1, [r0]
+    ldr   r0, =0x1e6e0018
+    ldr   r1, =0x00000120
+    str   r1, [r0]
+
+    ldr   r0, =0x1e6e0120
+    ldr   r1, [r0]
+    cmp   r1, #0x3
+    beq   MCLK2X_Phase_CBR_Done_DDR2
+    b     MCLK2X_Phase_CBR_Done_DDR3
+
+/******************************************************************************
+ MCLK2X lock to MCLK program
+  r0 - r3 = free
+  r5 = madjmax
+  r6 = dllend
+  0x1E720200 = 0x96cnt:failcnt:dllmax:dllmin
+ ******************************************************************************/
+CBRDLL1_2300_Start:
+    ldr   r0, =0x1e6e0064
+    ldr   r5, [r0]
+    and   r5, r5, #0xFF                          @ init madjmax
+    mov   r6, r5                                 @ init dllend
+
+    ldr   r1, =0x000000ff
+    ldr   r0, =0x1e720200
+    str   r1, [r0]                               @ init dllcnt2:dllmax:dllmin
+
+    mov   r3, #0x0                               @ init loop count
+cbrdll1_scan_start:
+    cmp   r3, r6
+    bge   cbrdll1_scan_end
+
+    ldr   r0, =0x1e6e0018
+    ldr   r1, =0x00008120
+    str   r1, [r0]
+
+    ldr   r0, =0x1e6e0068
+    mov   r1, r3
+    cmp   r1, r5
+    subge r1, r1, r5
+    str   r1, [r0]
+
+    ldr   r0, =0x1e6e0000                        @ dummy read
+    ldr   r1, [r0]
+
+    ldr   r0, =0x1e6e0018
+    ldr   r1, =0x00000120
+    str   r1, [r0]
+
+    ldr   r0, =0x1e6e0000                        @ dummy read
+    ldr   r1, [r0]
+    ldr   r0, =0x1e6e0000                        @ dummy read
+    ldr   r1, [r0]
+
+    ldr   r0, =0x1e6e001c
+    ldr   r1, [r0]
+    mov   r1, r1, lsr #16
+    and   r1, r1, #0xFF
+
+    and   r2, r1, #0x96
+    cmp   r2, #0x96
+    beq   cbrdll1_scan_pass                      @ if (mclk2x_phase & 0x96) == 0x96
+    ldr   r0, =0x1e720200
+    ldr   r1, [r0]
+    mov   r2, r1, lsr #8
+    ands  r2, r2, #0xFF                          @ get dllmax
+    beq   cbrdll1_scan_next                      @ if dllmax == 0
+    mov   r2, r1, lsr #16
+    and   r2, r2, #0xFF
+    add   r2, r2, #0x01
+    cmp   r2, #0x02
+    movge r6, r3
+    bic   r1, r1, #0x00FF0000
+    orr   r1, r1, r2, lsl #16
+    str   r1, [r0]
+    b     cbrdll1_scan_next
+
+cbrdll1_scan_pass:
+    cmp   r3, #0x0                               @ if dll = 0
+    moveq r3, #0x0F
+    addeq r6, r6, #0x10
+    beq   cbrdll1_scan_next
+    ldr   r0, =0x1e720200
+    ldr   r2, [r0]
+    cmp   r1, #0x96
+    bne   cbrdll1_scan_pass2
+    mov   r1, r2, lsr #24
+    add   r1, r1, #0x01
+    bic   r2, r2, #0xFF000000
+    orr   r2, r2, r1, lsl #24
+    cmp   r1, #0x03                              @ check (phase == 0x96) count == 3
+    bicge r2, r2, #0x0000FF00
+    bicge r2, r2, #0x000000FF
+    orrge r2, r2, r3, lsl #8
+    orrge r2, r2, r3
+    str   r2, [r0]
+    bge   cbrdll1_scan_end
+
+cbrdll1_scan_pass2:
+    and   r1, r2, #0xFF                          @ if(dllmin > dll)
+    cmp   r1, r3
+    bicgt r2, r2, #0x000000FF
+    orrgt r2, r2, r3
+
+    mov   r1, r2, lsr #8                         @ if(dllmax < dll)
+    and   r1, r1, #0xFF
+    cmp   r1, r3
+    biclt r2, r2, #0x0000FF00
+    orrlt r2, r2, r3, lsl #8
+
+    bic   r2, r2, #0x00FF0000
+    str   r2, [r0]
+
+cbrdll1_scan_next:
+    add   r3, r3, #0x01
+    b     cbrdll1_scan_start
+
+cbrdll1_scan_end:
+    ldr   r0, =0x1e720200
+    ldr   r1, [r0]
+    mov   r2, r1, lsr #8                         @ get dllmax
+    ands  r2, r2, #0xFF
+    bne   cbrdll1_scan_done                      @ if(dllmax != 0)
+    ldr   r0, =0x1e6e0064
+    ldr   r3, [r0]
+    bic   r1, r3, #0x000C0000
+    str   r1, [r0]
+    add   r0, r0, #0x04
+    mov   r1, #0x0
+    str   r1, [r0]
+
+    /* Delay about 10us */
+    ldr r2, =0x0000000A                          @ Set Timer3 Reload = 10 us
+    init_delay_timer
+delay0_1:
+    check_delay_timer
+    bne delay0_1
+    clear_delay_timer
+    /* end delay 10us */
+
+    ldr   r0, =0x1e6e0064
+    str   r3, [r0]
+
+    /* Delay about 10us */
+    ldr r2, =0x0000000A                          @ Set Timer3 Reload = 10 us
+    init_delay_timer
+delay0_2:
+    check_delay_timer
+    bne delay0_2
+    clear_delay_timer
+    /* end delay 10us */
+
+    b     CBRDLL1_2300_Start
+
+cbrdll1_scan_done:
+    and   r1, r1, #0xFF
+    add   r1, r1, r2
+    mov   r6, r1, lsr #1                         @ dll1.0 = (dllmin + dllmax) >> 1
+    cmp   r6, r5
+    subge r6, r6, r5
+    add   r3, r6, r5, lsr #2                     @ dll1.1 = dll1.0 + (MADJ >> 2)
+
+    ldr   r0, =0x1e6e0004
+    ldr   r1, [r0]
+    mov   r1, r1, lsr #10
+    tst   r1, #0x1
+    bne   cbrdll1_scan_set_2400
+    cmp   r3, r5
+    subge r3, r3, r5
+    mov   r2, #0x0
+    tst   r3, #0x08
+    beq   cbrdll1_scan_set_2300_2                @ if !(dll & 8)
+cbrdll1_scan_set_2300_1:                         @ if  (dll & 8)
+    mov   r1, #0x0
+    tst   r3, #0x08
+    addeq r1, r1, #0x01
+    cmp   r2, #0x05
+    addge r1, r1, #0x01
+    cmp   r1, #0x02
+    beq   cbrdll1_scan_set
+    add   r2, r2, #0x01
+    add   r3, r3, #0x01
+    cmp   r3, r5
+    subge r3, r3, r5
+    b     cbrdll1_scan_set_2300_1
+
+cbrdll1_scan_set_2300_2:
+    and   r1, r3, #0x07
+    cmp   r1, #0x07
+    beq   cbrdll1_scan_set
+    cmp   r2, #0x05
+    bge   cbrdll1_scan_set
+    add   r2, r2, #0x01
+    add   r3, r3, #0x01
+    cmp   r3, r5
+    subge r3, r3, r5
+    b     cbrdll1_scan_set_2300_2
+
+cbrdll1_scan_set_2400:
+    add   r3, r3, #0x05                          @ dll1.1 = dll1.0 + (MADJ >> 2) + 5
+    cmp   r3, r5
+    subge r3, r3, r5
+
+cbrdll1_scan_set:
+    orr   r1, r6, r3, lsl #8
+    ldr   r0, =0x1e6e0068
+    str   r1, [r0]
+
+    ldr   r0, =0x1e6e0120
+    ldr   r1, [r0]
+    cmp   r1, #0x0
+    beq   MCLK2X_Phase_CBR_Done_DDR3
+    cmp   r1, #0x1
+    beq   MCLK2X_Phase_CBR_Done_DDR2
+    b     CBRDLL1_2400_Call
+
+.LTORG
+
+/******************************************************************************
+ Calibration Code Start
+    SRAM buffer definition
+    0x1E720000 : Pass 1, DLLI MIN value range
+    0x1E720008 : DQS0 DLL valid range, 2nd time CBR
+    0x1E72000C : DQS1 DLL valid range, 2nd time CBR
+    0x1E720010 : DQ0  DLL valid range, Pass 1
+    0x1E720014 : DQ1  DLL valid range, Pass 1
+    ....
+    0x1E720048 : DQ14 DLL valid range, Pass 1
+    0x1E72004C : DQ15 DLL valid range, Pass 1
+    0x1E720090 : DLL1 SAdj record
+    0x1E720094 : DQL  Pass1 finetune result
+    0x1E720098 : DQH  Pass1 finetune result
+    0x1E72009C : DRAM initial time, (us)
+    0x1E7200A0 : CBR3 retry counter
+    0x1E7200A4 : DRAM initial time, (us)
+    0x1E7200A8 : Released date
+    0x1E7200AC : Released SDK version
+    0x1E7200B0 : DQS input mask window for MCR18[4] = 0
+    0x1E7200B4 : DQS input mask window for MCR18[4] = 1
+    0x1E720100 : DQIDLY=00, DLL valid range
+    0x1E720104 : DQIDLY=01, DLL valid range
+    ....
+    0x1E720178 : DQIDLY=30, DLL valid range
+    0x1E72017C : DQIDLY=31, DLL valid range
+    0x1E720180 : DQSI-MCLK2X P-phase pass record DLL2= 0-31
+    0x1E720184 : DQSI-MCLK2X P-phase pass record DLL2=32-63
+    0x1E720188 : DQSI-MCLK2X N-phase pass record DLL2= 0-31
+    0x1E72018C : DQSI-MCLK2X N-phase pass record DLL2=32-63
+ ******************************************************************************/
+Calibration_Start_pre:                           @ Toggle DQSI mask delay
+    ldr r0, =0x1e6e0018
+    ldr r1, [r0]
+    eor r1, r1, #0x10
+    str r1, [r0]
+
+Calibration_Start:
+/* Init SRAM buffer */
+    ldr r1, =0x000000ff
+    ldr r0, =0x1e720000
+    ldr r2, =0x1e720100
+init_sram_start:
+    str r1, [r0]
+    add r0, r0, #4
+    cmp r0, r2
+    blt init_sram_start
+
+    ldr r1, =0x00ff00ff
+    ldr r0, =0x1e720100
+    ldr r2, =0x1e720180
+init_sram_start2:
+    str r1, [r0]
+    add r0, r0, #4
+    cmp r0, r2
+    blt init_sram_start2
+
+    ldr r1, =0x00000000
+    ldr r0, =0x1e720180
+    ldr r2, =0x1e720200
+init_sram_start3:
+    str r1, [r0]
+    add r0, r0, #4
+    cmp r0, r2
+    blt init_sram_start3
+
+    ldr r0, =0x1e6e0068                          @ save the DLL1 SAdj initial value
+    ldr r1, [r0]
+    ldr r0, =0x1e720090
+    str r1, [r0]
+
+/* Start
+  r0 = free
+  r1 = free
+  r2 = free
+  r3 = free
+  r4 = record the return pc value, do not use
+  r5 = pattern table index
+  r6 = pass count
+  r7 = dram DLL2 parameter index (0x1e6e0068), max is 0x4C
+*/
+/******************************************************************************
+ Fine DQI delay and DQSI-MCLK phase
+  r8  = DQIDLY count
+  r9  = DQSI-MCLK2X phase count
+  r10 = pattern fail retry counter, initialize to 2 (fail 2 times)
+  r11 = passcnt accumulator for each DQIDLY
+ *****************************************************************************/
+CBR0_START:
+/* Debug - UART console message */
+    ldr r0, =0x1e784000
+    mov r1, #0x43                                @ 'C'
+    str r1, [r0]
+    mov r1, #0x42                                @ 'B'
+    str r1, [r0]
+    mov r1, #0x52                                @ 'R'
+    str r1, [r0]
+    mov r1, #0x30                                @ '0'
+    str r1, [r0]
+    mov r1, #0x2D                                @ '-'
+    str r1, [r0]
+/* Debug - UART console message */
+
+    ldr   r0, =0x1e6e0018
+    ldr   r1, [r0]
+    bic   r1, r1, #0xFF000000
+    bic   r1, r1, #0x00FF0000
+    str   r1, [r0]
+
+    ldr   r0, =0x1e6e0074                        @ set the testing DRAM size = 1KB
+    ldr   r1, =0x000003FF
+    str   r1, [r0]
+
+    mov   r8, #0x00                              @ init DQIDLY
+    mov   r9, #0x00                              @ init DQSI-MCLK2X phase
+    mov   r11, #0x01                             @ init passcnt accumulator
+
+cbr0_next_dqidly:
+    cmp   r9, #0x00
+    bne   cbr0_next_dqsiphase
+    cmp   r11, #0x00
+    addeq r8, r8, #0x01                          @ jump 1 stage if no pass at previous stage
+    mov   r11, #0x00
+    add   r8, r8, #0x01
+    cmp   r8, #0x1F                              @ max DQIDLY = 31
+    bgt   CBR0_END
+
+/* Debug - UART console message */
+    ldr   r0, =0x1e784000
+    and   r1, r8, #0x07
+    add   r1, r1, #0x30                          @ '0-7'
+    str   r1, [r0]
+/* Debug - UART console message */
+
+    ldr   r0, =0x1e6e0018
+    ldr   r1, [r0]
+    bic   r1, r1, #0x00FF0000
+    orr   r1, r1, r8, lsl #16
+    str   r1, [r0]
+    mov   r9, #0x01                              @ '1':p_phase, '0':n_phase
+
+    /* Delay about 3us */                        @ wait DQIDLY load
+    ldr r2, =0x00000003                          @ Set Timer4 Reload = 3 us
+    init_delay_timer
+delay_4:
+    check_delay_timer
+    bne delay_4
+    clear_delay_timer
+    /* end delay 3us */
+
+    b     cbr0_dll2_scan_start
+
+cbr0_next_dqsiphase:
+    ldr   r0, =0x1e6e0018
+    ldr   r1, [r0]
+    orr   r1, r1, r9, lsl #23                    @ set DQSI-MCLK2X phase
+    str   r1, [r0]
+    mov   r9, #0x00
+
+cbr0_dll2_scan_start:
+    mov   r6, #0x00                              @ init pass count
+    mov   r7, #0x00                              @ init DLL2 parameter index
+
+/****************************
+ DLL2 delay margin test loop
+ ***************************/
+cbr0_next_dll2_parameter:
+    ldr   r0, =0x1e6e0068                        @ load DLL2 parameter
+    ldr   r1, [r0]
+    bic   r1, r1, #0x00FF0000
+    bic   r1, r1, #0xFF000000
+    orr   r1, r1, r7, lsl #16
+    str   r1, [r0]
+    ldr   r2, =0x40404040                        @ DLL2 max is 0x40404040
+    cmp   r7, r2
+    bge   cbr0_next_dqidly
+    ldr   r2, =0x01010101
+    add   r7, r7, r2
+
+/* CBRScan3() start */
+    adrl  r5, PATTERN_TABLE                      @ init pattern table index
+/****************************
+ Test pattern iteration loop
+ ***************************/
+cbr0_next_test_pattern:
+    mov   r10, #2                                @ set the retry loop = 2 of each pattern
+    ldr   r1, [r5]                               @ load test pattern
+    ldr   r0, =0x1e6e007c
+    str   r1, [r0]
+    cmp   r1, #0x00                              @ the last data in pattern is 0x00
+    bne   cbr0_test_burst
+
+    and   r3, r7, #0xFF
+    sub   r3, r3, #0x01                          @ we add 1 after loop check so we need to decrease 1
+    cmp   r3, #0x00
+    beq   cbr0_next_dqidly                       @ pass at dlli = 0, invalid
+    add   r6, r6, #0x01                          @ increment pass count
+    add   r11, r11, #0x01                        @ increment pass count
+
+    ldr   r0, =0x1e720180                        @ record DLL2 pass window
+    cmp   r9, #0x00                              @ DQSI-MCLK2X phase check
+    addeq r0, r0, #0x08
+    cmp   r3, #32
+    addge r0, r0, #0x4
+    and   r1, r3, #0x1F
+    mov   r2, #0x1
+    mov   r2, r2, lsl r1
+    ldr   r1, [r0]
+    orr   r1, r1, r2
+    str   r1, [r0]
+
+    ldr   r0, =0x1e720100                        @ record DLL2 min:max value for each DQIDLY
+    add   r0, r0, r8, lsl #2
+    cmp   r9, #0x00                              @ DQSI-MCLK2X phase check
+    beq   cbr0_test_pass_dqsin
+    record_dll2_pass_range
+    b     cbr0_next_dll2_parameter
+
+cbr0_test_pass_dqsin:
+    record_dll2_pass_range_h
+    b     cbr0_next_dll2_parameter
+
+cbr0_test_pattern_fail:
+    cmp   r6, #5                                 @ passcnt >= 5
+    bge   cbr0_next_dqidly
+    ldr   r0, =0x1e720100                        @ reset DLL2 min:max value
+    add   r0, r0, r8, lsl #2
+    ldr   r1, [r0]
+    ldr   r2, =0xFFFF0000
+    ldr   r3, =0x000000FF
+    cmp   r9, #0x00
+    moveq r2, r2, lsr #16
+    moveq r3, r3, lsl #16
+    and   r1, r1, r2
+    orr   r1, r1, r3
+    str   r1, [r0]
+    b     cbr0_next_dll2_parameter               @ CBRScan3() end and test result fail, go to next step
+
+/****************************
+ Test fail retry loop
+ ***************************/
+cbr0_pattern_fail_retry:
+
+/* CBRTest3() start */
+cbr0_test_burst:
+    ldr   r0, =0x1e6e0070
+    ldr   r1, =0x00000000
+    str   r1, [r0]
+    ldr   r1, =0x000000C1
+    str   r1, [r0]
+    ldr   r3, =0x3000
+cbr0_wait_engine_idle_0:
+    ldr   r2, [r0]
+    tst   r2, r3                                 @ D[12] = idle bit
+    beq   cbr0_wait_engine_idle_0
+
+    ldr   r2, [r0]                               @ read fail bit status
+    mov   r1, #0x0
+    str   r1, [r0]
+    mov   r2, r2, lsr #13                        @ D[13] = fail bit
+    cmp   r2, #0x00
+    bne   cbr0_test_fail
+
+cbr0_test_single:
+    ldr   r0, =0x1e6e0070
+    ldr   r1, =0x00000000
+    str   r1, [r0]
+    ldr   r1, =0x00000085
+    str   r1, [r0]
+    ldr   r3, =0x3000
+cbr0_wait_engine_idle_1:
+    ldr   r2, [r0]
+    tst   r2, r3                                 @ D[12] = idle bit
+    beq   cbr0_wait_engine_idle_1
+
+    ldr   r2, [r0]                               @ read fail bit status
+    mov   r1, #0x0
+    str   r1, [r0]
+    mov   r2, r2, lsr #13                        @ D[13] = fail bit
+    cmp   r2, #0x00
+    beq   cbr0_test_pass
+
+/* CBRTest3() end */
+
+cbr0_test_fail:
+    subs  r10, r10, #1
+    bne   cbr0_pattern_fail_retry
+    b     cbr0_test_pattern_fail                 @ CBRScan3() return(0)
+
+cbr0_test_pass:
+    add   r5, r5, #0x04                          @ increase the test pattern index
+    b     cbr0_next_test_pattern
+
+CBR0_END:
+    mov   r5, #0x0                               @ init DQIDLY search count
+    mov   r6, #0x0                               @ init max_margin:g_margin
+    mov   r8, #0x0                               @ init g_side
+    mov   r7, #0x0                               @ init maximum margin DQIDLY,DQSI-MCLK2X phase
+cbr0_search_dll_margin_s:
+    ldr   r0, =0x1e720100
+    add   r0, r0, r5, lsl #2
+    ldr   r1, [r0]
+    and   r2, r1, #0xFF                          @ get dllmin_p
+    mov   r1, r1, lsr #8
+    and   r3, r1, #0xFF                          @ get dllmax_p
+    subs  r2, r3, r2                             @ get margin-P
+    movmi r2, #0x0
+    mov   r1, r1, lsr #8
+    and   r3, r1, #0xFF                          @ get dllmin_n
+    mov   r1, r1, lsr #8
+    and   r1, r1, #0xFF                          @ get dllmax_n
+    subs  r3, r1, r3                             @ get margin-N
+    movmi r3, #0x0
+    add   r1, r2, r3
+    cmp   r1, #0x0
+    beq   cbr0_search_dll_margin_e               @ if margin-P = 0 && margin-N = 0
+
+    ldr   r9, [r0]
+    ldr   r0, =0x1e720180
+    cmp   r2, r3
+    orrlt r5, r5, #0x80                          @ margin-N > margin-P
+    addlt r0, r0, #0x08
+    movlt r9, r9, lsr #16
+    movge r3, r2                                 @ max(margin-P/N)
+    add   r2, r3, #0x2                           @ define +/- 2 steps of variation
+    mov   r1, r6, lsr #16
+    cmp   r2, r1
+    blt   cbr0_search_dll_margin_e               @ if max(margin-P/N) + 2 < max_margin
+
+    and   r1, r9, #0xFF                          @ r1 = dlli counter
+    cmp   r1, #32
+    ldrge r2, [r0, #0x4]                         @ load pass window
+    ldrlt r2, [r0]
+    and   r1, r1, #0x1F
+    mov   r10, #0x1                              @ init test bit mask
+    mov   r10, r10, lsl r1
+    and   r1, r9, #0xFF
+cbr0_search_dllmin_margin_s:
+    tst   r2, r10
+    beq   cbr0_search_dllmin_margin_e
+    mov   r10, r10, lsr #1
+    cmp   r1, #32
+    ldreq r2, [r0]
+    ldreq r10, =0x80000000
+    subs  r1, r1, #0x1
+    bne   cbr0_search_dllmin_margin_s
+
+cbr0_search_dllmin_margin_e:
+    and   r2, r9, #0xFF
+    sub   r11, r2, r1                            @ get dllmin side margin
+
+    mov   r9, r9, lsr #8
+    and   r1, r9, #0xFF                          @ r1 = dlli counter
+    cmp   r1, #32
+    ldrge r2, [r0, #0x4]                         @ load pass window
+    ldrlt r2, [r0]
+    and   r1, r1, #0x1F
+    mov   r10, #0x1                              @ init test bit mask
+    mov   r10, r10, lsl r1
+    and   r1, r9, #0xFF
+cbr0_search_dllmax_margin_s:
+    tst   r2, r10
+    beq   cbr0_search_dllmax_margin_e
+    mov   r10, r10, lsl #1
+    cmp   r1, #31
+    ldreq r2, [r0, #0x4]
+    ldreq r10, =0x00000001
+    add   r1, r1, #0x1
+    cmp   r1, #64
+    bne   cbr0_search_dllmax_margin_s
+
+cbr0_search_dllmax_margin_e:
+    and   r2, r9, #0xFF
+    sub   r1, r1, r2                             @ get dllmax side margin
+    cmp   r1, r11
+    movlt r11, r1                                @ get side_margin
+
+cbr0_check_dll_margin:                           @ if max(margin-P/N) > g_margin && side_margin >= g_side && dqidly <= 20
+    cmp   r5, #20
+    bgt   cbr0_check_dll_margin2
+    and   r1, r6, #0xFF
+    cmp   r3, r1
+    ble   cbr0_check_dll_margin3
+    cmp   r11, r8
+    bge   cbr0_set_dll_margin
+
+cbr0_check_dll_margin2:                          @ if max(margin-P/N) > g_margin+1 && side_margin >= g_side)
+    and   r1, r6, #0xFF
+    add   r2, r1, #0x1
+    cmp   r3, r2
+    ble   cbr0_check_dll_margin3
+    cmp   r11, r8
+    bge   cbr0_set_dll_margin
+
+cbr0_check_dll_margin3:                          @ if side_margin > g_side && g_side < 8
+    cmp   r8, #8
+    bge   cbr0_search_dll_margin_e
+    cmp   r11, r8
+    ble   cbr0_search_dll_margin_e
+
+cbr0_set_dll_margin:
+    mov   r1, r6, lsr #16
+    cmp   r3, r1
+    bicgt r6, r6, #0x00FF0000
+    orrgt r6, r6, r3, lsl #16
+    bic   r6, r6, #0x000000FF
+    orr   r6, r6, r3
+    mov   r7, r5
+    mov   r8, r11
+
+cbr0_search_dll_margin_e:
+    and   r5, r5, #0x7F
+    add   r5, r5, #0x01
+    cmp   r5, #0x20                              @ last DQIDLY
+    blt   cbr0_search_dll_margin_s
+
+    ldr   r0, =0x1e6e0018
+    ldr   r1, [r0]
+    bic   r1, r1, #0x00FF0000
+    orr   r1, r1, r7, lsl #16
+    str   r1, [r0]
+
+    ldr   r0, =0x1e6e0068
+    ldr   r1, [r0]
+    bic   r1, r1, #0x00FF0000
+    bic   r1, r1, #0xFF000000
+    str   r1, [r0]
+
+    /* Delay about 5us */
+    ldr r2, =0x00000005                          @ Set Timer5 Reload = 5 us
+    init_delay_timer
+delay_5:
+    check_delay_timer
+    bne delay_5
+    clear_delay_timer
+    /* end delay 5us */
+
+    ldr r0, =0x1e6e000c                          @ Set refresh cycle
+    ldr r1, =0x00005C01
+    str r1, [r0]
+
+/******************************************************************************
+ Fine tune per bit DQ input delay -- Pass 1, left edge align
+  r8  = free
+  r9  = DQ fail bit accumulator
+  r10 = pattern fail counter, initialize to 5 (fail 5 times)
+  r11 = free
+ *****************************************************************************/
+CBR1_START:
+/* Debug - UART console message */
+    ldr r0, =0x1e784000
+    mov r1, #0x0D                                @ '\r'
+    str r1, [r0]
+    mov r1, #0x0A                                @ '\n'
+    str r1, [r0]
+    mov r1, #0x43                                @ 'C'
+    str r1, [r0]
+    mov r1, #0x42                                @ 'B'
+    str r1, [r0]
+    mov r1, #0x52                                @ 'R'
+    str r1, [r0]
+    mov r1, #0x31                                @ '1'
+    str r1, [r0]
+/* Debug - UART console message */
+
+    mov   r6, #0x00                              @ init pass count
+    mov   r7, #0x00                              @ init DLL2 parameter index
+
+/****************************
+ DLL2 delay margin test loop
+ ***************************/
+cbr1_next_dll2_parameter:
+    ldr   r0, =0x1e6e0068                        @ load DLL2 parameter
+    ldr   r1, [r0]
+    bic   r1, r1, #0x00FF0000
+    bic   r1, r1, #0xFF000000
+    orr   r1, r1, r7, lsl #16
+    str   r1, [r0]
+    ldr   r2, =0x40404040                        @ parameter's max is to 0x40404040
+    cmp   r7, r2
+    bge   CBR1_END
+    ldr   r2, =0x01010101
+    add   r7, r7, r2
+
+    ldr   r0, =0x1e6e0074                        @ set the testing DRAM size = 4KB
+    ldr   r1, =0x00000FFF
+    str   r1, [r0]
+
+/* CBRScan2() start */
+    ldr   r9, =0xFFFF                            @ init test status
+    adrl  r5, PATTERN_TABLE                      @ init pattern table index
+/****************************
+ Test pattern iteration loop
+ ***************************/
+cbr1_next_test_pattern:
+    mov   r10, #5                                @ set the retry loop of each pattern
+    ldr   r1, [r5]                               @ load test pattern
+    ldr   r0, =0x1e6e007c
+    str   r1, [r0]
+    cmp   r1, #0x00                              @ the last data in pattern is 0x00
+    bne   cbr1_test_single
+
+cbr1_test_pattern_end:
+    cmp   r9, #0x00
+    bne   cbr1_test_pass_dqi
+    cmp   r6, #10
+    bge   CBR1_END
+    b     cbr1_next_dll2_parameter               @ CBRScan2() end and test result fail, go to next step
+
+cbr1_test_pass_dqi:
+    and   r3, r7, #0xFF
+    sub   r3, r3, #0x01                          @ we add 1 after loop check so we need to decrease 1
+    add   r6, r6, #0x01                          @ increment pass count
+    ldr   r0, =0x1e720010
+    mov   r8, #0x01
+cbr1_test_pass_dqi_loop_s:
+    tst   r9, r8
+    beq   cbr1_test_pass_dqi_loop_e
+    record_dll2_pass_range
+
+cbr1_test_pass_dqi_loop_e:
+    add   r0, r0, #0x04
+    mov   r8, r8, lsl #1
+    ldr   r1, =0xFFFF
+    tst   r8, r1
+    bne   cbr1_test_pass_dqi_loop_s
+    b     cbr1_next_dll2_parameter
+
+/****************************
+ Test fail retry loop
+ ***************************/
+cbr1_pattern_fail_retry:
+
+/* CBRTest2() start */
+cbr1_test_single:
+    ldr   r0, =0x1e6e0070
+    ldr   r1, =0x00000000
+    str   r1, [r0]
+    ldr   r1, =0x00000005
+    str   r1, [r0]
+    ldr   r3, =0x1000
+    ldr   r1, =0x1000
+cbr1_wait_engine_idle_0:
+    subs  r1, r1, #1
+    beq   cbr1_test_single_end
+    ldr   r2, [r0]
+    tst   r2, r3                                 @ D[12] = idle bit
+    beq   cbr1_wait_engine_idle_0
+
+cbr1_test_single_end:
+    ldr   r0, =0x1e6e0078                        @ read fail bit status
+    ldr   r11, [r0]
+    orr   r11, r11, r11, lsr #16
+    bic   r11, r11, #0xFF000000
+    bic   r11, r11, #0x00FF0000
+
+    ldr   r1, =0xFFFF
+    cmp   r11, r1
+    beq   cbr1_test_fail
+
+cbr1_test_burst:
+    ldr   r0, =0x1e6e0070
+    ldr   r2, =0x00000000
+    str   r2, [r0]
+    ldr   r2, =0x00000041
+    str   r2, [r0]
+    ldr   r3, =0x1000
+    ldr   r1, =0x1000
+cbr1_wait_engine_idle_1:
+    subs  r1, r1, #1
+    beq   cbr1_test_burst_end
+    ldr   r2, [r0]
+    tst   r2, r3                                 @ D[12] = idle bit
+    beq   cbr1_wait_engine_idle_1
+
+cbr1_test_burst_end:
+    ldr   r0, =0x1e6e0078                        @ read fail bit status
+    ldr   r2, [r0]
+    orr   r2, r2, r2, lsr #16
+    bic   r2, r2, #0xFF000000
+    bic   r2, r2, #0x00FF0000
+    orr   r11, r11, r2
+
+    ldr   r2, =0xFFFF
+    cmp   r11, r2
+    bne   cbr1_test_pass
+/* CBRTest2() end */
+
+cbr1_test_fail:
+    subs  r10, r10, #1
+    bne   cbr1_pattern_fail_retry
+    mov   r9, #0x00
+    b     cbr1_test_pattern_end                  @ CBRScan2() return(0)
+
+cbr1_test_pass:
+    ldr   r1, =0xFFFF                            @ record the pass bit
+    eor   r11, r11, r1
+    and   r9, r9, r11                            @ DQ pass bit
+    cmp   r9, #0x00
+    beq   cbr1_test_pattern_end                  @ CBRScan2() return(0)
+
+    add   r5, r5, #0x04                          @ increase the test pattern index
+    b     cbr1_next_test_pattern
+
+CBR1_END:
+    mov   r5, #0x0                               @ init DQ DLL_min sum
+    mov   r6, #0x0                               @ init DQ DLL_min valid count
+    ldr   r0, =0x1e72000c
+    ldr   r3, =0x1e720050
+cbr1_search_dllmin_s:
+    add   r0, r0, #0x04
+    cmp   r0, r3
+    beq   cbr1_search_dllmin_e
+    ldr   r1, [r0]
+    mov   r2, r1, lsr #8
+    and   r2, r2, #0xFF                          @ get dllmax
+    and   r1, r1, #0xFF                          @ get dllmin
+    subs  r2, r2, r1                             @ dllmax - dllmin
+    bmi   cbr1_search_dllmin_s                   @ no valid margin found, bypass fine tune
+    cmp   r2, #10                                @ (dllmax - dllmin) < 10
+    blt   cbr1_search_dllmin_s                   @ no enough margin found, bypass fine tune
+    add   r5, r5, r1
+    add   r6, r6, #1
+    b     cbr1_search_dllmin_s
+
+cbr1_search_dllmin_e:
+    cmp   r6, #16
+    bne   Calibration_Start_pre                  @ not all bits valid, retry again
+
+    mov   r5, r5, lsr #4
+    ldr   r0, =0x1e720000
+    str   r5, [r0]
+
+    mov   r6, #0x00                              @ init DQL CBR value
+    ldr   r0, =0x1e720030
+    ldr   r7, =0x1e72000c
+cbr1_set_result_dql:
+    sub   r0, r0, #4
+    cmp   r0, r7
+    beq   cbr1_set_result_next
+    mov   r6, r6, lsl #3
+    ldr   r1, [r0]
+    mov   r2, r1, lsr #8
+    and   r2, r2, #0xFF                          @ get dllmax
+    and   r1, r1, #0xFF                          @ get dllmin
+    mov   r3, r1                                 @ dll = dllmin
+    cmp   r5, r3
+    blt   cbr1_set_result_dql_neg
+    sub   r1, r5, r3
+    mov   r2, #19
+    mul   r1, r2, r1
+    mov   r1, r1, lsr #5                         @ dqi_tune = ((gold_dll - dll) * 19) >> 5
+    cmp   r1, #2                                 @ dqi_tune max = 2
+    movgt r1, #2
+    orr   r6, r6, r1
+    b     cbr1_set_result_dql
+
+cbr1_set_result_dql_neg:
+    sub   r1, r3, r5
+    mov   r2, #19
+    mul   r1, r2, r1
+    mov   r1, r1, lsr #5                         @ dqi_tune = ((gold_dll - dll) * 19) >> 5
+    cmp   r1, #2                                 @ dqi_tune max = -2
+    movgt r1, #2
+    mov   r2, #8
+    sub   r1, r2, r1
+    and   r1, r1, #7
+    orr   r6, r6, r1
+    b     cbr1_set_result_dql
+
+cbr1_set_result_next:
+    ldr   r0, =0x1e6e0080                        @ save DQL fine tune result
+    str   r6, [r0]
+    ldr   r0, =0x1e720094
+    str   r6, [r0]
+
+    mov   r6, #0x00                              @ init DQH CBR value
+    ldr   r0, =0x1e720050
+    ldr   r7, =0x1e72002c
+cbr1_set_result_dqh:
+    sub   r0, r0, #4
+    cmp   r0, r7
+    beq   cbr1_set_result_end
+    mov   r6, r6, lsl #3
+    ldr   r1, [r0]
+    mov   r2, r1, lsr #8
+    and   r2, r2, #0xFF                          @ get dllmax
+    and   r1, r1, #0xFF                          @ get dllmin
+    mov   r3, r1                                 @ dll = dllmin
+    cmp   r5, r3
+    blt   cbr1_set_result_dqh_neg
+    sub   r1, r5, r3
+    mov   r2, #19
+    mul   r1, r2, r1
+    mov   r1, r1, lsr #5                         @ dqi_tune = ((gold_dll - dll) * 19) >> 5
+    cmp   r1, #3                                 @ dqi_tune max = 2
+    movgt r1, #3
+    subs  r1, r1, #1
+    movmi r1, #7
+    orr   r6, r6, r1
+    b     cbr1_set_result_dqh
+
+cbr1_set_result_dqh_neg:
+    sub   r1, r3, r5
+    mov   r2, #19
+    mul   r1, r2, r1
+    mov   r1, r1, lsr #5                         @ dqi_tune = ((gold_dll - dll) * 19) >> 5
+    add   r1, r1, #1
+    cmp   r1, #2                                 @ dqi_tune max = -2
+    movgt r1, #2
+    mov   r2, #8
+    sub   r1, r2, r1
+    and   r1, r1, #7
+    orr   r6, r6, r1
+    b     cbr1_set_result_dqh
+
+cbr1_set_result_end:
+    ldr   r0, =0x1e6e0084                        @ save DQH fine tune result
+    str   r6, [r0]
+    ldr   r0, =0x1e720098
+    str   r6, [r0]
+
+/******************************************************************************
+ Search the DLL2 detail margin
+ *****************************************************************************/
+    ldr   r0, =0x1e7200a0
+    mov   r1, #0
+    str   r1, [r0]
+
+CBR3_START:
+/* Debug - UART console message */
+    ldr r0, =0x1e784000
+    mov r1, #0x33                                @ '3'
+    str r1, [r0]
+/* Debug - UART console message */
+
+    mov   r6, #0x00                              @ init pass count
+    mov   r7, #0x00                              @ init DLL2 parameter index
+    ldr   r1, =0x000000ff
+    ldr   r0, =0x1e720008                        @ init DQL dllmax,dllmin
+    str   r1, [r0]
+    ldr   r0, =0x1e72000c                        @ init DQH dllmax,dllmin
+    str   r1, [r0]
+
+    ldr   r0, =0x1e7200a0                        @ CBR3 iteration counter
+    ldr   r1, [r0]
+    add   r1, r1, #1
+    str   r1, [r0]
+
+/****************************
+ DLL2 delay margin test loop
+ ***************************/
+cbr3_next_dll2_parameter:
+    ldr   r0, =0x1e6e0068                        @ load DLL2 parameter
+    ldr   r1, [r0]
+    bic   r1, r1, #0x00FF0000
+    bic   r1, r1, #0xFF000000
+    orr   r1, r1, r7, lsl #16
+    str   r1, [r0]
+    ldr   r2, =0x40404040                        @ parameter's max is to 0x40404040
+    cmp   r7, r2
+    bge   CBR3_END
+    ldr   r2, =0x01010101
+    add   r7, r7, r2
+
+    ldr   r0, =0x1e6e0074                        @ set the testing DRAM size = 64KB
+    ldr   r1, =0x0000FFFF
+    str   r1, [r0]
+
+/* CBRScan() start */
+    mov   r9, #0x03                              @ init test status
+    adrl  r5, PATTERN_TABLE                      @ init pattern table index
+/****************************
+ Test pattern iteration loop
+ ***************************/
+cbr3_next_test_pattern:
+    mov   r10, #5                                @ set the retry loop of each pattern
+    ldr   r1, [r5]                               @ load test pattern
+    ldr   r0, =0x1e6e007c
+    str   r1, [r0]
+    cmp   r1, #0x00                              @ the last data in pattern is 0x00
+    bne   cbr3_test_single
+
+cbr3_test_pattern_end:
+    cmp   r9, #0x00
+    bne   cbr3_test_pass_dql
+    cmp   r6, #10
+    bge   CBR3_END
+    b     cbr3_next_dll2_parameter               @ CBRScan() end and test result fail, go to next step
+
+cbr3_test_pass_dql:
+    and   r3, r7, #0xFF
+    sub   r3, r3, #0x01                          @ we add one after loop check so we need to decrease 1
+    add   r6, r6, #0x01                          @ increment pass count
+    tst   r9, #0x01
+    beq   cbr3_test_pass_dqh
+
+    ldr   r0, =0x1E720008
+    record_dll2_pass_range
+
+cbr3_test_pass_dqh:
+    tst   r9, #0x02
+    beq   cbr3_next_dll2_parameter
+    ldr   r0, =0x1E72000c
+    record_dll2_pass_range
+    b     cbr3_next_dll2_parameter
+
+/****************************
+ Test fail retry loop
+ ***************************/
+cbr3_pattern_fail_retry:
+
+/* CBRTest() start */
+cbr3_test_single:
+    ldr   r0, =0x1e6e0070
+    ldr   r1, =0x00000000
+    str   r1, [r0]
+    ldr   r1, =0x00000005
+    str   r1, [r0]
+    ldr   r3, =0x1000
+    ldr   r8, =0x10000
+cbr3_wait_engine_idle_0:
+    subs  r8, r8, #1
+    beq   cbr3_test_single_end
+    ldr   r2, [r0]
+    tst   r2, r3                                 @ D[12] = idle bit
+    beq   cbr3_wait_engine_idle_0
+
+cbr3_test_single_end:
+    ldr   r0, =0x1e6e0078                        @ read fail bit status
+    ldr   r11, [r0]
+    orr   r11, r11, r11, lsr #16
+    bic   r11, r11, #0xFF000000
+    bic   r11, r11, #0x00FF0000
+
+    ldr   r1, =0xFF
+    tst   r11, r1
+    beq   cbr3_test_burst
+    tst   r11, r1, lsl #8
+    bne   cbr3_test_fail
+
+cbr3_test_burst:
+    mov   r1, #0x00                              @ initialize loop index, r1 is loop's index
+cbr3_test_burst_loop:
+    ldr   r0, =0x1e6e0070
+    ldr   r2, =0x00000000
+    str   r2, [r0]
+    mov   r2, r1, lsl #3
+    orr   r2, r2, #0x41                          @ test command = 0x41 | (datagen << 3)
+    str   r2, [r0]
+    ldr   r3, =0x1000
+    ldr   r8, =0x10000
+cbr3_wait_engine_idle_1:
+    subs  r8, r8, #1
+    beq   cbr3_test_burst_end
+    ldr   r2, [r0]
+    tst   r2, r3                                 @ D[12] = idle bit
+    beq   cbr3_wait_engine_idle_1
+
+cbr3_test_burst_end:
+    ldr   r0, =0x1e6e0078                        @ read fail bit status
+    ldr   r2, [r0]
+    orr   r2, r2, r2, lsr #16
+    bic   r2, r2, #0xFF000000
+    bic   r2, r2, #0x00FF0000
+    orr   r11, r11, r2
+
+    ldr   r2, =0xFF
+    tst   r11, r2
+    beq   cbr3_next_test_burst_mode
+    tst   r11, r2, lsl #8
+    beq   cbr3_next_test_burst_mode
+/* CBRTest() end */
+
+cbr3_test_fail:
+    subs  r10, r10, #1
+    bne   cbr3_pattern_fail_retry
+    mov   r9, #0x00
+    b     cbr3_test_pattern_end                  @ CBRScan() return(0)
+
+cbr3_next_test_burst_mode:
+    add   r1, r1, #1                             @ increase the test mode index
+    cmp   r1, #0x08                              @ there are 8 modes
+    bne   cbr3_test_burst_loop
+
+    ldr   r1, =0xFF                              @ record the pass byte
+    tst   r11, r1
+    andne r9, r9, #0x02                          @ DQL fail
+    tst   r11, r1, lsl #8
+    andne r9, r9, #0x01                          @ DQH fail
+    cmp   r9, #0x00
+    beq   cbr3_test_pattern_end                  @ CBRScan() return(0)
+
+    add   r5, r5, #0x04                          @ increase the test pattern index
+    b     cbr3_next_test_pattern
+
+CBR3_END:
+    ldr   r0, =0x1e72000c                        @ check DQH margin
+    ldr   r1, [r0]
+    mov   r2, r1, lsr #8
+    and   r2, r2, #0xFF                          @ get dllmax
+    and   r1, r1, #0xFF                          @ get dllmin
+    subs  r5, r2, r1                             @ dllmax - dllmin
+    bmi   CBR3_START                             @ no valid margin found, retry again
+    cmp   r5, #10                                @ (dllmax - dllmin) < 10
+    blt   CBR3_START                             @ no enough margin found, retry again
+    add   r2, r1, r2                             @ (dllmin[1] + dllmax[1] + 1) >> 1
+    add   r2, r2, #0x01
+    mov   r1, r2, lsr #1
+    mov   r3, r1, lsl #8
+    ldr   r1, [r0]                               @ store the dll search result
+    bic   r1, r1, #0xFF000000
+    bic   r1, r1, #0x00FF0000
+    orr   r1, r1, r3, lsl #8
+    str   r1, [r0]
+
+    ldr   r0, =0x1e720008                        @ check DQL margin
+    ldr   r1, [r0]
+    mov   r2, r1, lsr #8
+    and   r2, r2, #0xFF                          @ get dllmax
+    and   r1, r1, #0xFF                          @ get dllmin
+    subs  r5, r2, r1                             @ dllmax - dllmin
+    bmi   CBR3_START                             @ no valid margin found, retry again
+    cmp   r5, #10                                @ (dllmax - dllmin) < 10
+    blt   CBR3_START                             @ no enough margin found, retry again
+    add   r2, r1, r2                             @ (dllmin[0] + dllmax[0] + 1) >> 1
+    add   r2, r2, #0x01
+    mov   r1, r2, lsr #1
+    ldr   r2, [r0]                               @ store the dll search result
+    bic   r2, r2, #0xFF000000
+    bic   r2, r2, #0x00FF0000
+    orr   r2, r2, r1, lsl #16
+    str   r2, [r0]
+    orr   r3, r3, r1
+
+    ldr   r0, =0x1e6e0068                        @ save the result dll value
+    ldr   r1, [r0]
+    bic   r1, r1, #0xFF000000
+    bic   r1, r1, #0x00FF0000
+    orr   r1, r1, r3, lsl #16
+    str   r1, [r0]
+    b     CBR4_START
+
+.LTORG
+
+/******************************************************************************
+ Search the DQS input mask margin
+ *****************************************************************************/
+CBR4_START:
+/* Debug - UART console message */
+    ldr r0, =0x1e784000
+    mov r1, #0x34                                @ '4'
+    str r1, [r0]
+/* Debug - UART console message */
+
+    ldr   r0, =0x1e6e0074                        @ set the testing DRAM size = 4KB
+    ldr   r1, =0x00000FFF
+    str   r1, [r0]
+
+    mov   r8, #0x00                              @ init MCR18[4]
+    ldr   r1, =0x000000ff
+    ldr   r0, =0x1e7200b0                        @ init MCR18[4]=0 max,min
+    str   r1, [r0]
+    ldr   r0, =0x1e7200b4                        @ init MCR18[4]=1 max,min
+    str   r1, [r0]
+
+    ldr   r0, =0x1e6e0018
+    ldr   r1, [r0]
+    bic   r1, r1, #0x0000001F
+    str   r1, [r0]
+
+    b     cbr4_scan_start
+
+cbr4_next_maskdly:
+    add   r8, r8, #0x01
+    and   r2, r8, #0x01
+    ldr   r0, =0x1e6e0018
+    ldr   r1, [r0]
+    bic   r1, r1, #0x0000001F
+    orr   r1, r1, r2, lsl #4
+    str   r1, [r0]
+    cmp   r8, #0x02
+    bge   CBR4_END
+
+cbr4_scan_start:
+    mov   r6, #0x00                              @ init pass count
+    mov   r7, #0x00                              @ init mask delay
+
+/****************************
+ DQS Mask delay margin test loop
+ ***************************/
+cbr4_next_parameter:
+    cmp   r7, #0x10                              @ max delay = 0xF
+    bge   cbr4_next_maskdly
+    ldr   r0, =0x1e6e0018                        @ load MCR18 parameter
+    ldr   r1, [r0]
+    bic   r1, r1, #0x0000000F
+    orr   r1, r1, r7
+    str   r1, [r0]
+    add   r7, r7, #0x01
+
+/* CBRScan3() start */
+    adrl  r5, PATTERN_TABLE                      @ init pattern table index
+/****************************
+ Test pattern iteration loop
+ ***************************/
+cbr4_next_test_pattern:
+    mov   r10, #2                                @ set the retry loop = 2 of each pattern
+    ldr   r1, [r5]                               @ load test pattern
+    ldr   r0, =0x1e6e007c
+    str   r1, [r0]
+    cmp   r1, #0x00                              @ the last data in pattern is 0x00
+    bne   cbr4_test_burst
+
+    and   r3, r7, #0xFF
+    sub   r3, r3, #0x01                          @ we add 1 after loop check so we need to decrease 1
+    add   r6, r6, #0x01                          @ increment pass count
+
+    ldr   r0, =0x1e7200b0                        @ record pass window
+    add   r0, r0, r8, lsl #2
+    record_dll2_pass_range
+    mov   r2, #0x01
+    add   r1, r1, r2, lsl #16
+    str   r1, [r0]
+    b     cbr4_next_parameter
+
+cbr4_test_pattern_fail:
+    cmp   r6, #5                                 @ passcnt >= 5
+    bge   cbr4_next_maskdly
+    b     cbr4_next_parameter
+
+/****************************
+ Test fail retry loop
+ ***************************/
+cbr4_pattern_fail_retry:
+
+/* CBRTest3() start */
+cbr4_test_burst:
+    ldr   r0, =0x1e6e0070
+    ldr   r1, =0x00000000
+    str   r1, [r0]
+    ldr   r1, =0x000000C1
+    str   r1, [r0]
+    ldr   r3, =0x3000
+cbr4_wait_engine_idle_0:
+    ldr   r2, [r0]
+    tst   r2, r3                                 @ D[12] = idle bit
+    beq   cbr4_wait_engine_idle_0
+
+    ldr   r2, [r0]                               @ read fail bit status
+    mov   r1, #0x0
+    str   r1, [r0]
+    mov   r2, r2, lsr #13                        @ D[13] = fail bit
+    cmp   r2, #0x00
+    bne   cbr4_test_fail
+
+cbr4_test_single:
+    ldr   r0, =0x1e6e0070
+    ldr   r1, =0x00000000
+    str   r1, [r0]
+    ldr   r1, =0x00000085
+    str   r1, [r0]
+    ldr   r3, =0x3000
+cbr4_wait_engine_idle_1:
+    ldr   r2, [r0]
+    tst   r2, r3                                 @ D[12] = idle bit
+    beq   cbr4_wait_engine_idle_1
+
+    ldr   r2, [r0]                               @ read fail bit status
+    mov   r1, #0x0
+    str   r1, [r0]
+    mov   r2, r2, lsr #13                        @ D[13] = fail bit
+    cmp   r2, #0x00
+    beq   cbr4_test_pass
+
+/* CBRTest3() end */
+
+cbr4_test_fail:
+    subs  r10, r10, #1
+    bne   cbr4_pattern_fail_retry
+    b     cbr4_test_pattern_fail                 @ CBRScan3() return(0)
+
+cbr4_test_pass:
+    add   r5, r5, #0x04                          @ increase the test pattern index
+    b     cbr4_next_test_pattern
+
+CBR4_END:
+    ldr   r0, =0x1e7200b0                        @ check mask margin
+    ldr   r1, [r0]
+    add   r0, r0, #0x04
+    ldr   r2, [r0]
+    ands  r6, r2, #0xFF                          @ get min of MCR18[4] = 1
+    bne   cbr4_noset_delay
+    ands  r5, r1, #0xFF                          @ get min of MCR18[4] = 0
+    bne   cbr4_set_delay
+    mov   r1, r1, lsr #8                         @ get max of MCR18[4] = 0
+    and   r1, r1, #0xFF
+    mov   r2, r2, lsr #8                         @ get max of MCR18[4] = 1
+    and   r2, r2, #0xFF
+    sub   r1, r1, r5
+    sub   r2, r2, r6
+    cmp   r1, r2
+    bge   cbr4_noset_delay
+
+cbr4_set_delay:
+    ldr   r0, =0x1e6e0018
+    ldr   r1, [r0]
+    orr   r1, r1, #0x10
+    str   r1, [r0]
+
+cbr4_noset_delay:
+    ldr   r0, =0x1e6e0070
+    ldr   r1, =0x00000000
+    str   r1, [r0]
+
+/******************************************************************************
+ CBR Finish
+ *****************************************************************************/
+/******************************************************************************
+ Check DRAM Size
+ *****************************************************************************/
+    ldr   r0, =0x1e6e2070
+    ldr   r1, [r0]
+    bic   r1, r1, #0xFEFFFFFF                    @ bit[24]=1 => DDR2
+    mov   r2, r1, lsr #24
+    cmp   r2, #0x01
+    beq   check_ddr2_size
+
+    ldr   r0, =0x1e6e0004
+    ldr   r5, [r0]
+    bic   r5, r5, #0x00000003                    @ record MCR04
+    orr   r1, r5, #0x3
+    str   r1, [r0]                               @ set to 4Gbit
+    ldr   r6, =0x003F2217
+#if defined(CONFIG_DRAM_336)
+    ldr   r6, =0x00361C13
+#endif
+    b     check_dram_size
+
+check_ddr2_size:
+    ldr   r0, =0x1e6e0004
+    ldr   r5, [r0]
+    bic   r5, r5, #0x00000023                    @ record MCR04
+    orr   r1, r5, #0x23
+    str   r1, [r0]                               @ set to 4Gbit
+    ldr   r6, =0x3F2B1B16
+#if defined(CONFIG_DRAM_336)
+    ldr   r6, =0x3B231612
+#endif
+
+    ldr   r0, =0x40000000
+    ldr   r1, =0x1817191A
+    str   r1, [r0]
+    ldr   r0, =0x40002000
+    ldr   r1, =0x73616532
+    str   r1, [r0]
+    ldr   r0, =0x40000000
+    ldr   r1, =0x1817191A
+    ldr   r2, [r0]
+    cmp   r1, r2
+    bne   check_dram_size_end                    @ == 512Mbit
+    orr   r5, r5, #0x20                          @ >= 1Gbit
+    mov   r6, r6, lsr #8
+
+check_dram_size:
+    ldr   r0, =0x50100000
+    ldr   r1, =0x41424344
+    str   r1, [r0]
+    ldr   r0, =0x48100000
+    ldr   r1, =0x25262728
+    str   r1, [r0]
+    ldr   r0, =0x40100000
+    ldr   r1, =0x191A1B1C
+    str   r1, [r0]
+    ldr   r0, =0x50100000
+    ldr   r1, =0x41424344
+    ldr   r2, [r0]
+    cmp   r2, r1                                 @ == 4Gbit
+    orreq r5, r5, #0x03
+    moveq r6, r6, lsr #16
+    beq   check_dram_size_end
+    ldr   r0, =0x48100000
+    ldr   r1, =0x25262728
+    ldr   r2, [r0]
+    cmp   r2, r1                                 @ == 2Gbit
+    orreq r5, r5, #0x02
+    moveq r6, r6, lsr #8
+    beq   check_dram_size_end
+    orr   r5, r5, #0x01                          @ == 1Gbit
+
+check_dram_size_end:
+    ldr   r0, =0x1e6e0004
+    str   r5, [r0]
+    ldr   r0, =0x1e6e0014
+    ldr   r1, [r0]
+    bic   r1, r1, #0x000000FF
+    and   r6, r6, #0xFF
+    orr   r1, r1, r6
+    str   r1, [r0]
+
+    ldr   r0, =0x1e6e0120                        @ VGA Compatible Mode
+    ldr   r1, =0x000050C0                        @ 408 MHz
+#if defined(CONFIG_DRAM_336)
+    ldr   r1, =0x00004DC0
+#endif
+    str   r1, [r0]
+
+/******************************************************************************
+ Version Number
+ *****************************************************************************/
+    ldr   r0, =0x1e7200a8
+    ldr   r1, =0x20141229                        @ released date
+    str   r1, [r0]
+
+    add   r0, r0, #4
+    ldr   r1, =0x00000060                        @ released SDK version
+    str   r1, [r0]
+
+/******************************************************************************
+ Calibration Code End
+ ******************************************************************************/
+
+set_scratch:
+    /*Set Scratch register Bit 6 after ddr initial finished */
+    ldr r0, =0x1e6e2040
+    ldr r1, [r0]
+    orr r1, r1, #0x40
+    str r1, [r0]
+
+/* Debug - UART console message */
+    ldr r0, =0x1e784000
+    mov r1, #0x44                                @ 'D'
+    str r1, [r0]
+    mov r1, #0x6F                                @ 'o'
+    str r1, [r0]
+    mov r1, #0x6E                                @ 'n'
+    str r1, [r0]
+    mov r1, #0x65                                @ 'e'
+    str r1, [r0]
+    mov r1, #0x0D                                @ '\r'
+    str r1, [r0]
+    mov r1, #0x0A                                @ '\n'
+    str r1, [r0]
+/* Debug - UART console message */
+
+/******************************************************************************
+ Solve PCIe ASPM issue, only applied to AST2300 series
+ ******************************************************************************/
+    ldr r0, =0x1e6e207c                          @ Check bounding for AST1150 existence
+    ldr r1, [r0]
+    mov r2, r1, lsr #24
+    cmp r2, #0x01
+    bne platform_exit                            @ not match AST2300
+    bic r1, r1, #0xFFFFFCFF
+    mov r1, r1, lsr #8
+    cmp r1, #0x02
+    beq platform_exit                            @ match AST1050
+
+    ldr r0, =0x1e6e2004                          @ Disable I2C controller reset
+    ldr r1, [r0]
+    orr r1, r1, #0x04
+    str r1, [r0]
+    bic r1, r1, #0x04
+    str r1, [r0]
+
+    ldr r0, =0x1e78a054                          @ Check I2C bus state, if busy then quit
+    ldr r1, [r0]
+    mov r1, r1, lsr #17
+    and r1, r1, #0x03
+    cmp r1, #0x03
+    bne platform_exit
+
+    ldr r0, =0x1e78a040                          @ Init I2C1 controller
+    mov r1, #0x01
+    orr r1, r1, r1, lsl #16
+    str r1, [r0]
+
+    ldr r0, =0x1e78a044
+    ldr r1, =0x77776704
+    str r1, [r0]
+
+    mov r1, #0x0
+    ldr r0, =0x1e78a048
+    str r1, [r0]
+    ldr r0, =0x1e78a04c
+    str r1, [r0]
+
+    ldr r0, =0x1e78a050
+    ldr r1, =0xFFFFFFFF
+    str r1, [r0]
+
+    ldr r0, =0x1e78a200                          @ Set AST1150 I2C password
+    ldr r1, =0x00A88FA8
+    str r1, [r0]
+
+    ldr r0, =0x1e78a05c
+    ldr r1, =0x00000200                          @ Enable buffer mode transfering 3 bytes
+    str r1, [r0]
+
+    ldr r0, =0x1e78a054
+    ldr r1, =0x00000063                          @ Fire commmand
+    str r1, [r0]
+
+    ldr r0, =0x1e78a050
+i2c_wait_cmddone_1:
+    ldr r1, [r0]
+    tst r1, #0x38
+    beq i2c_wait_cmddone_1
+    tst r1, #0x2A                                @ transmit error
+    bne platform_exit2
+    ldr r1, =0xFFFFFFFF
+    str r1, [r0]
+
+    ldr r0, =0x1e78a200                          @ Disable ASPM capability
+    ldr r1, =0x04005DA8
+    str r1, [r0]
+
+    ldr r0, =0x1e78a204
+    ldr r1, =0x00000024
+    str r1, [r0]
+
+    ldr r0, =0x1e78a05c
+    ldr r1, =0x00000200                          @ Enable buffer mode transfering 3 bytes
+    str r1, [r0]
+
+    ldr r0, =0x1e78a054
+    ldr r1, =0x00000063                          @ Fire commmand
+    str r1, [r0]
+
+    ldr r0, =0x1e78a050
+i2c_wait_cmddone_2:
+    ldr r1, [r0]
+    tst r1, #0x38
+    beq i2c_wait_cmddone_2
+    tst r1, #0x2A                                @ transmit error
+    bne platform_exit2
+    ldr r1, =0xFFFFFFFF
+    str r1, [r0]
+
+platform_exit2:
+    ldr r0, =0x1e78a040                          @ Disable I2C1 controller
+    mov r1, #0x00
+    str r1, [r0]
+
+    b   platform_exit
+.LTORG
+
+platform_exit:
+#ifdef      CONFIG_DRAM_ECC
+    ldr r0, =0x1e6e0004
+    ldr r1, [r0]
+    orr r1, r1, #0x80
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0054
+    ldr r1, =0x05000000                          /* ECC protected memory size, default set at 80M   */
+    str r1, [r0]
+
+    ldr r0, =0x1e6e007C
+    ldr r1, =0x00000000
+    str r1, [r0]
+    ldr r0, =0x1e6e0074
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0070
+    ldr r1, =0x00000221
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0070
+    ldr r2, =0x00001000
+ECC_Init_Flag:
+    ldr r1, [r0]
+    tst r1, r2                                   @ D[12] = 1, Done
+    beq ECC_Init_Flag
+
+    ldr r0, =0x1e6e0070
+    ldr r1, =0x00000000
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0050
+    ldr r1, =0x80000000
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0050
+    ldr r1, =0x00000000
+    str r1, [r0]
+
+    ldr r0, =0x1e6e0070
+    ldr r1, =0x00000400
+    str r1, [r0]
+#endif
+    ldr r0, =0x1e6e2008                          @ Set Video ECLK phase
+    ldr r1, [r0]
+    ldr r2, =0xfffffff3
+    and r1, r1, r2
+    orr r1, r1, #0x08
+    str r1, [r0]
+
+    ldr r0, =0x1e6e2004
+    ldr r1, [r0]
+    ldr r2, =0xFFBFFFFF                          @ Enable JTAG Master, solve ARM stucked by JTAG issue
+    and r1, r1, r2
+    str r1, [r0]
+
+    ldr r0, =0x1e6e2048                          @ Set MAC interface delay timing
+    ldr r1, =0x2255
+    str r1, [r0]
+
+    ldr r0, =0x1e6e2070                          @ Set MAC AHB bus clock
+    ldr r1, [r0]
+    mov r2, #0x04                                @ Default RMII, set MHCLK = HPLL/10
+    tst r1, #0xC0
+    movne r2, #0x02                              @ if RGMII,     set MHCLK = HPLL/6
+    ldr r0, =0x1e6e2008
+    ldr r1, [r0]
+    bic r1, r1, #0x00070000
+    orr r1, r1, r2, lsl #16
+    str r1, [r0]
+
+/* Test - DRAM initial time */
+    ldr r0, =0x1e782040
+    ldr r1, [r0]
+    ldr r0, =0xFFFFFFFF
+    sub r1, r0, r1
+    ldr r0, =0x1e72009c
+    str r1, [r0]
+    ldr r0, =0x1e7200a4
+    str r1, [r0]
+    ldr r0, =0x1e782030
+    ldr r1, [r0]
+    bic r1, r1, #0x0000F000
+    str r1, [r0]
+/* Test - DRAM initial time */
+
+/******************************************************************************
+ Reset GPIO registers when watchdog reset
+ ******************************************************************************/
+    ldr r0, =0x1e6e207c                          @ Check Revision ID
+    ldr r1, [r0]
+    mov r1, r1, lsr #24
+    cmp r1, #0x02
+    bne platform_exit3                           @ not match AST2400
+
+    ldr r0, =0x1e6e203c                          @ Check watchdog reset event
+    ldr r1, [r0]
+    and r1, r1, #0x06
+    cmp r1, #0x0
+    beq platform_exit3                           @ no watchdog reset event
+
+    ldr r0, =0x1e6e209c                          @ Check watchdog GPIO selection
+    ldr r1, [r0]
+    mov r1, r1, lsr #21
+    tst r1, #0x01
+    beq platform_exit3                           @ no watchdog reset selection
+
+    ldr r1, =0x00000000                          @ clear GPIO register reset by PRST_N
+    ldr r2, =0xFFFFFFFF
+    ldr r0, =0x1e780008
+    str r1, [r0]
+    ldr r0, =0x1e78000c
+    str r1, [r0]
+    ldr r0, =0x1e780010
+    str r1, [r0]
+    ldr r0, =0x1e780014
+    str r1, [r0]
+    ldr r0, =0x1e780018
+    str r2, [r0]
+    ldr r0, =0x1e780028
+    str r1, [r0]
+    ldr r0, =0x1e78002c
+    str r1, [r0]
+    ldr r0, =0x1e780030
+    str r1, [r0]
+    ldr r0, =0x1e780034
+    str r1, [r0]
+    ldr r0, =0x1e780038
+    str r2, [r0]
+    ldr r0, =0x1e780040
+    str r1, [r0]
+    ldr r0, =0x1e780044
+    str r1, [r0]
+    ldr r0, =0x1e780048
+    str r1, [r0]
+    ldr r0, =0x1e78004c
+    str r1, [r0]
+    ldr r0, =0x1e780050
+    str r1, [r0]
+    ldr r0, =0x1e780054
+    str r1, [r0]
+    ldr r0, =0x1e780058
+    str r1, [r0]
+    ldr r0, =0x1e780060
+    str r1, [r0]
+    ldr r0, =0x1e780064
+    str r1, [r0]
+    ldr r0, =0x1e780068
+    str r1, [r0]
+    ldr r0, =0x1e78006c
+    str r1, [r0]
+    ldr r0, =0x1e780090
+    str r1, [r0]
+    ldr r0, =0x1e780094
+    str r1, [r0]
+    ldr r0, =0x1e780098
+    str r1, [r0]
+    ldr r0, =0x1e78009c
+    str r1, [r0]
+    ldr r0, =0x1e7800a0
+    str r1, [r0]
+    ldr r0, =0x1e7800a4
+    str r1, [r0]
+    ldr r0, =0x1e7800a8
+    str r2, [r0]
+    ldr r0, =0x1e7800b0
+    str r1, [r0]
+    ldr r0, =0x1e7800b4
+    str r1, [r0]
+    ldr r0, =0x1e7800b8
+    str r1, [r0]
+    ldr r0, =0x1e7800e0
+    str r1, [r0]
+    ldr r0, =0x1e7800e4
+    str r1, [r0]
+    ldr r0, =0x1e7800e8
+    str r1, [r0]
+    ldr r0, =0x1e7800ec
+    str r1, [r0]
+    ldr r0, =0x1e7800f0
+    str r1, [r0]
+    ldr r0, =0x1e7800f4
+    str r1, [r0]
+    ldr r0, =0x1e7800f8
+    str r2, [r0]
+    ldr r0, =0x1e780100
+    str r1, [r0]
+    ldr r0, =0x1e780104
+    str r1, [r0]
+    ldr r0, =0x1e780108
+    str r1, [r0]
+    ldr r0, =0x1e780110
+    str r1, [r0]
+    ldr r0, =0x1e780114
+    str r1, [r0]
+    ldr r0, =0x1e780118
+    str r1, [r0]
+    ldr r0, =0x1e78011c
+    str r1, [r0]
+    ldr r0, =0x1e780120
+    str r1, [r0]
+    ldr r0, =0x1e780124
+    str r1, [r0]
+    ldr r0, =0x1e780128
+    str r2, [r0]
+    ldr r0, =0x1e780130
+    str r1, [r0]
+    ldr r0, =0x1e780134
+    str r1, [r0]
+    ldr r0, =0x1e780138
+    str r1, [r0]
+    ldr r0, =0x1e780140
+    str r1, [r0]
+    ldr r0, =0x1e780144
+    str r1, [r0]
+    ldr r0, =0x1e780148
+    str r1, [r0]
+    ldr r0, =0x1e78014c
+    str r1, [r0]
+    ldr r0, =0x1e780150
+    str r1, [r0]
+    ldr r0, =0x1e780154
+    str r1, [r0]
+    ldr r0, =0x1e780158
+    str r2, [r0]
+    ldr r0, =0x1e780160
+    str r1, [r0]
+    ldr r0, =0x1e780164
+    str r1, [r0]
+    ldr r0, =0x1e780168
+    str r1, [r0]
+    ldr r0, =0x1e780170
+    str r1, [r0]
+    ldr r0, =0x1e780174
+    str r1, [r0]
+    ldr r0, =0x1e780178
+    str r1, [r0]
+    ldr r0, =0x1e78017c
+    str r1, [r0]
+    ldr r0, =0x1e780180
+    str r1, [r0]
+    ldr r0, =0x1e780184
+    str r1, [r0]
+    ldr r0, =0x1e780188
+    str r2, [r0]
+    ldr r0, =0x1e780190
+    str r1, [r0]
+    ldr r0, =0x1e780194
+    str r1, [r0]
+    ldr r0, =0x1e780198
+    str r1, [r0]
+    ldr r0, =0x1e7801d0
+    str r1, [r0]
+    ldr r0, =0x1e7801d4
+    str r1, [r0]
+
+    ldr r0, =0x1e780204                          @ clear SGPIOM register reset by PRST_N
+    str r1, [r0]
+    ldr r0, =0x1e780208
+    str r1, [r0]
+    ldr r0, =0x1e78020c
+    str r1, [r0]
+    ldr r0, =0x1e780210
+    str r1, [r0]
+    ldr r0, =0x1e780214
+    str r2, [r0]
+    ldr r0, =0x1e780220
+    str r1, [r0]
+    ldr r0, =0x1e780224
+    str r1, [r0]
+    ldr r0, =0x1e780228
+    str r1, [r0]
+    ldr r0, =0x1e78022c
+    str r1, [r0]
+    ldr r0, =0x1e780230
+    str r2, [r0]
+    ldr r0, =0x1e78023c
+    str r1, [r0]
+    ldr r0, =0x1e780240
+    str r1, [r0]
+    ldr r0, =0x1e780244
+    str r1, [r0]
+    ldr r0, =0x1e780248
+    str r1, [r0]
+    ldr r0, =0x1e78024c
+    str r2, [r0]
+    ldr r0, =0x1e780254
+    ldr r3, =0x01000040
+    str r3, [r0]
+    ldr r0, =0x1e780258
+    str r1, [r0]
+    ldr r0, =0x1e78025c
+    str r1, [r0]
+    ldr r0, =0x1e780260
+    str r1, [r0]
+
+    ldr r0, =0x1e780300                          @ clear SGPIOS register reset by PRST_N
+    str r1, [r0]
+    ldr r0, =0x1e780304
+    str r1, [r0]
+    ldr r0, =0x1e780308
+    str r1, [r0]
+    ldr r0, =0x1e78030c
+    str r1, [r0]
+    ldr r0, =0x1e780310
+    str r1, [r0]
+    ldr r0, =0x1e780314
+    str r1, [r0]
+    ldr r0, =0x1e780318
+    str r2, [r0]
+    ldr r0, =0x1e78031c
+    str r2, [r0]
+    ldr r0, =0x1e780320
+    str r2, [r0]
+
+platform_exit3:
+
+/******************************************************************************
+ SPI Timing Calibration, not applicable to AST2300 series
+ ******************************************************************************/
+    ldr r0, =0x1e6e207c                          @ Check Revision ID
+    ldr r1, [r0]
+    mov r1, r1, lsr #24
+    cmp r1, #0x02
+    blt platform_exit4                           @ not match AST2400 or later
+
+    ldr r0, =0x1e6e2070                          @ Check SPI flash
+    ldr r1, [r0]
+    and r1, r1, #0x03
+    cmp r1, #0x02
+    bne platform_exit4
+
+    mov r2, #0x0
+    mov r6, #0x0
+    mov r7, #0x0
+    init_spi_checksum
+spi_checksum_wait_0:
+    ldr r1, [r0]
+    tst r1, r2
+    beq spi_checksum_wait_0
+    ldr r0, =0x1e620090
+    ldr r5, [r0]                                 @ record golden checksum
+    ldr r0, =0x1e620080
+    mov r1, #0x0
+    str r1, [r0]
+
+    ldr r0, =0x1e620010                          @ set to fast read mode
+    ldr r1, =0x000B0041
+    str r1, [r0]
+
+    ldr r6, =0x00F7E6D0                          @ Init spiclk loop
+    mov r8, #0x0                                 @ Init delay record
+
+spi_cbr_next_clkrate:
+    mov r6, r6, lsr #0x4
+    cmp r6, #0x0
+    beq spi_cbr_end
+
+    mov r7, #0x0                                 @ Init delay loop
+    mov r8, r8, lsl #4
+
+spi_cbr_next_delay_s:
+    mov r2, #0x8
+    init_spi_checksum
+spi_checksum_wait_1:
+    ldr r1, [r0]
+    tst r1, r2
+    beq spi_checksum_wait_1
+    ldr r0, =0x1e620090
+    ldr r2, [r0]                                 @ read checksum
+    ldr r0, =0x1e620080
+    mov r1, #0x0
+    str r1, [r0]
+    cmp r2, r5
+    bne spi_cbr_next_delay_e
+
+    mov r2, #0x0
+    init_spi_checksum
+spi_checksum_wait_2:
+    ldr r1, [r0]
+    tst r1, r2
+    beq spi_checksum_wait_2
+    ldr r0, =0x1e620090
+    ldr r2, [r0]                                 @ read checksum
+    ldr r0, =0x1e620080
+    mov r1, #0x0
+    str r1, [r0]
+    cmp r2, r5
+    bne spi_cbr_next_delay_e
+
+    orr r8, r8, r7                               @ record passed delay
+    b   spi_cbr_next_clkrate
+
+spi_cbr_next_delay_e:
+    add r7, r7, #0x1
+    cmp r7, #0x6
+    blt spi_cbr_next_delay_s
+    b   spi_cbr_next_clkrate
+
+spi_cbr_end:
+    ldr r0, =0x1e620094
+    str r8, [r0]
+    ldr r0, =0x1e620010
+    mov r1, #0x0
+    str r1, [r0]
+
+platform_exit4:
+
+    /* restore lr */
+    mov lr, r4
+
+    /* back to arch calling code */
+    mov pc, lr
diff --git a/board/aspeed/ast2400/rc4.c b/board/aspeed/ast2400/rc4.c
new file mode 100755
index 0000000..32e0ffa
--- /dev/null
+++ b/board/aspeed/ast2400/rc4.c
@@ -0,0 +1,68 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+struct rc4_state
+{
+    int x, y, m[256];
+};
+
+void rc4_setup( struct rc4_state *s, unsigned char *key,  int length )
+{
+    int i, j, k, *m, a;
+
+    s->x = 0;
+    s->y = 0;
+    m = s->m;
+
+    for( i = 0; i < 256; i++ )
+    {
+        m[i] = i;
+    }
+
+    j = k = 0;
+
+    for( i = 0; i < 256; i++ )
+    {
+        a = m[i];
+        j = (unsigned char) ( j + a + key[k] );
+        m[i] = m[j]; m[j] = a;
+        if( ++k >= length ) k = 0;
+    }
+}
+
+void rc4_crypt( struct rc4_state *s, unsigned char *data, int length )
+{ 
+    int i, x, y, *m, a, b;
+
+    x = s->x;
+    y = s->y;
+    m = s->m;
+
+    for( i = 0; i < length; i++ )
+    {
+        x = (unsigned char) ( x + 1 ); a = m[x];
+        y = (unsigned char) ( y + a );
+        m[x] = b = m[y];
+        m[y] = a;
+        data[i] ^= m[(unsigned char) ( a + b )];
+    }
+
+    s->x = x;
+    s->y = y;
+}
+
+void rc4_crypt_sw(unsigned char *data, int ulMsgLength, unsigned char *rc4_key, unsigned long ulKeyLength )
+{
+    struct rc4_state s;
+    
+    rc4_setup( &s, rc4_key, ulKeyLength );
+                                    
+    rc4_crypt( &s, data, ulMsgLength );    
+}
diff --git a/board/aspeed/ast2400/regtest.c b/board/aspeed/ast2400/regtest.c
new file mode 100755
index 0000000..1cd75ae
--- /dev/null
+++ b/board/aspeed/ast2400/regtest.c
@@ -0,0 +1,91 @@
+/*
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Diagnostics support
+ */
+#include <common.h>
+#include <command.h>
+#include <post.h>
+#include "slt.h"
+
+#if ((CFG_CMD_SLT & CFG_CMD_REGTEST) && defined(CONFIG_SLT))
+#include "regtest.h"
+
+int do_regtest (void)
+{
+	_SOCRegTestInfo	*pjSOCRegInfo;
+	_SOCRegTestTbl *pjRegTable;
+	unsigned long ulRegBase;
+        unsigned long ulIndex, ulBack, ulAND, ulMask, ulData, ulTemp;
+        unsigned long Flags = 0;
+	
+	/* unlock reg */
+        *(unsigned long *) (0x1e600000) = 0xaeed1a03;	/* AHBC */
+        *(unsigned long *) (0x1e6e0000) = 0xfc600309;	/* MMC */
+        *(unsigned long *) (0x1e6e2000) = 0x1688a8a8;	/* SCU */
+
+        /* SCU */
+
+        /* do test */	
+        pjSOCRegInfo = SOCRegTestInfo;
+        while (strcmp(pjSOCRegInfo->jName, "END"))
+        {
+            /* Reg. Test Start */
+            ulRegBase = pjSOCRegInfo->ulRegOffset;
+            pjRegTable = pjSOCRegInfo->pjTblIndex;
+            
+            while (pjRegTable->ulIndex != 0xFFFFFFFF)
+            {
+                ulIndex = ulRegBase + pjRegTable->ulIndex;	
+
+                ulBack = *(unsigned long *) (ulIndex);
+
+                ulMask  = pjRegTable->ulMask;
+                ulAND  = ~pjRegTable->ulMask;
+       	        	    	
+                ulData  = 0xFFFFFFFF & pjRegTable->ulMask;
+                *(unsigned long *) (ulIndex) = ulData;                
+                ulTemp = *(volatile unsigned long *) (ulIndex) & pjRegTable->ulMask;
+                if (ulData != ulTemp)
+                {
+                    Flags |= pjSOCRegInfo->ulFlags;
+                    printf("[DBG] RegTest: Failed Index:%x, Data:%x, Temp:%x \n", ulIndex, ulData, ulTemp);
+                }
+                
+                ulData  = 0x00000000 & pjRegTable->ulMask;
+                *(unsigned long *) (ulIndex) = ulData;                
+                ulTemp = *(volatile unsigned long *) (ulIndex) & pjRegTable->ulMask;
+                if (ulData != ulTemp)
+                {
+                    Flags |= pjSOCRegInfo->ulFlags;
+                    printf("[DBG] RegTest: Failed Index:%x, Data:%x, Temp:%x \n", ulIndex, ulData, ulTemp);
+                }
+                             
+                *(unsigned long *) (ulIndex) = ulBack;
+       
+                pjRegTable++;
+          	
+           } /* Individual Reg. Test */
+
+           if (Flags & pjSOCRegInfo->ulFlags)
+               printf("[INFO] RegTest: %s Failed \n", pjSOCRegInfo->jName);
+           
+           pjSOCRegInfo++;
+           
+        } /* Reg. Test */
+
+	return Flags;
+	
+}
+
+#endif /* CONFIG_SLT */
diff --git a/board/aspeed/ast2400/regtest.h b/board/aspeed/ast2400/regtest.h
new file mode 100755
index 0000000..49a360e
--- /dev/null
+++ b/board/aspeed/ast2400/regtest.h
@@ -0,0 +1,255 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+typedef struct {
+    unsigned long ulIndex;
+    unsigned long ulMask;
+} _SOCRegTestTbl;
+
+typedef struct {
+    unsigned char jName[10];
+    unsigned long ulRegOffset;
+    _SOCRegTestTbl *pjTblIndex;
+    unsigned long ulFlags;
+} _SOCRegTestInfo;
+
+_SOCRegTestTbl SMCRegTestTbl[] = {
+    {0x00000000, 0x00001FF3},
+    {0x00000004, 0xFFFFFFFF},
+    {0x00000008, 0x0FFF17FF},
+    {0x0000000C, 0xFFFFFFFF},
+    {0x00000010, 0xFF5FFFF3},
+    {0x00000018, 0x0FFFFFFF},
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl AHBCRegTestTbl[] = {
+    {0x00000080, 0x0000FFFE},        	
+    {0x00000088, 0x01000000},
+    {0x0000008c, 0x00000031},	
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl MICRegTestTbl[] = {
+/*	
+    {0x00000000, 0x0FFFFFF8},
+    {0x00000004, 0x0FFFFFF8},
+    {0x00000008, 0x0000FFFF},
+    {0x0000000C, 0x0FFFF000},
+    {0x00000010, 0xFFFFFFFF},
+*/
+    {0xFFFFFFFF, 0xFFFFFFFF},
+};
+
+_SOCRegTestTbl MAC1RegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl MAC2RegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl USB2RegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl VICRegTestTbl[] = {
+    {0x0000000C, 0xFFFFFFFF},
+    {0x00000024, 0xFFFFFFFF},
+    {0x00000028, 0xFFFFFFFF},
+    {0x0000002C, 0xFFFFFFFF},
+    {0xFFFFFFFF, 0xFFFFFFFF},
+};
+
+_SOCRegTestTbl MMCRegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl USB11RegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl SCURegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl HASERegTestTbl[] = {
+    {0x00000000, 0x0FFFFFF8},
+    {0x00000004, 0x0FFFFFF8},
+    {0x00000008, 0x0FFFFFF8},
+    {0x0000000C, 0x0FFFFFF8},
+    //{0x00000010, 0x00001FFF},
+    {0x00000020, 0x0FFFFFF8},
+    {0x00000024, 0x0FFFFFF8},
+    {0x00000028, 0x0FFFFFc0},
+    {0x0000002C, 0x0FFFFFFF},
+    //{0x00000030, 0x000003FF},
+    {0xFFFFFFFF, 0xFFFFFFFF},
+};
+
+_SOCRegTestTbl I2SRegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl CRTRegTestTbl[] = {
+/*	
+    {0x00000000, 0x001F3703},
+    {0x00000004, 0x0000FFC1},
+*/    
+    {0x00000010, 0x0FFF0FFF},
+    {0x00000014, 0x0FFF0FFF},
+    {0x00000018, 0x07FF07FF},
+    {0x0000001C, 0x07FF07FF},
+    {0x00000020, 0x0FFFFFF8},
+    {0x00000024, 0x07FF3FF8},
+/*    
+    {0x00000028, 0x003F003F},
+    {0x00000030, 0x003F003F},
+    {0x00000034, 0x0FFF0FFF},
+    {0x00000038, 0x0FFFFFF8},
+*/    
+    {0x00000040, 0x0FFF0FFF},
+    {0x00000044, 0x07FF07FF},
+    {0x00000048, 0x0FFFFFF8},
+    {0x0000004C, 0x00FF07F8},
+    {0x00000050, 0x000F0F0F},
+/*    
+    {0x00000060, 0x001F3703},
+    {0x00000064, 0x0000FFC1},
+*/    
+    {0x00000070, 0x0FFF0FFF},
+    {0x00000074, 0x0FFF0FFF},
+    {0x00000078, 0x07FF07FF},
+    {0x0000007C, 0x07FF07FF},
+    {0x00000080, 0x0FFFFFF8},
+    {0x00000084, 0x07FF3FF8},
+/*    
+    {0x00000088, 0x003F003F},
+    {0x00000090, 0x003F003F},
+    {0x00000094, 0x0FFF0FFF},
+    {0x00000098, 0x0FFFFFF8},
+*/    
+    {0x000000A0, 0x0FFF0FFF},
+    {0x000000A4, 0x07FF07FF},
+    {0x000000A8, 0x0FFFFFF8},
+    {0x000000AC, 0x00FF07F8},
+    {0x000000B0, 0x000F0F0F},
+    {0xFFFFFFFF, 0xFFFFFFFF},
+};
+
+_SOCRegTestTbl VIDEORegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl A2PRegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl MDMARegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl M2DRegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl GPIORegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl RTCRegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl TIMERRegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl UART1RegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl UART2RegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl WDTRegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl PWMRegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl VUART1RegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl VUART2RegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl LPCRegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl I2CRegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl PECIRegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl PCIARegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+_SOCRegTestTbl PCIRegTestTbl[] = {
+    {0xFFFFFFFF, 0xFFFFFFFF},        	
+};
+
+
+/* Test List */
+_SOCRegTestInfo SOCRegTestInfo[] = {
+    /* Test Name, Reg. Offset,      Test Table, Error Code  */
+    {   "SMCREG", 0x16000000,    SMCRegTestTbl, 0x00000001},
+    {  "AHBCREG", 0x1e600000,   AHBCRegTestTbl, 0x00000002},
+    {   "MICREG", 0x1e640000,    MICRegTestTbl, 0x00000004},
+    {  "MAC1REG", 0x1e660000,   MAC1RegTestTbl, 0x00000008},
+    {  "MAC2REG", 0x1e680000,   MAC2RegTestTbl, 0x00000010},
+    {  "USB2REG", 0x1e6a0000,   USB2RegTestTbl, 0x00000020},
+    {   "VICREG", 0x1e6c0000,    VICRegTestTbl, 0x00000040},
+    {   "MMCREG", 0x1e6e0000,    MMCRegTestTbl, 0x00000080},
+    { "USB11REG", 0x1e6e1000,  USB11RegTestTbl, 0x00000100},
+    {   "SCUREG", 0x1e6e2000,    SCURegTestTbl, 0x00000200},
+    {  "HASEREG", 0x1e6e3000,   HASERegTestTbl, 0x00000400},
+    {   "I2SREG", 0x1e6e5000,    I2SRegTestTbl, 0x00000800},
+    {   "CRTREG", 0x1e6e6000,    CRTRegTestTbl, 0x00001000},
+    { "VIDEOREG", 0x1e700000,  VIDEORegTestTbl, 0x00002000},
+    {   "A2PREG", 0x1e720000,    A2PRegTestTbl, 0x00004000},
+    {  "MDMAREG", 0x1e740000,   MDMARegTestTbl, 0x00008000},
+    {    "2DREG", 0x1e760000,    M2DRegTestTbl, 0x00010000},
+    {  "GPIOREG", 0x1e780000,   GPIORegTestTbl, 0x00020000},
+    {   "RTCREG", 0x1e781000,    RTCRegTestTbl, 0x00040000},
+    { "TIMERREG", 0x1e782000,  TIMERRegTestTbl, 0x00080000},
+    { "UART1REG", 0x1e783000,  UART1RegTestTbl, 0x00100000},
+    { "UART2REG", 0x1e784000,  UART2RegTestTbl, 0x00200000},
+    {   "WDTREG", 0x1e785000,    WDTRegTestTbl, 0x00400000},
+    {   "PWMREG", 0x1e786000,    PWMRegTestTbl, 0x00800000},
+    {"VUART1REG", 0x1e787000, VUART1RegTestTbl, 0x01000000},
+    {"VUART2REG", 0x1e788000, VUART2RegTestTbl, 0x02000000},
+    {   "LPCREG", 0x1e789000,    LPCRegTestTbl, 0x04000000},
+    {   "I2CREG", 0x1e78A000,    I2CRegTestTbl, 0x08000000},
+    {  "PECIREG", 0x1e78B000,   PECIRegTestTbl, 0x10000000},
+    {  "PCIAREG", 0x1e78C000,   PCIARegTestTbl, 0x20000000},
+    {   "PCIREG", 0x60000000,    PCIRegTestTbl, 0x40000000},        
+    {      "END", 0xffffffff,             NULL, 0xffffffff}
+};
diff --git a/board/aspeed/ast2400/slt.c b/board/aspeed/ast2400/slt.c
new file mode 100755
index 0000000..3283d34
--- /dev/null
+++ b/board/aspeed/ast2400/slt.c
@@ -0,0 +1,105 @@
+/*
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Diagnostics support
+ */
+#include <common.h>
+#include <command.h>
+#include <post.h>
+#include "slt.h"
+
+#if defined (CONFIG_SLT)
+
+int do_slt (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+    int flags = 0;
+    int loop  = 1;
+	
+    if (argc > 1) {
+        loop = simple_strtoul(argv[1], NULL, 10);
+    }
+	
+    do {
+
+do_slt_start:
+	/* Reg. Test */
+#if (CFG_CMD_SLT & CFG_CMD_REGTEST)
+	if (do_regtest())
+	{
+	    flags |= FLAG_REGTEST_FAIL;	
+            printf("[INFO] RegTest Failed \n");
+	}    
+	else
+            printf("[INFO] RegTest Passed \n");
+#endif
+#if (CFG_CMD_SLT & CFG_CMD_MACTEST)
+	if (do_mactest())
+	{
+	    flags |= FLAG_MACTEST_FAIL;	
+            printf("[INFO] MACTest Failed \n");
+	}    
+	else
+            printf("[INFO] MACTest Passed \n");
+#endif
+#if (CFG_CMD_SLT & CFG_CMD_VIDEOTEST)
+	if (do_videotest())
+	{
+	    flags |= FLAG_VIDEOTEST_FAIL;	
+            printf("[INFO] VideoTest Failed \n");
+	}    
+	else
+            printf("[INFO] VideoTest Passed \n");
+#endif
+#if (CFG_CMD_SLT & CFG_CMD_HACTEST)
+	if (do_hactest())
+	{
+	    flags |= FLAG_HACTEST_FAIL;	
+            printf("[INFO] HACTest Failed \n");
+	}    
+	else
+            printf("[INFO] HACTest Passed \n");
+#endif
+#if (CFG_CMD_SLT & CFG_CMD_MICTEST)
+	if (do_mictest())
+	{
+	    flags |= FLAG_MICTEST_FAIL;	
+            printf("[INFO] MICTest Failed \n");
+	}    
+	else
+            printf("[INFO] MICTest Passed \n");
+#endif
+	
+	/* Summary */
+	if (flags)
+            printf ("[INFO] SLT Test Failed!! \n");
+        else
+            printf ("[INFO] SLT Test Passed!! \n");    
+       
+        if (loop == 0)			/* infinite */
+            goto do_slt_start;
+        else
+            loop--;    
+            
+    } while (loop);
+
+    return 0;
+}
+/***************************************************/
+
+U_BOOT_CMD(
+	slt,	CONFIG_SYS_MAXARGS,	0,	do_slt,
+	"slt - slt test program \n",
+	NULL
+);
+
+#endif /* CONFIG_SLT */
diff --git a/board/aspeed/ast2400/slt.h b/board/aspeed/ast2400/slt.h
new file mode 100755
index 0000000..4e650bc
--- /dev/null
+++ b/board/aspeed/ast2400/slt.h
@@ -0,0 +1,29 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#define CFG_CMD_REGTEST		0x00000001
+#define CFG_CMD_MACTEST		0x00000002
+#define CFG_CMD_VIDEOTEST	0x00000004
+#define CFG_CMD_HACTEST		0x00000008
+#define CFG_CMD_MICTEST		0x00000010
+#define CFG_CMD_OSDTEST		0x00000020
+#define CFG_CMD_2DTEST  	0x00000040
+#define CFG_CMD_HWCTEST  	0x00000080
+
+#define FLAG_REGTEST_FAIL  	0x00000001
+#define FLAG_MACTEST_FAIL  	0x00000002
+#define FLAG_VIDEOTEST_FAIL  	0x00000004
+#define FLAG_HACTEST_FAIL  	0x00000008
+#define FLAG_MICTEST_FAIL  	0x00000010
+#define FLAG_OSDTEST_FAIL  	0x00000020
+#define FLAG_2DTEST_FAIL  	0x00000040
+#define FLAG_HWCTEST_FAIL  	0x00000080
+
+
diff --git a/board/aspeed/ast2400/type.h b/board/aspeed/ast2400/type.h
new file mode 100755
index 0000000..f57ee5a
--- /dev/null
+++ b/board/aspeed/ast2400/type.h
@@ -0,0 +1,116 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef _TYPE_H_
+#define _TYPE_H_
+
+	typedef unsigned char               BOOL;
+	typedef unsigned char               UINT8;
+	typedef unsigned short              UINT16;
+	typedef unsigned int                UINT32;
+
+	#define  FLONG                    unsigned long
+	#define  BYTE                     unsigned char
+	#define  INT                      int
+	#define  VOID                     void
+	#define  BOOLEAN                  unsigned short
+	#define  ULONG                    unsigned long
+	#define  USHORT                   unsigned short
+	#define  UCHAR                    unsigned char
+	#define  CHAR                     char
+	#define  LONG                     long
+	#define  PUCHAR                   UCHAR *
+	#define  PULONG                   ULONG *
+
+	#define  FAIL                     1
+
+	#define  intfunc      int386
+
+	#define  outdwport         outpd
+	#define  indwport          inpd
+	#define  outport           outp
+	#define  inport            inp
+
+	//#define     NULL    ((void *)0)
+	#define     FALSE   0
+	#define     TRUE    1
+
+	#define ReadMemoryBYTE(baseaddress,offset)        *(BYTE *)((ULONG)(baseaddress)+(ULONG)(offset))
+	#define ReadMemoryLong(baseaddress,offset)        *(ULONG *)((ULONG)(baseaddress)+(ULONG)(offset))
+	#define ReadMemoryShort(baseaddress,offset)       *(USHORT *)((ULONG)(baseaddress)+(ULONG)(offset))
+	#define WriteMemoryBYTE(baseaddress,offset,data)  *(BYTE *)((ULONG)(baseaddress)+(ULONG)(offset)) = (BYTE)(data)
+	#define WriteMemoryLong(baseaddress,offset,data)  *(ULONG *)((ULONG)(baseaddress)+(ULONG)(offset))=(ULONG)(data)
+	#define WriteMemoryShort(baseaddress,offset,data) *(USHORT *)((ULONG)(baseaddress)+(ULONG)(offset))=(USHORT)(data)
+	#define WriteMemoryLongWithANDData(baseaddress, offset, anddata, data)  *(ULONG *)((ULONG)(baseaddress)+(ULONG)(offset)) = *(ULONG *)((ULONG)(baseaddress)+(ULONG)(offset)) & (ULONG)(anddata) | (ULONG)(data)
+
+	#define WriteMemoryLongWithMASK(baseaddress, offset, data, mask) \
+	*(volatile ULONG *)((ULONG)(baseaddress)+(ULONG)(offset)) = *(volatile ULONG *)(((ULONG)(baseaddress)+(ULONG)(offset)) & (ULONG)(~(mask))) | ((ULONG)(data) & (ULONG)(mask))
+
+	#define ReadMemoryLongHost(baseaddress,offset)        *(volatile ULONG *)((ULONG)(baseaddress)+(ULONG)(offset))
+	#define WriteMemoryLongHost(baseaddress,offset,data)  *(volatile ULONG *)((ULONG)(baseaddress)+(ULONG)(offset))=(ULONG)(data)
+	#define WriteMemoryBYTEHost(baseaddress,offset,data)  *(volatile BYTE *)((ULONG)(baseaddress)+(ULONG)(offset)) = (BYTE)(data)    
+#define WriteMemoryLongWithMASKHost(baseaddress, offset, data, mask)  *(volatile ULONG *)((ULONG)(baseaddress)+(ULONG)(offset)) = (((*(volatile ULONG *)((ULONG)(baseaddress)+(ULONG)(offset)))&(~mask)) | (ULONG)((data)&(mask)))
+    
+	#define ReadMemoryLongClient(baseaddress,offset)        *(volatile ULONG *)((ULONG)(baseaddress)+(ULONG)(offset))
+	#define WriteMemoryLongClient(baseaddress,offset,data)  *(volatile ULONG *)((ULONG)(baseaddress)+(ULONG)(offset))=(ULONG)(data)
+	#define WriteMemoryBYTEClient(baseaddress,offset,data)  *(volatile BYTE *)((ULONG)(baseaddress)+(ULONG)(offset)) = (BYTE)(data)    
+#define WriteMemoryLongWithMASKClient(baseaddress, offset, data, mask)  *(volatile ULONG *)((ULONG)(baseaddress)+(ULONG)(offset)) = (((*(volatile ULONG *)((ULONG)(baseaddress)+(ULONG)(offset)))&(~mask)) | (ULONG)((data)&(mask)))
+
+#ifdef BUF_GLOBALS
+#define BUF_EXT
+#else
+#define BUF_EXT extern
+#endif
+
+BUF_EXT ULONG    g_CAPTURE_VIDEO1_BUF1_ADDR; /* VIDEO1_BUF_1_ADDR*/ 
+BUF_EXT ULONG    g_CAPTURE_VIDEO1_BUF2_ADDR; /* VIDEO1_BUF_2_ADDR*/
+BUF_EXT ULONG    g_VIDEO1_COMPRESS_BUF_ADDR; /* Encode destination address */
+BUF_EXT ULONG    g_VIDEO1_CRC_BUF_ADDR;
+BUF_EXT ULONG    g_VIDEO1_FLAG_BUF_ADDR;
+BUF_EXT ULONG    g_VIDEO1_RC4_BUF_ADDR;
+
+
+BUF_EXT ULONG    g_CAPTURE_VIDEO2_BUF1_ADDR; 
+BUF_EXT ULONG    g_CAPTURE_VIDEO2_BUF2_ADDR; 
+BUF_EXT ULONG    g_VIDEO2_COMPRESS_BUF_ADDR;
+BUF_EXT ULONG    g_VIDEO2_CRC_BUF_ADDR;
+BUF_EXT ULONG    g_VIDEO2_FLAG_BUF_ADDR;
+BUF_EXT ULONG    g_VIDEO2_RC4_BUF_ADDR;
+
+BUF_EXT ULONG    g_VIDEO1_DECODE_BUF_1_ADDR;
+BUF_EXT ULONG    g_VIDEO1_DECODE_BUF_2_ADDR;
+BUF_EXT ULONG    g_VIDEO1_DECOMPRESS_BUF_ADDR;
+BUF_EXT ULONG    g_VIDEO1_DECODE_RC4_BUF_ADDR;
+
+BUF_EXT ULONG    g_VIDEO2_DECODE_BUF_1_ADDR;
+BUF_EXT ULONG    g_VIDEO2_DECODE_BUF_2_ADDR;
+BUF_EXT ULONG    g_VIDEO2_DECOMPRESS_BUF_ADDR;
+BUF_EXT ULONG    g_VIDEO2_DECODE_RC4_BUF_ADDR;
+
+BUF_EXT ULONG    g_CAPTURE_VIDEOM_BUF1_ADDR; 
+BUF_EXT ULONG    g_CAPTURE_VIDEOM_BUF2_ADDR; 
+BUF_EXT ULONG    g_VIDEOM_COMPRESS_BUF_ADDR;
+BUF_EXT ULONG    g_VIDEOM_FLAG_BUF_ADDR;
+BUF_EXT ULONG    g_VIDEOM_RC4_BUF_ADDR;
+
+BUF_EXT ULONG    g_VIDEOM_DECODE_BUF_1_ADDR;
+BUF_EXT ULONG    g_VIDEOM_DECODE_BUF_2_ADDR;
+BUF_EXT ULONG    g_VIDEOM_DECOMPRESS_BUF_ADDR;
+BUF_EXT ULONG    g_VIDEOM_DECODE_RC4_BUF_ADDR;
+
+#ifdef WIN_GLOBALS
+#define WIN_EXT
+#else
+#define WIN_EXT extern
+#endif
+
+WIN_EXT USHORT	g_DefWidth, g_DefHeight;
+   
+#endif
diff --git a/board/aspeed/ast2400/u-boot.lds b/board/aspeed/ast2400/u-boot.lds
new file mode 100755
index 0000000..ff0fe22
--- /dev/null
+++ b/board/aspeed/ast2400/u-boot.lds
@@ -0,0 +1,56 @@
+/*
+ * (C) Copyright 2004
+ * Wolfgang Denk, DENX Software Engineering, <wg@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+/*OUTPUT_FORMAT("elf32-arm", "elf32-arm", "elf32-arm")*/
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x00000000;
+
+	. = ALIGN(4);
+	.text	   :
+	{
+	  cpu/arm926ejs/start.o	(.text)
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss : { *(.bss) }
+	_end = .;
+}
diff --git a/board/aspeed/ast2400/vdef.h b/board/aspeed/ast2400/vdef.h
new file mode 100755
index 0000000..3c99b7e
--- /dev/null
+++ b/board/aspeed/ast2400/vdef.h
@@ -0,0 +1,500 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef _VDEF_H_
+#define _VDEF_H_
+
+#define     VIDEO1                              0
+#define     VIDEO1_ON                           0x01
+#define     VIDEO2                              1
+#define     VIDEO2_ON                           0x02
+
+#define		VIDEOM_ON							0x04
+#define     VIDEOM                              2
+
+#define		CRT_1								0
+#define		CRT_1_ON							0x01
+#define		CRT_2								1
+#define		CRT_2_ON							0x02
+
+#define		SINGLE_CODEC_SINGLE_CAPTURE			0
+#define     AUTO_CODEC_SINGLE_CAPTURE			2
+#define		AUTO_CODEC_AUTO_CAPTURE				3
+
+#define		MAC1_BASE							0x1E660000
+#define     APB_BRIDGE_1_BASE                   0x1E6E0000
+#define     VIDEO_REG_BASE                      0x1E700000
+#define     APB_BRIDGE_2_BASE                   0x1E780000
+
+#define		DRAM_INIT_BASE						0x1E6E0000
+
+#define		SDRAM_PROTECT_REG					0x00
+    #define     SDRAM_WRITE_DISABLE             0
+    #define     SDRAM_WRITE_ENABLE              1
+
+#define		SCU_BASE							0x1E6E0000
+#define		SCU_OFFSET							0x2000
+
+#define		VIC_BASE							0x1E6C0000
+	#define		VIDEO_INT_BIT				7
+
+#define		IRQ_STATUS_REG						0x00
+#define		RAW_INT_STATUS_REG					0x08
+#define		INT_SEL_REG							0x0C
+	#define		FIQ_INT							1
+	#define		IRQ_INT							0	
+#define		INT_EN_REG							0x10
+#define		INT_EN_CLEAR_REG					0x14
+#define		INT_SOFT_REG						0x18
+#define		INT_SOFT_CLEAR_REG					0x1C
+#define		INT_SENSE_REG						0x24
+	#define		LEVEL_SENSE						1
+	#define		EDGE_SENSE						0
+#define		INT_EVENT_REG						0x2C
+	#define		HIGH_LEVEL_SENSE				1
+	#define		LOW_LEVEL_SENSE					0
+
+#define		SCU_HW_TRAPPING_REG					0x70 + SCU_OFFSET
+	#define		CLIENT_MODE_EN_BIT				18
+	#define		CLIENT_MODE_EN_MASK				0x00040000
+		#define		BE_HOST_CHIP				0
+		#define		BE_CLIENT_CHIP				1
+
+#define     SCU_ULOCK_KEY                       0x1688A8A8
+    
+#define     SCU_PROTECT_REG                     0x00 + SCU_OFFSET
+    #define     SCU_WRITE_DISABLE               0
+    #define     SCU_WRITE_ENABLE                1
+
+#define     SCU_CONTROL_REG                     0x04 + SCU_OFFSET    
+	#define     VIDEO_ENGINE_RESET				0x00000040
+		#define     VIDEO_ENGINE_RESET_BIT      6
+		#define     VIDEO_ENGINE_RESET_MASK     0x00000040
+        #define     VIDEO_RESET_EN              1
+        #define     VIDEO_RESET_OFF             0
+
+#define     SCU_CLOCK_SELECTION_REG             0x08 + SCU_OFFSET
+	#define		PORTA_CLOCK_DELAY_MASK			7 << 8	//Video port A output clcok selection
+		#define	PORTA_CLOCK_INV_DELAY_1NS		5 << 8	//Clock inversed and delay ~ 2ns
+		#define	PORTA_CLOCK_INV_DELAY_2NS		6 << 8	//Clock inversed and delay ~ 3ns
+	#define		PORTB_CLOCK_DELAY_MASK			7 << 12	//Video port B output clock delay
+		#define	PORTB_CLOCK_INV_DELAY_1NS		5 << 12	//Clock inversed and delay ~ 3ns
+		#define	PORTB_CLOCK_INV_DELAY_2NS		6 << 12	//Clock inversed and delay ~ 3ns
+	#define		PORTB_CLOCK_SEL					1 << 15 //Video port B clock selection
+		#define	PORTB_FROM_D1CLK				0 << 15
+		#define PORTB_FROM_D2CLK				1 << 15
+	#define		ECLK_CLK_SEL_MASK				(3 << 2)
+		#define	ECLK_FROM_HPLL					(1 << 2)
+
+	#define     D2CLK_CLOCK_SELECTION			0x00020000
+		#define     D2CLK_CLOCK_SELECTION_BIT   17
+		#define     D2CLK_CLOCK_SELECTION_MASK  0x00060000
+		#define		NORMAL_CRT1					0
+        #define     V1CLK_VIDEO1				2
+        #define     V1CLK_VIDEO2				3
+
+#define     SCU_CLOCK_STOP_REG					0x0C + SCU_OFFSET    
+	#define		EN_ECLK							0 << 0	//Enable ECLK (For Video Engine)
+	#define		STOP_ECLK_BIT					0
+	#define		STOP_ECLK_MASK					1 << 0
+	#define		EN_V1CLK						0 << 3  //Enable V1CLK (For Video Capture #1)
+	#define		STOP_V1CLK_BIT					3
+	#define		STOP_V1CLK_MASK					1 << 3
+	#define		EN_D1CLK						0 << 10 //Enable D1CLK (For CRT1)
+	#define		STOP_D1CLK_BIT					10
+	#define		STOP_D1CLK_MASK					1 << 10
+	#define		EN_D2CLK						0 << 11 //Stop D2CLK (For CRT2)
+	#define		STOP_D2CLK						(1 << 11)
+	#define		STOP_D2CLK_BIT					11
+	#define		STOP_D2CLK_MASK					1 << 11
+	#define		EN_V2CLK						0 << 12 //Stop V2CLK (For Video Capture #2)
+	#define		STOP_V2CLK_BIT					12
+	#define		STOP_V2CLK_MASK					1 << 12
+	#define		STOP_HACE_BIT					13
+	#define		EN_HACE							(0 << 13)
+	#define		STOP_HACE_MASK					(1 << 13)
+	#define     EN_I2SCLK						0 << 18
+	#define     STOP_I2SCLK_MASK				1 << 18
+
+#define     SCU_PIN_CTRL1_REG					0x74 + SCU_OFFSET
+	#define		I2C_5_PIN_EN					1 << 12	//Enable I2C #5 PIN
+	#define		I2C_5_PIN_OFF					0 << 12	//Disable I2C #5 PIN
+	#define		I2C_5_PIN_MASK					1 << 12
+	#define		VGA_PIN_OFF						0 << 15 //Enable VGA pins
+	#define		VGA_PIN_MASK					1 << 15
+	#define		VIDEO_PORTA_EN					1 << 16 //Enable Video port A control pins
+	#define		VIDEO_PORTA_MASK				1 << 16
+	#define		VIDEO_PORTB_EN					1 << 17 //Enable Video port B control pins
+	#define		VIDEO_PORTB_MASK				1 << 17
+	#define		VIDEO_VP1_EN					1 << 22 //Enable VP[11:0]
+	#define		VIDEO_VP1_MASK					1 << 22 
+	#define		VIDEO_VP2_EN					1 << 23 //Enable VP[23:12]
+	#define		VIDEO_VP2_MASK					1 << 23
+	#define		I2S_PIN_EN						1 << 29 //Enable I2S function pins
+	#define		I2S_PIN_MASK					1 << 29
+
+#define     SCU_PIN_CTRL2_REG					0x78 + SCU_OFFSET
+	#define		VIDEO_PORTA_SINGLE_EDGE_MASK	1 << 0
+		#define		VIDEO_PORTA_SINGLE_EDGE		1 << 0	//Enable Video port A single mode
+		#define		VIDEO_PORTA_DUAL_EDGE		0 << 0
+	#define		VIDEO_PORTB_SINGLE_EDGE_MASK	1 << 1
+		#define		VIDEO_PORTB_DUAL_EDGE		0 << 1
+		#define		VIDEO_PORTB_SINGLE_EDGE		1 << 1	//Enable Video port B single mode
+
+#define		SCU_M_PLL_PARAM_REG					0x20 + SCU_OFFSET
+
+#define		DRAM_BASE							0x40000000
+
+#define     INPUT_BITCOUNT_YUV444				4
+#define		INPUT_BITCOUNT_YUV420				2
+
+/* HW comment value */
+//PASSWORD
+#define     VIDEO_UNLOCK_KEY                    0x1A038AA8
+#define		SCU_UNLOCK_KEY						0x1688A8A8
+#define		SDRAM_UNLOCK_KEY					0xFC600309
+
+
+//#define     SAMPLE_RATE                                 12000000.0
+#ifdef OSC_NEW
+    #define     SAMPLE_RATE                                 24576000.0
+#else
+    #define     SAMPLE_RATE                                 24000000.0
+#endif
+
+#define     MODEDETECTION_VERTICAL_STABLE_MAXIMUM       0x4
+#define     MODEDETECTION_HORIZONTAL_STABLE_MAXIMUM     0x4
+#define     MODEDETECTION_VERTICAL_STABLE_THRESHOLD     0x4
+#define     MODEDETECTION_HORIZONTAL_STABLE_THRESHOLD   0x8
+
+#define     MODEDETECTION_EDGE_PIXEL_THRES_DIGITAL      2
+#define     MODEDETECTION_EDGE_PIXEL_THRES_ANALOGE      0x0A
+
+#define		MODEDETECTION_OK							0
+#define		MODEDETECTION_ERROR							1
+#define		JUDGE_MODE_ERROR							2
+
+//I2C Loop Count
+#define    LOOP_COUNT                                  1000
+#define    CAN_NOT_FIND_DEVICE                         1
+#define    SET_I2C_DONE                                0
+#define	   I2C_BASE									   0xA000
+#define    AC_TIMING                                   0x77743355
+
+//I2C channel and Devices
+#define     I2C_VIDEO1_EEPROM                           0x2
+#define     I2C_VIDEO2_EEPROM                           0x5
+#define     I2C_VIDEO2_9883                             0x4
+/*
+ULONG    CAPTURE1_ADDRESS =                     0x1000000;
+ULONG    CAPTURE2_ADDRESS =                     0x3000000;
+ULONG    PASS1_ENCODE_SOURCE_ADDRESS =          0x1000000;
+ULONG    PASS1_ENCODE_DESTINATION_ADDRESS =     0x2000000;
+ULONG    Buffer1_DECODE_SOURCE_ADDRESS =        0x1000000;
+ULONG    Buffer2_DECODE_SOURCE_ADDRESS =        0x1400000;
+ULONG    PASS1_DECODE_DESTINATION_ADDRESS =     0x600000;
+ULONG    CAPTURE_2ND_ADDRESS =                  0x1800000;
+ULONG    PASS1_2ND_ENCODE_SOURCE_ADDRESS =      0x1800000;
+ULONG    PASS1_2ND_ENCODE_DESTINATION_ADDRESS = 0x2800000;
+ULONG    PASS1_2ND_DECODE_SOURCE_ADDRESS =      0x1000000;
+ULONG    PASS1_2ND_DECODE_DESTINATION_ADDRESS = 0x600000;
+ULONG    PASS2_ENCODE_SOURCE_ADDRESS =          0x000000;
+ULONG    PASS2_ENCODE_DESTINATION_ADDRESS =     0xC00000;
+ULONG    PASS2_DECODE_SOURCE_ADDRESS =          0xC00000;
+ULONG    PASS2_DECODE_DESTINATION_ADDRESS =     0x600000;
+ULNG    PASS2_DECODE_REFERENCE_ADDRESS =       0x600000;
+*/
+
+typedef struct _CTL_REG_G {
+    ULONG   CompressMode:1;
+    ULONG   SkipEmptyFrame:1;
+    ULONG   MemBurstLen:2;
+    ULONG   LineBufEn:2;
+    ULONG   Unused:26;
+} CTL_REG_G;
+
+
+typedef union _U_CTL_G {
+    ULONG       Value;
+    CTL_REG_G   CtlReg;
+} U_CTL_G;
+
+typedef struct _MODE_DETECTION_PARAM_REG {
+    ULONG   Unused1:8;
+    ULONG   EdgePixelThres:8;
+    ULONG   VerStableMax:4;
+    ULONG   HorStableMax:4;
+    ULONG   VerDiffMax:4;
+    ULONG   HorDiffMax:4;
+} MODE_DETECTION_PARAM_REG;
+
+typedef struct _CRC_PRI_PARAM_REG {
+    ULONG   Enable:1;
+    ULONG   HighBitOnly:1;
+    ULONG   SkipCountMax:6;
+    ULONG   PolyLow:8;
+    ULONG   PolyHigh:16;
+} CRC_PRI_PARAM_REG;
+
+typedef union _U_CRC_PRI_PARAM {
+    ULONG               Value;
+    CRC_PRI_PARAM_REG   CRCPriParam;
+} U_CRC_PRI_PARAM;
+
+typedef struct _CRC_SEC_PARAM_REG {
+    ULONG   Unused1:8;
+    ULONG   PolyLow:8;
+    ULONG   PolyHigh:16;
+} CRC_SEC_PARAM_REG;
+
+typedef union _U_CRC_SEC_PARAM {
+    ULONG               Value;
+    CRC_SEC_PARAM_REG   CRCSecParam;
+} U_CRC_SEC_PARAM;
+
+typedef struct _GENERAL_INFO {
+    BYTE                EnableVideoM;
+    BYTE                CenterMode;
+	BYTE				RC4NoResetFrame;
+	BYTE				RC4TestMode;
+    U_CTL_G             uCtlReg;
+    U_CRC_PRI_PARAM     uCRCPriParam;
+    U_CRC_SEC_PARAM     uCRCSecParam;
+} GENERAL_INFO, *PGENERAL_INFO;
+
+typedef struct _SEQ_CTL_REG {
+    ULONG   Unused1:1;
+    ULONG   Unused2:1;
+    ULONG   Unused3:1;
+    ULONG   CaptureAutoMode:1;
+    ULONG   Unused4:1;
+    ULONG   CodecAutoMode:1;
+    ULONG   Unused5:1;
+    ULONG   WatchDog:1;
+    ULONG   CRTSel:1;
+    ULONG   AntiTearing:1;
+    ULONG   DataType:2;
+    ULONG   Unused6:20;
+} SEQ_CTL_REG;
+
+typedef union _U_SEQ_CTL {
+    ULONG               Value;
+    SEQ_CTL_REG   SeqCtlReg;
+} U_SEQ_CTL;
+
+typedef struct _CTL_REG {
+    ULONG   SrcHsync:1;
+    ULONG   SrcVsync:1;
+    ULONG   ExtSrc:1;
+    ULONG   AnalongExtSrc:1;
+    ULONG   IntTimingGen:1;
+    ULONG   IntDataFrom:1;
+    ULONG   WriteFmt:2;
+    ULONG   VGACursor:1;
+    ULONG   LinearMode:1;
+    ULONG   ClockDelay:2;
+    ULONG   CCIR656Src:1;
+    ULONG   PortClock:1;
+    ULONG   ExtPort:1;        
+    ULONG   Unused1:1;
+    ULONG   FrameRate:8;
+    ULONG   Unused2:8;
+} CTL_REG;
+
+typedef union _U_CTL {
+    ULONG       Value;
+    CTL_REG     CtlReg;
+} U_CTL_REG;
+
+typedef struct _TIMING_GEN_SETTING_H {
+    ULONG   HDEEnd:13;
+    ULONG   Unused1:3;
+    ULONG   HDEStart:13;
+    ULONG   Unused2:3;
+} TIMING_GEN_SETTING_H;
+
+typedef struct _TIMING_GEN_SETTING_V {
+    ULONG   VDEEnd:13;
+    ULONG   Unused1:3;
+    ULONG   VDEStart:13;
+    ULONG   Unused2:3;
+} TIMING_GEN_SETTING_V;
+
+typedef struct _BCD_CTL_REG {
+    ULONG   Enable:1;
+    ULONG   Unused1:15;
+    ULONG   Tolerance:8;
+    ULONG   Unused2:8;
+} BCD_CTL_REG;
+
+typedef union _U_BCD_CTL {
+    ULONG           Value;
+    BCD_CTL_REG     BCDCtlReg;
+} U_BCD_CTL;
+
+typedef struct _COMPRESS_WINDOW_REG {
+    ULONG   VerLine:13;
+    ULONG   Unused1:3;
+    ULONG   HorPixel:13;
+    ULONG   Unused2:3;
+} COMPRESS_WINDOW_REG;
+
+typedef struct _STREAM_BUF_SIZE {
+    ULONG   PacketSize:3;
+    ULONG   RingBufNum:2;
+    ULONG   Unused1:11;
+    ULONG   SkipHighMBThres:7;
+    ULONG   SkipTestMode:2;
+    ULONG   Unused2:7;
+} STREAM_BUF_SIZE;
+
+typedef union _U_STREAM_BUF {
+    ULONG               Value;
+    STREAM_BUF_SIZE     StreamBufSize;
+} U_STREAM_BUF;
+
+
+typedef struct _COMPRESS_CTL_REG {
+    ULONG   JPEGOnly:1; /* True: Jpeg Only mode(Disable VQ), False:Jpeg and VQ mix mode */
+    ULONG   En4VQ:1; /* True: 1, 2, 4 color mode, False: 1,2 color mode */
+    ULONG   CodecMode:1; /* High and best Quantization encoding/decoding setting*/
+    ULONG   DualQuality:1;
+    ULONG   EnBest:1;
+    ULONG   EnRC4:1;
+    ULONG   NorChromaDCTTable:5;
+    ULONG   NorLumaDCTTable:5;
+    ULONG   EnHigh:1;
+    ULONG   TestCtl:2;
+    ULONG   UVFmt:1;
+    ULONG   HufTable:2;
+    ULONG   AlterValue1:5;
+    ULONG   AlterValue2:5;
+} COMPRESS_CTL_REG;
+
+typedef union _U_COMPRESS_CTL {
+    ULONG               Value;
+    COMPRESS_CTL_REG    CompressCtlReg;
+} U_COMPRESS_CTL;
+
+typedef struct _QUANTI_TABLE_LOW_REG {
+    ULONG   ChromaTable:5;
+    ULONG   LumaTable:5;
+    ULONG   Unused1:22;
+} QUANTI_TABLE_LOW_REG;
+
+typedef union _U_CQUANTI_TABLE_LOW {
+    ULONG                   Value;
+    QUANTI_TABLE_LOW_REG    QTableLowReg;
+} U_QUANTI_TABLE_LOW;
+
+typedef struct _QUANTI_VALUE_REG {
+    ULONG   High:15;
+	ULONG	Unused1:1;
+    ULONG   Best:15;
+    ULONG   Unused2:1;
+} QUANTI_VALUE_REG;
+
+typedef union _U_QUANTI_VALUE {
+    ULONG               Value;
+    QUANTI_VALUE_REG    QValueReg;
+} U_QUANTI_VALUE;
+
+typedef struct _BSD_PARAM_REG {
+    ULONG   HighThres:8;
+    ULONG   LowThres:8;
+    ULONG   HighCount:6;
+    ULONG   Unused1:2;
+    ULONG   LowCount:6;
+    ULONG   Unused2:2;
+} BSD_PARAM_REG;
+
+typedef union _U_BSD_PARAM {
+    ULONG           Value;
+    BSD_PARAM_REG   BSDParamReg;
+} U_BSD_PARAM;
+
+typedef struct _VIDEO_INFO {
+    BYTE      ExtADCAct;    /* read from modection register */
+	BYTE	  EnableRC4;
+    BYTE      DownScalingMethod;
+    USHORT    AnalogDifferentialThreshold; /* BCD tolerance */
+    USHORT    DigitalDifferentialThreshold; /* BCD tolerance */
+    USHORT    DstWidth;
+    USHORT    DstHeight;
+    USHORT    SrcWidth;
+    USHORT    SrcHeight;
+    BYTE      HighLumaTable; /* if High and best Jpeg codec enable, use HighLumaTable and HighChromaTable, otherwise HighDeQuantiValue and BestDequantiValue*/
+    BYTE      HighChromaTable;
+    BYTE      HighDeQuantiValue;
+    BYTE      BestDequantiValue;
+    U_SEQ_CTL               uSeqCtlReg;
+    U_CTL_REG               uCtlReg;
+    U_BCD_CTL               uBCDCtlReg;
+    U_STREAM_BUF            uStreamBufSize;
+    U_COMPRESS_CTL          uCompressCtlReg;
+    U_QUANTI_TABLE_LOW      uQTableLowReg;
+    U_QUANTI_VALUE          uQValueReg;
+    U_BSD_PARAM             uBSDParamReg;
+} VIDEO_INFO, *PVIDEO_INFO ;
+
+typedef struct _VIDEOM_SEQ_CTL_REG {
+    ULONG   Unused1:1;  //Bit 0
+    ULONG   Unused2:1;	//Bit 1
+    ULONG   Unused3:1;		//Bit 2
+    ULONG   StreamMode:1;	//Bit 3
+    ULONG   Unused4:1;	//Bit 4
+    ULONG   CodecAutoMode:1;	//Bit 5
+	ULONG	Unused6:1;	//Bit 6
+    ULONG   Unused7:1;	//Bit 7
+    ULONG   SrcSel:1;	//Bit 8
+    ULONG   Unused9:1;	//Bit 9
+    ULONG   DataType:2;  //Bit[11:10]
+    ULONG   Unused12:20;
+} VIDEOM_SEQ_CTL_REG;
+
+typedef union _U_VIDEOM_SEQ_CTL {
+    ULONG					Value;
+    VIDEOM_SEQ_CTL_REG		SeqCtlReg;
+} U_VIDEOM_SEQ_CTL;
+
+typedef struct _VIDEOM_INFO {
+    BYTE      DownScalingMethod;
+    USHORT    AnalogDifferentialThreshold; /* BCD tolerance */
+    USHORT    DigitalDifferentialThreshold; /* BCD tolerance */
+    USHORT    DstWidth;
+    USHORT    DstHeight;
+    USHORT    SrcWidth;
+    USHORT    SrcHeight;
+    BYTE      HighLumaTable; /* if High and best Jpeg codec enable, use HighLumaTable and HighChromaTable, otherwise HighDeQuantiValue and BestDequantiValue*/
+    BYTE      HighChromaTable;
+    BYTE      HighDeQuantiValue;
+    BYTE      BestDequantiValue;
+    BYTE      PacketSize;   //the same as video1 & video2
+    BYTE      RingBufNum;
+	BYTE	  EnableRC4;
+    U_VIDEOM_SEQ_CTL        uSeqCtlReg;
+    U_BCD_CTL               uBCDCtlReg;
+    U_COMPRESS_CTL          uCompressCtlReg;
+    U_QUANTI_TABLE_LOW      uQTableLowReg;
+    U_QUANTI_VALUE          uQValueReg;
+    U_BSD_PARAM             uBSDParamReg;
+} VIDEOM_INFO, *PVIDEOM_INFO ;
+
+typedef struct _VIDEO_MODE_INFO
+{
+    USHORT    X;
+    USHORT    Y;
+    USHORT    ColorDepth;
+    USHORT    RefreshRate;
+    BYTE      ModeIndex;
+} VIDEO_MODE_INFO, *PVIDEO_MODE_INFO;
+
+#endif
+
diff --git a/board/aspeed/ast2400/vesa.h b/board/aspeed/ast2400/vesa.h
new file mode 100755
index 0000000..69aba90
--- /dev/null
+++ b/board/aspeed/ast2400/vesa.h
@@ -0,0 +1,163 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef _VESA_H_
+#define _VESA_H_
+
+typedef enum 
+{
+	VCLK25_175	= 0x00,
+	VCLK28_322	= 0x01,
+	VCLK31_5	= 0x02,
+	VCLK31_574	= 0x03,
+	VCLK32_76	= 0x04,
+	VCLK33_154	= 0x05,
+	VCLK36		= 0x06,
+	VCLK40		= 0x07,
+	VCLK45_978	= 0x08,
+	VCLK49_5	= 0x09,
+	VCLK50		= 0x0A,
+	VCLK52_95	= 0x0B,
+	VCLK56_25	= 0x0C,
+	VCLK65		= 0x0D,
+	VCLK74_48	= 0x0E,
+	VCLK75		= 0x0F,
+	VCLK78_75	= 0x10,
+	VCLK79_373	= 0x11,
+	VCLK81_624	= 0x12,
+	VCLK83_462	= 0x13,
+	VCLK84_715	= 0x14,
+	VCLK94_5	= 0x15,
+	VCLK106_5	= 0x16,
+	VCLK108		= 0x17,
+	VCLK119		= 0x18,
+	VCLK135		= 0x19,
+	VCLK136_358 = 0x1A,
+	VCLK146_25	= 0x1B,
+	VCLK154		= 0x1C,
+	VCLK157_5	= 0x1D,
+	VCLK162		= 0x1E
+} ePIXEL_CLOCK;
+
+typedef struct {
+    USHORT    HorizontalTotal;
+    USHORT    VerticalTotal;
+    USHORT    HorizontalActive;
+    USHORT    VerticalActive;
+    BYTE      RefreshRate;
+    double    HorizontalFrequency;
+    USHORT    HSyncTime;
+    USHORT    HBackPorch;
+    USHORT    VSyncTime;
+    USHORT    VBackPorch;
+    USHORT    HLeftBorder;
+    USHORT    HRightBorder;
+    USHORT    VBottomBorder;
+    USHORT	  VTopBorder;
+	USHORT	  PixelClock;
+	BOOL	  HorPolarity;
+	BOOL	  VerPolarity;
+    BYTE      ADCIndex1;
+    BYTE      ADCIndex2;
+    BYTE      ADCIndex3;
+    BYTE      ADCIndex5;
+    BYTE      ADCIndex6;
+    BYTE      ADCIndex7;
+    BYTE      ADCIndex8;
+    BYTE      ADCIndex9;
+    BYTE      ADCIndexA;
+    BYTE      ADCIndexF;
+    BYTE      ADCIndex15;
+    int       HorizontalShift;
+    int       VerticalShift;
+} VESA_MODE;
+
+#define HOR_POSITIVE 0
+#define HOR_NEGATIVE 1
+#define VER_POSITIVE 0
+#define VER_NEGATIVE 1
+
+#ifdef VESA_GLOBALS
+
+//  Note: Modified for modes which have border issue
+VESA_MODE vModeTable[] = {
+////////////////////////// 60Hz mode
+// 720x480 done
+  {1056, 497,  720,  480,  60, 29.900, 88,  104, 3, 13, 0, 0, 0, 0,	VCLK31_574,  HOR_NEGATIVE, VER_NEGATIVE, 0x41,	0xF0, 0x48, 0x05, 0x20, 0x58, 0x60, 0x60, 0x60,	0x5E, 0xFE,  6,	2},
+// 848x480 done                                                                               
+  {1064, 517,  848,  480,  60, 31.160, 88,  91,  3, 26, 0, 0, 0, 0,	VCLK33_154,  HOR_NEGATIVE, VER_NEGATIVE, 0x42,	0x70, 0x48, 0x05, 0x20, 0x58, 0x60, 0x60, 0x60,	0x5E, 0xFE,  6,	2},
+  {800,  525,  640,  480,  60, 31.469, 96,  40,  2, 25, 1, 1, 8, 8,	VCLK25_175,  HOR_NEGATIVE, VER_NEGATIVE, 0x31,	0xF0, 0x48, 0x05, 0x20, 0x60, 0x60, 0x60, 0x60,	0x5E, 0xFE,  6,	2},
+// 720x576                                                                                    
+  {912,  597,  720,  576,  60, 35.920, 72,  88,  3, 17, 0, 0, 0, 0,	VCLK32_76,   HOR_NEGATIVE, VER_NEGATIVE, 0x38,	0xF0, 0x48, 0x05, 0x20, 0x48, 0x60, 0x60, 0x60,	0x5E, 0xFE,  6,	2},
+// 960x600 GTF done                                                                           
+  {1232, 622,  960,  600,  60, 37.320, 96,  136, 3, 18, 0, 0, 0, 0,	VCLK45_978,  HOR_NEGATIVE, VER_NEGATIVE, 0x4C,	0xF0, 0x60, 0x05, 0x20, 0x60, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	0},
+  {1056, 628,  800,  600,  60, 37.879, 128, 88,  4, 23, 0, 0, 0, 0,	VCLK40,	     HOR_POSITIVE, VER_POSITIVE, 0x41,	0xF0, 0x60, 0x05, 0x20, 0x80, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	0},
+// 1088x612 GTF done                                                                          
+  {1392, 634,  1088, 612,  60, 38.04,  112, 152, 3, 18, 0, 0, 0, 0,	VCLK52_95,   HOR_NEGATIVE, VER_NEGATIVE, 0x56,	0xF0, 0x60, 0x05, 0x20, 0x70, 0x60, 0x60, 0x60, 0x5E, 0xFE, -1, 0},
+// 1280x720 GTF done                                                                          
+  {1664, 746,  1280, 720,  60, 44.760, 136, 192, 3, 22, 0, 0, 0, 0,	VCLK74_48,   HOR_NEGATIVE, VER_NEGATIVE, 0x67,	0xF0, 0xA8, 0x05, 0x20, 0x88, 0x60, 0x60, 0x60, 0x5E, 0xFE, -1, 0},
+// 1360x768 GTF done                                                                          
+  {1776, 795,  1360, 768,  60, 47.700, 144, 208, 3, 23, 0, 0, 0, 0,	VCLK84_715,  HOR_NEGATIVE, VER_NEGATIVE, 0x6E,	0xF0, 0xA8, 0x05, 0x20, 0x90, 0x60, 0x60, 0x60, 0x5E, 0xFE,  7, 1},
+// 1280x768 done                                                                              
+  {1664, 798,  1280, 768,  60, 47.700, 128, 184, 7, 20, 0, 0, 0, 0,	VCLK79_373,  HOR_NEGATIVE, VER_NEGATIVE, 0x67,	0xF0, 0xA8, 0x05, 0x20, 0x80, 0x60, 0x60, 0x60, 0x5E, 0xFE,  7, 1},
+  {1344, 806,  1024, 768,  60, 48.363, 136, 160, 6, 29, 0, 0, 0, 0,	VCLK65,	     HOR_NEGATIVE, VER_NEGATIVE, 0x53,	0xF0, 0xA8, 0x05, 0x20, 0x88, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	7},
+// 1280x800 GTF done                                                                          
+  {1680, 828,  1280, 800,  60, 49.680, 136, 200, 3, 24, 0, 0, 0, 0,	VCLK83_462,  HOR_NEGATIVE, VER_NEGATIVE, 0x68,	0xF0, 0xA8, 0x05, 0x20, 0x88, 0x60, 0x60, 0x60, 0x5E, 0xFE, -1, 0},
+// 1152x864 GTF done                                                                          
+  {1520, 895,  1152, 864,  60, 53.700, 120, 184, 3, 27, 0, 0, 0, 0,	VCLK81_624,  HOR_NEGATIVE, VER_NEGATIVE, 0x5E,	0xF0, 0xA8, 0x05, 0x20, 0x78, 0x60, 0x60, 0x60, 0x5E, 0xFE, -1, 0},
+// 1600x900 GTF done                                                                          
+  {2128, 932,  1600, 900,  60, 55.920, 168, 264, 3, 28, 0, 0, 0, 0,	VCLK119,	 HOR_NEGATIVE, VER_NEGATIVE, 0x84,	0xF0, 0xA8, 0x05, 0x20, 0xA8, 0x60, 0x60, 0x60, 0x5E, 0xFE, -1, 0},
+// 1440X900 CVT done                                                                          
+  {1904, 933,  1440, 900,  60, 55.935, 152, 232, 6,	25,	0, 0, 0, 0,	VCLK106_5,   HOR_NEGATIVE, VER_POSITIVE, 0x76,	0xF0, 0xA8, 0x05, 0x20, 0x96, 0x60, 0x60, 0x60, 0x5E, 0xFE, -1, 0},
+  {1800, 1000, 1280, 960,  60, 60.000, 112, 312, 3, 36, 0, 0, 0, 0,	VCLK108,	 HOR_POSITIVE, VER_POSITIVE, 0x70,	0x70, 0xA8, 0x05, 0x20, 0x70, 0x60, 0x60, 0x60, 0x5E, 0xFE, -1, 0},
+// 1600x1024 GTF done                                                                            
+  {2144, 1060, 1600, 1024, 60, 63.600, 168, 272, 3, 32, 0, 0, 0, 0,	VCLK136_358, HOR_NEGATIVE, VER_NEGATIVE, 0x85,	0xF0, 0xE8, 0x05, 0x20, 0xA8, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	0},
+  {1688, 1066, 1280, 1024, 60, 63.981, 112, 248, 3, 38, 0, 0, 0, 0,	VCLK108,	 HOR_POSITIVE, VER_POSITIVE, 0x69,	0x70, 0xA8, 0x05, 0x20, 0x70, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	0},
+// 1680X1050 CVT done Reduced Blanking                                                          
+  {1840, 1080, 1680, 1050, 60, 64.674, 32,  80,	 6,	21,	0, 0, 0, 0,	VCLK119,	 HOR_POSITIVE, VER_NEGATIVE, 0x72,	0xF0, 0xA8, 0x05, 0x20, 0x20, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	0},
+// 1920X1200 CVT done Reduced Blanking                           
+  {2080, 1235, 1920, 1200, 60, 74.038, 32,  80,  6, 26, 0, 0, 0, 0, VCLK154,     HOR_POSITIVE, VER_NEGATIVE, 0x81,	0xF0, 0xA8, 0x05, 0x20, 0x20, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	0},
+  //{2160,           1250,           1600,           1200, 60,75.000,           192,        304,         3,          46,          0,            0,             0,              0,			VCLK162,		HOR_POSITIVE,	VER_POSITIVE},
+  {2160, 1248, 1600, 1200, 60, 75.000, 192, 304, 3, 46, 0, 0, 0, 0,	VCLK162,	 HOR_POSITIVE, VER_POSITIVE, 0x86,	0xF0, 0xE8, 0x05, 0x20, 0xC0, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	0},
+                                                              
+//////////////////////  Not 60Hz mode                                                                                                                  
+  {900,  449,  720,  400,  70, 31.469, 108, 45,  2, 25, 1, 1, 8, 8,	0,			 HOR_NEGATIVE, VER_NEGATIVE, 0x38,	0x30, 0x48, 0x05, 0x20, 0x6C, 0x60, 0x60, 0x60,	0x5E, 0xFE,  6,	1},
+  {832,  520,  640,  480,  72, 37.861, 40,  120, 3, 20, 1, 1, 8, 8,	0,			 HOR_NEGATIVE, VER_NEGATIVE, 0x33,	0xF0, 0x48, 0x05, 0x20, 0x28, 0x60, 0x60, 0x60,	0x5E, 0xFE,  6,	3},
+  {840,  500,  640,  480,  75, 37.500, 64,  120, 3, 16, 0, 0, 0, 0,	0,			 HOR_NEGATIVE, VER_NEGATIVE, 0x34,	0x70, 0x48, 0x05, 0x20, 0x40, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	3},                                         
+  {832,  509,  640,  480,  85, 43.269, 56,  80,  3, 25, 0, 0, 0, 0,	0,			 HOR_NEGATIVE, VER_NEGATIVE, 0x33,	0xF0, 0x48, 0x05, 0x20, 0x38, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	3},
+  {1024, 625,  800,  600,  56, 35.156, 72,  128, 2, 22, 0, 0, 0, 0,	0,			 HOR_POSITIVE, VER_POSITIVE, 0x3F,	0xF0, 0x60, 0x05, 0x20, 0x48, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	0},
+  {1040, 666,  800,  600,  72, 48.077, 120, 64,  6, 23, 0, 0, 0, 0,	0,			 HOR_POSITIVE, VER_POSITIVE, 0x40,	0xF0, 0x60, 0x05, 0x20, 0x78, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	0},
+  {1056, 625,  800,  600,  75, 46.875, 80,  160, 3, 21, 0, 0, 0, 0,	0,			 HOR_POSITIVE, VER_POSITIVE, 0x41,	0xF0, 0x60, 0x05, 0x20, 0x50, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	0},
+  {1048, 631,  800,  600,  85, 53.674, 64,  152, 3, 27, 0, 0, 0, 0,	0,			 HOR_POSITIVE, VER_POSITIVE, 0x41,	0x70, 0x60, 0x05, 0x20, 0x40, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	0},
+  {1328, 806,  1024, 768,  70, 56.476, 136, 144, 6, 29, 0, 0, 0, 0,	0,			 HOR_NEGATIVE, VER_NEGATIVE, 0x52,	0xF0, 0xA8, 0x05, 0x20, 0x88, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	7},
+  {1312, 800,  1024, 768,  75, 60.023, 96,  176, 3, 28, 0, 0, 0, 0,	0,			 HOR_POSITIVE, VER_POSITIVE, 0x51,	0xF0, 0xA8, 0x05, 0x20, 0x60, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	1},
+  {1376, 808,  1024, 768,  85, 68.677, 96,  208, 3, 36, 0, 0, 0, 0,	0,			 HOR_POSITIVE, VER_POSITIVE, 0x55,	0xF0, 0xA8, 0x05, 0x20, 0x60, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	1},
+  {1600, 900,  1152, 864,  75, 67.500, 128, 256, 3, 32, 0, 0, 0, 0,	0,			 HOR_POSITIVE, VER_POSITIVE, 0x63,	0xF0, 0xA8, 0x05, 0x20, 0x80, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	0},
+  {1728, 1011, 1280, 960,  85, 85.938, 160, 224, 3, 47, 0, 0, 0, 0,	0,			 HOR_POSITIVE, VER_POSITIVE, 0x6B,	0xF0, 0xA8, 0x05, 0x20, 0xA0, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	0},
+  {1688, 1066, 1280, 1024, 75, 79.976, 144, 248, 3, 38, 0, 0, 0, 0,	0,			 HOR_POSITIVE, VER_POSITIVE, 0x69,	0x70, 0xE8, 0x05, 0x20, 0x90, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	0},
+  {1728, 1072, 1280, 1024, 85, 91.146, 160, 224, 3, 44, 0, 0, 0, 0,	0,			 HOR_POSITIVE, VER_POSITIVE, 0x6B,	0xF0, 0xA8, 0x05, 0x20, 0xA0, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	0},
+  {2160, 1250, 1600, 1200, 65, 81.250, 192, 304, 3, 46, 0, 0, 0, 0,	0,			 HOR_POSITIVE, VER_POSITIVE, 0x86,	0xF0, 0xA8, 0x05, 0x20, 0xC0, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	0},
+  {2160, 1250, 1600, 1200, 70, 87.500, 192, 304, 3, 46, 0, 0, 0, 0,	0,			 HOR_POSITIVE, VER_POSITIVE, 0x86,	0xF0, 0xA8, 0x05, 0x20, 0xC0, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	0},
+  {2160, 1250, 1600, 1200, 75, 93.750, 192, 304, 3, 46, 0, 0, 0, 0,	0,			 HOR_POSITIVE, VER_POSITIVE, 0x86,	0xF0, 0xA8, 0x05, 0x20, 0xC0, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	0},
+  {2160, 1250, 1600, 1200, 85, 106.250,192, 304, 3, 46, 0, 0, 0, 0,	0,			 HOR_POSITIVE, VER_POSITIVE, 0x86,	0xF0, 0xA8, 0x05, 0x20, 0xC0, 0x60, 0x60, 0x60,	0x5E, 0xFE, -1,	0}
+};
+
+USHORT  ModeNumberCount = sizeof (vModeTable) / sizeof (VESA_MODE);
+USHORT  Mode60HZCount = 21;
+
+#else  /* NOT VESA_GLOBALS */
+extern VESA_MODE vModeTable[];
+extern USHORT  ModeNumberCount;
+extern USHORT  Mode60HZCount;
+#endif
+
+#endif /* _VESA_H_ */
+
+
diff --git a/board/aspeed/ast2400/vfun.c b/board/aspeed/ast2400/vfun.c
new file mode 100755
index 0000000..f707e80
--- /dev/null
+++ b/board/aspeed/ast2400/vfun.c
@@ -0,0 +1,545 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#define BUF_GLOBALS
+#include "type.h"
+#include "vdef.h"
+#include "vreg.h"
+#include "crt.h"
+#include "vfun.h"
+
+ULONG UnlockSCURegHost(ULONG   MMIOBase, ULONG Key)
+{
+    WriteMemoryLongHost(SCU_BASE, SCU_PROTECT_REG, Key);
+    return ReadMemoryLongHost(SCU_BASE,SCU_PROTECT_REG);
+}
+
+void ResetVideoHost(void)
+{
+	WriteMemoryLongWithMASKHost(SCU_BASE, SCU_CONTROL_REG, VIDEO_RESET_EN << VIDEO_ENGINE_RESET_BIT, VIDEO_ENGINE_RESET_MASK);
+	WriteMemoryLongWithMASKHost(SCU_BASE, SCU_CONTROL_REG, VIDEO_RESET_OFF << VIDEO_ENGINE_RESET_BIT, VIDEO_ENGINE_RESET_MASK);
+}
+
+void StartModeDetectionTriggerHost(ULONG   MMIOBase, ULONG offset)
+{
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, offset, 0, MODE_DETECTION_TRIGGER);
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, offset, MODE_DETECTION_TRIGGER, MODE_DETECTION_TRIGGER);
+}
+
+BOOL ReadVideoInterruptHost(ULONG   MMIOBase, ULONG value)
+{
+    return ((ReadMemoryLongHost(VIDEO_REG_BASE, VIDEO_INT_CONTROL_READ_REG) & value) ? TRUE : FALSE);
+}
+
+ULONG UnlockVideoRegHost(ULONG   MMIOBase, ULONG Key)
+{
+    WriteMemoryLongHost(VIDEO_REG_BASE, KEY_CONTROL_REG, Key);
+    return ReadMemoryLongHost(VIDEO_REG_BASE,KEY_CONTROL_REG);
+}
+
+void StartVideoCaptureTriggerHost(ULONG   MMIOBase, ULONG offset)
+{
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, offset, 0, VIDEO_CAPTURE_TRIGGER);
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, offset, VIDEO_CAPTURE_TRIGGER, VIDEO_CAPTURE_TRIGGER);
+}
+
+void StartVideoCodecTriggerHost(ULONG   MMIOBase, ULONG offset)
+{
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, offset, 0, VIDEO_CODEC_TRIGGER);
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, offset, VIDEO_CODEC_TRIGGER, VIDEO_CODEC_TRIGGER);
+}
+
+void StopModeDetectionTriggerHost(ULONG   MMIOBase, ULONG offset)
+{
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, offset, 0, MODE_DETECTION_TRIGGER);
+}
+
+void ClearVideoInterruptHost(ULONG   MMIOBase, ULONG value)
+{
+    //WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO_INT_CONTROL_CLEAR_REG, value, value);
+	WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO_INT_CONTROL_CLEAR_REG, value);
+}
+
+/* UnLock SCU Host and Reset Engine */
+BOOL CheckOnStartHost(void)
+{
+    int i=0, dwValue=0;
+    
+    do
+    {
+	dwValue = UnlockSCURegHost(0, SCU_UNLOCK_KEY);
+	i++;
+    }
+    while ((SCU_WRITE_ENABLE != dwValue) && (i<10));
+
+    //Clear SCU Reset Register
+    WriteMemoryLongHost(SCU_BASE, SCU_CONTROL_REG, 0);
+
+    WriteMemoryLongWithMASKHost(SCU_BASE, SCU_CLOCK_STOP_REG, (EN_ECLK | EN_V1CLK | EN_V2CLK), (STOP_ECLK_MASK | STOP_V1CLK_MASK | STOP_V2CLK_MASK));
+
+#if	defined(CONFIG_AST2300)
+    WriteMemoryLongWithMASKHost(SCU_BASE, (0x90 + SCU_OFFSET), 0x00000020, 0x00000030);	//enable 24bits
+    WriteMemoryLongWithMASKHost(SCU_BASE, (0x88 + SCU_OFFSET), 0x000fff00, 0x000fff00);	//enable video multi-pins    
+#else	//AST2100 
+    //WriteMemoryLongWithMASKHost(SCU_BASE, SCU_PIN_CTRL1_REG, (VIDEO_PORTA_EN | VIDEO_PORTB_EN | VIDEO_VP1_EN | VIDEO_VP2_EN) , 
+    //							(VIDEO_PORTA_MASK | VIDEO_PORTB_MASK | VIDEO_VP1_MASK | VIDEO_VP2_MASK));
+    WriteMemoryLongWithMASKHost(SCU_BASE, SCU_PIN_CTRL2_REG, (VIDEO_PORTA_SINGLE_EDGE | VIDEO_PORTB_SINGLE_EDGE) , 
+	      						     (VIDEO_PORTA_SINGLE_EDGE_MASK | VIDEO_PORTB_SINGLE_EDGE_MASK));
+#endif	      						     
+
+    ResetVideoHost();
+
+    return TRUE;
+}
+
+BOOL CheckOnStartClient(void)
+{
+	int i=0, dwValue=0;
+    
+	do
+	{
+		dwValue = UnlockSCURegHost(0, SCU_UNLOCK_KEY);
+		i++;
+	}
+	while ((SCU_WRITE_ENABLE != dwValue) && (i<10));
+
+	//Clear SCU Reset Register
+	WriteMemoryLongClient(SCU_BASE, SCU_CONTROL_REG, 0);
+
+	WriteMemoryLongWithMASKClient(SCU_BASE, SCU_CLOCK_STOP_REG, (EN_ECLK | EN_V1CLK | EN_D1CLK | EN_D2CLK | EN_V2CLK), 
+								  (STOP_ECLK_MASK | STOP_D1CLK_MASK | STOP_D2CLK_MASK | STOP_V1CLK_MASK | STOP_V2CLK_MASK));
+
+	//WriteMemoryLongWithMASKClient(SCU_BASE, SCU_CLOCK_SELECTION_REG, PORTB_FROM_D2CLK | PORTB_CLOCK_INV_DELAY_3NS | PORTA_CLOCK_INV_DELAY_3NS, PORTB_CLOCK_SEL | PORTB_CLOCK_DELAY_MASK | PORTA_CLOCK_DELAY_MASK);
+	//A1EVA
+	WriteMemoryLongWithMASKClient(SCU_BASE, SCU_CLOCK_SELECTION_REG, (PORTB_FROM_D2CLK | PORTB_CLOCK_INV_DELAY_1NS | PORTA_CLOCK_INV_DELAY_1NS), (PORTB_CLOCK_SEL | PORTB_CLOCK_DELAY_MASK | PORTA_CLOCK_DELAY_MASK));
+	WriteMemoryLongWithMASKClient(SCU_BASE, 0x202C, (0x03<<9), (0x03<<9));
+
+	WriteMemoryLongWithMASKClient(SCU_BASE, SCU_PIN_CTRL1_REG, (VIDEO_PORTA_EN | VIDEO_PORTB_EN | VIDEO_VP1_EN | VIDEO_VP2_EN), 
+								  (VIDEO_PORTA_MASK | VIDEO_PORTB_MASK | VIDEO_VP1_MASK | VIDEO_VP2_MASK));
+
+#if CONFIG_AST3000
+	WriteMemoryLongWithMASKClient(SCU_BASE, SCU_PIN_CTRL2_REG, (VIDEO_PORTA_DUAL_EDGE | VIDEO_PORTB_DUAL_EDGE), 
+								  (VIDEO_PORTA_SINGLE_EDGE_MASK | VIDEO_PORTB_SINGLE_EDGE_MASK));
+#else
+	//2100 is single edge
+	WriteMemoryLongWithMASKClient(SCU_BASE, SCU_PIN_CTRL2_REG, (VIDEO_PORTA_SINGLE_EDGE | VIDEO_PORTB_SINGLE_EDGE), 
+								  (VIDEO_PORTA_SINGLE_EDGE_MASK | VIDEO_PORTB_SINGLE_EDGE_MASK));
+#endif
+
+	WriteMemoryLongWithMASKClient(SCU_BASE, SCU_CLOCK_STOP_REG, (EN_D1CLK | EN_D2CLK), (STOP_D1CLK_MASK | STOP_D2CLK_MASK));
+	WriteMemoryLongWithMASKClient(SCU_BASE, SCU_PIN_CTRL1_REG, VGA_PIN_OFF, VGA_PIN_MASK);
+
+    //ResetVideoHost();
+
+	return TRUE;
+}
+
+ULONG  InitializeVideoEngineHost (ULONG                MMIOBase,
+                               int                  nVideo,
+							   BOOL					HorPolarity,
+							   BOOL					VerPolarity)
+{
+    //ULONG   temp, temp1, temp2; 
+    ULONG   dwRegOffset = nVideo * 0x100;
+    ULONG   dwValue;
+    int     i;
+
+
+    /* General Video Control */
+    //LineBufEn 0
+    //dwValue = (COMPRESS_MODE << CODEC_DECOMPRESS_MODE_BIT) | DELAY_VSYNC_EN;
+    dwValue = 0;
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO_CONTROL_REG, dwValue);
+    //Video Data Truncation Register
+	WriteMemoryLongHost(VIDEO_REG_BASE, 0x328, 0);
+
+	//D2CLK clock must config according to video's line buffer
+	if (VIDEO1 == nVideo)
+	    dwValue = LINE_BUFFER_VIDEO1;
+    else
+        dwValue = LINE_BUFFER_VIDEO2;
+    
+	//D2CLK clock must config according to video's line buffer
+	switch (dwValue)
+	{
+	case LINE_BUFFER_OFF:
+		WriteMemoryLongWithMASKHost(SCU_BASE, SCU_CLOCK_SELECTION_REG, NORMAL_CRT1, D2CLK_CLOCK_SELECTION_MASK);
+		WriteMemoryLongWithMASKHost(SCU_BASE, SCU_CLOCK_STOP_REG, STOP_D2CLK, STOP_D2CLK_MASK);
+		break;
+	case LINE_BUFFER_VIDEO1:
+		WriteMemoryLongWithMASKHost(SCU_BASE, SCU_CLOCK_SELECTION_REG, V1CLK_VIDEO1 << D2CLK_CLOCK_SELECTION_BIT, D2CLK_CLOCK_SELECTION_MASK);
+		WriteMemoryLongWithMASKHost(SCU_BASE, SCU_CLOCK_STOP_REG, EN_D2CLK, STOP_D2CLK_MASK);
+		break;
+	case LINE_BUFFER_VIDEO2:
+		WriteMemoryLongWithMASKHost(SCU_BASE, SCU_CLOCK_SELECTION_REG, V1CLK_VIDEO2 << D2CLK_CLOCK_SELECTION_BIT, D2CLK_CLOCK_SELECTION_MASK);
+		WriteMemoryLongWithMASKHost(SCU_BASE, SCU_CLOCK_STOP_REG, EN_D2CLK, STOP_D2CLK_MASK);
+		break;
+	case LINE_BUFFER_VIDEOM:
+		//If select this option, it will config at videoM INIT
+		break;
+	default:
+		break;
+	}
+
+    dwValue = 0;
+    //VR30 now is capture window in the compression
+    dwValue = g_DefHeight << CAPTURE_VER_LINE_BIT |
+    g_DefWidth << CAPTURE_HOR_PIXEL_BIT;
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_CAPTURE_WINDOWS_REG + dwRegOffset, dwValue);        
+
+    dwValue = 0;
+    //VR34 now is destionation window in the compression
+	dwValue = g_DefHeight << COMPRESS_VER_LINE_BIT |
+	g_DefWidth << COMPRESS_HOR_PIXEL_BIT;
+
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_COMPRESS_WINDOWS_REG + dwRegOffset, dwValue);        
+
+    //BitCOUNT according compress data format
+    dwValue = YUV444_MODE;
+	if (YUV444_MODE == dwValue)
+		WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_BUF_LINE_OFFSET_REG + dwRegOffset, g_DefWidth * INPUT_BITCOUNT_YUV444, BUF_LINE_OFFSET_MASK);
+	else
+		WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_BUF_LINE_OFFSET_REG + dwRegOffset, g_DefWidth * INPUT_BITCOUNT_YUV420, BUF_LINE_OFFSET_MASK);
+              
+    //  CRC
+    //Disable
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO_CRC_PRIMARY_REG, 0x0);    
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO_CRC_SECOND_REG, 0x0);
+    
+    /* Sequence Control register */
+	//Oonly Encoder need to set
+	/* Engine Sequence Contol Register */
+	dwValue = (WATCH_DOG_EN << WATCH_DOG_ENABLE_BIT) |
+	            VIDEO_CAPTURE_AUTO_MODE |
+	            VIDEO_CODEC_AUTO_MODE;
+    
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_ENGINE_SEQUENCE_CONTROL_REG + dwRegOffset, dwValue);
+    
+    /* Control register */
+	dwValue = (HOR_NEGATIVE == HorPolarity) ? NO_INVERSE_POL : INVERSE_POL;
+	dwValue = (((VER_NEGATIVE == VerPolarity) ? NO_INVERSE_POL : INVERSE_POL) << VIDEO_VSYNC_POLARITY_BIT) | dwValue;
+    
+	/* HW Recommand*/
+	//dwValue = (TILE_MODE << 9) | dwValue;
+	dwValue = (EXTERNAL_VGA_SOURCE << EXTERNAL_SOURCE_BIT) | dwValue;
+    
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_CONTROL_REG + dwRegOffset, dwValue);
+        
+    /* BCD register */
+    //NO BCD
+    dwValue = 0;
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_BCD_CONTROL_REG + dwRegOffset, dwValue);
+
+    /* Stream Buffer Size register */
+    dwValue = (YUV_TEST << SKIP_TEST_MODE_BIT) |
+                (PACKET_SIZE_32KB << STREAM_PACKET_SIZE_BIT) |
+                (PACKETS_8 << RING_BUF_PACKET_NUM_BIT);
+    /* the same with Video1, Video2, and VideoM*/
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_STREAM_BUF_SIZE, dwValue);
+
+    /* Comression control register */
+    dwValue = (USE_UV_CIR656 << UV_CIR656_FORMAT_BIT)|
+                (JPEG_MIX_MODE << JPEG_ONLY_BIT)|
+                (VQ_4_COLOR_MODE << VQ_4_COLOR_BIT)|
+                (QUANTI_CODEC_MODE << QUALITY_CODEC_SETTING_BIT)|
+                (7 << NORMAL_QUANTI_CHROMI_TABLE_BIT) |
+                (23 << NORMAL_QUANTI_LUMI_TABLE_BIT);
+   
+    //Video2 have same value as video1
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_COMPRESS_CONTROL_REG, dwValue);
+
+    /* JPEG Quantization Table register */
+    dwValue = 0;
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_QUANTI_TABLE_LOW_REG, dwValue);
+    
+    /* Quantization value register */
+    //Video2 have same value as video1
+    dwValue = 0;
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_QUANTI_VALUE_REG, dwValue);
+
+    //Video BSD Parameter Register
+    //Video2 have same value as video1
+    dwValue = 0;
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_BSD_PARA_REG, dwValue);
+
+    //no scale
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_SCALE_FACTOR_REG,  0x10001000);
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_SCALE_FACTOR_PARAMETER0_REG, 0x00200000);
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_SCALE_FACTOR_PARAMETER1_REG, 0x00200000);
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_SCALE_FACTOR_PARAMETER2_REG, 0x00200000);
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_SCALE_FACTOR_PARAMETER3_REG, 0x00200000);
+    return TRUE;
+}
+
+ULONG  InitializeVideoEngineClient (ULONG                MMIOBase,
+                               int                  nVideo)
+{
+    //ULONG   temp, temp1, temp2; 
+    ULONG   dwRegOffset = nVideo * 0x100;
+    ULONG   dwValue;
+    int     i;
+
+
+    /* General Video Control */
+    //LineBufEn 0
+    dwValue = (DECOMPRESS_MODE << CODEC_DECOMPRESS_MODE_BIT);
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO_CONTROL_REG, dwValue);
+    //Video Data Truncation Register
+	WriteMemoryLongHost(VIDEO_REG_BASE, 0x328, 0);
+
+    //VR30 now is capture window in the compression
+    dwValue = g_DefHeight << CAPTURE_VER_LINE_BIT |
+    g_DefWidth << CAPTURE_HOR_PIXEL_BIT;
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_CAPTURE_WINDOWS_REG + dwRegOffset, dwValue, CAPTURE_VER_LINE_MASK | CAPTURE_HOR_PIXEL_MASK);        
+
+    //VR34 now is destionation window in the compression
+	dwValue = g_DefHeight << COMPRESS_VER_LINE_BIT |
+	g_DefWidth << COMPRESS_HOR_PIXEL_BIT;
+
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_COMPRESS_WINDOWS_REG + dwRegOffset, dwValue, COMPRESS_VER_LINE_MASK | COMPRESS_HOR_PIXEL_MASK);        
+
+    //BitCOUNT according compress data format
+    dwValue = YUV444_MODE;
+	if (YUV444_MODE == dwValue)
+		WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_BUF_LINE_OFFSET_REG + dwRegOffset, g_DefWidth * INPUT_BITCOUNT_YUV444, BUF_LINE_OFFSET_MASK);
+	else
+		WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_BUF_LINE_OFFSET_REG + dwRegOffset, g_DefWidth * INPUT_BITCOUNT_YUV420, BUF_LINE_OFFSET_MASK);
+              
+    //  CRC
+    //Disable
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO_CRC_PRIMARY_REG, 0x0);    
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO_CRC_SECOND_REG, 0x0);
+    
+    /* Sequence Control register */
+	//Oonly Encoder need to set
+	/* Engine Sequence Contol Register */
+    dwValue = VIDEO_CAPTURE_AUTO_MODE |
+        VIDEO_CODEC_AUTO_MODE;
+    
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_ENGINE_SEQUENCE_CONTROL_REG + dwRegOffset, dwValue);
+    
+    /* Control register */
+	/* HW Recommand*/
+	dwValue = (TILE_MODE << 9); 	
+    
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_CONTROL_REG + dwRegOffset, dwValue);
+        
+    /* BCD register */
+    //NO BCD
+    dwValue = 0;
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_BCD_CONTROL_REG + dwRegOffset, dwValue);
+
+    /* Stream Buffer Size register */
+    dwValue = (YUV_TEST << SKIP_TEST_MODE_BIT) |
+                (PACKET_SIZE_32KB << STREAM_PACKET_SIZE_BIT) |
+                (PACKETS_8 << RING_BUF_PACKET_NUM_BIT);
+    /* the same with Video1, Video2, and VideoM*/
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_STREAM_BUF_SIZE, dwValue);
+        
+
+    /* Comression control register */
+    dwValue = (USE_UV_CIR656 << UV_CIR656_FORMAT_BIT)|
+                (JPEG_MIX_MODE << JPEG_ONLY_BIT)|
+                (VQ_4_COLOR_MODE << VQ_4_COLOR_BIT)|
+                (QUANTI_CODEC_MODE << QUALITY_CODEC_SETTING_BIT)|
+                (7 << NORMAL_QUANTI_CHROMI_TABLE_BIT) |
+                (23 << NORMAL_QUANTI_LUMI_TABLE_BIT);
+   
+    //Video2 have same value as video1
+    if (VIDEO1 == nVideo)
+    {
+        WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_COMPRESS_CONTROL_REG, dwValue);
+    }
+    else
+    {
+        WriteMemoryLongHost(VIDEO_REG_BASE, VIDEOM_COMPRESS_CONTROL_REG, dwValue);
+    }
+
+    /* JPEG Quantization Table register */
+    dwValue = 0;
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_QUANTI_TABLE_LOW_REG, dwValue);
+    
+    /* Quantization value register */
+    //Video2 have same value as video1
+    dwValue = 0;
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_QUANTI_VALUE_REG, dwValue);
+
+    //Video BSD Parameter Register
+    //Video2 have same value as video1
+    dwValue = 0;
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_BSD_PARA_REG, dwValue);
+
+    return TRUE;
+}
+
+BYTE  GetI2CRegClient(ULONG  MMIOBase, 
+				 BYTE DeviceSelect, 
+				 BYTE DeviceAddress, 
+				 BYTE RegisterIndex)
+{
+    BYTE    Data;
+    ULONG   Status;
+
+//  Reset
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x00, 0);
+//  Set AC Timing and Speed
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x04, AC_TIMING);
+//  Lower Speed
+//    WriteMemoryLongWithANDData (VideoEngineInfo->VGAPCIInfo.ulMMIOBaseAddress, I2C_BASE + DeviceSelect * 0x40 + 0x04, 0, 0x33317805);
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x08, 0);
+//  Clear Interrupt
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x10, 0xFFFFFFFF);
+//  Enable Master Mode
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x00, 1);
+//  Enable Interrupt
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x0C, 0xAF);
+//  BYTE I2C Mode
+//  Start and Send Device Address
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x20, DeviceAddress);
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x14, 0x3);
+//  Wait TX ACK
+    do {
+        Status = ReadMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x10) & 0x03;
+    } while (Status != 1);
+//  Clear Interrupt
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x10, 0xFFFFFFFF);
+//  Send Device Register Index
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x20, RegisterIndex);
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x14, 0x2);
+//  Wait Tx ACK
+    do {
+        Status = ReadMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x10) & 0x03;
+    } while (Status != 1);
+//  Clear Interrupt
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x10, 0xFFFFFFFF);
+//  Start, Send Device Address + 1(Read Mode), Receive Data
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x20, DeviceAddress + 1);
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x14, 0x1B);
+//  Wait Rx Done
+    do {
+        Status = (ReadMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x10) & 0x04) >> 2;
+    } while (Status != 1);
+//  Clear Interrupt
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x10, 0xFFFFFFFF);
+
+//  Enable STOP Interrupt
+    WriteMemoryLongWithMASKClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x0C, 0x10, 0x10);
+//  Issue STOP Command
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x14, 0x20);
+//  Wait STOP
+    do {
+        Status = (ReadMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x10) & 0x10) >> 4;
+    } while (Status != 1);
+//  Disable STOP Interrupt
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x0C, 0x10);
+//  Clear Interrupt
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x10, 0xFFFFFFFF);
+//  Read Received Data
+    Data = (BYTE)((ReadMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x20) & 0xFF00) >> 8);
+
+    return    Data;
+}
+
+ULONG  SetI2CRegClient(ULONG  MMIOBase, 
+                 BYTE   DeviceSelect, 
+                 BYTE   DeviceAddress, 
+                 BYTE   RegisterIndex, 
+                 BYTE   RegisterValue)
+{
+    ULONG   Status; 
+	ULONG   Count = 0;
+
+//  Reset
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x00, 0);
+//  Set Speed
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x04, AC_TIMING);
+//  Lower Speed
+//    WriteMemoryLongWithANDData (VideoEngineInfo->VGAPCIInfo.ulMMIOBaseAddress, I2C_BASE + DeviceSelect * 0x40 + 0x04, 0, 0x33317805);
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x08, 0);
+//  Clear Interrupt
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x10, 0xFFFFFFFF);
+//  Enable Master Mode
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x00, 1);
+//  Enable Interrupt
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x0C, 0xAF);
+//  BYTE I2C Mode
+//  Start and Send Device Address
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x20, DeviceAddress);
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x14, 0x3);
+//  Wait Tx ACK
+    do {
+        Count++;
+        Status = ReadMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x10) & 0x03;
+
+		if (2 == Status)
+		{
+			//Clear Interrupt
+			WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x10, 0xFFFFFFFF);
+			//Re-Send Start and Send Device Address while NACK return
+			WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x20, DeviceAddress);
+			WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x14, 0x3);
+		}
+		//else
+		{
+			if (Count > LOOP_COUNT) {
+				return CAN_NOT_FIND_DEVICE;
+			}
+		}
+    } while (Status != 1);
+    Count = 0;
+//  Clear Interrupt
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x10, 0xFFFFFFFF);
+//  Send Device Register Index
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x20, RegisterIndex);
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x14, 0x2);
+//  Wait Tx ACK
+    do {
+        Count++;
+        Status = ReadMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x10) & 0x03;
+        if (Count > LOOP_COUNT) {
+            return CAN_NOT_FIND_DEVICE;
+        }
+    } while (Status != 1);
+    Count = 0;
+//  Clear Interrupt
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x10, 0xFFFFFFFF);
+//  Send Device Register Value and Stop
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x20, RegisterValue);
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x14, 0x2);
+//  Wait Tx ACK
+    do {
+        Count++;
+        Status = ReadMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x10) & 0x03;
+        if (Count > LOOP_COUNT) {
+            return CAN_NOT_FIND_DEVICE;
+        }
+    } while (Status != 1);
+    Count = 0;
+//  Clear Interrupt
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x10, 0xFFFFFFFF);
+//  Enable STOP Interrupt
+    WriteMemoryLongWithMASKClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x0C, 0x10, 0x10);
+//  Issue STOP Command
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x14, 0x20);
+//  Wait STOP
+    do {
+        Count++;
+        Status = (ReadMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x10) & 0x10) >> 4;
+        if (Count > LOOP_COUNT) {
+            return CAN_NOT_FIND_DEVICE;
+        }
+    } while (Status != 1);
+//  Disable STOP Interrupt
+    WriteMemoryLongWithMASKClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x0C, 0, 0x10);
+//  Clear Interrupt
+    WriteMemoryLongClient(APB_BRIDGE_2_BASE, I2C_BASE + DeviceSelect * 0x40 + 0x10, 0xFFFFFFFF);
+
+    return SET_I2C_DONE;
+}
diff --git a/board/aspeed/ast2400/vfun.h b/board/aspeed/ast2400/vfun.h
new file mode 100755
index 0000000..90f9ec4
--- /dev/null
+++ b/board/aspeed/ast2400/vfun.h
@@ -0,0 +1,79 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef _VFUN_H_
+#define _VFUN_H_
+
+//#define vBufAlign(x)		    ((x + 0x0000007F) & 0xFFFFFF80) //128 byte alignment
+#define vBufAlign(x)		    ((x + 0x000003FF) & 0xFFFFFC00) //128 byte alignment
+#define vBufAlign2(x)		    ((x + 0x0000FFFF) & 0xFFFF0000) //128 byte alignment
+#define v16byteAlign(x)		    ((x + 0x0000000F) & 0xFFFFFFF0)
+#define vBuf_ALIGNMENT			128
+
+#define HOST_TOTAL_SIZE         0x8000000   /* 128M */
+#define STATION_TOTAL_SIZE      0xF800000   /* 120M */
+
+#define VIDEO_SOURCE_SIZE       0x200000    /* 800X600X4 = 0x1D4C00 */
+#define VIDEO_MAX_STREAM_SIZE   0x400000    /* 32X128K = 0x400000 */
+#define VIDEO_FLAG_SIZE         0x5000      /* 1920X1200/128 = 0x4650*/ 
+#define VIDEO_CRC_SIZE          0x50000     /* 1920/64X1200X8 = 0x46500*/
+
+#define VIDEO1_EN_TOTAL_SIZE    (VIDEO_SOURCE_SIZE*2+VIDEO_MAX_STREAM_SIZE+VIDEO_FLAG_SIZE+VIDEO_CRC_SIZE) /* 0x1655000 =  about 23M*/
+#define VIDEO2_EN_TOTAL_SIZE    VIDEO1_EN_TOTAL_SIZE
+//#define VIDEOM_EN_TOTAL_SIZE    (VIDEO_SOURCE_SIZE*2+VIDEO_MAX_STREAM_SIZE+VIDEO_FLAG_SIZE) /* 0x1605000 = about 22.7M */
+//#define VIDEO_HOST_SIZE         (VIDEO1_EN_TOTAL_SIZE + VIDEO2_EN_TOTAL_SIZE + VIDEOM_EN_TOTAL_SIZE) /* 0x69922816 = about 70M */
+#define VIDEO_HOST_SIZE         (VIDEO1_EN_TOTAL_SIZE + VIDEO2_EN_TOTAL_SIZE) /* NOT NEED VIDEOM */
+
+#define VIDEO1_EN_BASE          0x100000
+#define VIDEO2_EN_BASE          (VIDEO1_EN_BASE + VIDEO1_EN_TOTAL_SIZE)
+#define VIDEOM_EN_BASE          (VIDEO2_EN_BASE + VIDEO2_EN_TOTAL_SIZE)
+
+#define VIDEO1_DE_TOTAL_SIZE    (VIDEO_MAX_STREAM_SIZE + VIDEO_SOURCE_SIZE) /* 0xD00000 = 13M*/
+#define VIDEO2_DE_TOTAL_SIZE    (VIDEO1_DE_TOTAL_SIZE)
+#define VIDEO_STATION_SIZE      (VIDEO1_DE_TOTAL_SIZE + VIDEO2_DE_TOTAL_SIZE) /* 26M */
+
+#define VIDEO1_DE_BASE          VIDEO_HOST_SIZE
+#define VIDEO2_DE_BASE          (VIDEO1_DE_BASE + VIDEO1_DE_TOTAL_SIZE)
+#define VIDEO_ALL_SIZE          (VIDEO_HOST_SIZE + VIDEO_STATION_SIZE) //Host and Station
+
+#define OutdwmBankModeHost(offset,data)         WriteMemoryLongHost(DRAM_BASE,offset,data)
+#define IndwmBankModeHost(offset)               ReadMemoryLongHost(DRAM_BASE,offset)      
+
+ULONG UnlockVideoRegHost(ULONG   MMIOBase, ULONG Key);
+BOOL CheckOnStartHost(void);
+BOOL CheckOnStartClient(void);
+void StartVideoCaptureTriggerHost(ULONG   MMIOBase, ULONG offset);
+void StartVideoCaptureTriggerHost(ULONG   MMIOBase, ULONG offset);
+void StartVideoCodecTriggerHost(ULONG   MMIOBase, ULONG offset);
+ULONG UnlockSCURegHost(ULONG   MMIOBase, ULONG Key);
+ULONG UnlockSCURegHost(ULONG   MMIOBase, ULONG Key);
+void StartModeDetectionTriggerHost(ULONG   MMIOBase, ULONG offset);
+void ClearVideoInterruptHost(ULONG   MMIOBase, ULONG value);
+BOOL ReadVideoInterruptHost(ULONG   MMIOBase, ULONG value);
+void StopModeDetectionTriggerHost(ULONG   MMIOBase, ULONG offset);
+void ResetVideoHost(void);
+ULONG  InitializeVideoEngineHost (ULONG                MMIOBase,
+                               int                  nVideo,
+							   BOOL					HorPolarity,
+				  BOOL					VerPolarity);
+ULONG  InitializeVideoEngineClient (ULONG                MMIOBase,
+				    int                  nVideo);
+BYTE  GetI2CRegClient(ULONG  MMIOBase, 
+				 BYTE DeviceSelect, 
+				 BYTE DeviceAddress, 
+				 BYTE RegisterIndex);
+
+ULONG  SetI2CRegClient(ULONG  MMIOBase, 
+                 BYTE   DeviceSelect, 
+                 BYTE   DeviceAddress, 
+                 BYTE   RegisterIndex, 
+				 BYTE   RegisterValue);
+#endif //_VFUN_H_
+
diff --git a/board/aspeed/ast2400/vgahw.h b/board/aspeed/ast2400/vgahw.h
new file mode 100755
index 0000000..7cbba0d
--- /dev/null
+++ b/board/aspeed/ast2400/vgahw.h
@@ -0,0 +1,175 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/******************************************************************************
+ * Mode Stuff
+ ******************************************************************************/
+/* Default Settings */
+#define CRT_LOW_THRESHOLD_VALUE         0x12
+#define CRT_HIGH_THRESHOLD_VALUE        0x1E
+
+/* Output Selection */
+#define CRT1				0x00
+#define CRT2				0x01
+#define DVI1				0x10
+#define DVI2				0x11
+#define LVDS1				0x20
+#define LVDS2				0x21
+
+/* Mode Limitation */
+#define MAX_HResolution		1600
+#define MAX_VResolution		1200
+ 
+/* Std. Table Index Definition */
+#define TextModeIndex 		0
+#define EGAModeIndex 		1
+#define VGAModeIndex 		2
+#define HiCModeIndex 		3
+#define TrueCModeIndex 		4
+
+/* DCLK Index */
+#define VCLK25_175     		0x00
+#define VCLK28_322     		0x01
+#define VCLK31_5       		0x02
+#define VCLK36         		0x03
+#define VCLK40         		0x04
+#define VCLK49_5       		0x05
+#define VCLK50         		0x06
+#define VCLK56_25      		0x07
+#define VCLK65		 	0x08
+#define VCLK75	        	0x09
+#define VCLK78_75      		0x0A
+#define VCLK94_5       		0x0B
+#define VCLK108        		0x0C
+#define VCLK135        		0x0D
+#define VCLK157_5      		0x0E
+#define VCLK162        		0x0F
+#define VCLK119        		0x10
+
+/* Flags Definition */
+#define Charx8Dot               0x00000001
+#define HalfDCLK                0x00000002
+#define DoubleScanMode          0x00000004
+#define LineCompareOff          0x00000008
+#define SyncPP                  0x00000000
+#define SyncPN                  0x00000040
+#define SyncNP                  0x00000080
+#define SyncNN                  0x000000C0
+#define HBorder                 0x00000020
+#define VBorder                 0x00000010
+#define COLORINDEX		0x00000000
+#define MONOINDEX		0x00000100
+
+/* DAC Definition */
+#define DAC_NUM_TEXT		64
+#define DAC_NUM_EGA		64
+#define DAC_NUM_VGA		256
+
+/* AST3000 Reg. Definition */
+#define	AST3000_VGAREG_BASE	0x1e6e6000
+#define AST3000_VGA1_CTLREG	0x00
+#define AST3000_VGA1_CTLREG2	0x04
+#define AST3000_VGA1_STATUSREG	0x08 
+#define AST3000_VGA1_PLL	0x0C
+#define AST3000_VGA1_HTREG	0x10
+#define AST3000_VGA1_HRREG	0x14
+#define AST3000_VGA1_VTREG	0x18
+#define AST3000_VGA1_VRREG	0x1C
+#define AST3000_VGA1_STARTADDR	0x20
+#define AST3000_VGA1_OFFSETREG	0x24
+#define AST3000_VGA1_THRESHOLD	0x28
+#define AST3000_HWC1_OFFSET     0x30
+#define AST3000_HWC1_XY		0x34
+#define AST3000_HWC1_PBase      0x38
+#define AST3000_OSD1_H          0x40
+#define AST3000_OSD1_V          0x44
+#define AST3000_OSD1_PBase      0x48
+#define AST3000_OSD1_Offset     0x4C
+#define AST3000_OSD1_THRESHOLD  0x50
+
+#define AST3000_VGA2_CTLREG	0x60
+#define AST3000_VGA2_CTLREG2	0x64
+#define AST3000_VGA2_STATUSREG	0x68 
+#define AST3000_VGA2_PLL	0x6C
+#define AST3000_VGA2_HTREG	0x70
+#define AST3000_VGA2_HRREG	0x74
+#define AST3000_VGA2_VTREG	0x78
+#define AST3000_VGA2_VRREG	0x7C
+#define AST3000_VGA2_STARTADDR	0x80
+#define AST3000_VGA2_OFFSETREG	0x84
+#define AST3000_VGA2_THRESHOLD	0x88
+#define AST3000_HWC2_OFFSET     0x90
+#define AST3000_HWC2_XY		0x94
+#define AST3000_HWC2_PBase      0x98
+#define AST3000_OSD2_H          0xA0
+#define AST3000_OSD2_V          0xA4
+#define AST3000_OSD2_PBase      0xA8
+#define AST3000_OSD2_Offset     0xAC
+#define AST3000_OSD2_THRESHOLD  0xB0
+
+/* Data Structure */
+typedef struct {
+    UCHAR ModeName[20];
+    USHORT usModeIndex;
+    USHORT usModeID;
+    USHORT usColorIndex;
+    USHORT usRefreshRateIndex;
+    USHORT usWidth;
+    USHORT usHeight;
+    USHORT usBitsPerPlane;
+    USHORT usRefreshRate;    
+} ModeInfoStruct;
+
+typedef struct {
+	
+    UCHAR MISC;	
+    UCHAR SEQ[4];
+    UCHAR CRTC[25];
+    UCHAR AR[20];	    
+    UCHAR GR[9];
+    
+} VBIOS_STDTABLE_STRUCT, *PVBIOS_STDTABLE_STRUCT;
+
+typedef struct {
+	
+    ULONG HT;
+    ULONG HDE;
+    ULONG HFP;
+    ULONG HSYNC;
+    ULONG VT;
+    ULONG VDE;
+    ULONG VFP;
+    ULONG VSYNC;
+    ULONG DCLKIndex;        
+    ULONG Flags;
+
+    ULONG ulRefreshRate;
+    ULONG ulRefreshRateIndex;
+    ULONG ulModeID;
+        
+} VBIOS_ENHTABLE_STRUCT, *PVBIOS_ENHTABLE_STRUCT;
+
+typedef struct {
+    UCHAR Param1;
+    UCHAR Param2;
+    UCHAR Param3;	
+} VBIOS_DCLK_INFO, *PVBIOS_DCLK_INFO;
+
+typedef struct {
+    UCHAR DACR;
+    UCHAR DACG;
+    UCHAR DACB;	
+} VBIOS_DAC_INFO, *PVBIOS_DAC_INFO;
+
+typedef struct {
+    PVBIOS_STDTABLE_STRUCT pStdTableEntry;
+    PVBIOS_ENHTABLE_STRUCT pEnhTableEntry;
+    	
+} VBIOS_MODE_INFO, *PVBIOS_MODE_INFO;
diff --git a/board/aspeed/ast2400/vhace.c b/board/aspeed/ast2400/vhace.c
new file mode 100755
index 0000000..d045cbd
--- /dev/null
+++ b/board/aspeed/ast2400/vhace.c
@@ -0,0 +1,66 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#define HASH_GLOBALS
+#include "type.h"
+#include "vdef.h"
+#include "vhace.h"
+#include "vfun.h"
+
+void HashAst3000(ULONG ulLength, ULONG *output, ULONG ulHashMode)
+{
+	ULONG i, ulTemp, ulCommand, ulDigestLength;
+	ULONG ulValue;
+   
+	/* Get Info */
+	switch (ulHashMode)
+	{
+	case VHASHMODE_MD5:
+		ulCommand = VHASH_ALG_SELECT_MD5;
+		ulDigestLength = 16;
+		break;
+	case VHASHMODE_SHA1:
+		ulCommand = VHASH_ALG_SELECT_SHA1;
+		ulDigestLength = 20;
+		break;
+	case VHASHMODE_SHA256:
+		ulCommand = VHASH_ALG_SELECT_SHA256;
+		ulDigestLength = 32;
+		break;
+	case VHASHMODE_SHA224:
+		ulCommand = VHASH_ALG_SELECT_SHA224;
+		ulDigestLength = 28;
+		break;       	
+	}
+   	
+	/* Init. HW */
+	WriteMemoryLongHost(VHAC_REG_BASE, VREG_HASH_SRC_BASE_OFFSET, g_HashSrcBuffer);
+	WriteMemoryLongHost(VHAC_REG_BASE, VREG_HASH_DST_BASE_OFFSET, g_HashDstBuffer);
+	WriteMemoryLongHost(VHAC_REG_BASE, VREG_HASH_LEN_OFFSET, ulLength);
+        
+    /* write src */
+	//already fill in g_VIDEO1_COMPRESS_BUF_ADDR
+
+    /* fire cmd */
+	WriteMemoryLongHost(VHAC_REG_BASE, VREG_HASH_CMD_OFFSET, ulCommand);
+    
+    /* get digest */
+    do {
+    	ulTemp = ReadMemoryLongHost(VHAC_REG_BASE, VREG_HASH_STATUS_OFFSET);
+    } while (ulTemp & VHASH_BUSY);	
+    	
+    for (i=0; i<ulDigestLength/4; i++)
+    {
+                ulValue = *(((ULONG *)g_HashDstBuffer) + i); 
+
+		//output is ULONG pointer
+		*(output + i) = ulValue;    
+    }        
+}
diff --git a/board/aspeed/ast2400/vhace.h b/board/aspeed/ast2400/vhace.h
new file mode 100755
index 0000000..460989b
--- /dev/null
+++ b/board/aspeed/ast2400/vhace.h
@@ -0,0 +1,58 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef _VHACE_H_
+#define _VHACE_H_
+
+#define VHASHMODE_MD5			0x00
+#define VHASHMODE_SHA1			0x01
+#define VHASHMODE_SHA256			0x02
+#define VHASHMODE_SHA224			0x03
+
+#define VHASH_ALG_SELECT_MASK		0x70
+#define VHASH_ALG_SELECT_MD5			0x00
+#define VHASH_ALG_SELECT_SHA1		0x20
+#define VHASH_ALG_SELECT_SHA224		0x40
+#define VHASH_ALG_SELECT_SHA256		0x50
+
+#define VHASH_BUSY			0x01
+
+#define VHAC_REG_BASE 			0x1e6e0000
+#define	VHAC_REG_OFFSET			0x3000
+
+#define VREG_HASH_SRC_BASE_OFFSET	(0x20+VHAC_REG_OFFSET)
+#define VREG_HASH_DST_BASE_OFFSET	(0x24+VHAC_REG_OFFSET)
+#define VREG_HASH_KEY_BASE_OFFSET	(0x28+VHAC_REG_OFFSET)
+#define VREG_HASH_LEN_OFFSET			(0x2C+VHAC_REG_OFFSET)
+#define VREG_HASH_CMD_OFFSET			(0x30+VHAC_REG_OFFSET)
+
+#define VREG_HASH_STATUS_OFFSET		(0x1C+VHAC_REG_OFFSET)
+
+typedef struct
+{
+	int HashMode;
+	int DigestLen;
+} HASH_METHOD;
+
+
+#ifdef HASH_GLOBALS
+#define HASH_EXT
+#else
+#define HASH_EXT extern
+#endif
+
+HASH_EXT HASH_METHOD	g_HashMethod;
+HASH_EXT BYTE			g_DigestBuf[32];
+HASH_EXT ULONG			g_HashSrcBuffer;
+HASH_EXT ULONG			g_HashDstBuffer;
+
+void HashAst3000(ULONG ulLength, ULONG *output, ULONG ulHashMode);
+#endif
+
diff --git a/board/aspeed/ast2400/videotest.c b/board/aspeed/ast2400/videotest.c
new file mode 100755
index 0000000..f2e4953
--- /dev/null
+++ b/board/aspeed/ast2400/videotest.c
@@ -0,0 +1,779 @@
+/*
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Diagnostics support
+ */
+#include <common.h>
+#include <command.h>
+#include <malloc.h>
+#include <post.h>
+
+#include "slt.h"
+#define WIN_GLOBALS
+#include "type.h"
+#include "vreg.h"
+#define VESA_GLOBALS
+#include "vesa.h"
+#include "vfun.h"
+#include "vdef.h"
+#include "vhace.h"
+#include "crt.h"
+#include "videotest.h"
+
+#define VHASH_ALIGNMENT			16
+#define VHASH_MAX_DST			(32+VHASH_ALIGNMENT)
+
+
+#if ((CFG_CMD_SLT & CFG_CMD_VIDEOTEST) && defined(CONFIG_SLT))
+#include "videotest.h"
+
+#define RAND_MAX 32767 //2^16-1
+
+ULONG randSeed = 1;
+
+void srand(ULONG seed)
+{
+  randSeed = seed;
+}
+
+int rand(void)
+{
+  randSeed = randSeed * 214013 + 2531011;
+  return (int)(randSeed >> 17); //32 -15 = 17
+}
+
+//static unsigned char CaptureVideo1Buf1Addr[VIDEO_SOURCE_SIZE], CaptureVideo1Buf2Addr[VIDEO_SOURCE_SIZE], Video1CompressBufAddr[CRYPTO_MAX_CONTEXT];
+ULONG pCaptureVideo1Buf1Addr[VIDEO_SOURCE_SIZE/4], pCaptureVideo1Buf2Addr[VIDEO_SOURCE_SIZE/4], pVideo1CompressBufAddr[VIDEO_MAX_STREAM_SIZE/4], pVideo1FlagBufAddr[VIDEO_FLAG_SIZE];
+ULONG pCaptureVideo2Buf1Addr[VIDEO_SOURCE_SIZE/4], pCaptureVideo2Buf2Addr[VIDEO_SOURCE_SIZE/4], pVideo2CompressBufAddr[VIDEO_MAX_STREAM_SIZE/4], pVideo2FlagBufAddr[VIDEO_FLAG_SIZE];
+
+ULONG pVHashDstBuffer[VHASH_MAX_DST/4];
+
+ULONG pVideo1DecAddr[VIDEO_SOURCE_SIZE/4];
+ULONG pCrt1Addr[VIDEO_SOURCE_SIZE/4];
+//ULONG pCap1Addr[VIDEO_SOURCE_SIZE/4];
+
+BOOL AllocateEncodeBufHost(ULONG MMIOBase, int nVideo)
+{
+    //ULONG     Addr;
+    //ULONG     dwRegOffset = nVideo * 0x100;
+
+    if (VIDEO1 == nVideo)
+    {
+        
+        //Addr = (ULONG)malloc(pVideoInfo->SrcWidth * pVideoInfo->SrcHeight * 4);
+        //pCaptureVideo1Buf1Addr = malloc(VIDEO_SOURCE_SIZE);
+
+        g_CAPTURE_VIDEO1_BUF1_ADDR = vBufAlign((ULONG)pCaptureVideo1Buf1Addr);
+        WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_BUF_1_ADDR_REG, g_CAPTURE_VIDEO1_BUF1_ADDR, BUF_1_ADDR_MASK);
+        
+        //Addr = (ULONG)malloc(pVideoInfo->SrcWidth * pVideoInfo->SrcHeight * 4);
+        //pCaptureVideo1Buf2Addr = malloc(VIDEO_SOURCE_SIZE);
+
+        g_CAPTURE_VIDEO1_BUF2_ADDR = vBufAlign((ULONG)pCaptureVideo1Buf2Addr);
+        WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_BUF_2_ADDR_REG, g_CAPTURE_VIDEO1_BUF2_ADDR, BUF_2_ADDR_MASK);
+        
+        //Addr = (ULONG)malloc(pVideoInfo->uStreamBufSize.StreamBufSize.RingBufNum * pVideoInfo->uStreamBufSize.StreamBufSize.PacketSize)
+        //pVideo1CompressBufAddr = malloc(VIDEO_MAX_STREAM_SIZE);
+        g_VIDEO1_COMPRESS_BUF_ADDR = vBufAlign((ULONG)pVideo1CompressBufAddr);
+        WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_COMPRESS_BUF_ADDR_REG, g_VIDEO1_COMPRESS_BUF_ADDR, BUF_2_ADDR_MASK);
+        
+        //Addr = (ULONG)malloc((pVideoInfo->SrcHeigh/64) * pVideoInfo->SrcWidth * 8);
+        //g_VIDEO1_CRC_BUF_ADDR = vBufAlign((ULONG)malloc(VIDEO_MAX_STREAM_SIZE));
+        //WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_CRC_BUF_ADDR_REG, g_VIDEO1_CRC_BUF_ADDR, BUF_2_ADDR_MASK);
+        
+
+        //Addr = (ULONG)malloc(pVideoInfo->SrcHeigh * pVideoInfo->SrcWidth  / 128 (/64*4/8));
+        //pVideo1FlagBufAddr = malloc(VIDEO_FLAG_SIZE);
+        g_VIDEO1_FLAG_BUF_ADDR = vBufAlign((ULONG)pVideo1FlagBufAddr);
+        WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_FLAG_BUF_ADDR_REG, g_VIDEO1_FLAG_BUF_ADDR, BUF_2_ADDR_MASK);
+    }
+    else if (VIDEO2 == nVideo)
+    {
+        //Addr = (ULONG)malloc(pVideoInfo->SrcWidth * pVideoInfo->SrcHeight * 4);
+        //pCaptureVideo2Buf1Addr = malloc(VIDEO_SOURCE_SIZE);
+        g_CAPTURE_VIDEO2_BUF1_ADDR = vBufAlign((ULONG)pCaptureVideo2Buf1Addr);
+        WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO2_BUF_1_ADDR_REG, g_CAPTURE_VIDEO2_BUF1_ADDR, BUF_1_ADDR_MASK);
+        
+        //Addr = (ULONG)malloc(pVideoInfo->SrcWidth * pVideoInfo->SrcHeight * 4);
+        //pCaptureVideo2Buf2Addr = malloc(VIDEO_SOURCE_SIZE);
+        g_CAPTURE_VIDEO2_BUF2_ADDR = vBufAlign((ULONG)pCaptureVideo2Buf2Addr);
+        WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO2_BUF_2_ADDR_REG, g_CAPTURE_VIDEO2_BUF2_ADDR, BUF_2_ADDR_MASK);
+        
+        //Addr = (ULONG)malloc(pVideoInfo->uStreamBufSize.StreamBufSize.RingBufNum * pVideoInfo->uStreamBufSize.StreamBufSize.PacketSize)
+        //pVideo2CompressBufAddr = malloc(VIDEO_MAX_STREAM_SIZE);
+        g_VIDEO2_COMPRESS_BUF_ADDR = vBufAlign((ULONG)pVideo2CompressBufAddr);
+        WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO2_COMPRESS_BUF_ADDR_REG, g_VIDEO2_COMPRESS_BUF_ADDR, BUF_2_ADDR_MASK);
+        
+        //Addr = (ULONG)malloc((pVideoInfo->SrcHeigh/64) * pVideoInfo->SrcWidth * 8);
+        //g_VIDEO1_CRC_BUF_ADDR = vBufAlign((ULONG)malloc(VIDEO_MAX_STREAM_SIZE));
+        //WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_CRC_BUF_ADDR_REG, g_VIDEO1_CRC_BUF_ADDR, BUF_2_ADDR_MASK);
+        
+
+        //Addr = (ULONG)malloc(pVideoInfo->SrcHeigh * pVideoInfo->SrcWidth  / 128 (/64*4/8));
+        //pVideo2FlagBufAddr = malloc(VIDEO_FLAG_SIZE);
+        g_VIDEO2_FLAG_BUF_ADDR = vBufAlign((ULONG)pVideo2FlagBufAddr);
+        WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO2_FLAG_BUF_ADDR_REG, g_VIDEO2_FLAG_BUF_ADDR, BUF_2_ADDR_MASK);
+    }
+  
+}
+
+/********************************************************/
+/* 1. product random data to encode                     */
+/* 2. use hash to verify encode function                */
+/* 3. use encode stream to decompress original data     */
+/********************************************************/
+int CodecTest(void)
+{
+    int	  num, i=0, j=0;
+    ULONG ulTemp = 0, ulTemp2;
+    int   dwValue;
+    ULONG ulHWWp;
+    ULONG ulHWPt;
+
+    //max size
+    ULONG tArray[32/4];
+    
+    //mode detection
+    BOOL	bExternal = TRUE;
+    BOOL	bAnalog = TRUE;
+    ULONG	Status;	    
+
+#if defined(CONFIG_AST2300)
+    ULONG ulHashSha1[5]  = {0x3f0c2ad6,0xc8eb7074,0xa9929352,0xfcd5b8b0,0x76fa8461};
+    ULONG aHashDecode[5] = {0xb23b62bb,0xd22a602b,0x113038a0,0x7217c6ab,0xcb156f06};
+#else
+    ULONG ulHashSha1[5] = {0x2a19e99f,0x99b1bb2d,0x9ac82862,0x49205e43,0x6bc4b4d7};
+    ULONG aHashDecode[5] = {0x2907a827,0xaf337079,0x47817f1f,0xb0b7cd68,0x8d33bd2};
+#endif
+
+    //Load pattern to src1 & src2 buffer
+    srand(1);
+
+    //Total size : DefWidth*DeHeight*4
+    //rand function: 16 bits one time is equal to 2 bytes
+    //OutdwmBankMode: 32 bits one time is equal to 4 bytes
+    for (i=0; i<g_DefWidth*g_DefHeight*2; i++)
+    {
+	if (i%2)
+	{
+	    ulTemp2 = rand();
+	    ulTemp = (ulTemp2 << 16) | ulTemp;
+	    //WriteMemoryLongHost(DRAM_BASE, g_CAPTURE_VIDEO1_BUF1_ADDR + ((i-1)/2)*4, ulTemp);
+	    *(((ULONG *)g_CAPTURE_VIDEO1_BUF1_ADDR) + (i-1)/2) = ulTemp;
+	    ulTemp = 0;
+	}
+	else
+	{
+	    ulTemp = rand();
+	}
+    }
+
+    /* init encoder engine */
+    InitializeVideoEngineHost (0,
+			       VIDEO1,
+			       vModeTable[2].HorPolarity,
+			       vModeTable[2].VerPolarity);
+
+    /* reset offset pointer register*/    
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_ENGINE_SEQUENCE_CONTROL_REG, 0, VIDEO_CODEC_TRIGGER | VIDEO_CAPTURE_TRIGGER);
+
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_COMPRESS_BUF_READ_OFFSET_REG, 0, COMPRESS_BUF_READ_OFFSET_MASK);
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_BUF_CODEC_OFFSET_READ, 0, BUF_CODEC_OFFSET_MASK);
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_COMPRESS_BUF_PROCESS_OFFSET_REG, 0, COMPRESS_BUF_PROCESS_OFFSET_MASK);
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_COMPRESS_FRAME_END_READ, 0, COMPRESS_FRAME_END_READ_MASK);
+
+    /* start compress stream */
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_ENGINE_SEQUENCE_CONTROL_REG, MODE_DETECTION_TRIGGER, MODE_DETECTION_TRIGGER);
+    //Stream mode: set CODEC trigger first
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_ENGINE_SEQUENCE_CONTROL_REG, VIDEO_CODEC_TRIGGER, VIDEO_CODEC_TRIGGER);
+
+    //Stream mode: start trigger (only trigger capture bit)
+    StartVideoCaptureTriggerHost(0, VIDEO1_ENGINE_SEQUENCE_CONTROL_REG);
+
+    //stop engine
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_ENGINE_SEQUENCE_CONTROL_REG, 0, 0xFF);    
+#if defined(CONFIG_AST2300)
+    do {	/* wait compress engine idle */
+	ulTemp = ReadMemoryLongHost(VIDEO_REG_BASE, VIDEO1_ENGINE_SEQUENCE_CONTROL_REG);    	
+    } while (!(ulTemp & 0x40000));	
+#endif
+
+    //read 30 times to get HW write pointer
+    for (i=0; i<30000; i++)
+	ulHWWp = ReadMemoryLongHost(VIDEO_REG_BASE, VIDEO1_BUF_CODEC_OFFSET_READ);
+
+    g_HashSrcBuffer = g_VIDEO1_COMPRESS_BUF_ADDR + 128; //skip encode data 128 byte	
+    g_HashDstBuffer = v16byteAlign((unsigned long)pVHashDstBuffer);
+    ulTemp = 300;
+
+    //Enable hash clock
+    WriteMemoryLongWithMASKHost(SCU_BASE, SCU_CLOCK_STOP_REG, EN_HACE, STOP_HACE_MASK);
+    g_HashMethod.HashMode = VHASHMODE_SHA1;
+    g_HashMethod.DigestLen = 20;
+    HashAst3000(ulTemp, tArray, g_HashMethod.HashMode);
+
+    if (strncmp((const char *)tArray, (const char *)ulHashSha1, g_HashMethod.DigestLen))
+    {
+	printf("[VIDEO] Encoder Test: Wrong\n");
+        //ExitVideoTest();
+        return VIDEO_ENCODE_FAIL;
+    }
+    else
+    {    
+	printf("[VIDEO] Encoder Test: Pass\n");
+    }
+
+#if 0
+    /******** prepare for next decoding test at the same chip ***********/
+    ResetVideoHost();
+
+    dwValue=0;
+
+    do
+    {
+	dwValue = UnlockVideoRegHost(0, VIDEO_UNLOCK_KEY);
+	i++;
+    }
+    while ((VIDEO_UNLOCK != dwValue) && (i<10));
+
+    if (VIDEO_UNLOCK != dwValue)
+    {
+	printf("[VIDEO] Video register is locked");
+	return VIDEO_UNLOCK_FAIL;
+    }
+
+    // allocate decoding buffer
+    //Use Compress buffer last time, and Don't need to allocate
+    g_VIDEO1_DECODE_BUF_1_ADDR = g_VIDEO1_COMPRESS_BUF_ADDR;
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_BUF_1_ADDR_REG, g_VIDEO1_DECODE_BUF_1_ADDR, BUF_1_ADDR_MASK);
+    
+    //	pVideo1DecAddr = malloc(VIDEO_SOURCE_SIZE);
+    g_VIDEO1_DECOMPRESS_BUF_ADDR = vBufAlign((unsigned long)pVideo1DecAddr);    
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_COMPRESS_BUF_ADDR_REG, g_VIDEO1_DECOMPRESS_BUF_ADDR, COMPRESS_BUF_ADDR_MASK);
+    
+    //Addr = (ULONG)malloc(256);
+    //g_VIDEO1_RC4_BUF_ADDR = Addr;
+    //g_VIDEO1_DECODE_RC4_BUF_ADDR = g_VIDEO1_DECOMPRESS_BUF_ADDR + 0x800000; //assume video size is 8MB for umcompressed buf;
+    //WriteMemoryLongWithMASKClient(VIDEO_REG_BASE, VIDEO1_RC4_TABLE_ADDR, g_VIDEO1_DECODE_RC4_BUF_ADDR, RC4_TABLE_ADDR_MASK);
+
+    //HW recommanded value
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_BUF_2_ADDR_REG, g_VIDEO1_DECOMPRESS_BUF_ADDR, BUF_2_ADDR_MASK);
+    //WriteMemoryLongWithMASKClient(VIDEO_REG_BASE, VIDEO1_BUF_2_ADDR_REG, 0, BUF_2_ADDR_MASK);
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_CRC_BUF_ADDR_REG, 0, BUF_2_ADDR_MASK);            
+
+    /* init encoder engine */
+    InitializeVideoEngineClient (0, VIDEO1);
+
+    /* reset offset pointer register*/    
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_ENGINE_SEQUENCE_CONTROL_REG, 0, VIDEO_CODEC_TRIGGER | VIDEO_CAPTURE_TRIGGER);
+
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_COMPRESS_BUF_READ_OFFSET_REG, 0, COMPRESS_BUF_READ_OFFSET_MASK);
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_BUF_CODEC_OFFSET_READ, 0, BUF_CODEC_OFFSET_MASK);
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_COMPRESS_BUF_PROCESS_OFFSET_REG, 0, COMPRESS_BUF_PROCESS_OFFSET_MASK);
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_COMPRESS_FRAME_END_READ, 0, COMPRESS_FRAME_END_READ_MASK);
+
+    StartVideoCodecTriggerHost(0, VIDEO1_ENGINE_SEQUENCE_CONTROL_REG);
+
+    //wrtie SW write pointer
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_DECOMPRESS_BUF_PROCESS_OFFSET_REG, ulHWWp, COMPRESS_BUF_READ_OFFSET_MASK);
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_DECOMPRESS_BUF_WRITE_OFFSET_REG, ulHWWp, COMPRESS_BUF_READ_OFFSET_MASK);
+
+    i = 0;
+
+    do
+    {
+        ulHWPt = ReadMemoryLongHost(VIDEO_REG_BASE, VIDEO1_BUF_CODEC_OFFSET_READ);
+        i++;
+    }while((ulHWPt != ulHWWp) && (i<10000));
+
+    if (10000 > i)
+    {
+ 	printf("[VIDEO] Decoder Pointer cannot move!!! /n");
+        //ExitVideoTest();
+	return VIDEO_DECODE_FAIL;       
+    }
+        
+    //8*8 YUVA block
+    for (i=24; i<g_DefWidth*g_DefHeight; i=i+32)
+    {
+        *(((ULONG *)g_VIDEO1_DECOMPRESS_BUF_ADDR) + i) = 0x0;
+	*(((ULONG *)g_VIDEO1_DECOMPRESS_BUF_ADDR) + i+1) = 0x0;
+    }
+
+    g_HashSrcBuffer = g_VIDEO1_DECOMPRESS_BUF_ADDR;
+    //g_HashDstBuffer = VIDEO1_EN_BASE + VIDEO_ALL_SIZE; //config forward
+
+    ulTemp = 300;
+
+    //Enable hash clock
+    WriteMemoryLongWithMASKHost(SCU_BASE, SCU_CLOCK_STOP_REG, EN_HACE, STOP_HACE_MASK);
+    g_HashMethod.HashMode = VHASHMODE_SHA1;
+    g_HashMethod.DigestLen = 20;
+    HashAst3000(ulTemp, tArray, g_HashMethod.HashMode);
+
+    if (strncmp((const char *)tArray, (const char *)aHashDecode, g_HashMethod.DigestLen))
+    {
+	printf("[VIDEO] Decoder Test: Wrong\n");
+        //ExitVideoTest();
+        return VIDEO_DECODE_FAIL;
+    }
+    else
+    {
+	printf("[VIDEO] Decoder Test: Pass\n");
+    }
+#endif
+
+    return VIDEO_TEST_OK;
+}
+
+/********************************************************/
+/*  Only used in the host                               */
+/*  test function: Mode detection and Capture pattern   */
+/********************************************************/
+int CapTest(void)
+{
+    ULONG   dwValue, Status;
+    int     i;
+    BOOL    bAnalog;
+    ULONG	HStart, HEnd, VStart, VEnd;
+    USHORT	usCRTHor, usCRTVer;
+    ULONG   ulHor, ulVer;
+    ULONG   ulVGABaseAddr, ulCapAddr;
+    ULONG   ulFlag;
+    
+    printf("\n --------- Mode Detection Test --------- \n");
+    //clear clear register
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_CONTROL_REG, 0);
+    dwValue = ReadMemoryLongHost(VIDEO_REG_BASE, VIDEO1_CONTROL_REG);
+
+    //  Note: Current mode detection procedure has to set signal input 1st
+    //Note: Clear and enable interrupt Encode
+    ClearVideoInterruptHost(0, VIDEO1_MODE_DETECTION_READY_CLEAR);
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO_INT_CONTROL_EN_REG, VIDEO1_MODE_DETECTION_READY_INT_EN, VIDEO1_MODE_DETECTION_READY_INT_EN);
+    //  Set input signal
+    dwValue |= EXTERNAL_VGA_SOURCE;
+    
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_CONTROL_REG, (dwValue <<EXTERNAL_SOURCE_BIT), EXTERNAL_SOURCE_MASK);
+
+//  Set H/V stable maximum
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO_MODE_DETECTION_PARAM_REG, (MODEDETECTION_VERTICAL_STABLE_MAXIMUM << VER_STABLE_MAX_BIT), 0x000F0000);
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO_MODE_DETECTION_PARAM_REG, (MODEDETECTION_HORIZONTAL_STABLE_MAXIMUM << HOR_STABLE_MAX_BIT), HOR_STABLE_MAX_BIT_MASK);
+//  Set H/V stable threshold
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO_MODE_DETECTION_PARAM_REG, (MODEDETECTION_VERTICAL_STABLE_THRESHOLD << VER_STABLE_THRES_BIT), VER_STABLE_THRES_BIT_MASK);
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO_MODE_DETECTION_PARAM_REG, (MODEDETECTION_HORIZONTAL_STABLE_THRESHOLD << HOR_STABLE_THRES_BIT), HOR_STABLE_THRES_BIT_MASK);
+    
+    //Trigger mode detection
+    // turn off WATCH_DOG first
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_ENGINE_SEQUENCE_CONTROL_REG, (WATCH_DOG_OFF << WATCH_DOG_ENABLE_BIT), WATCH_DOG_EN_MASK);
+        
+    //  Note: Clear mode detection ready interrupt
+    //ClearVideoInterrupt(MMIOBase, MODE_DETECTION_READY_CLEAR);
+    StartModeDetectionTriggerHost(0, VIDEO1_ENGINE_SEQUENCE_CONTROL_REG);
+
+
+//  Note: Polling mode detection ready interrupt
+    //it sometime take a long time, especially during change mode, 
+    //so the loop count must be big, or you can't pull it by timer
+    i = 0;
+    do {
+
+		Status = ReadVideoInterruptHost(0, VIDEO1_MODE_DETECTION_READY_READ);
+		i++;
+    } while ((!Status) & (i<500000));
+
+    if (!Status)
+    {
+	printf("[VIDEO] Mode detection error\n");
+        //ExitVideoTest();
+	return VIDEO_TEST_FAIL;
+    }
+
+    HStart	= (ReadMemoryLongHost(VIDEO_REG_BASE, VIDE1_MODE_DETECTION_EDGE_H_REG) & LEFT_EDGE_LOCATION_MASK) >> LEFT_EDGE_LOCATION_BIT;
+    HEnd	= (ReadMemoryLongHost(VIDEO_REG_BASE, VIDE1_MODE_DETECTION_EDGE_H_REG) & RIGHT_EDGE_LOCATION_MASK) >> RIGHT_EDGE_LOCATION_BIT;
+
+    VStart	= (ReadMemoryLongHost(VIDEO_REG_BASE, VIDE1_MODE_DETECTION_EDGE_V_REG) & TOP_EDGE_LOCATION_MASK) >> TOP_EDGE_LOCATION_BIT;
+    VEnd	= (ReadMemoryLongHost(VIDEO_REG_BASE, VIDE1_MODE_DETECTION_EDGE_V_REG) & BOTTOM_EDGE_LOCATION_MASK) >> BOTTOM_EDGE_LOCATION_BIT;
+
+    ulHor = HEnd-HStart+1;
+    ulVer = VEnd-VStart+1;
+
+    printf("[VIDEO] Resolution: H[%d] * V[%d]\n", ulHor, ulVer);
+
+    if ((g_DefWidth == ulHor) & (g_DefHeight == ulVer))
+    {
+    	printf("[VIDEO] Mode detection PASS\n");
+    }
+    else
+    {
+	printf("[VIDEO] Mode detection FAIL\n");
+	return VIDEO_TEST_FAIL;
+    }
+
+    if(!((ReadMemoryLongHost(VIDEO_REG_BASE, VIDEO1_MODE_DETECTION_STATUS_READ_REG) & ANALONG_DIGITAL_READ) >> ANALONG_DIGITAL_READ_BIT))
+	bAnalog = FALSE;
+    else
+	bAnalog = TRUE;
+
+    //  Note: Clear mode detection ready interrupt
+    ClearVideoInterruptHost(0, VIDEO1_MODE_DETECTION_READY_CLEAR);
+
+    printf("\n --------- Capture Test --------- \n");
+
+    //capture engine
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_TIMEING_GEN_HOR_REG, (HEnd << VIDEO_HDE_END_BIT), VIDEO_HDE_END_MASK);
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_TIMEING_GEN_HOR_REG, (HStart << VIDEO_HDE_START_BIT), VIDEO_HDE_START_MASK);
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_TIMEING_GEN_V_REG, (VEnd << VIDEO_VDE_END_BIT), VIDEO_VDE_END_MASK);
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_TIMEING_GEN_V_REG, (VStart << VIDEO_VDE_START_BIT), VIDEO_VDE_START_MASK);
+	
+    ulCapAddr = vBufAlign2((ULONG)pCaptureVideo1Buf1Addr);    
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_BUF_1_ADDR_REG, ulCapAddr, BUF_1_ADDR_MASK);
+    
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_BUF_2_ADDR_REG, 0, BUF_2_ADDR_MASK);
+
+    InitializeVideoEngineHost (0,
+			       VIDEO1,
+		               vModeTable[2].HorPolarity,
+			       vModeTable[2].VerPolarity);
+
+    WriteMemoryLongHost(VIDEO_REG_BASE, 0x04, 0x01);
+    WriteMemoryLongHost(VIDEO_REG_BASE, 0x300, 0x0);
+#if defined(CONFIG_AST2300)
+	WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, 0x8, 0x0880, 0x0ec0);
+#elif defined(CONFIG_AST3000)
+	WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, 0x8, 0x2800, 0x2800);	
+#else
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, 0x8, 0xa00, 0x2a80); //tile mode
+#endif
+
+    WriteMemoryLongWithMASKHost(VIDEO_REG_BASE, VIDEO1_TIMEING_GEN_HOR_REG, 0xa0000000, 0xa0000000);
+   
+    //only trigger capture, in source buffer (vr44), the front of data is correct.
+    //StartVideoCaptureTriggerHost(0, VIDEO1_ENGINE_SEQUENCE_CONTROL_REG);
+    WriteMemoryLongHost(VIDEO_REG_BASE, VIDEO1_ENGINE_SEQUENCE_CONTROL_REG, VIDEO_CAPTURE_TRIGGER);
+
+    i = 0;
+    do {
+        Status = ReadMemoryLongHost(VIDEO_REG_BASE, VIDEO1_ENGINE_SEQUENCE_CONTROL_REG) & CAPTURE_READY_MASK;
+	i++;
+    } while ((!Status) & (i<500000));
+
+    if (!Status)
+    {
+	printf("[VIDEO] Capture is not READY\n");
+	return VIDEO_TEST_FAIL;
+    }  
+
+#if !defined(CONFIG_AST2300)	
+    ulVGABaseAddr = ulCapAddr + 0x1000;
+
+    /* check pattern */
+    ulFlag = 0; //no 0 is error
+
+    for (i=0; i<100; i++)
+    {
+        dwValue = *(ULONG *)(ulVGABaseAddr + i*32);
+	if (0x32323232 != dwValue)
+	{
+	    printf("[VIDEO] Capture Test fail -- capture data doesn't match source \n");
+	    printf("[VIDEO]1 i=%d value=%x\n", i, dwValue);
+            ulFlag = 1;
+            break;
+	}
+
+	dwValue = *(ULONG *)(ulVGABaseAddr + i*32 + 4);
+	if (0x32323232 != dwValue)
+	{
+	    printf("[VIDEO] Capture Test fail -- capture data doesn't match source \n");
+	    printf("[VIDEO]2 i=%d value=%x\n", i, dwValue);
+	    ulFlag = 1;
+	    break;
+	}
+
+	dwValue = *(ULONG *)(ulVGABaseAddr + i*32 + 8);
+	if (0x80808080 != dwValue)
+	{
+	    printf("[VIDEO] Capture Test fail -- capture data doesn't match source \n");
+	    printf("[VIDEO]3 i=%d value=%x\n", i, dwValue);
+	    ulFlag = 1;
+	    break;
+	}
+
+	dwValue = *(ULONG *)(ulVGABaseAddr + i*32 + 12);
+	if (0x80808080 != dwValue)
+	{
+	    printf("[VIDEO] Capture Test fail -- capture data doesn't match source \n");
+	    printf("4 i=%d value=%x\n", i, dwValue);
+	    ulFlag = 1;
+	    break;
+	}
+
+	dwValue = *(ULONG *)(ulVGABaseAddr + i*32 + 16);
+	if (0x80808080 != dwValue)
+	{
+	   printf("[VIDEO] Capture Test fail -- capture data doesn't match source \n");
+	   printf("5 i=%d value=%x\n", i, dwValue);
+	   ulFlag = 1;
+	   break;
+	}
+
+	dwValue = *(ULONG *)(ulVGABaseAddr + i*32 + 20);
+	if (0x80808080 != dwValue)
+	{
+	   printf("[VIDEO] Capture Test fail -- capture data doesn't match source \n");
+	   printf("6 i=%d value=%x\n", i, dwValue);
+	   ulFlag = 1;
+	   break;
+	  }
+    }
+#endif
+
+    if (!ulFlag)
+    {
+        printf("[VIDEO] Capture Test OK\n");
+    }
+    else
+    {
+	printf("[VIDEO] Capture Test FAIL\n");
+	return VIDEO_TEST_FAIL;
+    }
+	
+    return VIDEO_TEST_OK;
+}
+
+/********************************************************/
+/*  Only used in the station                            */
+/********************************************************/
+int CRTTest(void)
+{
+    ULONG   ulVGABaseAddr;
+    BYTE    btCRTCenterMode, btCRTColorFmt;
+    USHORT  usCRTHor, usCRTVer;
+    ULONG   ulData;
+
+    int i,j;
+
+    //printf("\n --------- Turn on CRT --------- \n");
+    
+    //Enable CRT1 first
+    ulVGABaseAddr = vBufAlign((unsigned long)pCrt1Addr);
+    
+    btCRTCenterMode     = 0;
+    btCRTColorFmt	= YUV_444;
+    usCRTHor		= g_DefWidth;
+    usCRTVer		= g_DefHeight;	
+
+    CheckOnStartClient();
+
+    /* Fill Pattern */
+    for (i=0; i<usCRTHor; i++)
+    {
+	for (j=0; j<usCRTVer/8; j++)
+	{
+	    //Y
+	    //ulData = 0x10101010;
+	    ulData = 0x32323232;
+	    *(ULONG *)(ulVGABaseAddr + (i*usCRTVer*4+j*32)) = ulData;
+	    //ulData = 0x10101010;
+	    ulData = 0x32323232;
+	    *(ULONG *)(ulVGABaseAddr + (i*usCRTVer*4+j*32) +4) = ulData;
+	    //U
+	    ulData = 0x80808080;
+	    //ulData = 0x77777777;
+	    *(ULONG *)(ulVGABaseAddr + (i*usCRTVer*4+j*32) +8) = ulData;
+	    ulData = 0x80808080;
+	    //ulData = 0x77777777;
+	    *(ULONG *)(ulVGABaseAddr + (i*usCRTVer*4+j*32) +12) = ulData;
+	    //V
+	    ulData = 0x80808080;
+	    //ulData = 0x11111111;
+	    *(ULONG *)(ulVGABaseAddr + (i*usCRTVer*4+j*32) +16) = ulData;
+	    ulData = 0x80808080;
+	    //ulData = 0x11111111;
+	    *(ULONG *)(ulVGABaseAddr + (i*usCRTVer*4+j*32) +20) = ulData;
+	    //A
+	    ulData = 0xFFFFFFFFF;
+	    *(ULONG *)(ulVGABaseAddr + (i*usCRTVer*4+j*32) +24) = ulData;
+	    ulData = 0xFFFFFFFFF;
+	    *(ULONG *)(ulVGABaseAddr + (i*usCRTVer*4+j*32) +28) = ulData;
+	}
+    }  /* ~Fill Pattern */
+
+#if defined(CONFIG_AST2300)       
+    if(!ASTSetModeV (0, CRT_2, ulVGABaseAddr, usCRTHor, usCRTVer, btCRTColorFmt, btCRTCenterMode))
+#else
+    if(!ASTSetModeV (0, CRT_1, ulVGABaseAddr, usCRTHor, usCRTVer, btCRTColorFmt, btCRTCenterMode))
+#endif    
+    {   
+        printf("[VIDEO] The resolution is not in mode table list\n");
+        return CRT_FAIL;
+    }
+    
+    //printf("[VIDEO] CRT turn on\n");
+
+    return VIDEO_TEST_OK;
+}
+
+int do_videotest (void)
+{
+    int dwValue=0;
+    int i = 0;
+    int iRet;    
+    ULONG   ulRestore1, ulTemp;
+    BOOL    bClient;
+
+
+    //InitVideoTest();
+    g_DefWidth = 640; 
+    g_DefHeight= 480;
+
+    printf("\n --------- Codec Test --------- \n");
+
+#if defined(CONFIG_AST2300)
+    WriteMemoryLongWithMASKHost(SCU_BASE, SCU_CONTROL_REG, 0x00002000, 0x00002000);
+#endif
+
+    CheckOnStartHost();
+    
+    do
+    {
+        dwValue = UnlockVideoRegHost(0, VIDEO_UNLOCK_KEY);
+	i++;
+    }
+    while ((VIDEO_UNLOCK != dwValue) && (i<1000));
+
+    if (VIDEO_UNLOCK != dwValue)
+    {
+	printf("[VIDEO] Video register is locked \n");
+	return VIDEO_TEST_FAIL;
+    }
+    AllocateEncodeBufHost(0, VIDEO1);
+
+    iRet = CodecTest();	
+    if (iRet)
+        return VIDEO_TEST_FAIL;
+
+#if defined(CONFIG_AST2300)
+    /* Init SCU */ 
+    WriteMemoryLongWithMASKHost(SCU_BASE, (0x2c + SCU_OFFSET), 0x00040000, 0x00040010);	/* Enable D2-PLL */
+    WriteMemoryLongWithMASKHost(SCU_BASE, SCU_CLOCK_STOP_REG, 0, 0x00000400);		/* Enable D2CLK */
+    udelay(10);
+    WriteMemoryLongWithMASKHost(SCU_BASE, SCU_CONTROL_REG, 0, 0x00002000);
+    
+    WriteMemoryLongWithMASKHost(SCU_BASE, (0x90 + SCU_OFFSET), 0x20, 0x00000030); 	/* enable video mode single edge */
+    WriteMemoryLongWithMASKHost(SCU_BASE, (0x84 + SCU_OFFSET), 0xfffe0000, 0xfffe0000); /* multi-pins */
+    WriteMemoryLongWithMASKHost(SCU_BASE, (0x88 + SCU_OFFSET), 0x000fffff, 0x000fffff); /* multi-pins */    
+    
+    iRet = CRTTest();
+    if (iRet)
+    {
+    	printf("[VIDEO] CRT Test Failed \n");
+        return VIDEO_TEST_FAIL;
+    }
+
+    iRet = CapTest();		
+    if (iRet)
+    {
+    	printf("[VIDEO] Capture Test Failed \n");
+        return VIDEO_TEST_FAIL;
+    }
+#else
+    //Host or Client
+    bClient = ((ReadMemoryLong(SCU_BASE, SCU_HW_TRAPPING_REG) & CLIENT_MODE_EN_MASK)?TRUE:FALSE);
+    //reset video for another testing
+    ResetVideoHost();
+    dwValue=0;
+    i = 0;
+    do
+    {
+	dwValue = UnlockVideoRegHost(0, VIDEO_UNLOCK_KEY);
+	i++;
+    }
+    while ((VIDEO_UNLOCK != dwValue) && (i<10));
+
+    if (VIDEO_UNLOCK != dwValue)
+    {
+	printf("[VIDEO] Video register is locked");
+	return VIDEO_UNLOCK_FAIL;
+    }
+
+    //check if 1e6e0008[3,0] is 0
+    ulRestore1 = ReadMemoryLongHost(0x1e6e0000, 8);
+    dwValue = ReadMemoryLongHost(0x1e6e0000, 8)&0xF;
+
+    //set 1e6e0008[3,0] to 0
+    if (dwValue)
+    {
+        WriteMemoryLongHost(0x1e6e0000, 0, 0xfc600309);
+        
+        i=0;
+        do
+        {
+            i++;
+            dwValue = ReadMemoryLongHost(0x1e6e0000,0);
+        }while((1 != dwValue)&& (i<10));
+        
+        if (1 != dwValue)
+    	{
+    		printf("0x1e6e0000 is locked");
+    		return VIDEO_UNLOCK_FAIL;
+    	}
+    }
+
+    //only clear 1e6e0008[3,0]
+    WriteMemoryLongWithMASKHost(0x1e6e0000, 8, 0, 0xf);
+    
+    bClient = 0;
+    if (!bClient)
+    {
+        //To turn on crt, must be the client mode
+        WriteMemoryLongWithMASKHost(SCU_BASE, SCU_HW_TRAPPING_REG, (BE_CLIENT_CHIP << CLIENT_MODE_EN_BIT), CLIENT_MODE_EN_MASK);
+            
+        iRet = CRTTest();
+
+        if (iRet)
+        {
+            //trapping to host, the Vsync of CRT can't output and the host doesn't have video sync input
+            WriteMemoryLongWithMASKHost(SCU_BASE, SCU_HW_TRAPPING_REG, (BE_HOST_CHIP << CLIENT_MODE_EN_BIT), CLIENT_MODE_EN_MASK);
+            //restore value
+            WriteMemoryLongHost(0x1e6e0000, 8, ulRestore1);
+            //lock register
+            WriteMemoryLongHost(0x1e6e0000, 0, 0x12345678); 
+            return VIDEO_TEST_FAIL;
+        }
+        
+        iRet = CapTest();
+		
+        if (iRet)
+        {
+            //trapping to host, the Vsync of CRT can't output and the host doesn't have video sync input
+            WriteMemoryLongWithMASKHost(SCU_BASE, SCU_HW_TRAPPING_REG, (BE_HOST_CHIP << CLIENT_MODE_EN_BIT), CLIENT_MODE_EN_MASK);
+            //restore value
+            WriteMemoryLongHost(0x1e6e0000, 8, ulRestore1);
+            //lock register
+            WriteMemoryLongHost(0x1e6e0000, 0, 0x12345678); 
+
+            return VIDEO_TEST_FAIL;
+        }
+		//WriteMemoryLongWithMASKHost(SCU_BASE, SCU_HW_TRAPPING_REG, (BE_HOST_CHIP << CLIENT_MODE_EN_BIT), CLIENT_MODE_EN_MASK);
+    }
+    //trapping to host, the Vsync of CRT can't output and the host doesn't have video sync input
+    WriteMemoryLongWithMASKHost(SCU_BASE, SCU_HW_TRAPPING_REG, (BE_HOST_CHIP << CLIENT_MODE_EN_BIT), CLIENT_MODE_EN_MASK);
+    //restore value
+    WriteMemoryLongHost(0x1e6e0000, 8, ulRestore1);
+    //lock register
+    WriteMemoryLongHost(0x1e6e0000, 0, 0x12345678); 
+#endif
+
+    return VIDEO_TEST_OK;	
+}
+#endif /* CONFIG_SLT */
diff --git a/board/aspeed/ast2400/videotest.h b/board/aspeed/ast2400/videotest.h
new file mode 100755
index 0000000..79b8dd9
--- /dev/null
+++ b/board/aspeed/ast2400/videotest.h
@@ -0,0 +1,24 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* VideoTest.h */
+#ifndef _VIDEOTEST_H_
+#define _VIDEOTEST_H_
+
+#define VIDEO_TEST_OK       0
+#define VIDEO_TEST_FAIL     1
+
+#define VIDEO_UNLOCK_FAIL   1
+#define VIDEO_ENCODE_FAIL   2
+#define VIDEO_DECODE_FAIL   3
+#define CRT_FAIL            4
+
+#endif /* _VIDEOTEST_H_ */
+
diff --git a/board/aspeed/ast2400/vreg.h b/board/aspeed/ast2400/vreg.h
new file mode 100755
index 0000000..9738548
--- /dev/null
+++ b/board/aspeed/ast2400/vreg.h
@@ -0,0 +1,845 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef _VREG_H_
+#define _VREG_H_
+
+/********************************************************/
+/*    CRT register                                      */
+/********************************************************/
+#define    CRT_BASE_ADDRESS                    0x000400
+#define    VGA_GRAPH_BASE_ADDRESS              0x600000
+#define    VGA_CURSOR_BASE_ADDRESS             0x300000
+#define    VGA_OSD_BASE_ADDRESS                0x300000
+#define    RGB_565                             0x0
+#define    RGB_888                             0x1
+#define    YUV_444                             0x2
+#define	   NO_SUPPORTED_CRT_FMT				   0x3
+#define    CRT_LOW_THRESHOLD_VALUE             0x12
+#define    CRT_HIGH_THRESHOLD_VALUE            0x1E
+
+// AST3000's Registers 
+#ifdef Watcom
+#define     VIDEOBASE_OFFSET                            0x10000
+#else
+#define     VIDEOBASE_OFFSET                            0x0
+#endif
+
+#define     KEY_CONTROL_REG                             0x00 + VIDEOBASE_OFFSET
+    #define     VIDEO_LOCKED                            0
+    #define     VIDEO_UNLOCK                            1
+
+// Registers for video1 and video2
+#define     VIDEO1_ENGINE_SEQUENCE_CONTROL_REG          0x04 + VIDEOBASE_OFFSET
+#define     VIDEO2_ENGINE_SEQUENCE_CONTROL_REG          0x104 + VIDEOBASE_OFFSET
+    #define     MODE_DETECTION_TRIGGER                  0x00000001  //Bit[0] trigger HW auto mode detection
+    #define     VIDEO_CAPTURE_TRIGGER                   0x00000002  //Bit[1] trigger HW to capture video
+	#define		FORCE_HW_IDLE_MASK						(1<<2)		//Bit[2] Force engine into ready(idle) state
+		#define		ENGINE_RESET						(0<<2)
+		#define		ENGINE_IDLE							(1<<2)
+    #define     VIDEO_CAPTURE_AUTO_MODE                 0x00000008  //Bit[3]
+        #define     CAPTURE_FRAME_MODE                  0
+        #define     CAPTURE_AUTO_MODE                   1
+		#define		CAPTURE_AUTO_MODE_BIT				3
+		#define		CAPTURE_AUTO_MODE_MASK				0x00000008
+    #define     VIDEO_CODEC_TRIGGER                     0x00000010  //Bit[4] trigger HW to compress or decompress video
+        #define     CODEC_TRIGGER_BIT                   4
+        #define     CODEC_TRIGGER_MASK                  0x00000010
+        #define     CLEAR_CODEC_TRIGGER                 0
+        #define     EN_CODEC_TRIGGER                    1
+    #define     VIDEO_CODEC_AUTO_MODE                   0x00000020  //Bit[5]
+        #define     CODEC_FRAME_MODE                    0
+        #define     CODEC_AUTO_MODE                     1
+		#define		CODEC_AUTO_MODE_BIT					5
+        #define     CODEC_AUTO_MODE_MASK                0x00000020
+	#define		INSERT_FULL_FRAME_MASK					(1<<6)		//Bit[6] Insert full frame compression
+		#define		INSERT_FULL_FRAME_EN				(1<<6)
+		#define		INSERT_FULL_FRAME_OFF				(0<<6)
+    #define     WATCH_DOG_ENABLE                        0x00000080  //Bit[7] Video Enable watch dog for mode change detection
+        #define     WATCH_DOG_ENABLE_BIT                7
+        #define     WATCH_DOG_OFF                       0
+        #define     WATCH_DOG_EN                        1
+        #define     WATCH_DOG_EN_MASK                   0x00000080
+    #define     VIDEO_CRT_SELECTION                     0x00000100  //Bit[8]
+        #define     CRT1                                0
+        #define     CRT2                                1
+    #define     ANTI_TEARING_ENABLE                     0x00000200  //Bit[9] Anti-tearing mode enable for decoding
+        #define     ANTI_TEARING_EN                     1
+    #define     STREAM_DATA_MODE                        0x00000400  //Bit[11:10] Buffer and Stream Data type
+        #define     STREAM_DATA_MODE_BIT                10
+        #define     STREAM_DATA_MODE_MASK               0x00000C00
+        #define     YUV444_MODE                         0
+        #define     YUV420_MODE                         1
+        #define     YUV420_MODE_WITH_AST2000            2 //AST2000 compatible
+    #define     VIDEO_CAPTURE_READY                     0x00010000  //Bit[16] Video capture ready status read back(read only)
+		#define		CAPTURE_READY_MASK                  0x00010000  
+        #define     HW_BUSY                             0
+        #define     HW_IDLE                             1
+    #define     VIDEO_CODEC_READY                       0x00040000  //Bit[18] Video codec ready status read back(read only)
+		#define		CODEC_READY_MASK					0x00040000
+        //#define     HW_BUSY                             0
+        //#define     HW_IDLE                             1
+    
+#define    VIDEO1_CONTROL_REG                           0x08 + VIDEOBASE_OFFSET
+#define    VIDEO2_CONTROL_REG                           0x108 + VIDEOBASE_OFFSET
+    #define     VIDEO_HSYNC_POLARITY                    0x00000001  //Bit[0] Video source hsync polarity
+        #define     VIDEO_HSYNC_POLARITY_BIT            0
+        #define     NO_INVERSE_POL                      0
+        #define     INVERSE_POL							1
+    #define     VIDEO_VSYNC_POLARITY                    0x00000002  //Bit[1] Video source vsync polarity
+        #define     VIDEO_VSYNC_POLARITY_BIT            1        
+        //Setting defination the same as VIDEO_HSYNC_POLARITY
+    #define     VIDEO_EXTERNAL_SOURCE                   0x00000004  //Bit[2] Video external source
+        #define     EXTERNAL_SOURCE_BIT                 2
+        #define     INTERNAL_VGA_SOURCE                 0
+        #define     EXTERNAL_VGA_SOURCE                 1
+        #define     EXTERNAL_SOURCE_MASK                0x00000004                     
+    #define     VIDEO_ANALONG_EXTERNAL_SOURCE           0x00000008  //Bit[3] Video Analog external source
+        #define     ANALONG_EXTERNAL_SOURCE_BIT         3
+        #define     DVI_SOURCE                          0
+        #define     ANALOG_RGB_SOURCE                   1
+    #define     VIDEO_INTERNAL_TIMING_GEN               0x00000010  //Bit[4] Video Use internal timing generator
+        #define     INTERNAL_TIMING_GEN_BIT             4
+        #define     EXTERNAL_DE_SIGNAL                  0 //DVI only
+        #define     VR0C_VR10_DE_SINGAL                 1 //use VR0C and VR10 for generate VDE signal
+    /******     Video2 Only from DAC    ******/        
+    #define     VIDEO1_CAPTURE_FROM                     0x00000020  //Bit[5] Video1 capture data direct from VGA frame buffer(internal VGA only)  
+        #define     FROM_DAC_PORT                       0
+        #define     FROM_FRAME_BUFFER                   1     
+    #define     WRITE_DATA_FORMAT                       0x00000040  //Bit[7:6] Write data format
+        #define     WRITE_DATA_FORMAT_BIT               6
+        #define     WRTIE_DATA_FORMAT_MASK              0x000000C0
+        #define     CCIR601_2_YUV_FORMAT                0
+        #define     FULL_YUV_FORMAT                     1
+        #define     RGB_FORMAT                          2
+		#define     VGA_CURSOR_DISABLE                      0x00000100  //Bit[8] External video port slection
+        #define     VGA_CURSOR_NORMAL                   0
+        #define     VGA_CURSOR_OFF                      1    
+    #define     VIDEO_CAPTURE_LINEAR_MODE               0x00000200  //Bit[9] VIDEO_CAPTURE_LINEAR_MODE
+        #define     LINEAR_MODE                         0
+        #define     TILE_MODE		                    1		
+    #define     VIDEO_CLOCK_DELAY                       0x00000400  //Bit[11:10] Video clock delay control
+        #define     VIDEO_CLOCK_DELAY_BIT               10
+        #define     VIDEO_CLOCK_DELAY_MASK              0x00000C00
+        #define     DELAY_0_NS                          0
+        #define     DELAY_1_NS                          1
+        #define     INV_AND_DELAY_0_NS                  2
+        #define     INV_AND_DELAY_1_NS                  3
+    #define     VIDEO_CCIR656_SOURCE_MODE               0x00001000  //Bit[12] Video CCIR656 source mode
+        #define     RGB_SOURCE_MODE                     0
+        #define     CCIR656_SOURCE_MODE                 1
+    #define     SOURCE_PORT_CLOCK_MODE                  0x00002000  //Bit[13] Video Source port clock mode
+        #define     SINGLE_EDGE_MODE                    0
+        #define     DUAL_EDGE_MODE                      1
+    #define     EXTERNAL_PORT_SELECTION                 0x00004000  //Bit[14] External video port slection
+        #define     VIDEO_PORT_A                        0
+        #define     VIDEO_PORT_B                        1
+    #define     VIDEO_CAPTURE_FRAME_RATE                0x00010000  //Bit[23:16] Video capture frame rate control
+        #define     VIDEO_CAPTURE_FRAME_RATE_BIT        16
+        #define     VIDEO_CAPTURE_FRAME_RATE_MASK       0x00FF0000  //Maximum frame rate = XX * SourceFPS / 60
+
+#define    VIDEO1_TIMEING_GEN_HOR_REG                   0x0C + VIDEOBASE_OFFSET
+#define    VIDEO2_TIMEING_GEN_HOR_REG                   0x10C + VIDEOBASE_OFFSET
+    #define     VIDEO_HDE_END                           0x00000000  //Bit[12:0] Video HDE End timing generator
+    #define     VIDEO_HDE_END_BIT                       0  //Number of pixels from rising edge of Hsync for first active pixel
+    #define     VIDEO_HDE_END_MASK                      0x00001FFF
+    #define     VIDEO_HDE_START                         0x00010000  //Bit[28:16] Video HDE Start timing generator
+    #define     VIDEO_HDE_START_BIT                     16 //Number of pixels from rising edge of Hsync for last active pixel
+    #define     VIDEO_HDE_START_MASK                    0x1FFF0000
+        #define     FRAME_RATE_OFF                      0    
+    
+#define    VIDEO1_TIMEING_GEN_V_REG                     0x10 + VIDEOBASE_OFFSET
+#define    VIDEO2_TIMEING_GEN_V_REG                     0x110 + VIDEOBASE_OFFSET
+    #define     VIDEO_VDE_END                           0x00000001  //Bit[11:0] Video VDE End timing generator
+    #define     VIDEO_VDE_END_BIT                       0  //Number of pixels from rising edge of Vsync for first active pixel
+    #define     VIDEO_VDE_END_MASK                      0x00000FFF
+    #define     VIDEO_VDE_START                         0x00010000  //Bit[27:16] Video VDE Start timing generator
+    #define     VIDEO_VDE_START_BIT                     16 //Number of pixels from rising edge of Vsync for last active pixel
+    #define     VIDEO_VDE_START_MASK                    0x0FFF0000
+
+#define    VIDEO1_SCALE_FACTOR_REG                      0x14 + VIDEOBASE_OFFSET
+#define    VIDEO2_SCALE_FACTOR_REG                      0x114 + VIDEOBASE_OFFSET
+    #define     HOR_SCALING_FACTOR                      0x00000001  //Bit[15:0] Video Horizontal scaling factor
+    #define     HOR_SCALING_FACTOR_BIT                  0   //The formula=4096/(Horizontal scaling facotr)
+    #define     HOR_SCALING_FACTOR_MASK                 0x0000FFFF
+    #define     VER_SCALING_FACTOR                      0x00000000  //Bit[31:16] Video Vertical scaling factor
+    #define     VER_SCALING_FACTOR_BIT                  16   //The formula=4096/(Vertical scaling facotr)
+    #define     VER_SCALING_FACTOR_MASK                 0xFFFF0000
+
+#define    VIDEO1_SCALE_FACTOR_PARAMETER0_REG           0x18 + VIDEOBASE_OFFSET  //Scaling Parameters F00, F01, F02, F03
+#define    VIDEO2_SCALE_FACTOR_PARAMETER0_REG           0x118 + VIDEOBASE_OFFSET   
+
+#define    VIDEO1_SCALE_FACTOR_PARAMETER1_REG           0x1C + VIDEOBASE_OFFSET  //Scaling Parameters F10, F11, F12, F13
+#define    VIDEO2_SCALE_FACTOR_PARAMETER1_REG           0x11C + VIDEOBASE_OFFSET   
+
+#define    VIDEO1_SCALE_FACTOR_PARAMETER2_REG           0x20 + VIDEOBASE_OFFSET  //Scaling Parameters F20, F21, F22, F23
+#define    VIDEO2_SCALE_FACTOR_PARAMETER2_REG           0x120 + VIDEOBASE_OFFSET   
+
+#define    VIDEO1_SCALE_FACTOR_PARAMETER3_REG           0x24 + VIDEOBASE_OFFSET  //Scaling Parameters F30, F31, F32, F33
+#define    VIDEO2_SCALE_FACTOR_PARAMETER3_REG           0x124 + VIDEOBASE_OFFSET
+
+#define    VIDEO1_BCD_CONTROL_REG                       0x2C + VIDEOBASE_OFFSET
+#define    VIDEO2_BCD_CONTROL_REG                       0x12C + VIDEOBASE_OFFSET
+    #define     BCD_ENABLE                              0x00000001  //Bit[0] Enable block change detection(BCD)
+        #define     BCD_ENABLE_BIT                      0
+        #define     BCD_ENABLE_MASK                     0x00000001
+    #define     BCD_TOLERANCE                           0x00010000  //Bit[23:16]
+        #define     BCD_TOLERANCE_BIT                   16 //flag as changed block when the video data difference greater
+        #define     BCD_TOLERANCE_MASK                  0x00FF0000
+
+#define     VIDEO1_CAPTURE_WINDOWS_REG                  0x30 + VIDEOBASE_OFFSET
+#define     VIDEO2_CAPTURE_WINDOWS_REG                  0x130 + VIDEOBASE_OFFSET
+    #define     CAPTURE_VER_LINE						0x00000001  //Bit[10:0] Video compression vertical line total
+    #define     CAPTURE_VER_LINE_BIT					0
+    #define     CAPTURE_VER_LINE_MASK					0x000007FF
+    #define     CAPTURE_HOR_PIXEL						0x00010000  //Bit[26:16] Video compression vertical line total
+    #define     CAPTURE_HOR_PIXEL_BIT					16
+    #define     CAPTURE_HOR_PIXEL_MASK					0x07FF0000
+
+#define     VIDEO1_COMPRESS_WINDOWS_REG                 0x34 + VIDEOBASE_OFFSET
+#define     VIDEO2_COMPRESS_WINDOWS_REG                 0x134 + VIDEOBASE_OFFSET
+    #define     COMPRESS_VER_LINE                       0x00000001  //Bit[10:0] Video compression vertical line total
+    #define     COMPRESS_VER_LINE_BIT                   0
+    #define     COMPRESS_VER_LINE_MASK                  0x000007FF
+    #define     COMPRESS_HOR_PIXEL                      0x00010000  //Bit[26:16] Video compression vertical line total
+    #define     COMPRESS_HOR_PIXEL_BIT                  16
+    #define     COMPRESS_HOR_PIXEL_MASK                 0x07FF0000
+
+#define     VIDEO1_COMPRESS_BUF_PROCESS_OFFSET_REG      0x38
+#define     VIDEO2_COMPRESS_BUF_PROCESS_OFFSET_REG      0x138
+    #define     COMPRESS_BUF_PROCESS_OFFSET_ALIGN       127 //128 byte alignment
+    #define     COMPRESS_BUF_PROCESS_OFFSET_MASK        0xFFFFFF
+
+#define     VIDEO1_DECOMPRESS_BUF_PROCESS_OFFSET_REG    0x38
+#define     VIDEO2_DECOMPRESS_BUF_PROCESS_OFFSET_REG    0x138
+    #define     DECOMPRESS_BUF_PROCESS_OFFSET_ALIGN     127 //128 byte alignment
+    #define     DECOMPRESS_BUF_PROCESS_OFFSET_MASK      0xFFFFFF
+
+
+//For Compression
+#define     VIDEO1_COMPRESS_BUF_READ_OFFSET_REG         0x3C + VIDEOBASE_OFFSET     //For stream mode
+#define     VIDEO2_COMPRESS_BUF_READ_OFFSET_REG         0x13C + VIDEOBASE_OFFSET
+    #define     COMPRESS_BUF_READ_OFFSET_ALIGN          127 //128 byte alignment
+    #define     COMPRESS_BUF_READ_OFFSET_MASK           0x00FFFFFF
+//For Decompression
+#define     VIDEO1_DECOMPRESS_BUF_WRITE_OFFSET_REG      0x3C + VIDEOBASE_OFFSET     //For stream mode 
+#define     VIDEO2_DECOMPRESS_BUF_WRITE_OFFSET_REG      0x13C + VIDEOBASE_OFFSET
+    #define     DECOMPRESS_BUF_WRITE_OFFSET_ALIGN       127 //128 byte alignment
+    #define     DECOMPRESS_BUF_WRITE_OFFSET_MASK        0x00FFFFFF
+
+#define     VIDEO1_CRC_BUF_ADDR_REG                     0x40 + VIDEOBASE_OFFSET
+#define     VIDEO2_CRC_BUF_ADDR_REG                     0x140 + VIDEOBASE_OFFSET
+    #define     CRC_BUF_ADDR_ALIGN                      7   //8 byte alignment
+    #define     CRC_BUF_ADDR_MASK                       0x0FFFFFFF
+
+#define     VIDEO1_BUF_1_ADDR_REG                       0x44 + VIDEOBASE_OFFSET     //For Source Buffer in frame mode
+#define     VIDEO2_BUF_1_ADDR_REG                       0x144 + VIDEOBASE_OFFSET
+    #define     BUF_1_ADDR_ALIGN                        255 //256 byte alignment
+    #define     BUF_1_ADDR_MASK                         0x1FFFFFFF
+
+#define     VIDEO1_BUF_LINE_OFFSET_REG                  0x48 + VIDEOBASE_OFFSET     //Must set both in Frame/Stream mode
+#define     VIDEO2_BUF_LINE_OFFSET_REG                  0x148 + VIDEOBASE_OFFSET
+    #define     BUF_LINE_OFFSET_ALIGN                   7 //8 byte alignment
+    #define     BUF_LINE_OFFSET_MASK                    0x00003FFF
+
+#define     VIDEO1_BUF_2_ADDR_REG                       0x4C + VIDEOBASE_OFFSET     //For BCD Buffer in frame mode
+#define     VIDEO2_BUF_2_ADDR_REG                       0x14C + VIDEOBASE_OFFSET     
+    #define     BUF_2_ADDR_ALIGN                        255 //256 byte alignment
+    #define     BUF_2_ADDR_MASK                         0x1FFFFFFF
+
+#define     VIDEO1_FLAG_BUF_ADDR_REG                    0x50 + VIDEOBASE_OFFSET     //For block change flag buffer
+#define     VIDEO2_FLAG_BUF_ADDR_REG                    0x150 + VIDEOBASE_OFFSET     
+    #define     FLAG_BUF_ADDR_ALIGN                     7 //8 byte alignment
+    #define     FLAG_BUF_ADDR_MASK                      0x1FFFFFFF
+
+#define     VIDEO1_COMPRESS_BUF_ADDR_REG                0x54 + VIDEOBASE_OFFSET     //For stream mode
+#define     VIDEO2_COMPRESS_BUF_ADDR_REG                0x154 + VIDEOBASE_OFFSET     
+    #define     COMPRESS_BUF_ADDR_ALIGN                 127 //128 byte alignment
+    #define     COMPRESS_BUF_ADDR_MASK                  0x1FFFFFFF
+
+#define     VIDEO1_STREAM_BUF_SIZE                      0x58 + VIDEOBASE_OFFSET     //For stream mode 
+#define     VIDEO2_STREAM_BUF_SIZE                      0x158 + VIDEOBASE_OFFSET
+    #define     STREAM_PACKET_SIZE                      0x00000001
+        #define     STREAM_PACKET_SIZE_BIT              0
+        #define     STREAM_PACKET_SIZE_MASK             0x00000007
+        #define     PACKET_SIZE_1KB                     0
+        #define     PACKET_SIZE_2KB                     1
+        #define     PACKET_SIZE_4KB                     2
+        #define     PACKET_SIZE_8KB                     3
+        #define     PACKET_SIZE_16KB                    4
+        #define     PACKET_SIZE_32KB                    5
+        #define     PACKET_SIZE_64KB                    6
+        #define     PACKET_SIZE_128KB                   7
+    #define     RING_BUF_PACKET_NUM                     0x00000008
+        #define     RING_BUF_PACKET_NUM_BIT             3
+        #define     RING_BUF_PACKET_NUM_MASK            0x00000018
+        #define     PACKETS_4                           0
+        #define     PACKETS_8                           1
+        #define     PACKETS_16                          2
+        #define     PACKETS_32                          3
+    #define     SKIP_HIGH_MB_THRES                      0x00010000  //Bit[22:16] Skip high quality macro block threshold
+        #define     SKIP_HIGH_MB_THRES_BIT              16
+        #define     SKIP_HIGH_MB_THRES_MASK             0x007F0000
+    #define     SKIP_TEST_MODE                          0x00800000  //Bit[24:23] Skip test mode
+        #define     SKIP_TEST_MODE_BIT                  23
+        #define     SKIP_TEST_MODE_MASK                 0x01800000
+        #define     YUV_TEST                            2   //recommend
+
+#define     VIDEO1_BUF_CODEC_OFFSET_READ                0x5C + VIDEOBASE_OFFSET     //For stream mode,         
+#define     VIDEO2_BUF_CODEC_OFFSET_READ                0x15C + VIDEOBASE_OFFSET    //Video stream buffer offset read back(HW)
+    #define     BUF_CODEC_OFFSET_ALIGN                  255 //256 byte alignment
+    #define     BUF_CODEC_OFFSET_MASK                   0x00FFFFFF
+
+#define     VIDEO1_COMPRESS_CONTROL_REG                 0x60 + VIDEOBASE_OFFSET
+#define     VIDEO2_COMPRESS_CONTROL_REG                 0x160 + VIDEOBASE_OFFSET
+    #define     JPEG_ONLY_ENCODE                        0x00000001  //Bit[0] JPEG only encoding
+        #define     JPEG_ONLY_BIT                       0
+        #define     JPEG_MIX_MODE                       0   //Enable JPEG/VQ mix mode encoding
+        #define     JPEG_ONLY_MODE                      1   //JPEG encoding mode only
+    #define     VQ_4_COLOR_ENCODE                       0x00000002  //Bit[1] Enable 4 color VQ encoding
+        #define     VQ_4_COLOR_BIT                      1
+        #define     VQ_1_2_COLOR_MODE                   0   //1 and 2 color mode VQ encoding
+        #define     VQ_4_COLOR_MODE                     1   //1, 2 and 4 color VQ encoding
+    #define     QUALITY_CODEC_SETTING                   0x00000004  //Bit[2] High and best video quality codec mode setting
+        #define     QUALITY_CODEC_SETTING_BIT           2
+        #define     JPEG_CODEC_MODE                     0   //not supported in best video quality mode
+        #define     QUANTI_CODEC_MODE                   1
+    #define     JPEG_DUAL_QUALITY_EN                    0x00000008  //Bit[3] JPEG dual quality mode
+        #define     EN_JPEG_DUAL_QUALITY                1   //enable(only for normal video quality mode)
+    #define     BEST_QUALITY_EN                         0x00000010  //Bit[4] Best quality video mode enable
+        #define     BEST_QUALITY_EN_BIT                 4
+        #define     EN_BEST_QUALITY                     1   //enable(only for quantization codec mode)
+    #define     RC4_CRYPT_EN                            0x00000020  //Bit[5] Enable RC4 encryption/decryption
+		#define		RC4_CRYPT_EN_BIT					5
+		#define     RC4_CRYPT_EN_MASK                   0x00000020
+        #define     RC4_CRYPT_ON                        1   //enable
+    #define     NORMAL_QUANTI_CHROMI_TABLE              0x00000040  //Bit[10:6] Normal video quality mode JPEG DCT chromi quantination table
+        #define     NORMAL_QUANTI_CHROMI_TABLE_BIT      6
+        #define     NORMAL_QUANTI_CHROMI_TABLE_MASK     0x000007C0
+    #define     NORMAL_QUANTI_LUMI_TABLE                0x00000800  //Bit[15:11] Normal video quality mode JPEG DCT lumi quantination table
+        #define     NORMAL_QUANTI_LUMI_TABLE_BIT        11
+        #define     NORMAL_QUANTI_LUMI_TABLE_MASK       0x0000F800
+    #define     HIGH_QUALITY_EN                         0x00010000  //Bit[16] High video quality mode enable
+        #define     HIGH_QUALITY_EN_BIT                 16
+        #define     EN_HIGH_QUALITY                     1   //Enable
+    #define     UV_CIR656_FORMAT                        0x00080000  //Bit[19] UV fromat
+        #define     UV_CIR656_FORMAT_BIT                19
+        #define     USE_UV_CIR656                       1   //recommand
+    #define     HUFFMAN_TABLE_SELECT                    0x00100000  //Bit[20] JPEG Huffman table combination
+        #define     DUAL_TABLE                          0   //Dual Y, UV table
+        #define     SINGLE_TABLE                        1   //Single Y table
+        #define     SINGLE_UV_TABLE                     0x00200000  //1x: Single UV table
+    #define     HIGH_QUANTI_CHROMI_TABLE                0x00400000  //Bit[26:22] High quality JPEG DCT chromi quantization table
+        #define     HIGH_QUANTI_CHROMI_TABLE_BIT        22
+        #define     HIGH_QUANTI_CHROMI_TABLE_MASK       0x07C00000                
+    #define     HIGH_DEQUANTI_VALUE                     0x00400000  //Bit[26:22] High quality de-quantization value
+        #define     HIGH_DEQUANTI_VALUE_BIT             22
+        #define     HIGH_DEQUANTI_VALUE_MASK            0x07C00000        
+    #define     HIGH_QUANTI_LUMI_TABLE                  0x08000000  //Bit[31:27] High quality JPEG DCT lumi quantization table
+        #define     HIGH_QUANTI_LUMI_TABLE_BIT          27
+        #define     HIGH_QUANTI_LUMI_TABLE_MASK         0xF8000000
+    #define     BEST_DEQUANTI_VALUE                     0x08000000  //Bit[31:27] Best quality de-quantization value
+        #define     BEST_DEQUANTI_VALUE_BIT             27
+        #define     BEST_DEQUANTI_VALUE_MASK            0xF8000000
+        
+
+#define     VIDEO1_QUANTI_TABLE_LOW_REG                 0x64 + VIDEOBASE_OFFSET     //Match with 0x60 Bit[10:6], Bit[15:11]
+#define     VIDEO2_QUANTI_TABLE_LOW_REG                 0x164 + VIDEOBASE_OFFSET
+    #define     QUANTI_CHROMI_TABLE_LOW                 0x00000001  //Bit[4:0] Normal video low quality block chromi quantization table
+        #define     QUANTI_CHROMI_TABLE_LOW_BIT         0
+        #define     QUANTI_CHROMI_TABLE_LOW_MASK        0x0000001F
+    #define     QUANTI_LUMI_TABLE_LOW                   0x00000020  //Bit[9:5] Normal video low quality block lumi quantization table
+        #define     QUANTI_LUMI_TABLE_LOW_BIT           5
+        #define     QUANTI_LUMI_TABLE_LOW_MASK          0x000003E0
+
+#define     VIDEO1_QUANTI_VALUE_REG                     0x68 + VIDEOBASE_OFFSET     //Match with 0x60 Bit[26:22],Bit[31:27]
+#define     VIDEO2_QUANTI_VALUE_REG                     0x168 + VIDEOBASE_OFFSET
+    #define     HIGH_QUANTI_VALUE                       0x00000001  //Bit[14:0] High quality quantization value. Format is 1.14
+        #define     HIGH_QUANTI_VALUE_BIT               0
+        #define     HIGH_QUANTI_VALUE_MASK              0x00007FFF
+    #define     BEST_QUANTI_VALUE                       0x00010000  //Bit[30:16] Best quality quantization value. Format is 1.14
+        #define     BEST_QUANTI_VALUE_BIT               16
+        #define     BEST_QUANTI_VALUE_MASK              0x7FFF0000
+    
+#define     VIDEO1_BSD_PARA_REG                         0x6C + VIDEOBASE_OFFSET    //Video BSD Parameters Register    
+#define     VIDEO2_BSD_PARA_REG                         0x16C + VIDEOBASE_OFFSET
+    #define     BSD_HIGH_THRES                          0x00000001  //Bit[7:0] Block sharpness detection high threshold
+    #define     BSD_HIGH_THRES_BIT                      0
+    #define     BSD_HIGH_THRES_MASK                     0x000000FF
+    #define     BSD_LOW_THRES                           0x00000100  //Bit[15:8] Block shaprpness detection low threshold
+    #define     BSD_LOW_THRES_BIT                       8
+    #define     BSD_LOW_THRES_MASK                      0x0000FF00
+    #define     BSD_HIGH_COUNTS                         0x00010000  //Bit[21:16] Block sharpness detection high counts threshold
+    #define     BSD_HIGH_COUNTS_BIT                     16
+    #define     BSD_HIGH_COUNTS_MASK                    0x003F0000
+    #define     BSD_LOW_COUNTS                          0x00400000  //Bit[27:22] Block sharpness detection low counts threshold
+    #define     BSD_LOW_COUNTS_BIT                      22
+    #define     BSD_LOW_COUNTS_MASK                     0x0FC00000
+
+#define VIDEO1_COMPRESS_FRAME_SIZE_REG                  0x70 + VIDEOBASE_OFFSET
+#define VIDEO2_COMPRESS_FRAME_SIZE_REG                  0x170 + VIDEOBASE_OFFSET
+    #define     COMPRESS_FRAME_SIZE_READ                0x00000001  //Bit[19:0] Video compression frame size read back(number of DW)
+    #define     COMPRESS_FRAME_SIZE_READ_BIT            0
+    #define     COMPRESS_FRAME_SIZE_READ_MASK           0x003FFFFF
+
+#define     VIDEO1_COMPRESS_BLOCK_COUNT_REG             0x74 + VIDEOBASE_OFFSET
+#define     VIDEO2_COMPRESS_BLOCK_COUNT_REG             0x174 + VIDEOBASE_OFFSET
+    #define     PROCESS_BLOCK_COUNT_READ_BIT            0
+    #define     PROCESS_BLOCK_COUNT_READ_MASK			0x00003FFF	//Bit[13:0] Video processed total block counter read back(number of blocks)
+    #define     COMPRESS_BLOCK_COUNT_READ_BIT           16
+    #define     COMPRESS_BLOCK_COUNT_READ_MASK          0xFFFF0000	//Bit[29:16] Video processed total block counter read back(number of blocks)
+
+#define     VIDEO1_COMPRESS_FRAME_END_READ              0x78 + VIDEOBASE_OFFSET     //Video compression stream frame end pointer    
+#define     VIDEO2_COMPRESS_FRAME_END_READ              0x178 + VIDEOBASE_OFFSET
+    #define     COMPRESS_FRAME_END_READ_ALIGN           7
+    #define     COMPRESS_FRAME_END_READ_MASK            0x00FFFFFF
+
+#define     VIDEO1_COMPRESS_FRAME_COUNT_READ            0x7C + VIDEOBASE_OFFSET     
+#define     VIDEO2_COMPRESS_FRAME_COUNT_READ            0x17C + VIDEOBASE_OFFSET 
+    #define     COMPRESS_FRAME_COUNT_READ               0x00000001  //Bit[15:0] Video compression frame count read back(number of frame)
+    #define     COMPRESS_FRAME_COUNT_READ_BIT           0
+    #define     COMPRESS_FRAME_COUNT_READ_MASK          0xFFFFFFFF
+
+#define     VIDEO1_USER_DEFINE_HEADER                   0x80 + VIDEOBASE_OFFSET
+#define     VIDEO2_USER_DEFINE_HEADER                   0x180 + VIDEOBASE_OFFSET
+    #define     USER_DEFINE_HEADER                      0x00000001  //Bit[15:0] Video user defined header parameter
+    #define     USER_DEFINE_HEADER_BIT                  0
+    #define     USER_DEFINE_HEADER_MASK                 0x0000FFFF
+    
+#define     VIDE1_MODE_DETECTION_EDGE_H_REG             0x90 + VIDEOBASE_OFFSET
+#define     VIDE2_MODE_DETECTION_EDGE_H_REG             0x190 + VIDEOBASE_OFFSET
+    #define     LEFT_EDGE_LOCATION                      0x00000001  //Bit[11:0] Video source left edge location from sync rising edge
+    #define     LEFT_EDGE_LOCATION_BIT                  0
+    #define     LEFT_EDGE_LOCATION_MASK                 0x00000FFF
+	#define		NO_VER_SYNC								(1 << 12)		//Bit[12] No Vertical sync detected
+	#define		NO_HOR_SYNC								(1 << 13)		//Bit[13] No horizontal sync detected
+	#define		NO_ACTIVE_DISP							(1 << 14)		//Bit[14] No active display detected
+	#define		NO_DISP_CLOCK							(1 << 15)		
+    #define     RIGHT_EDGE_LOCATION                     0x00010000  //Bit[27:16] Video source right edge location from sync rising edge
+    #define     RIGHT_EDGE_LOCATION_BIT                 16
+    #define     RIGHT_EDGE_LOCATION_MASK                0x0FFF0000
+
+#define     VIDE1_MODE_DETECTION_EDGE_V_REG             0x94 + VIDEOBASE_OFFSET
+#define     VIDE2_MODE_DETECTION_EDGE_V_REG             0x194 + VIDEOBASE_OFFSET
+    #define     TOP_EDGE_LOCATION                       0x00000001  //Bit[11:0] Video source top edge location from sync rising edge
+    #define     TOP_EDGE_LOCATION_BIT                   0
+    #define     TOP_EDGE_LOCATION_MASK                  0x00000FFF
+    #define     BOTTOM_EDGE_LOCATION                    0x00010000  //Bit[27:16] Video source bottom edge location from sync rising edge
+    #define     BOTTOM_EDGE_LOCATION_BIT                16
+    #define     BOTTOM_EDGE_LOCATION_MASK               0x0FFF0000
+
+#define VIDEO1_MODE_DETECTION_STATUS_READ_REG           0x98 + VIDEOBASE_OFFSET
+#define VIDEO2_MODE_DETECTION_STATUS_READ_REG           0x198 + VIDEOBASE_OFFSET    
+    #define     MODE_DETECTION_HOR_TIME_READ            0x00000001  //Bit[11:0] Mode detection Horizontal time read back (read only)
+    #define     MODE_DETECTION_HOR_TIME_READ_BIT        0
+    #define     MODE_DETECTION_HOR_TIME_READ_MASK       0x00000FFF
+    #define     ANALONG_DIGITAL_READ                    0x00001000  //Bit[12] Auto detection for external analog or digital source read back
+        #define     ANALONG_DIGITAL_READ_BIT            12
+        #define     DVI_SIGNAL                          0
+        #define     ADC_SIGNAL                          1
+    #define     MODE_DETECTION_HOR_STABLE_READ          0x00002000  //Bit[13] Mode detection horizontal stable read back
+        #define     HOR_STABLE                          1
+    #define     MODE_DETECTION_VER_STABLE_READ          0x00004000  //Bit[14] Mode detection vertical stable read back
+        #define     VER_STABLE                          1
+    #define     OUT_LOCK_READ                           0x00008000  //Bit[15] Mode detection out of lock read back
+        #define     SIGNAL_OUT_LOCK                     1
+    #define     MODE_DETECTION_VER_LINE_READ            0x00010000  //Bit[27:16] Mode detection Vertical lines read back
+    #define     MODE_DETECTION_VER_LINE_READ_BIT        16
+    #define     MODE_DETECTION_VER_LINE_READ_MASK       0x0FFF0000
+    #define     VSYNC_POLARITY_READ                     0x10000000  //Bit[28] Vsync polarity read back
+    #define     HSYNC_POLARITY_READ                     0x20000000  //Bit[29] Hsync polarity read back
+    #define     MODE_DETECTION_VSYNC_READY              0x40000000  //Bit[30] Mode detection Vsync ready
+    #define     MODE_DETECTION_HSYNC_READY              0x80000000  //Bit[31] Mode detection Hsync ready
+
+/******     VIDEO MEMAGER SETTING               ******/
+#define     VIDEOM_ENGINE_SEQUENCE_CONTROL_REG          0x204 + VIDEOBASE_OFFSET
+    #define     VIDEOM_CAPTURE_TRIGGER                  0x00000002  //Bit[1] trigger HW to capture video
+    #define     VIDEOM_AUTO_MODE						0x00000008  //Bit[3]
+        #define     DISABLE_AUTO_MODE                   0
+        #define     AUTO_COMPRESS						1
+    #define     VIDEOM_CODEC_TRIGGER                    0x00000010  //Bit[4] trigger HW to compress or decompress video
+    #define     VIDEOM_SOURCE_SELECTION                 0x00000100  //Bit[8]
+        #define     VIDEO1                              0
+        #define     VIDEO2                              1
+    //#define     STREAM_DATA_MODE                        0x00000400  //Bit[11:10] Buffer and Stream Data type
+    //    #define     STREAM_DATA_MODE_BIT                10
+    //    #define     STREAM_DATA_MODE_MASK               0x00000C00
+    //    #define     YUV444_MODE                         0
+    //    #define     YUV420_MODE                         1
+    //    #define     YUV420_MODE_WITH_AST2000            2 //AST2000 compatible
+    #define     VIDEOM_CAPTURE_READY                    0x00010000  //Bit[16] Video capture ready status read back(read only)
+        //#define     HW_BUSY                             0
+        //#define     HW_IDLE                             1
+    #define     VIDEOM_CODEC_READY                      0x00040000  //Bit[18] Video codec ready status read back(read only)
+        //#define     HW_BUSY                             0
+        //#define     HW_IDLE                             1
+
+#define    VIDEOM_SCALE_FACTOR_REG                      0x214 + VIDEOBASE_OFFSET
+//    #define     HOR_SCALING_FACTOR                      0x00000001  //Bit[15:0] Video Horizontal scaling factor
+//    #define     HOR_SCALING_FACTOR_BIT                  0   //The formula=4096/(Horizontal scaling facotr)
+//    #define     HOR_SCALING_FACTOR_MASK                 0x0000FFFF
+//    #define     VER_SCALING_FACTOR                      0x00000000  //Bit[31:16] Video Vertical scaling factor
+//    #define     VER_SCALING_FACTOR_BIT                  16   //The formula=4096/(Vertical scaling facotr)
+//    #define     VER_SCALING_FACTOR_MASK                 0xFFFF0000
+
+#define    VIDEOM_SCALE_FACTOR_PARAMETER0_REG           0x218 + VIDEOBASE_OFFSET  //Scaling Parameters F00, F01, F02, F03
+
+#define    VIDEOM_SCALE_FACTOR_PARAMETER1_REG           0x21C + VIDEOBASE_OFFSET  //Scaling Parameters F10, F11, F12, F13
+
+#define    VIDEOM_SCALE_FACTOR_PARAMETER2_REG           0x220 + VIDEOBASE_OFFSET  //Scaling Parameters F20, F21, F22, F23
+
+#define    VIDEOM_SCALE_FACTOR_PARAMETER3_REG           0x224 + VIDEOBASE_OFFSET  //Scaling Parameters F30, F31, F32, F33
+
+#define    VIDEOM_BCD_CONTROL_REG                       0x22C + VIDEOBASE_OFFSET
+    //#define     BCD_ENABLE                              0x00000001  //Bit[0] Enable block change detection(BCD)
+    //#define     BCD_TOLERANCE                           0x00010000  //Bit[23:16]
+    //    #define     BCD_TOLERANCE_BIT                   16 //flag as changed block when the video data difference greater
+    //    #define     BCD_TOLERANCE_MASK                  0x00FF0000
+
+#define     VIDEOM_CAPTURE_WINDOWS_REG                  0x230 + VIDEOBASE_OFFSET
+    //#define     RC4_TABLE_ADDR_ALIGN                    7   //8 byte alignment
+    //#define     RC4_TABLE_ADDR_MASK                     0x0FFFFFFF
+
+#define     VIDEOM_COMPRESS_WINDOWS_REG                 0x234 + VIDEOBASE_OFFSET
+    //#define     COMPRESS_VER_LINE                       0x00000001  //Bit[12:0] Video compression vertical line total
+    //#define     COMPRESS_VER_LINE_BIT                   0
+    //#define     COMPRESS_VER_LINE_MASK                  0x00001FFF
+    //#define     COMPRESS_HOR_PIXEL                      0x00010000  //Bit[12:0] Video compression vertical line total
+    //#define     COMPRESS_HOR_PIXEL_BIT                  16
+    //#define     COMPRESS_HOR_PIXEL_MASK                 0x1FFF0000
+
+#define     VIDEOM_COMPRESS_BUF_PROCESS_OFFSET_REG      0x238
+    //#define     COMPRESS_BUF_PROCESS_OFFSET_ALIGN       127 //128 byte alignment
+    //#define     COMPRESS_BUF_PROCESS_OFFSET_MASK        0x3FFFFF
+
+
+//For Compression
+#define     VIDEOM_COMPRESS_BUF_READ_OFFSET_REG         0x23C + VIDEOBASE_OFFSET     //For stream mode
+    //#define     COMPRESS_BUF_READ_OFFSET_ALIGN          127 //128 byte alignment
+    //#define     COMPRESS_BUF_READ_OFFSET_MASK           0x003FFFFF
+//For Decompression
+#define     VIDEOM_DECOMPRESS_BUF_WRITE_OFFSET_REG      0x23C + VIDEOBASE_OFFSET     //For stream mode 
+    //#define     DECOMPRESS_BUF_WRITE_OFFSET_ALIGN       127 //128 byte alignment
+    //#define     DECOMPRESS_BUF_WRITE_OFFSET_MASK        0x003FFFFF
+    
+#define     VIDEOM_BUF_1_ADDR_REG                       0x244 + VIDEOBASE_OFFSET     //For Source Buffer in frame mode
+    //#define     BUF_1_ADDR_ALIGN                        255 //256 byte alignment
+    //#define     BUF_1_ADDR_MASK                         0x0FFFFFFF
+
+#define     VIDEOM_BUF_LINE_OFFSET_REG                  0x248 + VIDEOBASE_OFFSET     //Must set both in Frame/Stream mode
+    //#define     BUF_LINE_OFFSET_ALIGN                   7 //8 byte alignment
+    //#define     BUF_LINE_OFFSET_MASK                    0x00003FFF
+
+#define     VIDEOM_BUF_2_ADDR_REG                       0x24C + VIDEOBASE_OFFSET     //For BCD Buffer in frame mode
+    //#define     BUF_2_ADDR_ALIGN                        255 //256 byte alignment
+    //#define     BUF_2_ADDR_MASK                         0x0FFFFFFF
+
+#define     VIDEOM_FLAG_BUF_ADDR_REG                    0x250 + VIDEOBASE_OFFSET     //For block change flag buffer
+    //#define     FLAG_BUF_ADDR_ALIGN                     7 //8 byte alignment
+    //#define     FLAG_BUF_ADDR_MASK                      0x0FFFFFFF
+
+#define     VIDEOM_COMPRESS_BUF_ADDR_REG                0x254 + VIDEOBASE_OFFSET     //For stream mode
+    //#define     FLAG_BUF_ADDR_ALIGN                     7 //8 byte alignment
+    //#define     FLAG_BUF_ADDR_MASK                      0x0FFFFFFF
+    
+#define     VIDEOM_BUF_CODEC_OFFSET_READ                0x25C + VIDEOBASE_OFFSET     //For stream mode,         
+    //#define     BUF_CODEC_OFFSET_ALIGN                  255 //256 byte alignment
+    //#define     BUF_CODEC_OFFSET_MASK                   0x003FFFFF
+    
+#define     VIDEOM_COMPRESS_CONTROL_REG                 0x260 + VIDEOBASE_OFFSET
+    //#define     JPEG_ONLY_ENCODE                        0x00000001  //Bit[0] JPEG only encoding
+    //    #define     JPEG_MIX_MODE                       0   //Enable JPEG/VQ mix mode encoding
+    //    #define     JPEG_ONLY_MODE                      1   //JPEG encoding mode only
+    //#define     VQ_4_COLOR_ENCODE                       0x00000002  //Bit[1] Enable 4 color VQ encoding
+    //    #define     VQ_1_2_COLOR_MODE                   0   //1 and 2 color mode VQ encoding
+    //    #define     VQ_4_COLOR_MODE                     1   //1, 2 and 4 color VQ encoding
+    //#define     QUALITY_CODEC_SETTING                   0x00000004  //Bit[2] High and best video quality codec mode setting
+    //    #define     JPEG_CODEC_MODE                     0   //not supported in best video quality mode
+    //    #define     QUANTI_CODEC_MODE                   1
+    //#define     JPEG_DUAL_QUALITY_EN                    0x00000008  //Bit[3] JPEG dual quality mode
+    //    #define     EN_JPEG_DUAL_QUALITY                1   //enable(only for normal video quality mode)
+    //#define     BEST_QUALITY_EN                         0x00000010  //Bit[4] Best quality video mode enable
+    //    #define     EN_BEST_QUALITY                     1   //enable(only for quantization codec mode)
+    //#define     RC4_CRYPT_EN                            0x00000020  //Bit[5] Enable RC4 encryption/decryption
+    //    #define     EN_RC4_CRYPT                        1   //enable
+    //#define     NORMAL_QUANTI_CHROMI_TABLE              0x00000040  //Bit[10:6] Normal video quality mode JPEG DCT chromi quantination table
+    //    #define     NORMAL_QUANTI_CHROMI_TABLE_BIT      6
+    //    #define     NORMAL_QUANTI_CHROMI_TABLE_MASK     0x000007C0
+    //#define     NORMAL_QUANTI_LUMI_TABLE                0x00000800  //Bit[15:11] Normal video quality mode JPEG DCT lumi quantination table
+    //    #define     NORMAL_QUANTI_LUMI_TABLE_BIT        11
+    //    #define     NORMAL_QUANTI_LUMI_TABLE_MASK       0x0000F800
+    //#define     HIGH_QUALITY_EN                         0x00010000  //Bit[16] High video quality mode enable
+    //    #define     EN_HIGH_QUALITY                     1   //Enable
+    //#define     UV_CIR656_FORMAT                        0x00080000  //Bit[19] UV fromat
+    //    #define     USE_UV_CIR656                       1   //recommand
+    //#define     HUFFMAN_TABLE_SELECT                    0x00100000  //Bit[20] JPEG Huffman table combination
+    //    #define     DUAL_TABLE                          0   //Dual Y, UV table
+    //    #define     SINGLE_TABLE                        1   //Single Y table
+    //    #define     SINGLE_UV_TABLE                     0x00200000  //1x: Single UV table
+    //#define     HIGH_QUANTI_CHROMI_TABLE                0x00400000  //Bit[26:22] High quality JPEG DCT chromi quantization table
+    //    #define     HIGH_QUANTI_CHROMI_TABLE_BIT        22
+    //    #define     HIGH_QUANTI_CHROMI_TABLE_MASK       0x07C00000                
+    //#define     HIGH_DEQUANTI_VALUE                     0x00400000  //Bit[26:22] High quality de-quantization value
+    //    #define     HIGH_DEQUANTI_VALUE_BIT             22
+    //    #define     HIGH_DEQUANTI_VALUE_MASK            0x07C00000        
+    //#define     HIGH_QUANTI_LUMI_TABLE                  0x08000000  //Bit[31:27] High quality JPEG DCT lumi quantization table
+    //    #define     HIGH_QUANTI_LUMI_TABLE_BIT          27
+    //    #define     HIGH_QUANTI_LUMI_TABLE_MASK         0xF8000000
+    //#define     BEST_DEQUANTI_VALUE                     0x08000000  //Bit[31:27] Best quality de-quantization value
+    //    #define     BEST_QUANTI_VALUE_BIT               27
+    //    #define     BEST_QUANTI_VALUE_MASK              0xF8000000
+    
+#define     VIDEOM_QUANTI_TABLE_LOW_REG                 0x264 + VIDEOBASE_OFFSET     //Match with 0x60 Bit[10:6], Bit[15:11]
+//    #define     QUANTI_CHROMI_TABLE_LOW                 0x00000001  //Bit[4:0] Normal video low quality block chromi quantization table
+//        #define     QUANTI_CHROMI_TABLE_LOW_BIT         0
+//        #define     QUANTI_CHROMI_TABLE_LOW_MASK        0x0000001F
+//    #define     QUANTI_LUMI_TABLE_LOW                   0x00000020  //Bit[9:5] Normal video low quality block lumi quantization table
+//        #define     QUANTI_CHROMI_TABLE_LOW_BIT         5
+//        #define     QUANTI_CHROMI_TABLE_LOW_MASK        0x000003E0
+
+#define     VIDEOM_QUANTI_VALUE_REG                     0x268 + VIDEOBASE_OFFSET     //Match with 0x60 Bit[26:22],Bit[31:27]
+//    #define     HIGH_QUANTI_VALUE                       0x00000001  //Bit[14:0] High quality quantization value. Format is 1.14
+//        #define     HIGH_QUANTI_VALUE_BIT               0
+//        #define     HIGH_QUANTI_VALUE_MASK              0x00007FFF
+//    #define     BEST_QUANTI_VALUE                       0x00010000  //Bit[30:16] Best quality quantization value. Format is 1.14
+//        #define     BEST_QUANTI_VALUE_BIT               16
+//        #define     BEST_QUANTI_VALUE_MASK              0x7FFF0000
+    
+#define     VIDEOM_BSD_PARA_REG                         0x26C + VIDEOBASE_OFFSET    //Video BSD Parameters Register    
+//    #define     BSD_HIGH_THRES                          0x00000001  //Bit[7:0] Block sharpness detection high threshold
+//    #define     BSD_HIGH_THRES_BIT                      0
+//    #define     BSD_HIGH_THRES_MASK                     0x000000FF
+//    #define     BSD_LOW_THRES                           0x00000100  //Bit[15:8] Block shaprpness detection low threshold
+//    #define     BSD_LOW_THRES_BIT                       8
+//    #define     BSD_LOW_THRES_MASK                      0x0000FF00
+//    #define     BSD_HIGH_COUNTS                         0x00010000  //Bit[21:16] Block sharpness detection high counts threshold
+//    #define     BSD_HIGH_COUNTS_BIT                     16
+//    #define     BSD_HIGH_COUNTS_MASK                    0x003F0000
+//    #define     BSD_LOW_COUNTS                          0x01000000  //Bit[27:24] Block sharpness detection low counts threshold
+//    #define     BSD_LOW_COUNTS_BIT                      24
+//    #define     BSD_LOW_COUNTS_MASK                     0x3F000000
+
+#define VIDEOM_COMPRESS_FRAME_SIZE_REG					  0x270 + VIDEOBASE_OFFSET
+//    #define     COMPRESS_FRAME_SIZE_READ                0x00000001  //Bit[19:0] Video compression frame size read back(number of DW)
+//    #define     COMPRESS_FRAME_SIZE_READ_BIT            0
+//    #define     COMPRESS_FRAME_SIZE_READ_MASK           0x000FFFFF
+
+#define     VIDEOM_COMPRESS_BLOCK_COUNT_REG				  0x274 + VIDEOBASE_OFFSET
+//    #define     COMPRESS_BLOCK_COUNT_READ               0x00000001  //Bit[15:0] Video compress block counter read back(number of blocks)
+//    #define     COMPRESS_BLOCK_COUNT_READ_BIT           0
+//    #define     COMPRESS_BLOCK_COUNT_READ_MASK          0x0000FFFF
+
+#define     VIDEOM_COMPRESS_FRAME_END_READ              0x278 + VIDEOBASE_OFFSET     //Video compression stream frame end pointer    
+    //#define     COMPRESS_FRAME_END_READ_ALIGN           7
+    //#define     COMPRESS_FRAME_END_READ_MASK            0x003FFFFF
+    
+#define     VIDEOM_USER_DEFINE_HEADER_REG			      0x280 + VIDEOBASE_OFFSET
+//    #define     USER_DEFINE_HEADER                      0x00000001  //Bit[15:0] Video user defined header parameter
+//    #define     USER_DEFINE_HEADER_BIT                  0
+//    #define     USER_DEFINE_HEADER_MASK                 0x0000FFFF
+
+/******  VR300-VR3FC: General Control registers  *****/
+#define     VIDEO_CONTROL_REG                           0x300 + VIDEOBASE_OFFSET
+    #define     CODEC_DECOMPRESS_MODE                   0x00000001  //Bit[0] Codec in de-compression mode
+        #define     CODEC_DECOMPRESS_MODE_BIT           0
+        #define     CODEC_DECOMPRESS_MODE_MASK          0x00000001 
+        #define     COMPRESS_MODE                       0
+        #define     DECOMPRESS_MODE                     1
+    #define     VIDEO_SAFE_MODE							0x00000002  //Bit[1] VIDEO SAFE MODE
+		#define     VIDEO_SAFE_MODE_BIT					1
+		#define     VIDEO_SAFE_MODE_OFF		            0
+        #define     VIDEO_SAFE_MODE_ON		            1
+    #define     DELAY_VSYNC								0x00000004  //Bit[2] Delay Internal VSYNC
+        #define     DELAY_VSYNC_BIT                     2
+        #define     DELAY_VSYNC_MASK                    (1<<2)
+		#define		DELAY_VSYNC_OFF						(0<<2)
+		#define		DELAY_VSYNC_EN						(1<<2)
+    #define     VER_DOWNSCALING_LINE_BUFFER_EN          0x00000010  //Bit[5:4] Video vertical downscaling line buffer enable
+		#define		VER_LINE_BUFFER_MASK				(3<<4)
+        #define     LINE_BUFFER_OFF                     (0<<4)
+        #define     LINE_BUFFER_VIDEO1                  1
+        #define     LINE_BUFFER_VIDEO2                  2
+        #define     LINE_BUFFER_VIDEOM                  3
+    #define     RC4_KEY_BUFFER_SELECTION				(1UL<<6)  //Bit[7:6] RC4 Key Buffer Selection
+		#define		RC4_KEY_BUFFER_SELECTION_BIT		6
+		#define		RC4_KEY_BUFFER_SELECTION_MASK		(3UL<<6)
+        #define     RC4_KEY_BUFFER_VIDEO1               0
+        #define     RC4_KEY_BUFFER_VIDEO2               1
+        #define     RC4_KEY_BUFFER_VIDEOM               2
+    #define     RC4_INIT_RESET							(1UL<<8)  //Bit[8] RC4 initial reset
+		#define     RC4_INIT_RESET_BIT					8
+		#define     RC4_INIT_RESET_MASK					(1UL<<8)
+		#define     RC4_NORMAL_MODE						0
+		#define     RC4_RESET_COUNTER					1
+    #define     RC4_TEST_MODE							(1UL<<9)  //Bit[9] RC4 test mode
+		#define     RC4_TEST_MODE_BIT					9
+		#define     RC4_TEST_OFF						0
+		#define     RC4_TEST_ON							1
+    #define     RC4_SAVE_MODE							(1UL<<14)  //Bit[14] RC4 save mode
+		#define     RC4_SAVE_MODE_BIT					14
+		#define     RC4_SAVE_MODE_MASK					(1UL<<14)
+		#define     RC4_SAVE_MODE_OFF					0
+		#define     RC4_SAVE_MODE_ON					1
+    #define     RC4_NO_RESET_FRAME						(1UL<<15)  //Bit[15] RC4 no reset when frame completed
+		#define     RC4_NO_RESET_FRAME_BIT				15
+		#define     RC4_NO_RESET_FRAME_MASK				(1UL<<15)
+		#define     RC4_NO_RESET_FRAME_OFF				0		//Always reset
+		#define     RC4_NO_RESET_FRAME_ON				1
+
+#define VIDEO_INT_CONTROL_EN_REG                        0x304 + VIDEOBASE_OFFSET
+    #define     VIDEO1_WATCH_DOG_INT_EN                 0x00000001  //Bit[0] Enable Video1 mode detection watch dog out of lock interrupt
+    #define     VIDEO1_INPUT_COMPLETE_INT_EN            0x00000002  //Bit[1] Enable Video1 video input complete interrupt  (frame complete only for frame mode)
+    #define     VIDEO1_PACKET_READY_INT_EN              0x00000004  //Bit[2] Enable Video1 packet ready interrupt
+    #define     VIDEO1_COMPRESS_COMPLETE_INT_EN         0x00000008  //Bit[3] Enable Video1 compression complete interrupt
+    #define     VIDEO1_MODE_DETECTION_READY_INT_EN      0x00000010  //Bit[4] Enable video1 mode detection ready interrupt
+    #define     VIDEO1_FRAME_COMPLETE_INT_EN            0x00000020  //Bit[5] Enable Video1 frame complete interrupt     (only for stream mode)
+    #define     VIDEO1_STREAM_ERR_INT_EN                0x00000040  //Bit[6] Enable Video1 decode stream error interrupt
+    #define     VIDEO2_WATCH_DOG_INT_EN                 0x00000100  //Bit[8] Enable Video2 mode detection watch dog out of lock interrupt
+    #define     VIDEO2_INPUT_COMPLETE_INT_EN            0x00000200  //Bit[9] Enable Video2 video input complete interrupt  (frame complete only for frame mode)
+    #define     VIDEO2_PACKET_READY_INT_EN              0x00000400  //Bit[10] Enable Video2 packet ready interrupt
+    #define     VIDEO2_COMPRESS_COMPLETE_INT_EN         0x00000800  //Bit[11] Enable Video2 compression complete interrupt
+    #define     VIDEO2_MODE_DETECTION_READY_INT_EN      0x00001000  //Bit[12] Enable video2 mode detection ready interrupt
+    #define     VIDEO2_FRAME_COMPLETE_INT_EN            0x00002000  //Bit[13] Enable Video2 frame complete interrupt    (only for stream mode)
+    #define     VIDEO2_STREAM_ERR_INT_EN                0x00004000  //Bit[14] Enable Video2 decode stream error interrupt
+    #define     VIDEOM_INPUT_COMPLETE_INT_EN            0x00010000  //Bit[16] Enable VideoM video input complete interrupt
+    #define     VIDEOM_COMPRESS_COMPLETE_INT_EN         0x00020000  //Bit[17] Enable VideoM compression complete interrupt
+	#define     VIDEOM_PACKET_READY_INT_EN				0x00040000  //Bit[18] Enable VideoM packet ready interrupt
+	#define     VIDEOM_FRAME_COMPLETE_INT_EN            0x00080000  //Bit[19] Enable VideoM frame complete interrupt    (only for stream mode)
+    
+#define VIDEO_INT_CONTROL_READ_REG                      0x308 + VIDEOBASE_OFFSET //Clear when write 1
+    #define     VIDEO1_WATCH_DOG_READ                   0x00000001  //Bit[0] Video1 mode detection watch dog out of lock interrupt status read back
+        #define     VIDEO1_WATCH_DOG_BIT				0
+        #define     VIDEO1_WATCH_DOG_MASK				0x00000001
+    #define     VIDEO1_INPUT_COMPLETE_READ              0x00000002  //Bit[1] Video1 video input complete interrupt status read back (frame complete only for frame mode)
+        #define     VIDEO1_INPUT_COMPLETE_BIT			1
+        #define     VIDEO1_INPUT_COMPLETE_MASK			0x00000002
+    #define     VIDEO1_PACKET_READY_READ                0x00000004  //Bit[2] Video1 packet ready interrupt status read back
+        #define     VIDEO1_PACKET_READY_BIT		        2
+        #define     VIDEO1_PACKET_READY_MASK		    0x00000004
+    #define     VIDEO1_COMPRESS_COMPLETE_READ           0x00000008  //Bit[3] Video1 compression complete interrupt status read back
+        #define     VIDEO1_COMPRESS_COMPLETE_BIT		3
+        #define     VIDEO1_COMPRESS_COMPLETE_MASK		0x00000008
+    #define     VIDEO1_MODE_DETECTION_READY_READ        0x00000010  //Bit[4] Video1 mode detection ready interrupt status read back
+        #define     VIDEO1_MODE_DETECTION_READY_BIT     4
+    #define     VIDEO1_FRAME_COMPLETE_READ              0x00000020  //Bit[5] Video1 frame complete interrupt status read back
+        #define     VIDEO1_FRAME_COMPLETE_BIT			5
+        #define     VIDEO1_FRAME_COMPLETE_MASK			0x00000020
+    #define     VIDEO1_STREAM_ERR_READ                  0x00000040  //Bit[6] Video1 decode stream error interrupt status read back
+        #define     VIDEO1_STREAM_ERR_BIT				6
+        #define     VIDEO1_STREAM_ERR_MASK				0x00000040
+    #define     VIDEO2_WATCH_DOG_READ                   0x00000100  //Bit[8] Video2 mode detection watch dog out of lock interrupt status read back
+        #define     VIDEO2_WATCH_DOG_BIT				8
+        #define     VIDEO2_WATCH_DOG_MASK				0x00000100
+    #define     VIDEO2_INPUT_COMPLETE_READ              0x00000200  //Bit[9] Video2 video input complete interrupt status read back (frame complete only for frame mode)
+        #define     VIDEO2_INPUT_COMPLETE_BIT			9
+        #define     VIDEO2_INPUT_COMPLETE_MASK			0x00000200
+    #define     VIDEO2_PACKET_READY_READ                0x00000400  //Bit[10] Video2 packet ready interrupt status read back
+        #define     VIDEO2_PACKET_READY_BIT		        10
+        #define     VIDEO2_PACKET_READY_MASK		    0x00000400
+    #define     VIDEO2_COMPRESS_COMPLETE_READ           0x00000800  //Bit[11] Video2 compression complete interrupt status read back 
+        #define     VIDEO2_COMPRESS_COMPLETE_BIT		11
+        #define     VIDEO2_COMPRESS_COMPLETE_MASK		0x00000800      
+		#define     VIDEO2_MODE_DETECTION_READY_READ    0x00001000  //Bit[12] Video2 mode detection ready interrupt status read back
+        #define     VIDEO2_MODE_DETECTION_READY_BIT     12              
+    #define     VIDEO2_FRAME_COMPLETE_READ              0x00002000  //Bit[13] Video2 frame complete interrupt status read back
+        #define     VIDEO2_FRAME_COMPLETE_BIT		    13
+        #define     VIDEO2_FRAME_COMPLETE_MASK			0x00002000
+    #define     VIDEO2_STREAM_ERR_READ                  0x00004000  //Bit[14] Video2 decode stream error interrupt status read back
+        #define     VIDEO2_STREAM_ERR_BIT				14
+        #define     VIDEO2_STREAM_ERR_MASK				0x00004000
+    //need check spec
+    #define     VIDEOM_INPUT_COMPLETE_READ              0x00010000  //Bit[16] VideoM video input complete interrupt status read back
+        #define     VIDEOM_INPUT_COMPLETE_BIT			16
+        #define     VIDEOM_INPUT_COMPLETE_MASK			0x00010000
+    #define     VIDEOM_COMPRESS_COMPLETE_READ           0x00020000  //Bit[17] VideoM compression complete interrupt status read back
+        #define     VIDEOM_COMPRESS_COMPLETE_BIT		17
+        #define     VIDEOM_COMPRESS_COMPLETE_MASK		0x00020000
+    #define     VIDEOM_PACKET_READY_READ                0x00040000  //Bit[18] Clear Packet ready interrupt when write 1
+        #define     VIDEOM_PACKET_READY_BIT             18
+        #define     VIDEOM_PACKET_READY_MASK            0x00040000    
+    #define     VIDEOM_FRAME_COMPLETE_READ              0x00080000  //Bit[19] Clear Frame complete interrupt when write 1
+        #define     VIDEOM_FRAME_COMPLETE_BIT           19
+        #define     VIDEOM_FRAME_COMPLETE_MASK          0x00080000
+   
+#define VIDEO_INT_CONTROL_CLEAR_REG                     0x308 + VIDEOBASE_OFFSET //Clear when write 1
+    //Clear when write 1
+    #define     VIDEO1_WATCH_DOG_CLEAR                  0x00000001  //Bit[0] Clear mode detection watch dog out of lock interrupt when write 1
+    #define     VIDEO1_INPUT_COMPLETE_CLEAR             0x00000002  //Bit[1] Clear video input complete interrupt when write 1 (frame complete only for frame mode)
+    #define     VIDEO1_PACKET_READY_CLEAR               0x00000004  //Bit[2] Clear Packet ready interrupt when write 1
+        #define     VIDEO1_PACKET_READY_CLEAR_BIT       2
+        #define     VIDEO1_PACKET_READY_CLEAR_MASK      0x00000004
+    #define     VIDEO1_COMPRESS_COMPLETE_CLEAR          0x00000008  //Bit[3] Clear video compression interrupt when write 1
+    #define     VIDEO1_MODE_DETECTION_READY_CLEAR       0x00000010  //Bit[4] Clear Video1 Mode detection ready interrupt when write 1
+    #define     VIDEO1_FRAME_COMPLETE_CLEAR             0x00000020  //Bit[5] Clear Frame complete interrupt when write 1
+        #define     VIDEO1_FRAME_COMPLETE_CLEAR_BIT     5
+        #define     VIDEO1_FRAME_COMPLETE_CLEAR_MASK    0x00000020
+    #define     VIDEO1_STREAM_ERR_CLEAR                 0x00000040  //Bit[6] Clear decode stream error interrupt when write 1
+    #define     VIDEO2_WATCH_DOG_CLEAR                  0x00000100  //Bit[8] Clear Mode detection interrupt when write 1
+    #define     VIDEO2_INPUT_COMPLETE_CLEAR             0x00000200  //Bit[9] Clear video input complete interrupt when write 1
+    #define     VIDEO2_PACKET_READY_CLEAR               0x00000400  //Bit[10] Clear packet ready interrupt when write 1
+    #define     VIDEO2_COMPRESS_COMPLETE_CLEAR          0x00000800  //Bit[11] Clear video compression complete interrupt when write 1
+    #define     VIDEO2_MODE_DETECTION_READY_CLEAR       0x00001000  //Bit[12] Clear Video2 Mode detection ready interrupt when write 1
+    #define     VIDEO2_FRAME_COMPLETE_CLEAR             0x00002000  //Bit[13] Clear Frame complete interrupt when write 1 (frame complete only for frame mode)
+    #define     VIDEO2_STREAM_ERR_CLEAR                 0x00004000  //Bit[14] Clear Decode stream error interrupt when write 1
+    //need check spec
+    #define     VIDEOM_INPUT_COMPLETE_CLEAR             0x00010000  //Bit[16] Clear video input complete interrupt when write 1
+    #define     VIDEOM_COMPRESS_COMPLETE_CLEAR          0x00020000  //Bit[17] Clear compression complete interrupt when write 1
+        #define     VIDEOM_COMPRESS_COMPLETE_CLEAR_BIT  17
+        #define     VIDEOM_COMPRESS_COMPLETE_CLEAR_MASK 0x00020000    
+	#define     VIDEOM_PACKET_READY_CLEAR				0x00040000  //Bit[18] Clear compression complete interrupt when write 1
+        #define     VIDEOM_PACKET_READY_CLEAR_BIT       18
+        #define     VIDEOM_PACKET_READY_CLEAR_MASK      0x00040000    
+    #define     VIDEOM_FRAME_COMPLETE_CLEAR             0x00100000  //Bit[20] Clear Frame complete interrupt when write 1
+        #define     VIDEOM_FRAME_COMPLETE_CLEAR_BIT     20
+        #define     VIDEOM_FRAME_COMPLETE_CLEAR_MASK    0x00100000
+    #define     VIDEOM_STREAM_ERR_CLEAR                 0x00200000  //Bit[21] Clear decode stream error interrupt when write 1
+    
+#define VIDEO_MODE_DETECTION_PARAM_REG                  0x30C + VIDEOBASE_OFFSET
+    #define     EDGE_PIXEL_THRES_BIT                    8           //Bit[15:8] Mode detection edge pixel threshold
+    #define     EDGE_PIXEL_THRES_MASK                   0x0000FF00  
+    #define     VER_STABLE_MAX_BIT                      16          //Bit[19:16] Mode detection vertical stable maximum
+    #define     VER_STABLE_MAX_BIT_MASK                 0x000F0000  
+    #define     HOR_STABLE_MAX_BIT                      20          //Bit[23:20] Mode detection horizontal stable maximum
+    #define     HOR_STABLE_MAX_BIT_MASK                 0x00F00000
+    #define     VER_STABLE_THRES_BIT                    24          //Bit[27:24] Mode detection vertical stable threshold
+    #define     VER_STABLE_THRES_BIT_MASK               0x0F000000  
+    #define     HOR_STABLE_THRES_BIT                    28          //Bit[31:28] Mode detection horizontal stable threshold
+    #define     HOR_STABLE_THRES_BIT_MASK               0xF0000000
+    
+#define VIDEO_CRC_PRIMARY_REG                           0x320 + VIDEOBASE_OFFSET
+    #define     CRC_CHECK_EN                            0x00000001  //Bit[0] Video port 1/2 Enable video capture write CRC check
+        #define     CRC_CHECK_EN_BIT                    0
+    #define     CRC_CHECK_HIGH                          0x00000002  //Bit[1] Video port 1/2 CRC check high bit only
+        #define     CRC_CHECK_HIGH_BIT                  1
+    #define     SKIP_COUNT_MAX                          0x00000004  //Bit[7:2] Video port 1/2 Max capture write skip count
+        #define     SKIP_COUNT_MAX_BIT                  2
+        #define     SKIP_COUNT_MAX_MASK                 0x000000FC
+    #define     CRC_PRIMARY_POLY_LOW                    0x00000100  //Bit[15:8] Primary CRC low 8-bit polynomial
+        #define     CRC_RIMARY_POLY_LOW_BIT             8
+        #define     CRC_RIMARY_POLY_LOW_MASK            0x0000FF00
+    #define     CRC_PRIMARY_POLY_HIGH                   0x00010000  //Bit[31:16] Primary CRC high 8-bit polynomial
+        #define     CRC_RIMARY_POLY_HIGH_BIT            16
+        #define     CRC_RIMARY_POLY_HIGH_MASK           0xFFFF0000
+        
+
+#define VIDEO_CRC_SECOND_REG                            0x324 + VIDEOBASE_OFFSET
+    #define     CRC_SECOND_POLY_LOW                     0x00000100  //Bit[15:8] Secondary CRC low 8-bit polynomial
+        #define     CRC_SECOND_POLY_LOW_BIT             8
+        #define     CRC_SECOND_POLY_LOW_MASK            0x0000FF00
+    #define     CRC_SECOND_POLY_HIGH                    0x00010000  //Bit[31:16] Secondary CRC high 8-bit polynomial
+        #define     CRC_SECOND_POLY_HIGH_BIT            16
+        #define     CRC_SECOND_POLY_HIGH_MASK           0xFFFF0000
+
+#define VIDEO1_RC4_KEYS_REG                              0x400 + VIDEOBASE_OFFSET //Total Video1 RC4 Keys     
+#define VIDEO2_RC4_KEYS_REG                              0x500 + VIDEOBASE_OFFSET //Total Video2 RC4 Keys     
+#define VIDEOM_RC4_KEYS_REG                              0x600 + VIDEOBASE_OFFSET //Total VideoM RC4 Keys     
+
+#endif /* end of _VREG_H_ */
+
diff --git a/boards.cfg b/boards.cfg
index 6a368de..674896b 100644
--- a/boards.cfg
+++ b/boards.cfg
@@ -72,6 +72,7 @@ mini2440                     arm         arm920t     mini2440            friendl
 VCMA9                        arm         arm920t     vcma9               mpl            s3c24x0
 smdk2410                     arm         arm920t     -                   samsung        s3c24x0
 omap1510inn                  arm         arm925t     -                   ti
+ast2400                      arm         arm926ejs   ast2400             aspeed         aspeed
 integratorap_cm926ejs        arm         arm926ejs   integrator          armltd         -           integratorap:CM926EJ_S
 integratorcp_cm926ejs        arm         arm926ejs   integrator          armltd         -           integratorcp:CM924EJ_S
 aspenite                     arm         arm926ejs   -                   Marvell        armada100
diff --git a/common/Makefile b/common/Makefile
index 53c92ef..6ba5f38 100644
--- a/common/Makefile
+++ b/common/Makefile
@@ -190,6 +190,8 @@ COBJS-$(CONFIG_CMD_ZIP) += cmd_zip.o
 COBJS-$(CONFIG_CMD_ZFS) += cmd_zfs.o
 
 # others
+OBJS-$(CONFIG_CMD_NETTEST) += cmd_nettest.o
+COBJS-$(CONFIG_CMD_SLT) += cmd_slt.o
 COBJS-$(CONFIG_BOOTSTAGE) += bootstage.o
 COBJS-$(CONFIG_CONSOLE_MUX) += iomux.o
 COBJS-y += flash.o
diff --git a/common/cmd_nettest.c b/common/cmd_nettest.c
new file mode 100644
index 0000000..249d7b6
--- /dev/null
+++ b/common/cmd_nettest.c
@@ -0,0 +1,214 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#include <common.h>
+#include <command.h>
+#include <COMMINF.H>
+
+#ifdef SLT_UBOOT
+extern int main_function(int argc, char *argv[]);
+
+int do_mactest (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+    ModeSwitch = MODE_DEDICATED;
+    return main_function( argc, argv);
+}
+
+int do_ncsitest (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+    ModeSwitch = MODE_NSCI;
+    return main_function( argc, argv);
+}
+
+U_BOOT_CMD(
+    mactest,    CONFIG_SYS_MAXARGS, 0,  do_mactest,
+    "mactest - Dedicated LAN test program \n",
+    NULL
+);
+U_BOOT_CMD(
+    ncsitest,    CONFIG_SYS_MAXARGS, 0,  do_ncsitest,
+    "ncsitest- Share LAN (NC-SI) test program \n",
+    NULL
+);
+
+// ------------------------------------------------------------------------------
+int do_phyread (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+    int     MACnum;
+    int     PHYreg;
+    ULONG   result_data;
+    int     ret = 0;
+    int     PHYaddr;
+    int     timeout = 0;    
+
+    do {
+        if ( argc != 4 ) {
+            printf(" Wrong parameter number.\n" );
+            printf(" phyr mac addr reg\n"  );
+            printf("   mac     : 0 or 1.   [hex]\n"  );
+            printf("   PHY addr: 0 to 31.  [hex]\n"  );
+            printf("   register: 0 to 0xFF.[hex]\n"  );
+            printf(" example: phyr 0 0 1\n"  );
+            ret = -1;
+            break;
+        }
+
+        MACnum  = strtoul(argv[1], NULL, 16);
+        PHYaddr = strtoul(argv[2], NULL, 16);
+        PHYreg  = strtoul(argv[3], NULL, 16);
+        
+        if ( MACnum == 0 ) {
+            // Set MAC 0
+            H_MAC_BASE  = MAC_BASE1;
+        }
+        else if ( MACnum == 1 ) {
+                // Set MAC 1
+                H_MAC_BASE  = MAC_BASE2;
+        }
+        else {
+            printf("wrong parameter (mac number)\n");
+            ret = -1;
+            break;
+        }
+        MAC_PHYBASE = H_MAC_BASE;
+        
+        if ( ( PHYaddr < 0 ) || ( PHYaddr > 31 ) ) {
+            printf("wrong parameter (PHY address)\n");
+            ret = -1;
+            break;
+        }
+            
+        MAC_40h_old = ReadSOC_DD( H_MAC_BASE + 0x40 );
+        AST2300_NewMDIO = (MAC_40h_old & 0x80000000) ? 1 : 0;
+        
+        if ( AST2300_NewMDIO ) {
+            WriteSOC_DD( MAC_PHYBASE + 0x60, MAC_PHYRd_New | (PHYaddr << 5) | ( PHYreg & 0x1f ) );
+            while ( ReadSOC_DD( MAC_PHYBASE + 0x60 ) & MAC_PHYBusy_New ) {
+                if ( ++timeout > TIME_OUT_PHY_RW ) {
+                    ret = -1;
+                    break;
+                }
+            }
+            DELAY(Delay_PHYRd);
+            result_data = ReadSOC_DD( MAC_PHYBASE + 0x64 ) & 0xffff;  
+        } 
+        else {
+            WriteSOC_DD( MAC_PHYBASE + 0x60, MDC_Thres | MAC_PHYRd | (PHYaddr << 16) | ((PHYreg & 0x1f) << 21) );
+            while ( ReadSOC_DD( MAC_PHYBASE + 0x60 ) & MAC_PHYRd ) {
+                if ( ++timeout > TIME_OUT_PHY_RW ) {
+                    ret = -1;
+                    break;
+                }
+            }
+            DELAY( Delay_PHYRd );
+            result_data = ReadSOC_DD( MAC_PHYBASE + 0x64 ) >> 16;
+        }
+        printf(" PHY[%d] reg[%2X] = %08lX\n", PHYaddr, PHYreg, result_data ); 
+    } while ( 0 );
+    
+    return ret;
+}
+
+
+int do_phywrite (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+    int     MACnum;
+    int     PHYreg;
+    int     PHYaddr;
+    ULONG   reg_data;
+    int     ret     = 0;
+    int     timeout = 0;    
+    
+    do {
+        if ( argc != 5 )
+        {
+            printf(" Wrong parameter number.\n" );
+            printf(" phyw mac addr reg data\n"  );
+            printf("   mac     : 0 or 1.     [hex]\n"  );
+            printf("   PHY addr: 0 to 31.    [hex]\n"  );
+            printf("   register: 0 to 0xFF.  [hex]\n"  );
+            printf("   data    : 0 to 0xFFFF.[hex]\n"  );
+            printf(" example: phyw 0 0 0 610\n"  );
+            ret = -1;
+            break;
+        }
+        
+        MACnum   = strtoul(argv[1], NULL, 16);
+        PHYaddr  = strtoul(argv[2], NULL, 16);
+        PHYreg   = strtoul(argv[3], NULL, 16);
+        reg_data = strtoul(argv[4], NULL, 16);
+        
+        if ( MACnum == 0 ) {
+            // Set MAC 0
+            H_MAC_BASE  = MAC_BASE1;
+        }
+        else if ( MACnum == 1 ) {
+                // Set MAC 1
+                H_MAC_BASE  = MAC_BASE2;
+        }
+        else {
+            printf("wrong parameter (mac number)\n");
+            ret = -1;
+            break;
+        }
+        MAC_PHYBASE = H_MAC_BASE;
+        
+        if ( ( PHYaddr < 0 ) || ( PHYaddr > 31 ) ) {
+            printf("wrong parameter (PHY address)\n");
+            ret = -1;
+            break;
+        }
+        
+        MAC_40h_old = ReadSOC_DD( H_MAC_BASE + 0x40 );
+        AST2300_NewMDIO = (MAC_40h_old & 0x80000000) ? 1 : 0;
+        
+        if (AST2300_NewMDIO) {
+            WriteSOC_DD( MAC_PHYBASE + 0x60, ( reg_data << 16 ) | MAC_PHYWr_New | (PHYaddr<<5) | (PHYreg & 0x1f));
+
+            while ( ReadSOC_DD( MAC_PHYBASE + 0x60 ) & MAC_PHYBusy_New ) {
+                if ( ++timeout > TIME_OUT_PHY_RW ) {
+                    ret = -1;
+                    break;
+                }
+            }
+        } 
+        else {
+            WriteSOC_DD( MAC_PHYBASE + 0x64, reg_data );
+            WriteSOC_DD( MAC_PHYBASE + 0x60, MDC_Thres | MAC_PHYWr | (PHYaddr<<16) | ((PHYreg & 0x1f) << 21));
+
+            while ( ReadSOC_DD( MAC_PHYBASE + 0x60 ) & MAC_PHYWr ) {
+                if ( ++timeout > TIME_OUT_PHY_RW ) {
+                    ret = -1;
+                    break;
+                }
+            }
+        } // End if (AST2300_NewMDIO)
+        
+        printf("Write: PHY[%d] reg[%2X] = %08lX\n", PHYaddr, PHYreg, reg_data );     
+    } while ( 0 );
+
+    return ret;
+}
+
+U_BOOT_CMD(
+    phyr,    CONFIG_SYS_MAXARGS, 0,  do_phyread,
+    "phyr    - Read PHY register.  (phyr mac addr reg)\n",
+    NULL
+);
+
+U_BOOT_CMD(
+    phyw,    CONFIG_SYS_MAXARGS, 0,  do_phywrite,
+    "phyw    - Write PHY register. (phyw mac addr reg data)\n",
+    NULL
+);
+
+#endif // End SLT_UBOOT
+
diff --git a/common/cmd_slt.c b/common/cmd_slt.c
new file mode 100644
index 0000000..9763692
--- /dev/null
+++ b/common/cmd_slt.c
@@ -0,0 +1,49 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#include <command.h>
+
+extern int pll_function(int argc, char *argv[]);
+extern int trap_function(int argc, char *argv[]);
+extern int dram_stress_function(int argc, char *argv[]);
+
+int do_plltest (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+    return pll_function( argc, argv);
+}
+
+U_BOOT_CMD(
+    plltest,   CONFIG_SYS_MAXARGS, 0,  do_plltest,
+    "plltest - PLLTest [pll mode] [err rate] \n",
+    NULL
+);
+
+int do_traptest (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+    return trap_function( argc, argv);
+}
+
+U_BOOT_CMD(
+    traptest,   CONFIG_SYS_MAXARGS, 0,  do_traptest,
+    "traptest- Check hardware trap for CPU clock and CPU\\AHB ratio.\n",
+    NULL
+);
+
+int do_dramtest (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
+{
+    return dram_stress_function( argc, argv);
+}
+
+U_BOOT_CMD(
+    dramtest,   CONFIG_SYS_MAXARGS, 0,  do_dramtest,
+    "dramtest- Stress DRAM.\n",
+    NULL
+);
diff --git a/drivers/i2c/Makefile b/drivers/i2c/Makefile
index 72e85a3..2b35587 100644
--- a/drivers/i2c/Makefile
+++ b/drivers/i2c/Makefile
@@ -43,6 +43,7 @@ COBJS-$(CONFIG_S3C44B0_I2C) += s3c44b0_i2c.o
 COBJS-$(CONFIG_SOFT_I2C) += soft_i2c.o
 COBJS-$(CONFIG_TEGRA_I2C) += tegra_i2c.o
 COBJS-$(CONFIG_TSI108_I2C) += tsi108_i2c.o
+COBJS-$(CONFIG_DRIVER_ASPEED_I2C) += aspeed_i2c.o
 COBJS-$(CONFIG_U8500_I2C) += u8500_i2c.o
 COBJS-$(CONFIG_SH_I2C) += sh_i2c.o
 COBJS-$(CONFIG_SH_SH7734_I2C) += sh_sh7734_i2c.o
diff --git a/drivers/i2c/aspeed_i2c.c b/drivers/i2c/aspeed_i2c.c
new file mode 100755
index 0000000..ff6c756
--- /dev/null
+++ b/drivers/i2c/aspeed_i2c.c
@@ -0,0 +1,286 @@
+/*
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <common.h>
+#include <asm/arch/aspeed_i2c.h>
+
+#ifdef CONFIG_DRIVER_ASPEED_I2C
+
+void i2c_init (int speed, int slaveadd)
+{
+	unsigned long SCURegister;
+//I2C Reset
+        SCURegister = inl (SCU_BASE + SCU_RESET_CONTROL);
+        outl (SCURegister & ~(0x04), SCU_BASE + SCU_RESET_CONTROL);
+//I2C Multi-Pin
+        SCURegister = inl (SCU_BASE + SCU_MULTIFUNCTION_PIN_CTL5_REG);
+        outl ((SCURegister | 0x30000), SCU_BASE + SCU_MULTIFUNCTION_PIN_CTL5_REG);
+//Reset
+	outl (0, I2C_FUNCTION_CONTROL_REGISTER);
+//Set AC Timing, we use fix AC timing for eeprom in u-boot
+	outl (AC_TIMING, I2C_AC_TIMING_REGISTER_1);
+	outl (0, I2C_AC_TIMING_REGISTER_2);
+//Clear Interrupt
+	outl (ALL_CLEAR, I2C_INTERRUPT_STATUS_REGISTER);
+//Enable Master Mode
+	outl (MASTER_ENABLE, I2C_FUNCTION_CONTROL_REGISTER);
+//Enable Interrupt, STOP Interrupt has bug in AST2000
+	outl (0xAF, I2C_INTERRUPT_CONTROL_REGISTER);
+//Set Slave address, should not use for eeprom
+	outl (slaveadd, I2C_DEVICE_ADDRESS_REGISTER);
+}
+
+static int i2c_read_byte (u8 devaddr, u16 regoffset, u8 * value, int alen)
+{
+	int i2c_error = 0;
+	u32 status, count = 0;
+
+//Start and Send Device Address
+	outl (devaddr, I2C_BYTE_BUFFER_REGISTER);
+	outl (MASTER_START_COMMAND | MASTER_TX_COMMAND, I2C_COMMAND_REGISTER);
+//Wait Tx ACK
+        do {
+            status = (inl (I2C_INTERRUPT_STATUS_REGISTER) & (TX_ACK | TX_NACK));
+            count++;
+            if (count == LOOP_COUNT) {
+                i2c_error = 1;
+                printf ("Start and Send Device Address can't get ACK back\n");
+                return i2c_error;
+            }
+        } while (status != TX_ACK);
+        count = 0;
+//Clear Interrupt
+	outl (ALL_CLEAR, I2C_INTERRUPT_STATUS_REGISTER);
+//Check if address length equals to 16bits
+        if (alen != 1) {
+//Send Device Register Offset (HIGH BYTE)
+	    outl ((regoffset & 0xFF00) >> 8, I2C_BYTE_BUFFER_REGISTER);
+	    outl (MASTER_TX_COMMAND, I2C_COMMAND_REGISTER);
+//Wait Tx ACK
+            do {
+                status = (inl (I2C_INTERRUPT_STATUS_REGISTER) & (TX_ACK | TX_NACK));
+                count++;
+                if (count == LOOP_COUNT) {
+                    i2c_error = 1;
+                    printf ("Send Device Register Offset can't get ACK back\n");
+                    return i2c_error;
+                }
+            } while (status != TX_ACK);
+            count = 0;
+//Clear Interrupt
+	    outl (ALL_CLEAR, I2C_INTERRUPT_STATUS_REGISTER);
+	}
+//Send Device Register Offset(LOW)
+	outl (regoffset & 0xFF, I2C_BYTE_BUFFER_REGISTER);
+	outl (MASTER_TX_COMMAND, I2C_COMMAND_REGISTER);
+//Wait Tx ACK
+        do {
+            status = (inl (I2C_INTERRUPT_STATUS_REGISTER) & (TX_ACK | TX_NACK));
+            count++;
+            if (count == LOOP_COUNT) {
+                i2c_error = 1;
+                printf ("Send Device Register Offset can't get ACK back\n");
+                return i2c_error;
+            }
+        } while (status != TX_ACK);
+        count = 0;
+//Clear Interrupt
+	outl (ALL_CLEAR, I2C_INTERRUPT_STATUS_REGISTER);
+//Start, Send Device Address + 1 (Read Mode), Receive Data
+	outl (devaddr + 1, I2C_BYTE_BUFFER_REGISTER);
+	outl (MASTER_START_COMMAND | MASTER_TX_COMMAND | MASTER_RX_COMMAND | RX_COMMAND_LIST, I2C_COMMAND_REGISTER);
+//Wait Rx Done
+        do {
+            status = (inl (I2C_INTERRUPT_STATUS_REGISTER) & RX_DONE);
+            count++;
+            if (count == LOOP_COUNT) {
+                i2c_error = 1;
+                printf ("Can't get RX_DONE back\n");
+                return i2c_error;
+            }
+        } while (status != RX_DONE);
+        count = 0;
+//Clear Interrupt
+	outl (ALL_CLEAR, I2C_INTERRUPT_STATUS_REGISTER);
+//Enable Interrupt + Stop Interrupt
+	outl (0xBF, I2C_INTERRUPT_CONTROL_REGISTER);
+//Issue Stop Command
+	outl (MASTER_STOP_COMMAND, I2C_COMMAND_REGISTER);
+//Wait Stop
+        do {
+            status = (inl (I2C_INTERRUPT_STATUS_REGISTER) & STOP_DONE);
+            count++;
+            if (count == LOOP_COUNT) {
+                i2c_error = 1;
+                printf ("Can't get STOP back\n");
+                return i2c_error;
+            }
+        } while (status != STOP_DONE);
+//Disable Stop Interrupt
+	outl (0xAF, I2C_INTERRUPT_CONTROL_REGISTER);
+//Clear Interrupt
+	outl (ALL_CLEAR, I2C_INTERRUPT_STATUS_REGISTER);
+//Read Received Data
+        *value = ((inl (I2C_BYTE_BUFFER_REGISTER) & 0xFF00) >> 8);
+
+	return i2c_error;
+}
+
+static int i2c_write_byte (u8 devaddr, u16 regoffset, u8 value, int alen)
+{
+	int i2c_error = 0;
+        u32 status, count = 0;
+
+//Start and Send Device Address
+	outl (devaddr, I2C_BYTE_BUFFER_REGISTER);
+	outl (MASTER_START_COMMAND | MASTER_TX_COMMAND, I2C_COMMAND_REGISTER);
+//Wait Tx ACK
+        do {
+            status = (inl (I2C_INTERRUPT_STATUS_REGISTER) & (TX_ACK | TX_NACK));
+            count++;
+            if (status == TX_NACK) {
+//Clear Interrupt
+   	        outl (ALL_CLEAR, I2C_INTERRUPT_STATUS_REGISTER);
+//Re-send Start and Send Device Address while NACK return
+	        outl (devaddr, I2C_BYTE_BUFFER_REGISTER);
+        	outl (MASTER_START_COMMAND | MASTER_TX_COMMAND, I2C_COMMAND_REGISTER);
+            }
+            else {
+            	if (count == LOOP_COUNT) {
+            	    i2c_error = 1;
+                    printf ("Start and Send Device Address can't get ACK back\n");
+                    return i2c_error;
+            	}
+            }
+        } while (status != TX_ACK);
+        count = 0;
+//Clear Interrupt
+	outl (ALL_CLEAR, I2C_INTERRUPT_STATUS_REGISTER);
+//Check if address length equals to 16bits
+        if (alen != 1) {
+//Send Device Register Offset (HIGH BYTE)
+	    outl ((regoffset & 0xFF00) >> 8, I2C_BYTE_BUFFER_REGISTER);
+	    outl (MASTER_TX_COMMAND, I2C_COMMAND_REGISTER);
+//Wait Tx ACK
+            do {
+                status = (inl (I2C_INTERRUPT_STATUS_REGISTER) & (TX_ACK | TX_NACK));
+                count++;
+                if (count == LOOP_COUNT) {
+                    i2c_error = 1;
+                    printf ("Send Device Register Offset can't get ACK back\n");
+                    return i2c_error;
+                }
+            } while (status != TX_ACK);
+            count = 0;
+//Clear Interrupt
+	    outl (ALL_CLEAR, I2C_INTERRUPT_STATUS_REGISTER);
+	}
+//Send Device Register Offset
+	outl (regoffset & 0xFF, I2C_BYTE_BUFFER_REGISTER);
+	outl (MASTER_TX_COMMAND, I2C_COMMAND_REGISTER);
+//Wait Tx ACK
+        do {
+            status = (inl (I2C_INTERRUPT_STATUS_REGISTER) & (TX_ACK | TX_NACK));
+            count++;
+            if (count == LOOP_COUNT) {
+                i2c_error = 1;
+                printf ("Send Device Register Offset can't get ACK back\n");
+                return i2c_error;
+            }
+        } while (status != TX_ACK);
+        count = 0;
+//Clear Interrupt
+	outl (ALL_CLEAR, I2C_INTERRUPT_STATUS_REGISTER);
+//Send Device Register Value
+	outl (value, I2C_BYTE_BUFFER_REGISTER);
+	outl (MASTER_TX_COMMAND, I2C_COMMAND_REGISTER);
+//Wait Tx ACK
+        do {
+            status = (inl (I2C_INTERRUPT_STATUS_REGISTER) & (TX_ACK | TX_NACK));
+            count++;
+            if (count == LOOP_COUNT) {
+                i2c_error = 1;
+                printf ("Send Device Register Value can't get ACK back\n");
+                return i2c_error;
+            }
+        } while (status != TX_ACK);
+        count = 0;
+//Clear Interrupt
+	outl (ALL_CLEAR, I2C_INTERRUPT_STATUS_REGISTER);
+//Enable Interrupt + Stop Interrupt
+	outl (0xBF, I2C_INTERRUPT_CONTROL_REGISTER);
+//Issue Stop Command
+	outl (MASTER_STOP_COMMAND, I2C_COMMAND_REGISTER);
+//Wait Stop
+        do {
+            status = (inl (I2C_INTERRUPT_STATUS_REGISTER) & STOP_DONE);
+            count++;
+            if (count == LOOP_COUNT) {
+                i2c_error = 1;
+                printf ("Can't get STOP back\n");
+                return i2c_error;
+            }
+        } while (status != STOP_DONE);
+//Disable Stop Interrupt
+	outl (0xAF, I2C_INTERRUPT_CONTROL_REGISTER);
+//Clear Interrupt
+	outl (ALL_CLEAR, I2C_INTERRUPT_STATUS_REGISTER);
+
+	return i2c_error;
+}
+
+int i2c_probe (uchar chip)
+{
+//Suppose IP is always on chip
+	int res = 0;
+	
+	return res;
+}
+
+int i2c_read (uchar device_addr, uint register_offset, int alen, uchar * buffer, int len)
+{
+	int i;
+
+        if ((alen == 1) && ((register_offset + len) > 256)) {
+        	printf ("Register index overflow\n");
+        }
+        
+        for (i = 0; i < len; i++) {
+	        if (i2c_read_byte (device_addr, register_offset + i, &buffer[i], alen)) {
+		        printf ("I2C read: I/O error\n");
+			i2c_init (CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+int i2c_write (uchar device_addr, uint register_offset, int alen, uchar * buffer, int len)
+{
+	int i;
+
+        if ((alen == 1) && ((register_offset + len) > 256)) {
+        	printf ("Register index overflow\n");
+        }
+
+        for (i = 0; i < len; i++) {
+	        if (i2c_write_byte (device_addr, register_offset + i, buffer[i], alen)) {
+		        printf ("I2C read: I/O error\n");
+			i2c_init (CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
+			return 1;
+   	        }
+	}
+
+	return 0;
+}
+
+#endif /* CONFIG_DRIVER_ASPEED_I2C */
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index 9cf2983..a1d19ca 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -68,6 +68,7 @@ COBJS-$(CONFIG_PLB2800_ETHER) += plb2800_eth.o
 COBJS-$(CONFIG_RTL8139) += rtl8139.o
 COBJS-$(CONFIG_RTL8169) += rtl8169.o
 COBJS-$(CONFIG_SH_ETHER) += sh_eth.o
+COBJS-$(CONFIG_ASPEEDNIC) += aspeednic.o
 COBJS-$(CONFIG_SMC91111) += smc91111.o
 COBJS-$(CONFIG_SMC911X) += smc911x.o
 COBJS-$(CONFIG_SUNXI_WEMAC) += sunxi_wemac.o
diff --git a/drivers/net/aspeednic.c b/drivers/net/aspeednic.c
new file mode 100644
index 0000000..6b1ce05
--- /dev/null
+++ b/drivers/net/aspeednic.c
@@ -0,0 +1,1528 @@
+/*
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <common.h>
+
+#if defined(CONFIG_CMD_NET) && defined(CONFIG_NET_MULTI) && defined(CONFIG_ASPEEDNIC)
+
+#include <malloc.h>
+#include <net.h>
+#include <pci.h>
+
+
+/*
+  SCU88 D[31]: MAC1 MDIO
+  SCU88 D[30]: MAC1 MDC
+  SCU90 D[2]:  MAC2 MDC/MDIO
+  SCU80 D[0]:  MAC1 Link
+  SCU80 D[1]:  MAC2 Link
+*/
+#define pci_find_devices         NULL
+#define pci_read_config_dword    NULL
+#if defined(CONFIG_AST1300)
+#define SCU_BASE                 CONFIG_SCUREG_BASE
+#else
+#define SCU_BASE                 0x1E6E2000
+#endif
+#define SCU_RESET_CONTROL        0x04
+#define SCU_CLOCK_SELECTION      0x08
+#define SCU_CLOCK_CONTROL        0x0C
+#define SCU_MAC_CLOCK_DELAY      0x48
+#define SCU_SCRATCH_REGISTER     0x40
+#define SCU_HARDWARE_TRAPPING    0x70
+#define SCU_PIN_MUX              0x74
+#define SCU_MULTIFUNCTION_PIN_CTL1_REG     0x80
+#define SCU_MULTIFUNCTION_PIN_CTL3_REG     0x88
+#define SCU_MULTIFUNCTION_PIN_CTL5_REG     0x90
+#define MAC_INTERFACE            0x1C0
+#define GMII                     0x0
+#define MII                      0x40
+#define MAC1_CLOCK_ENABLE        (1 << 20)
+#define MAC2_CLOCK_ENABLE        (1 << 21)
+#define MAC_AHB_CLOCK_DIVIDER    (0x07 << 16)
+#if defined(CONFIG_AST2300_FPGA_2) || defined(CONFIG_AST2300) || defined(CONFIG_AST3100) || defined(CONFIG_AST2400)
+#define MAC1_MDIO                (1 << 31)
+#define MAC1_MDC                 (1 << 30)
+#define MAC1_PHY_LINK            (1 << 0)
+#define MAC2_MDC_MDIO            (1 << 2)
+#define MAC1_PHY_LINK            (1 << 0)
+#define MAC2_PHY_LINK            (1 << 1)
+#else
+#define MAC2_MDC_MDIO            (1 << 20)
+#define MAC2_MII                 (1 << 21)
+#define MAC1_PHY_LINK            (1 << 25)
+#define MAC2_PHY_LINK            (1 << 26)
+#endif
+
+#if defined(CONFIG_AST1300)
+unsigned int aspeednic_iobase[1] = {CONFIG_MACREG_BASE};
+#else
+unsigned int aspeednic_iobase[CONFIG_ASPEED_MAC_NUMBER] = {
+  0x1E660000, 0x1E680000};
+#endif
+
+#undef DEBUG_SROM
+#undef DEBUG_SROM2
+
+#undef UPDATE_SROM
+
+/* PCI Registers.
+ */
+#define PCI_CFDA_PSM    0x43
+
+#define CFRV_RN   0x000000f0  /* Revision Number */
+
+#define WAKEUP    0x00    /* Power Saving Wakeup */
+#define SLEEP   0x80    /* Power Saving Sleep Mode */
+
+#define DC2114x_BRK 0x0020    /* CFRV break between DC21142 & DC21143 */
+
+/* MAC chip register */
+#define ISR_REG       0x00        // interrups status register
+#define IER_REG       0x04        // interrupt maks register
+#define MAC_MADR_REG            0x08        // MAC address (Most significant)
+#define MAC_LADR_REG            0x0c        // MAC address (Least significant)
+
+#define MAHT0_REG     0x10        // Multicast Address Hash Table 0 register
+#define MAHT1_REG     0x14        // Multicast Address Hash Table 1 register
+#define TXPD_REG      0x18        // Transmit Poll Demand register
+#define RXPD_REG      0x1c        // Receive Poll Demand register
+#define TXR_BADR_REG            0x20        // Transmit Ring Base Address register
+#define RXR_BADR_REG            0x24        // Receive Ring Base Address register
+
+#define HPTXPD_REG      0x28  //
+#define HPTXR_BADR_REG            0x2c  //
+
+#define ITC_REG       0x30        // interrupt timer control register
+#define APTC_REG      0x34        // Automatic Polling Timer control register
+#define DBLAC_REG     0x38        // DMA Burst Length and Arbitration control register
+
+#define DMAFIFOS_REG            0x3c  //
+#define FEAR_REG      0x44  //
+#define TPAFCR_REG      0x48  //
+#define RBSR_REG      0x4c  //for NC Body
+#define MACCR_REG     0x50        // MAC control register
+#define MACSR_REG     0x54        // MAC status register
+#define PHYCR_REG     0x60        // PHY control register
+#define PHYDATA_REG     0x64        // PHY Write Data register
+#define FCR_REG       0x68        // Flow Control register
+#define BPR_REG       0x6c        // back pressure register
+#define WOLCR_REG     0x70        // Wake-On-Lan control register
+#define WOLSR_REG     0x74        // Wake-On-Lan status register
+#define WFCRC_REG     0x78        // Wake-up Frame CRC register
+#define WFBM1_REG     0x80        // wake-up frame byte mask 1st double word register
+#define WFBM2_REG     0x84        // wake-up frame byte mask 2nd double word register
+#define WFBM3_REG     0x88        // wake-up frame byte mask 3rd double word register
+#define WFBM4_REG     0x8c        // wake-up frame byte mask 4th double word register
+
+
+// --------------------------------------------------------------------
+//    MACCR_REG
+// --------------------------------------------------------------------
+
+#define SW_RST_bit      (1UL<<31)       // software reset/
+#define DIRPATH_bit     (1UL<<21)
+#define RX_IPCS_FAIL_bit  (1UL<<20) //
+#define RX_TCPCS_FAIL_bit (1UL<<19) //
+#define SPEED_100M_MODE_bit     (1UL<<19)
+#define RX_UDPCS_FAIL_bit (1UL<<18) //
+#define RX_BROADPKT_bit   (1UL<<17)       // Receiving broadcast packet
+#define RX_MULTIPKT_bit   (1UL<<16)       // receiving multicast packet
+#define RX_HT_EN_bit    (1UL<<15)
+#define RX_ALLADR_bit   (1UL<<14)       // not check incoming packet's destination address
+#define JUMBO_LF_bit    (1UL<<13) //
+#define RX_RUNT_bit     (1UL<<12)       // Store incoming packet even its length is les than 64 byte
+#define CRC_CHK_bit     (1UL<<11) //
+#define CRC_APD_bit     (1UL<<10)       // append crc to transmit packet
+#define GMAC_MODE_bit   (1UL<<9)  //
+#define FULLDUP_bit     (1UL<<8)        // full duplex
+#define ENRX_IN_HALFTX_bit  (1UL<<7)  //
+#define LOOP_EN_bit     (1UL<<6)        // Internal loop-back
+#define HPTXR_EN_bit    (1UL<<5)  //
+#define REMOVE_VLAN_bit   (1UL<<4)  //
+#define RXMAC_EN_bit    (1UL<<3)        // receiver enable
+#define TXMAC_EN_bit    (1UL<<2)        // transmitter enable
+#define RXDMA_EN_bit    (1UL<<1)        // enable DMA receiving channel
+#define TXDMA_EN_bit    (1UL<<0)        // enable DMA transmitting channel
+
+//---------------------------------------------------
+//  PHY R/W Register Bit
+//---------------------------------------------------
+#define MIIWR                   (1UL<<27)
+#define MIIRD                   (1UL<<26)
+#define MDC_CYCTHR              0x34
+#define PHY_SPEED_MASK          0xC000
+#define PHY_DUPLEX_MASK         0x2000
+#define SPEED_1000M             0x02
+#define SPEED_100M              0x01
+#define SPEED_10M               0x00
+#define DUPLEX_FULL             0x01
+#define DUPLEX_HALF             0x00
+#define RESOLVED_BIT            0x800
+
+#define PHY_SPEED_DUPLEX_MASK   0x01E0
+#define PHY_100M_DUPLEX         0x0100
+#define PHY_100M_HALF           0x0080
+#define PHY_10M_DUPLEX          0x0040
+#define PHY_10M_HALF            0x0020
+
+
+
+/* Descriptor bits.
+ */
+#define TXDMA_OWN 0x80000000  /* Own Bit */
+#define RXPKT_RDY       0x00000000
+#define RXPKT_STATUS    0x80000000
+//#define EDORR   0x00008000  /* Receive End Of Ring */
+#define EDORR   0x40000000  /* Receive End Of Ring */
+#define LRS   0x10000000  /* Last Descriptor */
+#define RD_ES   0x00008000  /* Error Summary */
+//#define EDOTR   0x00008000  /* Transmit End Of Ring */
+#define EDOTR   0x40000000  /* Transmit End Of Ring */
+#define T_OWN   0x80000000  /* Own Bit */
+#define LTS   0x10000000  /* Last Segment */
+#define FTS   0x20000000  /* First Segment */
+#define CRC_ERR         0x00080000
+#define TD_ES   0x00008000  /* Error Summary */
+#define TD_SET    0x08000000  /* Setup Packet */
+#define RX_ERR          0x00040000
+#define FTL             0x00100000
+#define RUNT            0x00200000
+#define RX_ODD_NB       0x00400000
+
+#define POLL_DEMAND 1
+#define RESET_DE4X5(dev) {                                              \
+    int i;                                                              \
+    i=INL(dev, MACCR_REG);                                              \
+    udelay(1000);                                                       \
+    OUTL(dev, i | SW_RST_bit, MACCR_REG);                               \
+    for (; (INL(dev, MACCR_REG ) & SW_RST_bit) != 0; ) {udelay(1000);}  \
+    OUTL(dev, 0, IER_REG );                                             \
+  }
+
+#define START_MAC(dev) {                                              \
+    s32 omr;                                                          \
+    omr = INL(dev, MACCR_REG);                                        \
+    omr |= RXMAC_EN_bit | TXMAC_EN_bit | RXDMA_EN_bit | TXDMA_EN_bit; \
+    OUTL(dev, omr, MACCR_REG);    /* Enable the TX and/or RX */       \
+  }
+
+#define STOP_MAC(dev) {                                                 \
+    s32 omr;                                                            \
+    omr = INL(dev, MACCR_REG);                                          \
+    omr &= ~(RXMAC_EN_bit | TXMAC_EN_bit | RXDMA_EN_bit | TXDMA_EN_bit); \
+    OUTL(dev, omr, MACCR_REG);    /* Disable the TX and/or RX */        \
+  }
+
+#define NUM_RX_DESC PKTBUFSRX
+#define NUM_TX_DESC 1     /* Number of TX descriptors   */
+#define RX_BUFF_SZ  PKTSIZE_ALIGN
+#define TX_BUFF_SZ  1514
+
+#define TOUT_LOOP   1000000
+#define PHY_LOOP    250
+#define ETH_ALEN  6
+#define NCSI_LOOP   1500000
+#define RETRY_COUNT     1
+
+struct de4x5_desc {
+  volatile s32 status;
+  u32 des1;
+  u32 reserved;
+  u32 buf;
+};
+
+//PHY Information
+#define PHYID_VENDOR_MASK   0xfffffc00
+#define PHYID_VENDOR_MODEL_MASK   0xfffffff0
+#define PHYID_VENDOR_MARVELL    0x01410c00
+#define PHYID_VENDOR_BROADCOM   0x00406000
+#define PHYID_VENDOR_REALTEK    0x001cc800
+#define PHYID_RTL8201EL     0x001cc810
+#define PHYID_RTL8211         0x001cc910
+#define PHYID_BCM54612E             0x03625E6A
+
+//NCSI define & structure
+//NC-SI Command Packet
+typedef struct {
+//Ethernet Header
+  unsigned char  DA[6];
+  unsigned char  SA[6];
+  unsigned short EtherType;           //DMTF NC-SI
+//NC-SI Control Packet
+  unsigned char  MC_ID;           //Management Controller should set this field to 0x00
+  unsigned char  Header_Revision;         //For NC-SI 1.0 spec, this field has to set 0x01
+  unsigned char  Reserved_1;            //Reserved has to set to 0x00
+  unsigned char  IID;             //Instance ID
+  unsigned char  Command;
+  unsigned char  Channel_ID;
+  unsigned short Payload_Length;          //Payload Length = 12 bits, 4 bits are reserved
+  unsigned long  Reserved_2;
+  unsigned long  Reserved_3;
+}  NCSI_Command_Packet;
+
+unsigned char  Payload_Data[16];
+unsigned char  Payload_Pad[4] = {0x00, 0x00, 0x00, 0x00};
+unsigned long  Payload_Checksum = 0x00000000;
+
+
+//Command and Response Type
+#define CLEAR_INITIAL_STATE     0x00      //M
+#define SELECT_PACKAGE        0x01      //M
+#define DESELECT_PACKAGE      0x02      //M
+#define ENABLE_CHANNEL        0x03      //M
+#define DISABLE_CHANNEL       0x04      //M
+#define RESET_CHANNEL       0x05      //M
+#define ENABLE_CHANNEL_NETWORK_TX   0x06      //M
+#define DISABLE_CHANNEL_NETWORK_TX    0x07      //M
+#define AEN_ENABLE        0x08
+#define SET_LINK        0x09      //M
+#define GET_LINK_STATUS       0x0A      //M
+#define SET_VLAN_FILTER       0x0B      //M
+#define ENABLE_VLAN       0x0C      //M
+#define DISABLE_VLAN        0x0D      //M
+#define SET_MAC_ADDRESS       0x0E      //M
+#define ENABLE_BROADCAST_FILTERING    0x10      //M
+#define DISABLE_BROADCAST_FILTERING   0x11      //M
+#define ENABLE_GLOBAL_MULTICAST_FILTERING 0x12
+#define DISABLE_GLOBAL_MULTICAST_FILTERING  0x13
+#define SET_NCSI_FLOW_CONTROL     0x14
+#define GET_VERSION_ID        0x15      //M
+#define GET_CAPABILITIES      0x16      //M
+#define GET_PARAMETERS        0x17      //M
+#define GET_CONTROLLER_PACKET_STATISTICS  0x18
+#define GET_NCSI_STATISTICS     0x19
+#define GET_NCSI_PASS_THROUGH_STATISTICS  0x1A
+
+//NC-SI Response Packet
+typedef struct {
+  unsigned char  DA[6];
+  unsigned char  SA[6];
+  unsigned short EtherType;           //DMTF NC-SI
+//NC-SI Control Packet
+  unsigned char  MC_ID;           //Management Controller should set this field to 0x00
+  unsigned char  Header_Revision;         //For NC-SI 1.0 spec, this field has to set 0x01
+  unsigned char  Reserved_1;            //Reserved has to set to 0x00
+  unsigned char  IID;             //Instance ID
+  unsigned char  Command;
+  unsigned char  Channel_ID;
+  unsigned short Payload_Length;          //Payload Length = 12 bits, 4 bits are reserved
+  unsigned short  Reserved_2;
+  unsigned short  Reserved_3;
+  unsigned short  Reserved_4;
+  unsigned short  Reserved_5;
+  unsigned short  Response_Code;
+  unsigned short  Reason_Code;
+  unsigned char   Payload_Data[64];
+}  NCSI_Response_Packet;
+
+NCSI_Command_Packet NCSI_Request;
+NCSI_Response_Packet NCSI_Respond;
+
+//Standard Response Code
+#define COMMAND_COMPLETED     0x00
+#define COMMAND_FAILED        0x01
+#define COMMAND_UNAVAILABLE     0x02
+#define COMMAND_UNSUPPORTED     0x03
+
+//Standard Reason Code
+#define NO_ERROR        0x0000
+#define INTERFACE_INITIALIZATION_REQUIRED 0x0001
+#define PARAMETER_IS_INVALID      0x0002
+#define CHANNEL_NOT_READY     0x0003
+#define PACKAGE_NOT_READY     0x0004
+#define INVALID_PAYLOAD_LENGTH      0x0005
+#define UNKNOWN_COMMAND_TYPE      0x7FFF
+
+
+struct AEN_Packet {
+//Ethernet Header
+  unsigned char  DA[6];
+  unsigned char  SA[6];           //Network Controller SA = FF:FF:FF:FF:FF:FF
+  unsigned short EtherType;           //DMTF NC-SI
+//AEN Packet Format
+  unsigned char  MC_ID;           //Network Controller should set this field to 0x00
+  unsigned char  Header_Revision;         //For NC-SI 1.0 spec, this field has to set 0x01
+  unsigned char  Reserved_1;            //Reserved has to set to 0x00
+//    unsigned char  IID = 0x00;            //Instance ID = 0 in Network Controller
+//    unsigned char  Command = 0xFF;          //AEN = 0xFF
+  unsigned char  Channel_ID;
+//    unsigned short Payload_Length = 0x04;       //Payload Length = 4 in Network Controller AEN Packet
+  unsigned long  Reserved_2;
+  unsigned long  Reserved_3;
+  unsigned char  AEN_Type;
+//    unsigned char  Reserved_4[3] = {0x00, 0x00, 0x00};
+  unsigned long  Optional_AEN_Data;
+  unsigned long  Payload_Checksum;
+};
+
+//AEN Type
+#define LINK_STATUS_CHANGE      0x0
+#define CONFIGURATION_REQUIRED      0x1
+#define HOST_NC_DRIVER_STATUS_CHANGE    0x2
+
+typedef struct {
+  unsigned char Package_ID;
+  unsigned char Channel_ID;
+  unsigned long Capabilities_Flags;
+  unsigned long Broadcast_Packet_Filter_Capabilities;
+  unsigned long Multicast_Packet_Filter_Capabilities;
+  unsigned long Buffering_Capabilities;
+  unsigned long AEN_Control_Support;
+} NCSI_Capability;
+NCSI_Capability NCSI_Cap;
+
+//SET_MAC_ADDRESS
+#define UNICAST   (0x00 << 5)
+#define MULTICAST (0x01 << 5)
+#define DISABLE_MAC_ADDRESS_FILTER  0x00
+#define ENABLE_MAC_ADDRESS_FILTER 0x01
+
+//GET_LINK_STATUS
+#define LINK_DOWN 0
+#define LINK_UP   1
+
+static struct de4x5_desc rx_ring[NUM_RX_DESC] __attribute__ ((aligned(32))); /* RX descriptor ring         */
+static struct de4x5_desc tx_ring[NUM_TX_DESC] __attribute__ ((aligned(32))); /* TX descriptor ring         */
+static int rx_new;                             /* RX descriptor ring pointer */
+static int tx_new;                             /* TX descriptor ring pointer */
+static unsigned char tx_buffer[NUM_TX_DESC][TX_BUFF_SZ] __attribute__ ((aligned(32)));
+static unsigned char rx_buffer[NUM_RX_DESC][RX_BUFF_SZ] __attribute__ ((aligned(32)));
+
+
+static char rxRingSize;
+static char txRingSize;
+static unsigned int InstanceID = 0;
+static int Retry = 0;
+
+static int   aspeednic_init(struct eth_device* dev, bd_t* bis);
+static int   aspeednic_send(struct eth_device* dev, volatile void *packet, int length);
+static int   aspeednic_recv(struct eth_device* dev);
+static void  aspeednic_halt(struct eth_device* dev);
+static void  set_mac_address (struct eth_device* dev, bd_t* bis);
+static void  phy_write_register (struct eth_device* dev, u8 PHY_Register, u8 PHY_Address, u16 PHY_Data);
+static u16   phy_read_register (struct eth_device* dev, u8 PHY_Register, u8 PHY_Address);
+static void  set_mac_control_register(struct eth_device* dev);
+
+#if defined(CONFIG_E500)
+#define phys_to_bus(a) (a)
+#else
+#define phys_to_bus(a)  pci_phys_to_mem((pci_dev_t)dev->priv, a)
+#endif
+
+static int INL(struct eth_device* dev, u_long addr)
+{
+  return le32_to_cpu(*(volatile u_long *)(addr + dev->iobase));
+}
+
+static void OUTL(struct eth_device* dev, int command, u_long addr)
+{
+  *(volatile u_long *)(addr + dev->iobase) = cpu_to_le32(command);
+}
+
+
+struct eth_device aspeednic_device[CONFIG_ASPEED_MAC_NUMBER];
+
+void NCSI_Struct_Initialize(void)
+{
+  unsigned long i;
+
+  for (i = 0; i < 6; i++) {
+    NCSI_Request.DA[i] = 0xFF;
+    NCSI_Respond.DA[i] = 0xFF;
+    NCSI_Respond.SA[i] = 0xFF;
+  }
+  NCSI_Request.EtherType = 0xF888;
+  NCSI_Request.MC_ID = 0;
+  NCSI_Request.Header_Revision = 0x01;
+  NCSI_Request.Reserved_1 = 0;
+  NCSI_Request.Reserved_2 = 0;
+  NCSI_Request.Reserved_3 = 0;
+  NCSI_Respond.EtherType = 0xF888;
+  NCSI_Respond.MC_ID = 0;
+  NCSI_Respond.Header_Revision = 0x01;
+  NCSI_Respond.Reserved_1 = 0;
+  NCSI_Respond.Reserved_2 = 0;
+  NCSI_Respond.Reserved_3 = 0;
+}
+
+int aspeednic_initialize(bd_t *bis)
+{
+  int               card_number = 0;
+  unsigned int    iobase, SCURegister;
+  struct eth_device*  dev;
+
+#if defined(CONFIG_AST2300_FPGA_2) || defined(CONFIG_AST2300) || defined(CONFIG_AST3100) || defined(CONFIG_AST2400)
+//AST2300
+//MAC1 CLOCK/RESET/PHY_LINK/MDC_MDIO in SCU
+  SCURegister = le32_to_cpu(*(volatile u_long *)(SCU_BASE + SCU_RESET_CONTROL));
+  *(volatile u_long *)(SCU_BASE + SCU_RESET_CONTROL) = cpu_to_le32(SCURegister | 0x800);
+  udelay(100);
+  SCURegister = le32_to_cpu(*(volatile u_long *)(SCU_BASE + SCU_CLOCK_CONTROL));
+  *(volatile u_long *)(SCU_BASE + SCU_CLOCK_CONTROL) = cpu_to_le32(SCURegister & ~(MAC1_CLOCK_ENABLE));
+  udelay(10000);
+//Add Clock Selection in AST2300 A1, Please check the datasheet for more detail
+//The current sample code uses 0: H-PLL/2 because all EVBs have RGMII interface
+//        SCURegister = le32_to_cpu(*(volatile u_long *)(SCU_BASE + SCU_CLOCK_SELECTION));
+//  *(volatile u_long *)(SCU_BASE + SCU_CLOCK_SELECTION) = cpu_to_le32(SCURegister & ~(MAC_AHB_CLOCK_DIVIDER));
+  SCURegister = le32_to_cpu(*(volatile u_long *)(SCU_BASE + SCU_RESET_CONTROL));
+  *(volatile u_long *)(SCU_BASE + SCU_RESET_CONTROL) = cpu_to_le32(SCURegister & ~(0x800));
+  SCURegister = le32_to_cpu(*(volatile u_long *)(SCU_BASE + SCU_MULTIFUNCTION_PIN_CTL3_REG));
+  *(volatile u_long *)(SCU_BASE + SCU_MULTIFUNCTION_PIN_CTL3_REG) = cpu_to_le32(SCURegister | (MAC1_MDIO | MAC1_MDC));
+//        SCURegister = le32_to_cpu(*(volatile u_long *)(SCU_BASE + SCU_MAC_CLOCK_DELAY));
+//Currently we use fix value in MAC timing on EVB
+//  *(volatile u_long *)(SCU_BASE + SCU_MAC_CLOCK_DELAY) = CONFIG_MAC_INTERFACE_CLOCK_DELAY;
+#ifdef CONFIG_MAC1_PHY_LINK_INTERRUPT
+  SCURegister = le32_to_cpu(*(volatile u_long *)(SCU_BASE + SCU_MULTIFUNCTION_PIN_CTL1_REG));
+  *(volatile u_long *)(SCU_BASE + SCU_MULTIFUNCTION_PIN_CTL1_REG) = cpu_to_le32(SCURegister | (MAC1_PHY_LINK));
+#endif
+
+//MAC2 CLOCK/RESET/PHY_LINK/MDC_MDIO
+#ifdef CONFIG_MAC2_ENABLE
+  SCURegister = le32_to_cpu(*(volatile u_long *)(SCU_BASE + SCU_RESET_CONTROL));
+  *(volatile u_long *)(SCU_BASE + SCU_RESET_CONTROL) = cpu_to_le32(SCURegister | 0x1000);
+  udelay(10);
+  SCURegister = le32_to_cpu(*(volatile u_long *)(SCU_BASE + SCU_CLOCK_CONTROL));
+  *(volatile u_long *)(SCU_BASE + SCU_CLOCK_CONTROL) = cpu_to_le32(SCURegister & ~(MAC2_CLOCK_ENABLE));
+  udelay(10000);
+  SCURegister = le32_to_cpu(*(volatile u_long *)(SCU_BASE + SCU_RESET_CONTROL));
+  *(volatile u_long *)(SCU_BASE + SCU_RESET_CONTROL) = cpu_to_le32(SCURegister & ~(0x1000));
+  SCURegister = le32_to_cpu(*(volatile u_long *)(SCU_BASE + SCU_MULTIFUNCTION_PIN_CTL5_REG));
+  *(volatile u_long *)(SCU_BASE + SCU_MULTIFUNCTION_PIN_CTL5_REG) = cpu_to_le32(SCURegister | (MAC2_MDC_MDIO));
+#endif
+#ifdef CONFIG_MAC2_PHY_LINK_INTERRUPT
+  SCURegister = le32_to_cpu(*(volatile u_long *)(SCU_BASE + SCU_MULTIFUNCTION_PIN_CTL1_REG));
+  *(volatile u_long *)(SCU_BASE + SCU_MULTIFUNCTION_PIN_CTL1_REG) = cpu_to_le32(SCURegister | (MAC2_PHY_LINK));
+#endif
+#else
+//AST1100/AST2050/AST2100
+//MAC1 RESET/PHY_LINK in SCU
+  SCURegister = le32_to_cpu(*(volatile u_long *)(SCU_BASE + SCU_RESET_CONTROL));
+  *(volatile u_long *)(SCU_BASE + SCU_RESET_CONTROL) = cpu_to_le32(SCURegister & ~(0x800));
+#ifdef CONFIG_MAC1_PHY_LINK_INTERRUPT
+  SCURegister = le32_to_cpu(*(volatile u_long *)(SCU_BASE + SCU_PIN_MUX));
+  *(volatile u_long *)(SCU_BASE + SCU_PIN_MUX) = cpu_to_le32(SCURegister | (MAC1_PHY_LINK));
+#endif
+
+//MAC2
+#ifdef CONFIG_MAC2_ENABLE
+  SCURegister = le32_to_cpu(*(volatile u_long *)(SCU_BASE + SCU_RESET_CONTROL));
+  *(volatile u_long *)(SCU_BASE + SCU_RESET_CONTROL) = cpu_to_le32(SCURegister & ~(0x1000));
+  SCURegister = le32_to_cpu(*(volatile u_long *)(SCU_BASE + SCU_PIN_MUX));
+  *(volatile u_long *)(SCU_BASE + SCU_PIN_MUX) = cpu_to_le32(SCURegister | (MAC2_MDC_MDIO));
+#endif
+#ifdef CONFIG_MAC2_MII_ENABLE
+  SCURegister = le32_to_cpu(*(volatile u_long *)(SCU_BASE + SCU_PIN_MUX));
+  *(volatile u_long *)(SCU_BASE + SCU_PIN_MUX) = cpu_to_le32(SCURegister | (MAC2_MII));
+#endif
+#ifdef CONFIG_MAC2_PHY_LINK_INTERRUPT
+  SCURegister = le32_to_cpu(*(volatile u_long *)(SCU_BASE + SCU_PIN_MUX));
+  *(volatile u_long *)(SCU_BASE + SCU_PIN_MUX) = cpu_to_le32(SCURegister | (MAC2_PHY_LINK));
+#endif
+#endif
+
+  iobase = aspeednic_iobase[card_number];
+
+  dev = &aspeednic_device[card_number];
+
+
+  sprintf(dev->name, "aspeednic#%d", card_number);
+
+  dev->iobase = iobase;
+
+  if (CONFIG_MAC1_PHY_SETTING >= 1) {
+//NCSI Struct Initialize
+    NCSI_Struct_Initialize();
+  }
+//Set Scratch register (0x1E6E2040 D[15:14])(0x1E6E2041 D[7:6]) to inform kernel MAC1 driver
+  SCURegister = le32_to_cpu(*(volatile u_long *)(SCU_BASE + SCU_SCRATCH_REGISTER));
+  *(volatile u_long *)(SCU_BASE + SCU_SCRATCH_REGISTER) = cpu_to_le32((SCURegister & ~(0xc000)) | (CONFIG_MAC1_PHY_SETTING << 14));
+//Set Scratch register (0x1E6E2040 D[13:12])(0x1E6E2041 D[5:4]) to inform kernel MAC2 driver
+  SCURegister = le32_to_cpu(*(volatile u_long *)(SCU_BASE + SCU_SCRATCH_REGISTER));
+  *(volatile u_long *)(SCU_BASE + SCU_SCRATCH_REGISTER) = cpu_to_le32((SCURegister & ~(0x3000)) | (CONFIG_MAC2_PHY_SETTING << 12));
+
+
+  dev->init   = aspeednic_init;
+  dev->halt   = aspeednic_halt;
+  dev->send   = aspeednic_send;
+  dev->recv   = aspeednic_recv;
+
+  /* Ensure we're not sleeping. */
+  if (CONFIG_MAC1_PHY_SETTING >= 1) {
+    udelay(2000000); //2.0 sec
+  }
+  else {
+    udelay(10 * 1000);
+  }
+
+
+  dev->init(dev, bis);
+
+  eth_register(dev);
+
+
+  return card_number;
+}
+
+void Calculate_Checksum(unsigned char *buffer_base, int Length)
+{
+  unsigned int i, CheckSum = 0;
+  unsigned int Data, Data1;
+
+  for (i = 0; i < ((Length - 14) / 2); i++) {
+    Data = buffer_base[i * 2];
+    Data1 = buffer_base[i * 2 + 1];
+    CheckSum += ((Data << 8) + Data1);
+  }
+  Payload_Checksum = (~(CheckSum) + 1); //2's complement
+//Inverse for insert into buffer
+  Data = (Payload_Checksum & 0xFF000000) >> 24;
+  Data1 = (Payload_Checksum & 0x000000FF) << 24;
+  Payload_Checksum = (Payload_Checksum & 0x00FFFF00) + Data + Data1;
+  Data = (Payload_Checksum & 0x00FF0000) >> 8;
+  Data1 = (Payload_Checksum & 0x0000FF00) << 8;
+  Payload_Checksum = (Payload_Checksum & 0xFF0000FF) + Data + Data1;
+}
+
+void copy_data (int Length)
+{
+  memcpy ((unsigned char *)(tx_ring[tx_new].buf + 30), &Payload_Data, Length);
+  Calculate_Checksum((unsigned char *)(tx_ring[tx_new].buf + 14), 30 + Length);
+  memcpy ((unsigned char *)(tx_ring[tx_new].buf + 30 + Length), &Payload_Checksum, 4);
+}
+
+void NCSI_Rx (void)
+{
+  unsigned long status, length, i = 0;
+
+  do {
+    status = (s32)le32_to_cpu(rx_ring[rx_new].status);
+    i++;
+  } while (!(((status & RXPKT_STATUS) != 0) || (i >= NCSI_LOOP)));
+
+  if (i < NCSI_LOOP) {
+    if (status & LRS) {
+      length = (le32_to_cpu(rx_ring[rx_new].status) & 0x3FFF);
+      memcpy (&NCSI_Respond, (unsigned char *)rx_ring[rx_new].buf, length);
+    }
+    rx_ring[rx_new].status &= cpu_to_le32(0x7FFFFFFF);
+    rx_new = (rx_new + 1) % rxRingSize;
+  }
+}
+
+void DeSelect_Package (struct eth_device* dev, int Package_ID)
+{
+  unsigned long Combined_Channel_ID;
+
+//TX
+  do {
+    InstanceID++;
+    NCSI_Request.IID = InstanceID;
+    NCSI_Request.Command = DESELECT_PACKAGE;
+    Combined_Channel_ID = (Package_ID << 5) + 0x1F; //Internal Channel ID = 0x1F, 0x1F means all channel
+    NCSI_Request.Channel_ID = Combined_Channel_ID;
+    NCSI_Request.Payload_Length = 0;
+    memcpy ((unsigned char *)tx_ring[tx_new].buf, &NCSI_Request, 30);
+    copy_data (NCSI_Request.Payload_Length);
+    aspeednic_send (dev, (void *)tx_ring[tx_new].buf, 30 + NCSI_Request.Payload_Length + 4);
+//RX
+    NCSI_Rx();
+    if ((NCSI_Respond.IID != InstanceID) || (NCSI_Respond.Command != (DESELECT_PACKAGE | 0x80)) || (NCSI_Respond.Response_Code != COMMAND_COMPLETED)) {
+      printf ("Retry: Command = %x, Response_Code = %x\n", NCSI_Request.Command, NCSI_Respond.Response_Code);
+      Retry++;
+      InstanceID--;
+    }
+    else {
+      Retry = 0;
+    }
+  } while ((Retry != 0) && (Retry <= RETRY_COUNT));
+  Retry = 0;
+}
+
+int Select_Package (struct eth_device* dev, int Package_ID)
+{
+  unsigned long Combined_Channel_ID, Found = 0;
+
+//TX
+  do {
+    InstanceID++;
+    NCSI_Request.IID = InstanceID;
+    NCSI_Request.Command = SELECT_PACKAGE;
+    Combined_Channel_ID = (Package_ID << 5) + 0x1F; //Internal Channel ID = 0x1F
+    NCSI_Request.Channel_ID = Combined_Channel_ID;
+    NCSI_Request.Payload_Length = (4 << 8);
+    memcpy ((unsigned char *)tx_ring[tx_new].buf, &NCSI_Request, 30);
+    NCSI_Request.Payload_Length = 4;
+    memset ((void *)Payload_Data, 0, 4);
+    Payload_Data[3] = 1; //Arbitration Disable
+    copy_data (NCSI_Request.Payload_Length);
+    aspeednic_send (dev, (void *)tx_ring[tx_new].buf, 30 + NCSI_Request.Payload_Length + 4);
+//RX
+    NCSI_Rx();
+    if ((NCSI_Respond.IID != InstanceID) || (NCSI_Respond.Command != (SELECT_PACKAGE | 0x80)) || (NCSI_Respond.Response_Code != COMMAND_COMPLETED)) {
+      printf ("Retry: Command = %x, Response_Code = %x\n", NCSI_Request.Command, NCSI_Respond.Response_Code);
+      Retry++;
+      Found = 0;
+      InstanceID--;
+    }
+    else {
+      Retry = 0;
+      Found = 1;
+    }
+  } while ((Retry != 0) && (Retry <= RETRY_COUNT));
+  Retry = 0;
+
+  return Found;
+}
+
+void DeSelect_Active_Package (struct eth_device* dev)
+{
+  unsigned long Combined_Channel_ID;
+//TX
+  do {
+    InstanceID++;
+    NCSI_Request.IID = InstanceID;
+    NCSI_Request.Command = DESELECT_PACKAGE;
+    Combined_Channel_ID = (NCSI_Cap.Package_ID << 5) + 0x1F; //Internal Channel ID = 0x1F, 0x1F means all channel
+    NCSI_Request.Channel_ID = Combined_Channel_ID;
+    NCSI_Request.Payload_Length = 0;
+    memcpy ((unsigned char *)tx_ring[tx_new].buf, &NCSI_Request, 30);
+    copy_data (NCSI_Request.Payload_Length);
+    aspeednic_send (dev, (void *)tx_ring[tx_new].buf, 30 + NCSI_Request.Payload_Length + 4);
+//RX
+    NCSI_Rx();
+    if ((NCSI_Respond.IID != InstanceID) || (NCSI_Respond.Command != (DESELECT_PACKAGE | 0x80)) || (NCSI_Respond.Response_Code != COMMAND_COMPLETED)) {
+      printf ("Retry: Command = %x, Response_Code = %x\n", NCSI_Request.Command, NCSI_Respond.Response_Code);
+      Retry++;
+      InstanceID--;
+    }
+    else {
+      Retry = 0;
+    }
+  } while ((Retry != 0) && (Retry <= RETRY_COUNT));
+  Retry = 0;
+}
+
+int Select_Active_Package (struct eth_device* dev)
+{
+  unsigned long Combined_Channel_ID, Found = 0;
+//TX
+  do {
+    InstanceID++;
+    NCSI_Request.IID = InstanceID;
+    NCSI_Request.Command = SELECT_PACKAGE;
+    Combined_Channel_ID = (NCSI_Cap.Package_ID << 5) + 0x1F; //Internal Channel ID = 0x1F
+    NCSI_Request.Channel_ID = Combined_Channel_ID;
+    NCSI_Request.Payload_Length = (4 << 8);
+    memcpy ((unsigned char *)tx_ring[tx_new].buf, &NCSI_Request, 30);
+    NCSI_Request.Payload_Length = 4;
+    memset ((void *)Payload_Data, 0, 4);
+    Payload_Data[3] = 1; //Arbitration Disable
+    copy_data (NCSI_Request.Payload_Length);
+    aspeednic_send (dev, (void *)tx_ring[tx_new].buf, 30 + NCSI_Request.Payload_Length + 4);
+//RX
+    NCSI_Rx();
+    if ((NCSI_Respond.IID != InstanceID) || (NCSI_Respond.Command != (SELECT_PACKAGE | 0x80)) || (NCSI_Respond.Response_Code != COMMAND_COMPLETED)) {
+      printf ("Retry: Command = %x, Response_Code = %x\n", NCSI_Request.Command, NCSI_Respond.Response_Code);
+      Retry++;
+      Found = 0;
+      InstanceID--;
+    }
+    else {
+      Retry = 0;
+      Found = 1;
+    }
+  } while ((Retry != 0) && (Retry <= RETRY_COUNT));
+  Retry = 0;
+
+  return Found;
+}
+
+int Clear_Initial_State (struct eth_device* dev, int Channel_ID)
+{
+  unsigned long Combined_Channel_ID, Found = 0;
+//TX
+  do {
+    InstanceID++;
+    NCSI_Request.IID = InstanceID;
+    NCSI_Request.Command = CLEAR_INITIAL_STATE;
+    Combined_Channel_ID = (NCSI_Cap.Package_ID << 5) + Channel_ID; //Internal Channel ID = 0
+    NCSI_Request.Channel_ID = Combined_Channel_ID;
+    NCSI_Request.Payload_Length = 0;
+    memcpy ((unsigned char *)tx_ring[tx_new].buf, &NCSI_Request, 30);
+    copy_data (NCSI_Request.Payload_Length);
+    aspeednic_send (dev, (void *)tx_ring[tx_new].buf, 30 + NCSI_Request.Payload_Length + 4);
+//RX
+    NCSI_Rx();
+    if ((NCSI_Respond.IID != InstanceID) || (NCSI_Respond.Command != (CLEAR_INITIAL_STATE | 0x80)) || (NCSI_Respond.Response_Code != COMMAND_COMPLETED)) {
+      printf ("Retry: Command = %x, Response_Code = %x\n", NCSI_Request.Command, NCSI_Respond.Response_Code);
+      Retry++;
+      Found = 0;
+      InstanceID--;
+    }
+    else {
+      Retry = 0;
+      Found = 1;
+    }
+  } while ((Retry != 0) && (Retry <= RETRY_COUNT));
+  Retry = 0;
+
+  return Found;
+}
+
+void Get_Version_ID (struct eth_device* dev)
+{
+  unsigned long Combined_Channel_ID;
+//TX
+  do {
+    InstanceID++;
+    NCSI_Request.IID = InstanceID;
+    NCSI_Request.Command = GET_VERSION_ID;
+    Combined_Channel_ID = (NCSI_Cap.Package_ID << 5) + NCSI_Cap.Channel_ID;
+    NCSI_Request.Channel_ID = Combined_Channel_ID;
+    NCSI_Request.Payload_Length = 0;
+    memcpy ((unsigned char *)tx_ring[tx_new].buf, &NCSI_Request, 30);
+    copy_data (NCSI_Request.Payload_Length);
+    aspeednic_send (dev, (void *)tx_ring[tx_new].buf, 30 + NCSI_Request.Payload_Length + 4);
+//RX
+    NCSI_Rx();
+    if ((NCSI_Respond.IID != InstanceID) || (NCSI_Respond.Command != (GET_VERSION_ID | 0x80)) || (NCSI_Respond.Response_Code != COMMAND_COMPLETED)) {
+      printf ("Retry: Command = %x, Response_Code = %x\n", NCSI_Request.Command, NCSI_Respond.Response_Code);
+      Retry++;
+      InstanceID--;
+    }
+    else {
+      Retry = 0;
+    }
+  } while ((Retry != 0) && (Retry <= RETRY_COUNT));
+  Retry = 0;
+}
+
+void Get_Capabilities (struct eth_device* dev)
+{
+  unsigned long Combined_Channel_ID;
+//TX
+  do {
+    InstanceID++;
+    NCSI_Request.IID = InstanceID;
+    NCSI_Request.Command = GET_CAPABILITIES;
+    Combined_Channel_ID = (NCSI_Cap.Package_ID << 5) + NCSI_Cap.Channel_ID;
+    NCSI_Request.Channel_ID = Combined_Channel_ID;
+    NCSI_Request.Payload_Length = 0;
+    memcpy ((unsigned char *)tx_ring[tx_new].buf, &NCSI_Request, 30);
+    copy_data (NCSI_Request.Payload_Length);
+    aspeednic_send (dev, (void *)tx_ring[tx_new].buf, 30 + NCSI_Request.Payload_Length + 4);
+//RX
+    NCSI_Rx();
+    if ((NCSI_Respond.IID != InstanceID) || (NCSI_Respond.Command != (GET_CAPABILITIES | 0x80)) || (NCSI_Respond.Response_Code != COMMAND_COMPLETED)) {
+      printf ("Retry: Command = %x, Response_Code = %x\n", NCSI_Request.Command, NCSI_Respond.Response_Code);
+      Retry++;
+      InstanceID--;
+    }
+    else {
+      Retry = 0;
+      NCSI_Cap.Capabilities_Flags = NCSI_Respond.Payload_Data[0];
+      NCSI_Cap.Broadcast_Packet_Filter_Capabilities = NCSI_Respond.Payload_Data[1];
+      NCSI_Cap.Multicast_Packet_Filter_Capabilities = NCSI_Respond.Payload_Data[2];
+      NCSI_Cap.Buffering_Capabilities = NCSI_Respond.Payload_Data[3];
+      NCSI_Cap.AEN_Control_Support = NCSI_Respond.Payload_Data[4];
+    }
+  } while ((Retry != 0) && (Retry <= RETRY_COUNT));
+  Retry = 0;
+}
+
+void Enable_Set_MAC_Address (struct eth_device* dev)
+{
+  unsigned long Combined_Channel_ID, i;
+//TX
+  do {
+    InstanceID++;
+    NCSI_Request.IID = InstanceID;
+    NCSI_Request.Command = SET_MAC_ADDRESS;
+    Combined_Channel_ID = (NCSI_Cap.Package_ID << 5) + NCSI_Cap.Channel_ID;
+    NCSI_Request.Channel_ID = Combined_Channel_ID;
+    NCSI_Request.Payload_Length = (8 << 8);
+    memcpy ((unsigned char *)tx_ring[tx_new].buf, &NCSI_Request, 30);
+    NCSI_Request.Payload_Length = 8;
+    for (i = 0; i < 6; i++) {
+      Payload_Data[i] = NCSI_Request.SA[i];
+    }
+    Payload_Data[6] = 1; //MAC Address Num = 1 --> address filter 1, fixed in sample code
+    Payload_Data[7] = UNICAST + 0 + ENABLE_MAC_ADDRESS_FILTER; //AT + Reserved + E
+    copy_data (NCSI_Request.Payload_Length);
+    aspeednic_send (dev, (void *)tx_ring[tx_new].buf, 30 + NCSI_Request.Payload_Length + 4);
+//RX
+    NCSI_Rx();
+    if ((NCSI_Respond.IID != InstanceID) || (NCSI_Respond.Command != (SET_MAC_ADDRESS | 0x80)) || (NCSI_Respond.Response_Code != COMMAND_COMPLETED)) {
+      printf ("Retry: Command = %x, Response_Code = %x\n", NCSI_Request.Command, NCSI_Respond.Response_Code);
+      Retry++;
+      InstanceID--;
+    }
+  } while ((Retry != 0) && (Retry <= RETRY_COUNT));
+  Retry = 0;
+}
+
+void Enable_Broadcast_Filter (struct eth_device* dev)
+{
+  unsigned long Combined_Channel_ID;
+//TX
+  do {
+    InstanceID++;
+    NCSI_Request.IID = InstanceID;
+    NCSI_Request.Command = ENABLE_BROADCAST_FILTERING;
+    Combined_Channel_ID = (NCSI_Cap.Package_ID << 5) + NCSI_Cap.Channel_ID;
+    NCSI_Request.Channel_ID = Combined_Channel_ID;
+    NCSI_Request.Payload_Length = (4 << 8);
+    memcpy ((unsigned char *)tx_ring[tx_new].buf, &NCSI_Request, 30);
+    NCSI_Request.Payload_Length = 4;
+    memset ((void *)Payload_Data, 0, 4);
+    Payload_Data[3] = 0xF; //ARP, DHCP, NetBIOS
+    copy_data (NCSI_Request.Payload_Length);
+    aspeednic_send (dev, (void *)tx_ring[tx_new].buf, 30 + NCSI_Request.Payload_Length + 4);
+//RX
+    NCSI_Rx();
+    if ((NCSI_Respond.IID != InstanceID) || (NCSI_Respond.Command != (ENABLE_BROADCAST_FILTERING | 0x80)) || (NCSI_Respond.Response_Code != COMMAND_COMPLETED)) {
+      printf ("Retry: Command = %x, Response_Code = %x\n", NCSI_Request.Command, NCSI_Respond.Response_Code);
+      Retry++;
+      InstanceID--;
+    }
+    else {
+      Retry = 0;
+    }
+  } while ((Retry != 0) && (Retry <= RETRY_COUNT));
+  Retry = 0;
+}
+
+void Enable_AEN (struct eth_device* dev)
+{
+  unsigned long Combined_Channel_ID;
+//TX
+  do {
+    InstanceID++;
+    NCSI_Request.IID = InstanceID;
+    NCSI_Request.Command = AEN_ENABLE;
+    Combined_Channel_ID = (NCSI_Cap.Package_ID << 5) + NCSI_Cap.Channel_ID;
+    NCSI_Request.Channel_ID = Combined_Channel_ID;
+    NCSI_Request.Payload_Length = (8 << 8);
+    memcpy ((unsigned char *)tx_ring[tx_new].buf, &NCSI_Request, 30);
+    NCSI_Request.Payload_Length = 8;
+    memset ((void *)Payload_Data, 0, 8);
+    Payload_Data[3] = 0x00; //MC ID
+    Payload_Data[7] = 0x01; //Link Status only
+    copy_data (NCSI_Request.Payload_Length);
+    aspeednic_send (dev, (void *)tx_ring[tx_new].buf, 30 + NCSI_Request.Payload_Length + 4);
+//RX
+    NCSI_Rx();
+    if ((NCSI_Respond.IID != InstanceID) || (NCSI_Respond.Command != (AEN_ENABLE | 0x80)) || (NCSI_Respond.Response_Code != COMMAND_COMPLETED)) {
+      printf ("Retry: Command = %x, Response_Code = %x\n", NCSI_Request.Command, NCSI_Respond.Response_Code);
+      Retry++;
+      InstanceID--;
+    }
+    else {
+      Retry = 0;
+    }
+  } while ((Retry != 0) && (Retry <= RETRY_COUNT));
+  Retry = 0;
+}
+
+void Enable_Network_TX (struct eth_device* dev)
+{
+  unsigned long Combined_Channel_ID;
+//TX
+  do {
+    InstanceID++;
+    NCSI_Request.IID = InstanceID;
+    NCSI_Request.Command = ENABLE_CHANNEL_NETWORK_TX;
+    Combined_Channel_ID = (NCSI_Cap.Package_ID << 5) + NCSI_Cap.Channel_ID;
+    NCSI_Request.Channel_ID = Combined_Channel_ID;
+    NCSI_Request.Payload_Length = 0;
+    memcpy ((unsigned char *)tx_ring[tx_new].buf, &NCSI_Request, 30);
+    copy_data (NCSI_Request.Payload_Length);
+    aspeednic_send (dev, (void *)tx_ring[tx_new].buf, 30 + NCSI_Request.Payload_Length + 4);
+//RX
+    NCSI_Rx();
+    if ((NCSI_Respond.IID != InstanceID) || (NCSI_Respond.Command != (ENABLE_CHANNEL_NETWORK_TX | 0x80)) || (NCSI_Respond.Response_Code != COMMAND_COMPLETED)) {
+      printf ("Retry: Command = %x, Response_Code = %x\n", NCSI_Request.Command, NCSI_Respond.Response_Code);
+      Retry++;
+      InstanceID--;
+    }
+    else {
+      Retry = 0;
+    }
+  } while ((Retry != 0) && (Retry <= RETRY_COUNT));
+  Retry = 0;
+}
+
+void Disable_Network_TX (struct eth_device* dev)
+{
+  unsigned long Combined_Channel_ID;
+//TX
+  do {
+    InstanceID++;
+    NCSI_Request.IID = InstanceID;
+    NCSI_Request.Command = DISABLE_CHANNEL_NETWORK_TX;
+    Combined_Channel_ID = (NCSI_Cap.Package_ID << 5) + NCSI_Cap.Channel_ID;
+    NCSI_Request.Channel_ID = Combined_Channel_ID;
+    NCSI_Request.Payload_Length = 0;
+    memcpy ((unsigned char *)tx_ring[tx_new].buf, &NCSI_Request, 30);
+    copy_data (NCSI_Request.Payload_Length);
+    aspeednic_send (dev, (void *)tx_ring[tx_new].buf, 30 + NCSI_Request.Payload_Length + 4);
+//RX
+    NCSI_Rx();
+    if ((NCSI_Respond.IID != InstanceID) || (NCSI_Respond.Command != (DISABLE_CHANNEL_NETWORK_TX | 0x80)) || (NCSI_Respond.Response_Code != COMMAND_COMPLETED)) {
+      printf ("Retry: Command = %x, Response_Code = %x\n", NCSI_Request.Command, NCSI_Respond.Response_Code);
+      Retry++;
+      InstanceID--;
+    }
+    else {
+      Retry = 0;
+    }
+  } while ((Retry != 0) && (Retry <= RETRY_COUNT));
+  Retry = 0;
+}
+
+void Enable_Channel (struct eth_device* dev)
+{
+  unsigned long Combined_Channel_ID;
+//TX
+  do {
+    InstanceID++;
+    NCSI_Request.IID = InstanceID;
+    NCSI_Request.Command = ENABLE_CHANNEL;
+    Combined_Channel_ID = (NCSI_Cap.Package_ID << 5) + NCSI_Cap.Channel_ID;
+    NCSI_Request.Channel_ID = Combined_Channel_ID;
+    NCSI_Request.Payload_Length = 0;
+    memcpy ((unsigned char *)tx_ring[tx_new].buf, &NCSI_Request, 30);
+    copy_data (NCSI_Request.Payload_Length);
+    aspeednic_send (dev, (void *)tx_ring[tx_new].buf, 30 + NCSI_Request.Payload_Length + 4);
+//RX
+    NCSI_Rx();
+    if ((NCSI_Respond.IID != InstanceID) || (NCSI_Respond.Command != (ENABLE_CHANNEL | 0x80)) || (NCSI_Respond.Response_Code != COMMAND_COMPLETED)) {
+      printf ("Retry: Command = %x, Response_Code = %x\n", NCSI_Request.Command, NCSI_Respond.Response_Code);
+      Retry++;
+      InstanceID--;
+    }
+    else {
+      Retry = 0;
+    }
+  } while ((Retry != 0) && (Retry <= RETRY_COUNT));
+  Retry = 0;
+}
+
+void Disable_Channel (struct eth_device* dev)
+{
+  unsigned long Combined_Channel_ID;
+//TX
+  do {
+    InstanceID++;
+    NCSI_Request.IID = InstanceID;
+    NCSI_Request.Command = DISABLE_CHANNEL;
+    Combined_Channel_ID = (NCSI_Cap.Package_ID << 5) + NCSI_Cap.Channel_ID;
+    NCSI_Request.Channel_ID = Combined_Channel_ID;
+    NCSI_Request.Payload_Length = (4 << 8);
+    memcpy ((unsigned char *)tx_ring[tx_new].buf, &NCSI_Request, 30);
+    NCSI_Request.Payload_Length = 4;
+    memset ((void *)Payload_Data, 0, 4);
+    Payload_Data[3] = 0x1; //ALD
+    copy_data (NCSI_Request.Payload_Length);
+    aspeednic_send (dev, (void *)tx_ring[tx_new].buf, 30 + NCSI_Request.Payload_Length + 4);
+//RX
+    NCSI_Rx();
+    if ((NCSI_Respond.IID != InstanceID) || (NCSI_Respond.Command != (DISABLE_CHANNEL | 0x80)) || (NCSI_Respond.Response_Code != COMMAND_COMPLETED)) {
+      printf ("Retry: Command = %x, Response_Code = %x\n", NCSI_Request.Command, NCSI_Respond.Response_Code);
+      Retry++;
+      InstanceID--;
+    }
+    else {
+      Retry = 0;
+    }
+  } while ((Retry != 0) && (Retry <= RETRY_COUNT));
+  Retry = 0;
+}
+
+int Get_Link_Status (struct eth_device* dev)
+{
+  unsigned long Combined_Channel_ID;
+//TX
+  do {
+    InstanceID++;
+    NCSI_Request.IID = InstanceID;
+    NCSI_Request.Command = GET_LINK_STATUS;
+    Combined_Channel_ID = (NCSI_Cap.Package_ID << 5) + NCSI_Cap.Channel_ID;
+    NCSI_Request.Channel_ID = Combined_Channel_ID;
+    NCSI_Request.Payload_Length = 0;
+    memcpy ((unsigned char *)tx_ring[tx_new].buf, &NCSI_Request, 30);
+    copy_data (NCSI_Request.Payload_Length);
+    aspeednic_send (dev, (void *)tx_ring[tx_new].buf, 30 + NCSI_Request.Payload_Length + 4);
+//RX
+    NCSI_Rx();
+    if ((NCSI_Respond.IID != InstanceID) || (NCSI_Respond.Command != (GET_LINK_STATUS | 0x80)) || (NCSI_Respond.Response_Code != COMMAND_COMPLETED)) {
+      printf ("Retry: Command = %x, Response_Code = %x\n", NCSI_Request.Command, NCSI_Respond.Response_Code);
+      Retry++;
+      InstanceID--;
+    }
+    else {
+      Retry = 0;
+    }
+  } while ((Retry != 0) && (Retry <= RETRY_COUNT));
+  Retry = 0;
+  if (NCSI_Respond.Payload_Data[3] & 0x40) {
+    return (NCSI_Respond.Payload_Data[3] & 0x01); //Link Up or Not
+  }
+  else {
+    return 0; //Auto Negotiate did not finish
+  }
+}
+
+void Set_Link (struct eth_device* dev)
+{
+  unsigned long Combined_Channel_ID;
+//TX
+  do {
+    InstanceID++;
+    NCSI_Request.IID = InstanceID;
+    NCSI_Request.Command = SET_LINK;
+    Combined_Channel_ID = (NCSI_Cap.Package_ID << 5) + NCSI_Cap.Channel_ID;
+    NCSI_Request.Channel_ID = Combined_Channel_ID;
+    NCSI_Request.Payload_Length = (8 << 8);
+    memcpy ((unsigned char *)tx_ring[tx_new].buf, &NCSI_Request, 30);
+    NCSI_Request.Payload_Length = 8;
+    memset ((void *)Payload_Data, 0, 8);
+    Payload_Data[2] = 0x02; //full duplex
+    Payload_Data[3] = 0x04; //100M, auto-disable
+    copy_data (NCSI_Request.Payload_Length);
+    aspeednic_send (dev, (void *)tx_ring[tx_new].buf, 30 + NCSI_Request.Payload_Length + 4);
+//RX
+    NCSI_Rx();
+    if ((NCSI_Respond.IID != InstanceID) || (NCSI_Respond.Command != (SET_LINK | 0x80)) || (NCSI_Respond.Response_Code != COMMAND_COMPLETED)) {
+      printf ("Retry: Command = %x, Response_Code = %x\n", NCSI_Request.Command, NCSI_Respond.Response_Code);
+      Retry++;
+      InstanceID--;
+    }
+    else {
+      Retry = 0;
+    }
+  } while ((Retry != 0) && (Retry <= RETRY_COUNT));
+  Retry = 0;
+}
+
+static int aspeednic_init(struct eth_device* dev, bd_t* bis)
+{
+  unsigned long i, Package_Found = 0, Channel_Found = 0, Re_Send = 0, Link_Status;
+
+  RESET_DE4X5(dev);
+  set_mac_address (dev, bis);
+  set_mac_control_register (dev);
+
+  for (i = 0; i < NUM_RX_DESC; i++) {
+    rx_ring[i].status = cpu_to_le32(RXPKT_RDY + RX_BUFF_SZ);
+    rx_ring[i].buf = (u32)(&rx_buffer[i]);
+    rx_ring[i].reserved = 0;
+  }
+
+  for (i=0; i < NUM_TX_DESC; i++) {
+    tx_ring[i].status = 0;
+    tx_ring[i].des1 = 0;
+    tx_ring[i].buf = (u32)(&tx_buffer[i]);
+    tx_ring[i].reserved = 0;
+  }
+
+  rxRingSize = NUM_RX_DESC;
+  txRingSize = NUM_TX_DESC;
+
+  rx_ring[rxRingSize - 1].status |= cpu_to_le32(EDORR);
+  tx_ring[txRingSize - 1].status |= cpu_to_le32(EDOTR);
+
+  OUTL(dev, ((u32) &tx_ring), TXR_BADR_REG);
+  OUTL(dev, ((u32) &rx_ring), RXR_BADR_REG);
+
+  START_MAC(dev);
+
+  tx_new = 0;
+  rx_new = 0;
+
+  if (CONFIG_MAC1_PHY_SETTING >= 1) {
+//NCSI Start
+//DeSelect Package/ Select Package
+    for (i = 0; i < 4; i++) {
+      DeSelect_Package (dev, i);
+      Package_Found = Select_Package (dev, i);
+      if (Package_Found == 1) {
+//AST2100/AST2050/AST1100 supports 1 package only in current firmware version
+        NCSI_Cap.Package_ID = i;
+//        Package_Found = 0;
+        break;
+      }
+    }
+    if (Package_Found != 0) {
+//Initiali State
+      for (i = 0; i < 2; i++) { //Suppose 2 channels in current version, You could modify it to 0x1F to support 31 channels
+        Channel_Found = Clear_Initial_State(dev, i);
+        if (Channel_Found == 1) {
+          NCSI_Cap.Channel_ID = i;
+          printf ("Found NCSI Network Controller at (%d, %d)\n", NCSI_Cap.Package_ID, NCSI_Cap.Channel_ID);
+//Get Version and Capabilities
+          Get_Version_ID(dev);
+          Get_Capabilities(dev);
+          Select_Active_Package(dev);
+//Configuration
+          Enable_Set_MAC_Address(dev);
+          Enable_Broadcast_Filter(dev);
+//Enable TX
+          Enable_Network_TX(dev);
+//Enable Channel
+          Enable_Channel(dev);
+//Get Link Status
+          Re_Get_Link_Status:
+          Link_Status = Get_Link_Status(dev);
+          if (Link_Status == LINK_UP) {
+            printf ("Using NCSI Network Controller (%d, %d)\n", NCSI_Cap.Package_ID, NCSI_Cap.Channel_ID);
+            break;
+          }
+          else if ((Link_Status == LINK_DOWN) && (Re_Send < 2)) {
+            Re_Send++;
+            goto Re_Get_Link_Status;
+          }
+//Disable TX
+          Disable_Network_TX(dev);
+//Disable Channel
+//          Disable_Channel(dev);
+          Re_Send = 0;
+          Channel_Found = 0;
+        }
+      }
+    }
+  }
+  return 1;
+}
+
+static int aspeednic_send(struct eth_device* dev, volatile void *packet, int length)
+{
+  int   status = -1, oldlength = 0, fail = 0;
+  int   i;
+
+  if (length <= 0) {
+    printf("%s: bad packet size: %d\n", dev->name, length);
+    goto Done;
+  }
+
+
+  for(i = 0; (tx_ring[tx_new].status & cpu_to_le32(TXDMA_OWN)) == 0x80000000; i++) {
+    if (i >= TOUT_LOOP) {
+      printf("%s: tx error buffer not ready\n", dev->name);
+      fail = 1;
+      goto Done;
+    }
+  }
+
+
+  if (length < 60) {
+    oldlength = length;
+//            memset ((void *)cpu_to_le32((u32) (packet + length)), 0, 60 - length);
+    length = 60;
+  }
+  tx_ring[tx_new].buf    = cpu_to_le32(((u32) packet));
+  tx_ring[tx_new].status   &= (~(0x3FFF));
+  tx_ring[tx_new].status   |= cpu_to_le32(LTS | FTS | length);
+  tx_ring[tx_new].status |= cpu_to_le32(TXDMA_OWN);
+
+  OUTL(dev, POLL_DEMAND, TXPD_REG);
+
+  for (i = 0; (tx_ring[tx_new].status & cpu_to_le32(TXDMA_OWN)) == 0x80000000; i++)
+  {
+    if (i >= TOUT_LOOP)
+    {
+      printf(".%s: tx buffer not ready\n", dev->name);
+      fail = 1;
+      goto Done;
+    }
+  }
+
+  if (fail != 1) {
+    status = oldlength;
+  }
+
+  Done:
+  tx_new = (tx_new+1) % NUM_TX_DESC;
+
+  return status;
+}
+
+static int aspeednic_recv(struct eth_device* dev)
+{
+  s32   status;
+  int   length    = 0;
+
+  for ( ; ; )
+  {
+    status = (s32)le32_to_cpu(rx_ring[rx_new].status);
+
+    if ((status & RXPKT_STATUS) == 0) {
+      break;
+    }
+
+    if (status & LRS) {
+      /* Valid frame status.
+       */
+      if (status & (RX_ERR | CRC_ERR | FTL | RUNT | RX_ODD_NB)) {
+
+        /* There was an error.
+         */
+        printf("RX error status = 0x%08X\n", status);
+      } else {
+        /* A valid frame received.
+         */
+        length = (le32_to_cpu(rx_ring[rx_new].status) & 0x3FFF);
+        debug("%s(): RX buffer %d, %x received\n",
+              __func__, rx_new, length);
+
+
+        /* Pass the packet up to the protocol
+         * layers.
+         */
+        NetReceive(rx_buffer[rx_new], length - 4);
+      }
+
+      /* Change buffer ownership for this frame, back
+       * to the adapter.
+       */
+      rx_ring[rx_new].status &= cpu_to_le32(0x7FFFFFFF);
+//      rx_ring[rx_new].status = cpu_to_le32(RXPKT_RDY);
+    }
+
+    /* Update entry information.
+     */
+    rx_new = (rx_new + 1) % rxRingSize;
+  }
+
+  return length;
+}
+
+static void aspeednic_halt(struct eth_device* dev)
+{
+  STOP_MAC(dev);
+}
+
+static void set_mac_address (struct eth_device* dev, bd_t* bis)
+{
+  unsigned char  mac_address[6]; // 6 bytes mac address
+  unsigned char  ethaddress[20]; // string for setenv function
+  char *s;
+  int i, env;                // env variable 0: eeprom, 1: environment parameters
+
+  s = getenv ("eeprom");
+  env = (s && (*s == 'y')) ? 0 : 1;
+
+  if (env == 0) {
+    env = 1;
+    eeprom_init ();
+    eeprom_read (0xA0, 0, mac_address, 6);
+
+    for (i = 0; i < 6; i++) {
+      if (mac_address[i] != 0xFF) {
+        env = 0;  //Suppose not all 0xFF is valid
+      }
+    }
+  }
+
+  if (env == 0) { // EEPROM
+    sprintf (ethaddress, "%02X:%02X:%02X:%02X:%02X:%02X", mac_address[0], mac_address[1], mac_address[2], mac_address[3], mac_address[4], mac_address[5]);
+    setenv ("ethaddr", ethaddress);
+    OUTL(dev, ((mac_address[2] << 24) | (mac_address[3] << 16) | (mac_address[4] << 8) | mac_address[5]), MAC_LADR_REG);
+    OUTL(dev, ((mac_address[0] << 8) | mac_address[1]), MAC_MADR_REG);
+    if (CONFIG_MAC1_PHY_SETTING >= 1) {
+      for (i = 0; i < 6; i++) {
+        NCSI_Request.SA[i] = mac_address[i];
+      }
+    }
+  }
+  else { // Environment Parameters
+    OUTL(dev, ((bis->bi_enetaddr[2] << 24) | (bis->bi_enetaddr[3] << 16) | (bis->bi_enetaddr[4] << 8) | bis->bi_enetaddr[5]), MAC_LADR_REG);
+    OUTL(dev, ((bis->bi_enetaddr[0] << 8) | bis->bi_enetaddr[1]), MAC_MADR_REG);
+    if (CONFIG_MAC1_PHY_SETTING >= 1) {
+      for (i = 0; i < 6; i++) {
+        NCSI_Request.SA[i] = bis->bi_enetaddr[i];
+      }
+    }
+  }
+
+}
+
+
+static u16 phy_read_register (struct eth_device* dev, u8 PHY_Register, u8 PHY_Address)
+{
+  u32 Data, Status = 0, Loop_Count = 0, PHY_Ready = 1;
+  u16 Return_Data;
+
+#ifdef  REALTEK_PHY_SUPPORT
+  PHY_Address = 0x01;
+#endif
+//20us * 100 = 2ms > (1 / 2.5Mhz) * 0x34
+  OUTL(dev, (PHY_Register << 21) + (PHY_Address << 16) + MIIRD + MDC_CYCTHR, PHYCR_REG);
+  do {
+    udelay(20);
+    Status = (INL (dev, PHYCR_REG) & MIIRD);
+    Loop_Count++;
+    if (Loop_Count >= 100) {
+      PHY_Ready = 0;
+      break;
+    }
+  } while (Status == MIIRD);
+
+  if (PHY_Ready == 0) {
+    printf ("PHY NOT REDAY ");
+    return 0;
+  }
+  Data = INL (dev, PHYDATA_REG);
+  Return_Data = (Data >> 16);
+
+  return Return_Data;
+}
+
+
+static void phy_write_register (struct eth_device* dev, u8 PHY_Register, u8 PHY_Address, u16 PHY_Data)
+{
+  u32 Status = 0, Loop_Count = 0, PHY_Ready = 1;
+
+#ifdef  REALTEK_PHY_SUPPORT
+  PHY_Address = 0x01;
+#endif
+//20us * 100 = 2ms > (1 / 2.5Mhz) * 0x34
+  OUTL(dev, PHY_Data, PHYDATA_REG);
+  OUTL(dev, (PHY_Register << 21) + (PHY_Address << 16) + MIIWR + MDC_CYCTHR, PHYCR_REG);
+  do {
+    udelay(20);
+    Status = (INL (dev, PHYCR_REG) & MIIWR);
+    Loop_Count++;
+    if (Loop_Count >= 100) {
+      PHY_Ready = 0;
+      break;
+    }
+  } while (Status == MIIWR);
+  if (PHY_Ready == 0) {
+    printf ("PHY NOT REDAY ");
+  }
+}
+
+static void set_mac_control_register (struct eth_device* dev)
+{
+  unsigned long MAC_CR_Register = 0;
+  unsigned long   Loop_Count = 0, PHY_Ready = 1, Chip_ID;
+  u16    PHY_Status, PHY_Speed, PHY_Duplex, Resolved_Status = 0, Advertise, Link_Partner;
+
+  if (CONFIG_MAC1_PHY_SETTING >= 1) {
+    MAC_CR_Register = SPEED_100M_MODE_bit | RX_BROADPKT_bit | FULLDUP_bit | RXMAC_EN_bit | RXDMA_EN_bit | TXMAC_EN_bit | TXDMA_EN_bit | CRC_APD_bit;
+  }
+  else {
+    MAC_CR_Register = SPEED_100M_MODE_bit | FULLDUP_bit | RXMAC_EN_bit | RXDMA_EN_bit | TXMAC_EN_bit | TXDMA_EN_bit | CRC_APD_bit;
+  }
+
+  if (CONFIG_MAC1_PHY_SETTING != 2) {
+    Chip_ID = ((phy_read_register (dev, 0x02, 0)) << 16);
+    Chip_ID |= (phy_read_register (dev, 0x03, 0) & 0xffff);
+    if (((Chip_ID & PHYID_VENDOR_MASK) == PHYID_VENDOR_BROADCOM) ||
+        ((Chip_ID & PHYID_VENDOR_MODEL_MASK) == PHYID_RTL8201EL)) {
+      Advertise = phy_read_register (dev, 0x04, 0);
+      Link_Partner = phy_read_register (dev, 0x05, 0);
+      Advertise = (Advertise & PHY_SPEED_DUPLEX_MASK);
+      Link_Partner = (Link_Partner & PHY_SPEED_DUPLEX_MASK);
+      if ((Advertise & Link_Partner) & PHY_100M_DUPLEX) {
+        MAC_CR_Register |= SPEED_100M_MODE_bit;
+        MAC_CR_Register |= FULLDUP_bit;
+      }
+      else if ((Advertise & Link_Partner) & PHY_100M_HALF) {
+        MAC_CR_Register |= SPEED_100M_MODE_bit;
+        MAC_CR_Register &= ~FULLDUP_bit;
+      }
+      else if ((Advertise & Link_Partner) & PHY_10M_DUPLEX) {
+        MAC_CR_Register &= ~SPEED_100M_MODE_bit;
+        MAC_CR_Register |= FULLDUP_bit;
+      }
+      else if ((Advertise & Link_Partner) & PHY_10M_HALF) {
+        MAC_CR_Register &= ~SPEED_100M_MODE_bit;
+        MAC_CR_Register &= ~FULLDUP_bit;
+      }
+    }
+    else if (((Chip_ID & PHYID_VENDOR_MASK) == PHYID_VENDOR_MARVELL) ||
+             ((Chip_ID & PHYID_VENDOR_MODEL_MASK) == PHYID_RTL8211)) {
+//Max waiting time = (20 + 2)ms * 250(PHY_LOOP) = 5.5s
+      do {
+        udelay (20000);
+        Resolved_Status = (phy_read_register (dev, 0x11, 0) & RESOLVED_BIT);
+        Loop_Count++;
+        if (Loop_Count >= PHY_LOOP) {
+          PHY_Ready = 0;
+          printf ("PHY NOT READY ");
+          break;
+        }
+      } while (Resolved_Status != RESOLVED_BIT);
+
+      if (PHY_Ready == 1) {
+        PHY_Status = phy_read_register (dev, 0x11, 0);
+        PHY_Speed = (PHY_Status & PHY_SPEED_MASK) >> 14;
+        PHY_Duplex = (PHY_Status & PHY_DUPLEX_MASK) >> 13;
+
+        if (PHY_Speed == SPEED_1000M) {
+          MAC_CR_Register |= GMAC_MODE_bit;
+        }
+        else {
+          MAC_CR_Register &= ~GMAC_MODE_bit;
+          if (PHY_Speed == SPEED_10M) {
+            MAC_CR_Register &= ~SPEED_100M_MODE_bit;
+          }
+        }
+        if (PHY_Duplex == DUPLEX_HALF) {
+          MAC_CR_Register &= ~FULLDUP_bit;
+        }
+      }
+//LED Control
+//              if (Chip_ID == 0x1C) {
+//                  PHY_Status = phy_read_register (dev, 0x18, 0);
+//                phy_write_register (dev, 0x18, 0, (PHY_Status | 0x09));
+//              }
+//LED Control D[0], D[6]
+//              if (Chip_ID == 0x141) {
+//                  PHY_Status = phy_read_register (dev, 0x18, 0);
+//                phy_write_register (dev, 0x18, 0, ((PHY_Status & ~(0x41)) | 0x01));
+//              }
+    }
+    else if (Chip_ID == PHYID_BCM54612E )  {
+      phy_write_register ( dev, 0x1C, 1, 0x8C00 ); // Disable GTXCLK Clock Delay Enable
+      phy_write_register ( dev, 0x18, 1, 0xF0E7 ); // Disable RGMII RXD to RXC Skew
+
+      Advertise = phy_read_register (dev, 0x04, 1);
+      Link_Partner = phy_read_register (dev, 0x05, 1);
+      Advertise = (Advertise & PHY_SPEED_DUPLEX_MASK);
+      Link_Partner = (Link_Partner & PHY_SPEED_DUPLEX_MASK);
+      if ((Advertise & Link_Partner) & PHY_100M_DUPLEX) {
+        MAC_CR_Register |= SPEED_100M_MODE_bit;
+        MAC_CR_Register |= FULLDUP_bit;
+      }
+      else if ((Advertise & Link_Partner) & PHY_100M_HALF) {
+        MAC_CR_Register |= SPEED_100M_MODE_bit;
+        MAC_CR_Register &= ~FULLDUP_bit;
+      }
+      else if ((Advertise & Link_Partner) & PHY_10M_DUPLEX) {
+        MAC_CR_Register &= ~SPEED_100M_MODE_bit;
+        MAC_CR_Register |= FULLDUP_bit;
+      }
+      else if ((Advertise & Link_Partner) & PHY_10M_HALF) {
+        MAC_CR_Register &= ~SPEED_100M_MODE_bit;
+        MAC_CR_Register &= ~FULLDUP_bit;
+      }
+    }else {
+      printf("Unknow Chip_ID %x\n",Chip_ID);
+    }
+  }
+  OUTL(dev, MAC_CR_Register, MACCR_REG);
+}
+
+#endif  /* CFG_CMD_NET && CONFIG_NET_MULTI && CONFIG_ASPEEDMAC */
diff --git a/include/configs/ast1100.h b/include/configs/ast1100.h
new file mode 100755
index 0000000..dbd656e
--- /dev/null
+++ b/include/configs/ast1100.h
@@ -0,0 +1,257 @@
+/*
+ * (C) Copyright 2004
+ * Peter Chen <peterc@socle-tech.com.tw>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * Version Identity 
+ */
+#define CONFIG_IDENT_STRING	" ASPEED (v.0.12) "
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+//#define CONFIG_INIT_CRITICAL			/* define for U-BOOT 1.1.1 */
+#undef  CONFIG_INIT_CRITICAL			/* undef for  U-BOOT 1.1.4 */ 
+#define CONFIG_ARM926EJS	1		/* This is an arm926ejs CPU */
+#define	CONFIG_ASPEED		1
+#define CONFIG_AST1100		1
+//#define CONFIG_AST1100_FPGA
+#undef CONFIG_AST1100_FPGA			/* undef if real chip */
+//#define CONFIG_AST1100A2_PATCH
+#undef CONFIG_AST1100A2_PATCH
+//#define CONFIG_2SPIFLASH			/* Boot SPI: CS2, 2nd SPI: CS0 */ /* Not ready */
+#undef CONFIG_2SPIFLASH
+#undef CONFIG_DDR512_200
+#define CONFIG_DDRII1G_200	1
+#undef CONFIG_ASPEED_SLT
+
+//#define CONFIG_USE_IRQ				/* we don't need IRQ/FIQ stuff */
+#define CONFIG_MISC_INIT_R 
+
+/* 
+ * Environment Config
+ */
+#define CONFIG_CMDLINE_TAG	 1		/* enable passing of ATAGs	*/
+#define CONFIG_SETUP_MEMORY_TAGS 1
+#define CONFIG_INITRD_TAG	 1
+#define	CONFIG_BOOTARGS 	"debug console=ttyS1,115200n8 ramdisk_size=16384 root=/dev/ram rw init=/linuxrc mem=80M"
+#ifdef  CONFIG_ASPEED_SLT
+#define CONFIG_BOOTDELAY	1		/* autoboot after 3 seconds	*/
+#else
+#define CONFIG_BOOTDELAY	3		/* autoboot after 3 seconds	*/
+#endif
+#define CONFIG_BOOTCOMMAND	"bootm 14080000 14300000"
+#define CONFIG_BOOTFILE		"all.bin"
+#define CONFIG_ENV_OVERWRITE
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_DFL
+#define CONFIG_CMD_ENV
+#define CONFIG_CMD_FLASH
+#define CONFIG_CMD_NET
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_EEPROM
+
+/* 
+ * CPU Setting
+ */
+#define CPU_CLOCK_RATE		18000000	/* 16.5 MHz clock for the ARM core */
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 128*1024)
+#define CONFIG_SYS_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+
+/*
+ * Stack sizes,  The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128*1024)	/* regular stack */
+#define CONFIG_STACKSIZE_IRQ	(4*1024)	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
+
+/*
+ * Memory Configuration
+ */
+#define CONFIG_NR_DRAM_BANKS	1	   	/* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0x40000000 	/* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE	0x4000000 	/* 64 MB */
+
+#define CONFIG_SYS_SDRAM_BASE	0x40000000
+
+/*
+ * FLASH Configuration
+ */
+#define PHYS_FLASH_1		0x14000000 	/* Flash Bank #1 */
+#define PHYS_FLASH_2		0x14800000 	/* Flash Bank #2 */
+#define PHYS_FLASH_2_BASE	0x10000000
+
+#ifdef CONFIG_2SPIFLASH
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_2_BASE
+#define CONFIG_FLASH_BANKS_LIST 	{ PHYS_FLASH_1, PHYS_FLASH_2 }
+#define CONFIG_SYS_MAX_FLASH_BANKS 	2
+#define CONFIG_SYS_MAX_FLASH_SECT	(256)		/* max number of sectors on one chip */
+
+#define CONFIG_ENV_IS_IN_FLASH		1
+#define CONFIG_ENV_OFFSET		0x7F0000 	/* environment starts here  */
+#define CONFIG_ENV_SIZE			0x010000 	/* Total Size of Environment Sector */
+#else
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_1
+#define CONFIG_FLASH_BANKS_LIST 	{ PHYS_FLASH_1 }
+#define CONFIG_SYS_MAX_FLASH_BANKS 	1
+#define CONFIG_SYS_MAX_FLASH_SECT	(256)		/* max number of sectors on one chip */
+
+#define CONFIG_ENV_IS_IN_FLASH		1
+#define CONFIG_ENV_OFFSET		0x7F0000 	/* environment starts here  */
+#define CONFIG_ENV_SIZE			0x010000 	/* Total Size of Environment Sector */
+#endif
+
+#define __LITTLE_ENDIAN
+#define CONFIG_FLASH_SPI
+
+#define CONFIG_MONITOR_BASE		TEXT_BASE
+#define CONFIG_MONITOR_LEN		(192 << 10)
+
+/* timeout values are in ticks */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	(20*CONFIG_SYS_HZ) 	/* Timeout for Flash Erase */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	(20*CONFIG_SYS_HZ) 	/* Timeout for Flash Write */
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP				/* undef to save memory		*/
+
+#define CONFIG_SYS_PROMPT		"boot# " 	/* Monitor Command Prompt	*/
+#define CONFIG_SYS_CBSIZE		256		/* Console I/O Buffer Size	*/
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16) /* Print Buffer Size */
+#define CONFIG_SYS_MAXARGS		16		/* max number of command args	*/
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE	/* Boot Argument Buffer Size	*/
+
+#define CONFIG_SYS_MEMTEST_START	0x40000000	/* memtest works on	*/
+#define CONFIG_SYS_MEMTEST_END		0x44FFFFFF	/* 256 MB in DRAM	*/
+
+#define	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+#undef	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+#define CONFIG_SYS_LOAD_ADDR		0x43000000	/* default load address */
+
+#define CONFIG_SYS_TIMERBASE		0x1E782000	/* use timer 1 */
+#define CONFIG_SYS_HZ			(1*1000*1000)	/* use external clk (1M) */
+
+/*
+ * Serial Configuration
+ */
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	4
+#define CONFIG_SYS_NS16550_CLK		24000000
+#define CONFIG_SYS_NS16550_COM1		0x1e783000
+#define CONFIG_SYS_NS16550_COM2		0x1e784000
+#define	CONFIG_SYS_LOADS_BAUD_CHANGE
+#define CONFIG_SERIAL1			1
+#define CONFIG_CONS_INDEX		2
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/*
+ * USB device configuration
+ */
+/*
+#define CONFIG_USB_DEVICE		1
+#define CONFIG_USB_TTY			1
+
+#define CONFIG_USBD_VENDORID		0x1234
+#define CONFIG_USBD_PRODUCTID		0x5678
+#define CONFIG_USBD_MANUFACTURER	"Siemens"
+#define CONFIG_USBD_PRODUCT_NAME	"SX1"
+*/
+
+/*
+ * I2C configuration
+ */
+#define CONFIG_HARD_I2C
+#define CONFIG_SYS_I2C_SPEED		100000
+#define CONFIG_SYS_I2C_SLAVE		1
+#define CONFIG_DRIVER_ASPEED_I2C
+
+/*
+* EEPROM configuration
+*/
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN 	2
+#define CONFIG_SYS_I2C_EEPROM_ADDR 	0xa0
+
+/*
+ * NIC configuration
+ */
+#define __BYTE_ORDER __LITTLE_ENDIAN
+#define __LITTLE_ENDIAN_BITFIELD
+#define CONFIG_MAC_PARTITION
+#define CONFIG_ASPEEDNIC
+//#define CONFIG_MAC1_PHY_LINK_INTERRUPT
+//#define CONFIG_MAC2_ENABLE
+//#define CONFIG_MAC2_MII_ENABLE
+//#define CONFIG_MAC2_PHY_LINK_INTERRUPT
+
+/*
+*-------------------------------------------------------------------------------
+* NOTICE: MAC1 and MAC2 now have their own seperate PHY configuration.
+* We use 2 bits for each MAC in the scratch register(D[15:11] in 0x1E6E2040) to
+* inform kernel driver.
+* The meanings of the 2 bits are:
+* 00(0): Dedicated PHY
+* 01(1): ASPEED's EVA + INTEL's NC-SI PHY chip EVA
+* 10(2): ASPEED's MAC is connected to NC-SI PHY chip directly
+* 11: Reserved
+*
+* We use CONFIG_MAC1_PHY_SETTING and CONFIG_MAC2_PHY_SETTING in U-Boot
+* 0: Dedicated PHY
+* 1: ASPEED's EVA + INTEL's NC-SI PHY chip EVA
+* 2: ASPEED's MAC is connected to NC-SI PHY chip directly
+* 3: Reserved
+*-------------------------------------------------------------------------------
+*/
+#define CONFIG_MAC1_PHY_SETTING		0
+#define CONFIG_MAC2_PHY_SETTING		0
+#define CONFIG_NET_MULTI
+#define CONFIG_ETHACT			aspeednic#0
+#define CONFIG_GATEWAYIP		192.168.0.1
+#define CONFIG_NETMASK			255.255.255.0
+#define CONFIG_IPADDR			192.168.0.188
+#define CONFIG_SERVERIP			192.168.0.126
+#define CONFIG_ETHADDR			00:C0:A8:12:34:56
+#define CONFIG_ETH1ADDR			00:C0:A8:12:34:57
+
+/*
+ * SLT
+ */
+/* 
+#define CONFIG_SLT
+#define CFG_CMD_SLT		(CFG_CMD_REGTEST | CFG_CMD_MACTEST | CFG_CMD_VIDEOTEST | CFG_CMD_HACTEST | CFG_CMD_MICTEST)
+*/
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ast2100.h b/include/configs/ast2100.h
new file mode 100644
index 0000000..07733b9
--- /dev/null
+++ b/include/configs/ast2100.h
@@ -0,0 +1,272 @@
+/*
+ * (C) Copyright 2004
+ * Peter Chen <peterc@socle-tech.com.tw>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+//#define CONFIG_INIT_CRITICAL			/* define for U-BOOT 1.1.1 */
+#undef  CONFIG_INIT_CRITICAL			/* undef for  U-BOOT 1.1.4 */ 
+#define CONFIG_ARM926EJS	1		/* This is an arm926ejs CPU */
+#define	CONFIG_ASPEED		1
+#define CONFIG_AST2100		1
+//#define CONFIG_AST2100_FPGA
+#undef CONFIG_AST2100_FPGA			/* undef if real chip */
+//#define CONFIG_AST2100A2_PATCH
+#undef CONFIG_AST2100A2_PATCH
+#define CONFIG_SYS_FLASH_CFI				/* CONFIG_FLASH_CFI, CONFIG_FLASH_SPI is exclusive*/
+//#define CONFIG_FLASH_SPI
+//#define CONFIG_2SPIFLASH			/* Boot SPI: CS2, 2nd SPI: CS0 */
+#undef CONFIG_DDRII1G_266
+#undef CONFIG_2SPIFLASH
+#undef CONFIG_ASPEED_SLT
+
+//#define CONFIG_USE_IRQ				/* we don't need IRQ/FIQ stuff */
+#define CONFIG_MISC_INIT_R 
+
+/* 
+ * Environment Config
+ */
+#define CONFIG_CMDLINE_TAG	 1		/* enable passing of ATAGs	*/
+#define CONFIG_SETUP_MEMORY_TAGS 1
+#define CONFIG_INITRD_TAG	 1
+#define	CONFIG_BOOTARGS 	"debug console=ttyS1,115200n8 ramdisk_size=16384 root=/dev/ram rw init=/linuxrc mem=80M"
+#define CONFIG_BOOTDELAY	3		/* autoboot after 3 seconds	*/
+#ifdef	CONFIG_SYS_FLASH_CFI 
+#define CONFIG_BOOTCOMMAND	"bootm 10080000 10300000"
+#else
+#define CONFIG_BOOTCOMMAND	"bootm 14080000 14300000"
+#endif
+#define CONFIG_BOOTFILE		"all.bin"
+#define CONFIG_ENV_OVERWRITE
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_DFL
+#define CONFIG_CMD_ENV
+#define CONFIG_CMD_FLASH
+#define CONFIG_CMD_NET
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_EEPROM
+
+/* 
+ * CPU Setting
+ */
+#define CPU_CLOCK_RATE		18000000	/* 16.5 MHz clock for the ARM core */
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 128*1024)
+#define CONFIG_SYS_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+
+/*
+ * Stack sizes,  The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128*1024)	/* regular stack */
+#define CONFIG_STACKSIZE_IRQ	(4*1024)	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
+
+/*
+ * Memory Configuration
+ */
+#define CONFIG_NR_DRAM_BANKS	1	   	/* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0x40000000 	/* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE	0x4000000 	/* 64 MB */
+
+#define CONFIG_SYS_SDRAM_BASE	0x40000000
+
+/*
+ * FLASH Configuration
+ */
+#ifdef CONFIG_SYS_FLASH_CFI				/* NOR Flash */
+
+#define PHYS_FLASH_1		0x10000000 	/* Flash Bank #1 */
+
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_1
+#define CONFIG_FLASH_BANKS_LIST 	{ PHYS_FLASH_1 }
+
+#define CONFIG_SYS_MAX_FLASH_BANKS 	1
+#define CONFIG_SYS_MAX_FLASH_SECT	(256)		/* max number of sectors on one chip */
+
+#define CONFIG_ENV_IS_IN_FLASH	1
+#define CONFIG_ENV_OFFSET		0x60000 	/* environment starts here  */
+#define CONFIG_ENV_SIZE		0x20000 	/* Total Size of Environment Sector */
+
+#define CONFIG_SYS_FLASH_CFI_AMD_RESET
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+
+#else						/* SPI Flash */
+
+#define PHYS_FLASH_1		0x14000000 	/* Flash Bank #1 */
+#define PHYS_FLASH_2		0x14800000 	/* Flash Bank #2 */
+#define PHYS_FLASH_2_BASE	0x10000000
+
+#ifdef CONFIG_2SPIFLASH
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_2_BASE
+#define CONFIG_FLASH_BANKS_LIST 	{ PHYS_FLASH_1, PHYS_FLASH_2 }
+#define CONFIG_SYS_MAX_FLASH_BANKS 	2
+#define CONFIG_SYS_MAX_FLASH_SECT	(256)		/* max number of sectors on one chip */
+
+#define CONFIG_ENV_IS_IN_FLASH		1
+#define CONFIG_ENV_OFFSET		0x7F0000 	/* environment starts here  */
+#define CONFIG_ENV_SIZE			0x010000 	/* Total Size of Environment Sector */
+#else
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_1
+#define CONFIG_FLASH_BANKS_LIST 	{ PHYS_FLASH_1 }
+#define CONFIG_SYS_MAX_FLASH_BANKS 	1
+#define CONFIG_SYS_MAX_FLASH_SECT	(256)		/* max number of sectors on one chip */
+
+#define CONFIG_ENV_IS_IN_FLASH		1
+#define CONFIG_ENV_OFFSET		0x7F0000 	/* environment starts here  */
+#define CONFIG_ENV_SIZE			0x010000 	/* Total Size of Environment Sector */
+#endif
+
+#endif
+
+#define __LITTLE_ENDIAN
+
+#define CONFIG_MONITOR_BASE		TEXT_BASE
+#define CONFIG_MONITOR_LEN		(192 << 10)
+
+/* timeout values are in ticks */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	(20*CONFIG_SYS_HZ) 	/* Timeout for Flash Erase */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	(20*CONFIG_SYS_HZ) 	/* Timeout for Flash Write */
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP				/* undef to save memory		*/
+
+#define CONFIG_SYS_PROMPT		"boot# " 	/* Monitor Command Prompt	*/
+#define CONFIG_SYS_CBSIZE		256		/* Console I/O Buffer Size	*/
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16) /* Print Buffer Size */
+#define CONFIG_SYS_MAXARGS		16		/* max number of command args	*/
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE	/* Boot Argument Buffer Size	*/
+
+#define CONFIG_SYS_MEMTEST_START	0x40000000	/* memtest works on	*/
+#define CONFIG_SYS_MEMTEST_END		0x44FFFFFF	/* 256 MB in DRAM	*/
+
+#define	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+#undef	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+#define CONFIG_SYS_LOAD_ADDR		0x43000000	/* default load address */
+
+#define CONFIG_SYS_TIMERBASE		0x1E782000	/* use timer 1 */
+#define CONFIG_SYS_HZ			(1*1000*1000)	/* use external clk (1M) */
+
+/*
+ * Serial Configuration
+ */
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	4
+#define CONFIG_SYS_NS16550_CLK		24000000
+#define CONFIG_SYS_NS16550_COM1		0x1e783000
+#define CONFIG_SYS_NS16550_COM2		0x1e784000
+#define	CONFIG_SYS_LOADS_BAUD_CHANGE
+#define CONFIG_SERIAL1			1
+#define CONFIG_CONS_INDEX		2
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/*
+ * USB device configuration
+ */
+/*
+#define CONFIG_USB_DEVICE		1
+#define CONFIG_USB_TTY			1
+
+#define CONFIG_USBD_VENDORID		0x1234
+#define CONFIG_USBD_PRODUCTID		0x5678
+#define CONFIG_USBD_MANUFACTURER	"Siemens"
+#define CONFIG_USBD_PRODUCT_NAME	"SX1"
+*/
+
+/*
+ * I2C configuration
+ */
+#define CONFIG_HARD_I2C
+#define CONFIG_SYS_I2C_SPEED		100000
+#define CONFIG_SYS_I2C_SLAVE		1
+#define CONFIG_DRIVER_ASPEED_I2C
+
+/*
+* EEPROM configuration
+*/
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN 	2
+#define CONFIG_SYS_I2C_EEPROM_ADDR 	0xa0
+
+/*
+ * NIC configuration
+ */
+#define __BYTE_ORDER __LITTLE_ENDIAN
+#define __LITTLE_ENDIAN_BITFIELD
+#define CONFIG_MAC_PARTITION
+#define CONFIG_ASPEEDNIC
+#define CONFIG_MAC1_PHY_LINK_INTERRUPT
+#define CONFIG_MAC2_ENABLE
+#define CONFIG_MAC2_MII_ENABLE
+//#define CONFIG_MAC2_PHY_LINK_INTERRUPT
+/*
+*-------------------------------------------------------------------------------
+* NOTICE: MAC1 and MAC2 now have their own seperate PHY configuration.
+* We use 2 bits for each MAC in the scratch register(D[15:11] in 0x1E6E2040) to
+* inform kernel driver.
+* The meanings of the 2 bits are:
+* 00(0): Dedicated PHY
+* 01(1): ASPEED's EVA + INTEL's NC-SI PHY chip EVA
+* 10(2): ASPEED's MAC is connected to NC-SI PHY chip directly
+* 11: Reserved
+*
+* We use CONFIG_MAC1_PHY_SETTING and CONFIG_MAC2_PHY_SETTING in U-Boot
+* 0: Dedicated PHY
+* 1: ASPEED's EVA + INTEL's NC-SI PHY chip EVA
+* 2: ASPEED's MAC is connected to NC-SI PHY chip directly
+* 3: Reserved
+*-------------------------------------------------------------------------------
+*/
+#define CONFIG_MAC1_PHY_SETTING		0
+#define CONFIG_MAC2_PHY_SETTING		0
+#define CONFIG_NET_MULTI
+#define CONFIG_ETHACT			aspeednic#0
+#define CONFIG_GATEWAYIP		192.168.0.1
+#define CONFIG_NETMASK			255.255.255.0
+#define CONFIG_IPADDR			192.168.0.188
+#define CONFIG_SERVERIP			192.168.0.106
+#define CONFIG_ETHADDR			00:C0:A8:12:34:56
+#define CONFIG_ETH1ADDR			00:C0:A8:12:34:57
+
+/*
+ * SLT
+ */
+/*
+#define CONFIG_SLT
+#define CONFIG_CMD_SLT		(CONFIG_CMD_REGTEST | CONFIG_CMD_MACTEST | CONFIG_CMD_VIDEOTEST | CONFIG_CMD_HACTEST | CONFIG_CMD_MICTEST)
+*/
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ast2300.h b/include/configs/ast2300.h
new file mode 100644
index 0000000..678e7c3
--- /dev/null
+++ b/include/configs/ast2300.h
@@ -0,0 +1,325 @@
+/*
+ * (C) Copyright 2004
+ * Peter Chen <peterc@socle-tech.com.tw>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+//#define CONFIG_INIT_CRITICAL			/* define for U-BOOT 1.1.1 */
+#undef  CONFIG_INIT_CRITICAL			/* undef for  U-BOOT 1.1.4 */ 
+#define CONFIG_ARM926EJS	1		/* This is an arm926ejs CPU */
+#define	CONFIG_ASPEED		1
+#define CONFIG_AST2300		1
+//#define CONFIG_AST1070		1
+//#define CONFIG_SYS_FLASH_CFI			/* CONFIG_FLASH_CFI, CONFIG_FLASH_SPI is exclusive*/
+#define CONFIG_FLASH_SPI
+//#define CONFIG_2SPIFLASH			/* Boot SPI: CS2, 2nd SPI: CS0 */
+#undef CONFIG_2SPIFLASH
+#undef CONFIG_ASPEED_SLT
+#define CONFIG_FLASH_AST2300
+#define CONFIG_FLASH_AST2300_DMA
+//#define CONFIG_FLASH_SPIx2_Dummy
+//#define CONFIG_FLASH_SPIx4_Dummy
+#define CONFIG_CRT_DISPLAY	1		/* undef if not support CRT */
+
+//#define CONFIG_USE_IRQ				/* we don't need IRQ/FIQ stuff */
+#define CONFIG_MISC_INIT_R 
+
+/*
+ * DRAM Config
+ *
+ * 1. DRAM Size              //
+ *    CONFIG_DRAM_512MBIT    // 512M bit
+ *    CONFIG_DRAM_1GBIT      // 1G   bit (default)
+ *    CONFIG_DRAM_2GBIT      // 2G   bit
+ *    CONFIG_DRAM_4GBIT      // 4G   bit 
+ * 2. DRAM Speed             //
+ *    CONFIG_DRAM_336        // 336MHz (DDR-667)
+ *    CONFIG_DRAM_408        // 408MHz (DDR-800) (default)
+ * 3. VGA Mode
+ *    CONFIG_CRT_DISPLAY     // define to disable VGA function
+ * 4. ECC Function enable
+ *    CONFIG_DRAM_ECC        // define to enable ECC function
+ * 5. UART Debug Message
+ *    CONFIG_DRAM_UART_OUT   // enable output message at UART5
+ *    CONFIG_DRAM_UART_38400 // set the UART baud rate to 38400, default is 115200
+ */
+ 
+//1. DRAM Size
+//#define    CONFIG_DRAM_512MBIT
+#define    CONFIG_DRAM_1GBIT
+//#define    CONFIG_DRAM_2GBIT
+//#define    CONFIG_DRAM_4GBIT
+//2. DRAM Speed
+//#define    CONFIG_DRAM_336
+#define    CONFIG_DRAM_408
+//3. VGA Mode
+//#define    CONFIG_CRT_DISPLAY
+//4. ECC Function enable
+//#define    CONFIG_DRAM_ECC
+//5. UART Debug Message
+#define    CONFIG_DRAM_UART_OUT
+//#define    CONFIG_DRAM_UART_38400
+
+
+
+/* 
+ * Environment Config
+ */
+#define CONFIG_CMDLINE_TAG	 1		/* enable passing of ATAGs	*/
+#define CONFIG_SETUP_MEMORY_TAGS 1
+#define CONFIG_INITRD_TAG	 1
+#define	CONFIG_BOOTARGS 	"debug console=ttyS0,115200n8 ramdisk_size=16384 root=/dev/ram rw init=/linuxrc mem=80M"
+#define CONFIG_UPDATE           "tftp 40800000 ast2300.scr; so 40800000'"
+
+#define CONFIG_BOOTDELAY	3		/* autoboot after 3 seconds	*/
+#ifdef CONFIG_FLASH_AST2300
+#define CONFIG_BOOTCOMMAND	"bootm 20080000 20300000"
+#else
+#ifdef	CONFIG_SYS_FLASH_CFI 
+#define CONFIG_BOOTCOMMAND	"bootm 10080000 10300000"
+#else
+#define CONFIG_BOOTCOMMAND	"bootm 14080000 14300000"
+#endif
+#endif
+#define CONFIG_BOOTFILE		"all.bin"
+#define CONFIG_ENV_OVERWRITE
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_DFL
+#define CONFIG_CMD_ENV
+#define CONFIG_CMD_FLASH
+#define CONFIG_CMD_NET
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_EEPROM
+
+/* 
+ * CPU Setting
+ */
+#define CPU_CLOCK_RATE		18000000	/* 16.5 MHz clock for the ARM core */
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 768*1024)
+#define CONFIG_SYS_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+
+/*
+ * Stack sizes,  The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128*1024)	/* regular stack */
+#define CONFIG_STACKSIZE_IRQ	(4*1024)	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
+
+/*
+ * Memory Configuration
+ */
+#define CONFIG_NR_DRAM_BANKS	1	   	/* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0x40000000 	/* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE	0x4000000 	/* 64 MB */
+
+#define CONFIG_SYS_SDRAM_BASE	0x40000000
+
+/*
+ * FLASH Configuration
+ */
+#ifdef CONFIG_SYS_FLASH_CFI				/* NOR Flash */
+
+#ifdef CONFIG_FLASH_AST2300
+#define PHYS_FLASH_1			0x20000000 	/* Flash Bank #1 */
+#else
+#define PHYS_FLASH_1			0x10000000 	/* Flash Bank #1 */
+#endif
+
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_1
+#define CONFIG_FLASH_BANKS_LIST 	{ PHYS_FLASH_1 }
+
+#define CONFIG_SYS_MAX_FLASH_BANKS 	1
+#define CONFIG_SYS_MAX_FLASH_SECT	(256)		/* max number of sectors on one chip */
+
+#define CONFIG_ENV_IS_IN_FLASH	1
+#define CONFIG_ENV_OFFSET			0x60000 	/* environment starts here  */
+#define CONFIG_ENV_SIZE			0x20000 	/* Total Size of Environment Sector */
+
+#define CONFIG_SYS_FLASH_CFI_AMD_RESET
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+
+#else						/* SPI Flash */
+
+#ifdef CONFIG_FLASH_AST2300
+#define PHYS_FLASH_1		0x20000000 	/* Flash Bank #1 */
+#else
+#define PHYS_FLASH_1		0x14000000 	/* Flash Bank #1 */
+#define PHYS_FLASH_2		0x14800000 	/* Flash Bank #2 */
+#define PHYS_FLASH_2_BASE	0x10000000
+#endif
+
+#ifdef CONFIG_2SPIFLASH
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_2_BASE
+#define CONFIG_FLASH_BANKS_LIST 	{ PHYS_FLASH_1, PHYS_FLASH_2 }
+#define CONFIG_SYS_MAX_FLASH_BANKS 	2
+#define CONFIG_SYS_MAX_FLASH_SECT	(1024)		/* max number of sectors on one chip */
+
+#define CONFIG_ENV_IS_IN_FLASH		1
+#define CONFIG_ENV_OFFSET		0x7F0000 	/* environment starts here  */
+#define CONFIG_ENV_SIZE			0x010000 	/* Total Size of Environment Sector */
+#else
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_1
+#define CONFIG_FLASH_BANKS_LIST 	{ PHYS_FLASH_1 }
+#define CONFIG_SYS_MAX_FLASH_BANKS 	1
+#define CONFIG_SYS_MAX_FLASH_SECT	(1024)		/* max number of sectors on one chip */
+
+#define CONFIG_ENV_IS_IN_FLASH		1
+#define CONFIG_ENV_OFFSET		0x7F0000 	/* environment starts here  */
+#define CONFIG_ENV_SIZE			0x010000 	/* Total Size of Environment Sector */
+#endif
+
+#endif
+
+#define __LITTLE_ENDIAN
+
+#define CONFIG_MONITOR_BASE		TEXT_BASE
+#define CONFIG_MONITOR_LEN		(192 << 10)
+
+/* timeout values are in ticks */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	(20*CONFIG_SYS_HZ) 	/* Timeout for Flash Erase */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	(20*CONFIG_SYS_HZ) 	/* Timeout for Flash Write */
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP				/* undef to save memory		*/
+
+#define CONFIG_SYS_PROMPT		"boot# " 	/* Monitor Command Prompt	*/
+#define CONFIG_SYS_CBSIZE		256		/* Console I/O Buffer Size	*/
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16) /* Print Buffer Size */
+#define CONFIG_SYS_MAXARGS		16		/* max number of command args	*/
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE	/* Boot Argument Buffer Size	*/
+
+#define CONFIG_SYS_MEMTEST_START	0x40000000	/* memtest works on	*/
+#define CONFIG_SYS_MEMTEST_END		0x44FFFFFF	/* 256 MB in DRAM	*/
+
+#define	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+#undef	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+#define CONFIG_SYS_LOAD_ADDR		0x43000000	/* default load address */
+
+#define CONFIG_SYS_TIMERBASE		0x1E782000	/* use timer 1 */
+#define CONFIG_SYS_HZ			(1*1000*1000)	/* use external clk (1M) */
+
+/*
+ * Serial Configuration
+ */
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	4
+#define CONFIG_SYS_NS16550_CLK		24000000
+#define CONFIG_SYS_NS16550_COM1		0x1e783000
+#define CONFIG_SYS_NS16550_COM2		0x1e784000
+#define	CONFIG_SYS_LOADS_BAUD_CHANGE
+#define CONFIG_SERIAL1			1
+#define CONFIG_CONS_INDEX		2
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/*
+ * USB device configuration
+ */
+/*
+#define CONFIG_USB_DEVICE		1
+#define CONFIG_USB_TTY			1
+
+#define CONFIG_USBD_VENDORID		0x1234
+#define CONFIG_USBD_PRODUCTID		0x5678
+#define CONFIG_USBD_MANUFACTURER	"Siemens"
+#define CONFIG_USBD_PRODUCT_NAME	"SX1"
+*/
+
+/*
+ * I2C configuration
+ */
+#define CONFIG_HARD_I2C
+#define CONFIG_SYS_I2C_SPEED		100000
+#define CONFIG_SYS_I2C_SLAVE		1
+#define CONFIG_DRIVER_ASPEED_I2C
+
+/*
+* EEPROM configuration
+*/
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN 	2
+#define CONFIG_SYS_I2C_EEPROM_ADDR 	0xa0
+
+/*
+ * NIC configuration
+ */
+#define __BYTE_ORDER __LITTLE_ENDIAN
+#define __LITTLE_ENDIAN_BITFIELD
+#define CONFIG_MAC_PARTITION
+#define CONFIG_ASPEEDNIC
+//#define CONFIG_MAC1_PHY_LINK_INTERRUPT
+#define CONFIG_MAC2_ENABLE
+#define CONFIG_MAC2_PHY_LINK_INTERRUPT
+/*
+*-------------------------------------------------------------------------------
+* NOTICE: MAC1 and MAC2 now have their own seperate PHY configuration.
+* We use 2 bits for each MAC in the scratch register(D[15:11] in 0x1E6E2040) to
+* inform kernel driver.
+* The meanings of the 2 bits are:
+* 00(0): Dedicated PHY
+* 01(1): ASPEED's EVA + INTEL's NC-SI PHY chip EVA
+* 10(2): ASPEED's MAC is connected to NC-SI PHY chip directly
+* 11: Reserved
+*
+* We use CONFIG_MAC1_PHY_SETTING and CONFIG_MAC2_PHY_SETTING in U-Boot
+* 0: Dedicated PHY
+* 1: ASPEED's EVA + INTEL's NC-SI PHY chip EVA
+* 2: ASPEED's MAC is connected to NC-SI PHY chip directly
+* 3: Reserved
+*-------------------------------------------------------------------------------
+*/
+#define CONFIG_MAC1_PHY_SETTING		2
+#define CONFIG_MAC2_PHY_SETTING		0
+#define CONFIG_MAC_INTERFACE_CLOCK_DELAY	0x2255
+#define CONFIG_NET_MULTI
+#define CONFIG_ETHACT			aspeednic#0
+#define CONFIG_GATEWAYIP		192.168.0.1
+#define CONFIG_NETMASK			255.255.255.0
+#define CONFIG_IPADDR			192.168.0.45
+#define CONFIG_SERVERIP			192.168.0.81
+#define CONFIG_ETHADDR			00:C0:A8:12:34:56
+#define CONFIG_ETH1ADDR			00:C0:A8:12:34:57
+
+/*
+ * SLT
+ */
+/*
+#define CONFIG_SLT
+#define CFG_CMD_SLT		(CFG_CMD_VIDEOTEST | CFG_CMD_MACTEST | CFG_CMD_HACTEST | CFG_CMD_MICTEST)
+*/
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ast2300_ast1070.h b/include/configs/ast2300_ast1070.h
new file mode 100644
index 0000000..a7abdf5
--- /dev/null
+++ b/include/configs/ast2300_ast1070.h
@@ -0,0 +1,323 @@
+/*
+ * (C) Copyright 2004
+ * Peter Chen <peterc@socle-tech.com.tw>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+//#define CONFIG_INIT_CRITICAL			/* define for U-BOOT 1.1.1 */
+#undef  CONFIG_INIT_CRITICAL			/* undef for  U-BOOT 1.1.4 */ 
+#define CONFIG_ARM926EJS	1		/* This is an arm926ejs CPU */
+#define	CONFIG_ASPEED		1
+#define CONFIG_AST2300		1
+#define CONFIG_AST1070		1
+//#define CONFIG_SYS_FLASH_CFI			/* CONFIG_FLASH_CFI, CONFIG_FLASH_SPI is exclusive*/
+#define CONFIG_FLASH_SPI
+//#define CONFIG_2SPIFLASH			/* Boot SPI: CS2, 2nd SPI: CS0 */
+#undef CONFIG_2SPIFLASH
+#undef CONFIG_ASPEED_SLT
+#define CONFIG_FLASH_AST2300
+#define CONFIG_FLASH_AST2300_DMA
+//#define CONFIG_FLASH_SPIx2_Dummy
+//#define CONFIG_FLASH_SPIx4_Dummy
+#define CONFIG_CRT_DISPLAY	1		/* undef if not support CRT */
+
+//#define CONFIG_USE_IRQ				/* we don't need IRQ/FIQ stuff */
+#define CONFIG_MISC_INIT_R 
+
+/*
+ * DRAM Config
+ *
+ * 1. DRAM Size              //
+ *    CONFIG_DRAM_512MBIT    // 512M bit
+ *    CONFIG_DRAM_1GBIT      // 1G   bit (default)
+ *    CONFIG_DRAM_2GBIT      // 2G   bit
+ *    CONFIG_DRAM_4GBIT      // 4G   bit 
+ * 2. DRAM Speed             //
+ *    CONFIG_DRAM_336        // 336MHz (DDR-667)
+ *    CONFIG_DRAM_408        // 408MHz (DDR-800) (default)
+ * 3. VGA Mode
+ *    CONFIG_CRT_DISPLAY     // define to disable VGA function
+ * 4. ECC Function enable
+ *    CONFIG_DRAM_ECC        // define to enable ECC function
+ * 5. UART Debug Message
+ *    CONFIG_DRAM_UART_OUT   // enable output message at UART5
+ *    CONFIG_DRAM_UART_38400 // set the UART baud rate to 38400, default is 115200
+ */
+ 
+//1. DRAM Size
+//#define    CONFIG_DRAM_512MBIT
+#define    CONFIG_DRAM_1GBIT
+//#define    CONFIG_DRAM_2GBIT
+//#define    CONFIG_DRAM_4GBIT
+//2. DRAM Speed
+//#define    CONFIG_DRAM_336
+#define    CONFIG_DRAM_408
+//3. VGA Mode
+//#define    CONFIG_CRT_DISPLAY
+//4. ECC Function enable
+//#define    CONFIG_DRAM_ECC
+//5. UART Debug Message
+#define    CONFIG_DRAM_UART_OUT
+//#define    CONFIG_DRAM_UART_38400
+
+
+
+/* 
+ * Environment Config
+ */
+#define CONFIG_CMDLINE_TAG	 1		/* enable passing of ATAGs	*/
+#define CONFIG_SETUP_MEMORY_TAGS 1
+#define CONFIG_INITRD_TAG	 1
+#define	CONFIG_BOOTARGS 	"debug console=ttyS0,115200n8 ramdisk_size=16384 root=/dev/ram rw init=/linuxrc mem=80M"
+#define CONFIG_BOOTDELAY	3		/* autoboot after 3 seconds	*/
+#ifdef CONFIG_FLASH_AST2300
+#define CONFIG_BOOTCOMMAND	"bootm 20080000 20300000"
+#else
+#ifdef	CONFIG_SYS_FLASH_CFI 
+#define CONFIG_BOOTCOMMAND	"bootm 10080000 10300000"
+#else
+#define CONFIG_BOOTCOMMAND	"bootm 14080000 14300000"
+#endif
+#endif
+#define CONFIG_BOOTFILE		"all.bin"
+#define CONFIG_ENV_OVERWRITE
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_DFL
+#define CONFIG_CMD_ENV
+#define CONFIG_CMD_FLASH
+#define CONFIG_CMD_NET
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_EEPROM
+
+/* 
+ * CPU Setting
+ */
+#define CPU_CLOCK_RATE		18000000	/* 16.5 MHz clock for the ARM core */
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 768*1024)
+#define CONFIG_SYS_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+
+/*
+ * Stack sizes,  The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128*1024)	/* regular stack */
+#define CONFIG_STACKSIZE_IRQ	(4*1024)	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
+
+/*
+ * Memory Configuration
+ */
+#define CONFIG_NR_DRAM_BANKS	1	   	/* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0x40000000 	/* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE	0x4000000 	/* 64 MB */
+
+#define CONFIG_SYS_SDRAM_BASE	0x40000000
+
+/*
+ * FLASH Configuration
+ */
+#ifdef CONFIG_SYS_FLASH_CFI				/* NOR Flash */
+
+#ifdef CONFIG_FLASH_AST2300
+#define PHYS_FLASH_1			0x20000000 	/* Flash Bank #1 */
+#else
+#define PHYS_FLASH_1			0x10000000 	/* Flash Bank #1 */
+#endif
+
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_1
+#define CONFIG_FLASH_BANKS_LIST 	{ PHYS_FLASH_1 }
+
+#define CONFIG_SYS_MAX_FLASH_BANKS 	1
+#define CONFIG_SYS_MAX_FLASH_SECT	(256)		/* max number of sectors on one chip */
+
+#define CONFIG_ENV_IS_IN_FLASH	1
+#define CONFIG_ENV_OFFSET			0x60000 	/* environment starts here  */
+#define CONFIG_ENV_SIZE			0x20000 	/* Total Size of Environment Sector */
+
+#define CONFIG_SYS_FLASH_CFI_AMD_RESET
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+
+#else						/* SPI Flash */
+
+#ifdef CONFIG_FLASH_AST2300
+#define PHYS_FLASH_1		0x20000000 	/* Flash Bank #1 */
+#else
+#define PHYS_FLASH_1		0x14000000 	/* Flash Bank #1 */
+#define PHYS_FLASH_2		0x14800000 	/* Flash Bank #2 */
+#define PHYS_FLASH_2_BASE	0x10000000
+#endif
+
+#ifdef CONFIG_2SPIFLASH
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_2_BASE
+#define CONFIG_FLASH_BANKS_LIST 	{ PHYS_FLASH_1, PHYS_FLASH_2 }
+#define CONFIG_SYS_MAX_FLASH_BANKS 	2
+#define CONFIG_SYS_MAX_FLASH_SECT	(1024)		/* max number of sectors on one chip */
+
+#define CONFIG_ENV_IS_IN_FLASH		1
+#define CONFIG_ENV_OFFSET		0x7F0000 	/* environment starts here  */
+#define CONFIG_ENV_SIZE			0x010000 	/* Total Size of Environment Sector */
+#else
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_1
+#define CONFIG_FLASH_BANKS_LIST 	{ PHYS_FLASH_1 }
+#define CONFIG_SYS_MAX_FLASH_BANKS 	1
+#define CONFIG_SYS_MAX_FLASH_SECT	(1024)		/* max number of sectors on one chip */
+
+#define CONFIG_ENV_IS_IN_FLASH		1
+#define CONFIG_ENV_OFFSET		0x7F0000 	/* environment starts here  */
+#define CONFIG_ENV_SIZE			0x010000 	/* Total Size of Environment Sector */
+#endif
+
+#endif
+
+#define __LITTLE_ENDIAN
+
+#define CONFIG_MONITOR_BASE		TEXT_BASE
+#define CONFIG_MONITOR_LEN		(192 << 10)
+
+/* timeout values are in ticks */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	(20*CONFIG_SYS_HZ) 	/* Timeout for Flash Erase */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	(20*CONFIG_SYS_HZ) 	/* Timeout for Flash Write */
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP				/* undef to save memory		*/
+
+#define CONFIG_SYS_PROMPT		"boot# " 	/* Monitor Command Prompt	*/
+#define CONFIG_SYS_CBSIZE		256		/* Console I/O Buffer Size	*/
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16) /* Print Buffer Size */
+#define CONFIG_SYS_MAXARGS		16		/* max number of command args	*/
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE	/* Boot Argument Buffer Size	*/
+
+#define CONFIG_SYS_MEMTEST_START	0x40000000	/* memtest works on	*/
+#define CONFIG_SYS_MEMTEST_END		0x44FFFFFF	/* 256 MB in DRAM	*/
+
+#define	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+#undef	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+#define CONFIG_SYS_LOAD_ADDR		0x43000000	/* default load address */
+
+#define CONFIG_SYS_TIMERBASE		0x1E782000	/* use timer 1 */
+#define CONFIG_SYS_HZ			(1*1000*1000)	/* use external clk (1M) */
+
+/*
+ * Serial Configuration
+ */
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	4
+#define CONFIG_SYS_NS16550_CLK		24000000
+#define CONFIG_SYS_NS16550_COM1		0x1e783000
+#define CONFIG_SYS_NS16550_COM2		0x1e784000
+#define	CONFIG_SYS_LOADS_BAUD_CHANGE
+#define CONFIG_SERIAL1			1
+#define CONFIG_CONS_INDEX		2
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/*
+ * USB device configuration
+ */
+/*
+#define CONFIG_USB_DEVICE		1
+#define CONFIG_USB_TTY			1
+
+#define CONFIG_USBD_VENDORID		0x1234
+#define CONFIG_USBD_PRODUCTID		0x5678
+#define CONFIG_USBD_MANUFACTURER	"Siemens"
+#define CONFIG_USBD_PRODUCT_NAME	"SX1"
+*/
+
+/*
+ * I2C configuration
+ */
+#define CONFIG_HARD_I2C
+#define CONFIG_SYS_I2C_SPEED		100000
+#define CONFIG_SYS_I2C_SLAVE		1
+#define CONFIG_DRIVER_ASPEED_I2C
+
+/*
+* EEPROM configuration
+*/
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN 	2
+#define CONFIG_SYS_I2C_EEPROM_ADDR 	0xa0
+
+/*
+ * NIC configuration
+ */
+#define __BYTE_ORDER __LITTLE_ENDIAN
+#define __LITTLE_ENDIAN_BITFIELD
+#define CONFIG_MAC_PARTITION
+#define CONFIG_ASPEEDNIC
+//#define CONFIG_MAC1_PHY_LINK_INTERRUPT
+#define CONFIG_MAC2_ENABLE
+#define CONFIG_MAC2_PHY_LINK_INTERRUPT
+/*
+*-------------------------------------------------------------------------------
+* NOTICE: MAC1 and MAC2 now have their own seperate PHY configuration.
+* We use 2 bits for each MAC in the scratch register(D[15:11] in 0x1E6E2040) to
+* inform kernel driver.
+* The meanings of the 2 bits are:
+* 00(0): Dedicated PHY
+* 01(1): ASPEED's EVA + INTEL's NC-SI PHY chip EVA
+* 10(2): ASPEED's MAC is connected to NC-SI PHY chip directly
+* 11: Reserved
+*
+* We use CONFIG_MAC1_PHY_SETTING and CONFIG_MAC2_PHY_SETTING in U-Boot
+* 0: Dedicated PHY
+* 1: ASPEED's EVA + INTEL's NC-SI PHY chip EVA
+* 2: ASPEED's MAC is connected to NC-SI PHY chip directly
+* 3: Reserved
+*-------------------------------------------------------------------------------
+*/
+#define CONFIG_MAC1_PHY_SETTING		0
+#define CONFIG_MAC2_PHY_SETTING		0
+#define CONFIG_MAC_INTERFACE_CLOCK_DELAY	0x2255
+#define CONFIG_NET_MULTI
+#define CONFIG_ETHACT			aspeednic#0
+#define CONFIG_GATEWAYIP		192.168.0.1
+#define CONFIG_NETMASK			255.255.255.0
+#define CONFIG_IPADDR			192.168.0.45
+#define CONFIG_SERVERIP			192.168.0.81
+#define CONFIG_ETHADDR			00:C0:A8:12:34:56
+#define CONFIG_ETH1ADDR			00:C0:A8:12:34:57
+
+/*
+ * SLT
+ */
+/*
+#define CONFIG_SLT
+#define CFG_CMD_SLT		(CFG_CMD_VIDEOTEST | CFG_CMD_MACTEST | CFG_CMD_HACTEST | CFG_CMD_MICTEST)
+*/
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ast2300_nor.h b/include/configs/ast2300_nor.h
new file mode 100644
index 0000000..77b8fe3
--- /dev/null
+++ b/include/configs/ast2300_nor.h
@@ -0,0 +1,322 @@
+/*
+ * (C) Copyright 2004
+ * Peter Chen <peterc@socle-tech.com.tw>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+//#define CONFIG_INIT_CRITICAL			/* define for U-BOOT 1.1.1 */
+#undef  CONFIG_INIT_CRITICAL			/* undef for  U-BOOT 1.1.4 */ 
+#define CONFIG_ARM926EJS	1		/* This is an arm926ejs CPU */
+#define	CONFIG_ASPEED		1
+#define CONFIG_AST2300		1
+#define CONFIG_SYS_FLASH_CFI			/* CONFIG_FLASH_CFI, CONFIG_FLASH_SPI is exclusive*/
+//#define CONFIG_FLASH_SPI
+//#define CONFIG_2SPIFLASH			/* Boot SPI: CS2, 2nd SPI: CS0 */
+#undef CONFIG_2SPIFLASH
+#undef CONFIG_ASPEED_SLT
+#define CONFIG_FLASH_AST2300
+#define CONFIG_FLASH_AST2300_DMA
+//#define CONFIG_FLASH_SPIx2_Dummy
+//#define CONFIG_FLASH_SPIx4_Dummy
+#define CONFIG_CRT_DISPLAY	1		/* undef if not support CRT */
+
+//#define CONFIG_USE_IRQ				/* we don't need IRQ/FIQ stuff */
+#define CONFIG_MISC_INIT_R 
+
+/*
+ * DRAM Config
+ *
+ * 1. DRAM Size              //
+ *    CONFIG_DRAM_512MBIT    // 512M bit
+ *    CONFIG_DRAM_1GBIT      // 1G   bit (default)
+ *    CONFIG_DRAM_2GBIT      // 2G   bit
+ *    CONFIG_DRAM_4GBIT      // 4G   bit 
+ * 2. DRAM Speed             //
+ *    CONFIG_DRAM_336        // 336MHz (DDR-667)
+ *    CONFIG_DRAM_408        // 408MHz (DDR-800) (default)
+ * 3. VGA Mode
+ *    CONFIG_CRT_DISPLAY     // define to disable VGA function
+ * 4. ECC Function enable
+ *    CONFIG_DRAM_ECC        // define to enable ECC function
+ * 5. UART Debug Message
+ *    CONFIG_DRAM_UART_OUT   // enable output message at UART5
+ *    CONFIG_DRAM_UART_38400 // set the UART baud rate to 38400, default is 115200
+ */
+ 
+//1. DRAM Size
+//#define    CONFIG_DRAM_512MBIT
+#define    CONFIG_DRAM_1GBIT
+//#define    CONFIG_DRAM_2GBIT
+//#define    CONFIG_DRAM_4GBIT
+//2. DRAM Speed
+//#define    CONFIG_DRAM_336
+#define    CONFIG_DRAM_408
+//3. VGA Mode
+//#define    CONFIG_CRT_DISPLAY
+//4. ECC Function enable
+//#define    CONFIG_DRAM_ECC
+//5. UART Debug Message
+#define    CONFIG_DRAM_UART_OUT
+//#define    CONFIG_DRAM_UART_38400
+
+
+
+/* 
+ * Environment Config
+ */
+#define CONFIG_CMDLINE_TAG	 1		/* enable passing of ATAGs	*/
+#define CONFIG_SETUP_MEMORY_TAGS 1
+#define CONFIG_INITRD_TAG	 1
+#define	CONFIG_BOOTARGS 	"debug console=ttyS0,115200n8 ramdisk_size=16384 root=/dev/ram rw init=/linuxrc mem=80M"
+#define CONFIG_BOOTDELAY	3		/* autoboot after 3 seconds	*/
+#ifdef CONFIG_FLASH_AST2300
+#define CONFIG_BOOTCOMMAND	"bootm 20080000 20300000"
+#else
+#ifdef	CONFIG_SYS_FLASH_CFI 
+#define CONFIG_BOOTCOMMAND	"bootm 10080000 10300000"
+#else
+#define CONFIG_BOOTCOMMAND	"bootm 14080000 14300000"
+#endif
+#endif
+#define CONFIG_BOOTFILE		"all.bin"
+#define CONFIG_ENV_OVERWRITE
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_DFL
+#define CONFIG_CMD_ENV
+#define CONFIG_CMD_FLASH
+#define CONFIG_CMD_NET
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_EEPROM
+
+/* 
+ * CPU Setting
+ */
+#define CPU_CLOCK_RATE		18000000	/* 16.5 MHz clock for the ARM core */
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 768*1024)
+#define CONFIG_SYS_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+
+/*
+ * Stack sizes,  The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128*1024)	/* regular stack */
+#define CONFIG_STACKSIZE_IRQ	(4*1024)	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
+
+/*
+ * Memory Configuration
+ */
+#define CONFIG_NR_DRAM_BANKS	1	   	/* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0x40000000 	/* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE	0x4000000 	/* 64 MB */
+
+#define CONFIG_SYS_SDRAM_BASE	0x40000000
+
+/*
+ * FLASH Configuration
+ */
+#ifdef CONFIG_SYS_FLASH_CFI				/* NOR Flash */
+
+#ifdef CONFIG_FLASH_AST2300
+#define PHYS_FLASH_1			0x20000000 	/* Flash Bank #1 */
+#else
+#define PHYS_FLASH_1			0x10000000 	/* Flash Bank #1 */
+#endif
+
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_1
+#define CONFIG_FLASH_BANKS_LIST 	{ PHYS_FLASH_1 }
+
+#define CONFIG_SYS_MAX_FLASH_BANKS 	1
+#define CONFIG_SYS_MAX_FLASH_SECT	(256)		/* max number of sectors on one chip */
+
+#define CONFIG_ENV_IS_IN_FLASH	1
+#define CONFIG_ENV_OFFSET			0x60000 	/* environment starts here  */
+#define CONFIG_ENV_SIZE			0x20000 	/* Total Size of Environment Sector */
+
+#define CONFIG_SYS_FLASH_CFI_AMD_RESET
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+
+#else						/* SPI Flash */
+
+#ifdef CONFIG_FLASH_AST2300
+#define PHYS_FLASH_1		0x20000000 	/* Flash Bank #1 */
+#else
+#define PHYS_FLASH_1		0x14000000 	/* Flash Bank #1 */
+#define PHYS_FLASH_2		0x14800000 	/* Flash Bank #2 */
+#define PHYS_FLASH_2_BASE	0x10000000
+#endif
+
+#ifdef CONFIG_2SPIFLASH
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_2_BASE
+#define CONFIG_FLASH_BANKS_LIST 	{ PHYS_FLASH_1, PHYS_FLASH_2 }
+#define CONFIG_SYS_MAX_FLASH_BANKS 	2
+#define CONFIG_SYS_MAX_FLASH_SECT	(1024)		/* max number of sectors on one chip */
+
+#define CONFIG_ENV_IS_IN_FLASH		1
+#define CONFIG_ENV_OFFSET		0x7F0000 	/* environment starts here  */
+#define CONFIG_ENV_SIZE			0x010000 	/* Total Size of Environment Sector */
+#else
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_1
+#define CONFIG_FLASH_BANKS_LIST 	{ PHYS_FLASH_1 }
+#define CONFIG_SYS_MAX_FLASH_BANKS 	1
+#define CONFIG_SYS_MAX_FLASH_SECT	(1024)		/* max number of sectors on one chip */
+
+#define CONFIG_ENV_IS_IN_FLASH		1
+#define CONFIG_ENV_OFFSET		0x7F0000 	/* environment starts here  */
+#define CONFIG_ENV_SIZE			0x010000 	/* Total Size of Environment Sector */
+#endif
+
+#endif
+
+#define __LITTLE_ENDIAN
+
+#define CONFIG_MONITOR_BASE		TEXT_BASE
+#define CONFIG_MONITOR_LEN		(192 << 10)
+
+/* timeout values are in ticks */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	(20*CONFIG_SYS_HZ) 	/* Timeout for Flash Erase */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	(20*CONFIG_SYS_HZ) 	/* Timeout for Flash Write */
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP				/* undef to save memory		*/
+
+#define CONFIG_SYS_PROMPT		"boot# " 	/* Monitor Command Prompt	*/
+#define CONFIG_SYS_CBSIZE		256		/* Console I/O Buffer Size	*/
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16) /* Print Buffer Size */
+#define CONFIG_SYS_MAXARGS		16		/* max number of command args	*/
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE	/* Boot Argument Buffer Size	*/
+
+#define CONFIG_SYS_MEMTEST_START	0x40000000	/* memtest works on	*/
+#define CONFIG_SYS_MEMTEST_END		0x44FFFFFF	/* 256 MB in DRAM	*/
+
+#define	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+#undef	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+#define CONFIG_SYS_LOAD_ADDR		0x43000000	/* default load address */
+
+#define CONFIG_SYS_TIMERBASE		0x1E782000	/* use timer 1 */
+#define CONFIG_SYS_HZ			(1*1000*1000)	/* use external clk (1M) */
+
+/*
+ * Serial Configuration
+ */
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	4
+#define CONFIG_SYS_NS16550_CLK		24000000
+#define CONFIG_SYS_NS16550_COM1		0x1e783000
+#define CONFIG_SYS_NS16550_COM2		0x1e784000
+#define	CONFIG_SYS_LOADS_BAUD_CHANGE
+#define CONFIG_SERIAL1			1
+#define CONFIG_CONS_INDEX		2
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/*
+ * USB device configuration
+ */
+/*
+#define CONFIG_USB_DEVICE		1
+#define CONFIG_USB_TTY			1
+
+#define CONFIG_USBD_VENDORID		0x1234
+#define CONFIG_USBD_PRODUCTID		0x5678
+#define CONFIG_USBD_MANUFACTURER	"Siemens"
+#define CONFIG_USBD_PRODUCT_NAME	"SX1"
+*/
+
+/*
+ * I2C configuration
+ */
+#define CONFIG_HARD_I2C
+#define CONFIG_SYS_I2C_SPEED		100000
+#define CONFIG_SYS_I2C_SLAVE		1
+#define CONFIG_DRIVER_ASPEED_I2C
+
+/*
+* EEPROM configuration
+*/
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN 	2
+#define CONFIG_SYS_I2C_EEPROM_ADDR 	0xa0
+
+/*
+ * NIC configuration
+ */
+#define __BYTE_ORDER __LITTLE_ENDIAN
+#define __LITTLE_ENDIAN_BITFIELD
+#define CONFIG_MAC_PARTITION
+#define CONFIG_ASPEEDNIC
+//#define CONFIG_MAC1_PHY_LINK_INTERRUPT
+#define CONFIG_MAC2_ENABLE
+#define CONFIG_MAC2_PHY_LINK_INTERRUPT
+/*
+*-------------------------------------------------------------------------------
+* NOTICE: MAC1 and MAC2 now have their own seperate PHY configuration.
+* We use 2 bits for each MAC in the scratch register(D[15:11] in 0x1E6E2040) to
+* inform kernel driver.
+* The meanings of the 2 bits are:
+* 00(0): Dedicated PHY
+* 01(1): ASPEED's EVA + INTEL's NC-SI PHY chip EVA
+* 10(2): ASPEED's MAC is connected to NC-SI PHY chip directly
+* 11: Reserved
+*
+* We use CONFIG_MAC1_PHY_SETTING and CONFIG_MAC2_PHY_SETTING in U-Boot
+* 0: Dedicated PHY
+* 1: ASPEED's EVA + INTEL's NC-SI PHY chip EVA
+* 2: ASPEED's MAC is connected to NC-SI PHY chip directly
+* 3: Reserved
+*-------------------------------------------------------------------------------
+*/
+#define CONFIG_MAC1_PHY_SETTING		0
+#define CONFIG_MAC2_PHY_SETTING		0
+#define CONFIG_MAC_INTERFACE_CLOCK_DELAY	0x2255
+#define CONFIG_NET_MULTI
+#define CONFIG_ETHACT			aspeednic#0
+#define CONFIG_GATEWAYIP		192.168.0.1
+#define CONFIG_NETMASK			255.255.255.0
+#define CONFIG_IPADDR			192.168.0.188
+#define CONFIG_SERVERIP			192.168.0.106
+#define CONFIG_ETHADDR			00:C0:A8:12:34:56
+#define CONFIG_ETH1ADDR			00:C0:A8:12:34:57
+
+/*
+ * SLT
+ */
+/*
+#define CONFIG_SLT
+#define CFG_CMD_SLT		(CFG_CMD_VIDEOTEST | CFG_CMD_MACTEST | CFG_CMD_HACTEST | CFG_CMD_MICTEST)
+*/
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ast2300_spi.h b/include/configs/ast2300_spi.h
new file mode 100644
index 0000000..bc65530
--- /dev/null
+++ b/include/configs/ast2300_spi.h
@@ -0,0 +1,322 @@
+/*
+ * (C) Copyright 2004
+ * Peter Chen <peterc@socle-tech.com.tw>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+//#define CONFIG_INIT_CRITICAL			/* define for U-BOOT 1.1.1 */
+#undef  CONFIG_INIT_CRITICAL			/* undef for  U-BOOT 1.1.4 */ 
+#define CONFIG_ARM926EJS	1		/* This is an arm926ejs CPU */
+#define	CONFIG_ASPEED		1
+#define CONFIG_AST2300		1
+//#define CONFIG_SYS_FLASH_CFI			/* CONFIG_FLASH_CFI, CONFIG_FLASH_SPI is exclusive*/
+#define CONFIG_FLASH_SPI
+//#define CONFIG_2SPIFLASH			/* Boot SPI: CS2, 2nd SPI: CS0 */
+#undef CONFIG_2SPIFLASH
+#undef CONFIG_ASPEED_SLT
+#define CONFIG_FLASH_AST2300
+#define CONFIG_FLASH_AST2300_DMA
+//#define CONFIG_FLASH_SPIx2_Dummy
+//#define CONFIG_FLASH_SPIx4_Dummy
+#define CONFIG_CRT_DISPLAY	1		/* undef if not support CRT */
+
+//#define CONFIG_USE_IRQ				/* we don't need IRQ/FIQ stuff */
+#define CONFIG_MISC_INIT_R 
+
+/*
+ * DRAM Config
+ *
+ * 1. DRAM Size              //
+ *    CONFIG_DRAM_512MBIT    // 512M bit
+ *    CONFIG_DRAM_1GBIT      // 1G   bit (default)
+ *    CONFIG_DRAM_2GBIT      // 2G   bit
+ *    CONFIG_DRAM_4GBIT      // 4G   bit 
+ * 2. DRAM Speed             //
+ *    CONFIG_DRAM_336        // 336MHz (DDR-667)
+ *    CONFIG_DRAM_408        // 408MHz (DDR-800) (default)
+ * 3. VGA Mode
+ *    CONFIG_CRT_DISPLAY     // define to disable VGA function
+ * 4. ECC Function enable
+ *    CONFIG_DRAM_ECC        // define to enable ECC function
+ * 5. UART Debug Message
+ *    CONFIG_DRAM_UART_OUT   // enable output message at UART5
+ *    CONFIG_DRAM_UART_38400 // set the UART baud rate to 38400, default is 115200
+ */
+ 
+//1. DRAM Size
+//#define    CONFIG_DRAM_512MBIT
+#define    CONFIG_DRAM_1GBIT
+//#define    CONFIG_DRAM_2GBIT
+//#define    CONFIG_DRAM_4GBIT
+//2. DRAM Speed
+//#define    CONFIG_DRAM_336
+#define    CONFIG_DRAM_408
+//3. VGA Mode
+//#define    CONFIG_CRT_DISPLAY
+//4. ECC Function enable
+//#define    CONFIG_DRAM_ECC
+//5. UART Debug Message
+#define    CONFIG_DRAM_UART_OUT
+//#define    CONFIG_DRAM_UART_38400
+
+
+
+/* 
+ * Environment Config
+ */
+#define CONFIG_CMDLINE_TAG	 1		/* enable passing of ATAGs	*/
+#define CONFIG_SETUP_MEMORY_TAGS 1
+#define CONFIG_INITRD_TAG	 1
+#define	CONFIG_BOOTARGS 	"debug console=ttyS0,115200n8 ramdisk_size=16384 root=/dev/ram rw init=/linuxrc mem=80M"
+#define CONFIG_BOOTDELAY	3		/* autoboot after 3 seconds	*/
+#ifdef CONFIG_FLASH_AST2300
+#define CONFIG_BOOTCOMMAND	"bootm 20080000 20300000"
+#else
+#ifdef	CONFIG_SYS_FLASH_CFI 
+#define CONFIG_BOOTCOMMAND	"bootm 10080000 10300000"
+#else
+#define CONFIG_BOOTCOMMAND	"bootm 14080000 14300000"
+#endif
+#endif
+#define CONFIG_BOOTFILE		"all.bin"
+#define CONFIG_ENV_OVERWRITE
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_DFL
+#define CONFIG_CMD_ENV
+#define CONFIG_CMD_FLASH
+#define CONFIG_CMD_NET
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_EEPROM
+
+/* 
+ * CPU Setting
+ */
+#define CPU_CLOCK_RATE		18000000	/* 16.5 MHz clock for the ARM core */
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 768*1024)
+#define CONFIG_SYS_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+
+/*
+ * Stack sizes,  The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128*1024)	/* regular stack */
+#define CONFIG_STACKSIZE_IRQ	(4*1024)	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
+
+/*
+ * Memory Configuration
+ */
+#define CONFIG_NR_DRAM_BANKS	1	   	/* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0x40000000 	/* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE	0x4000000 	/* 64 MB */
+
+#define CONFIG_SYS_SDRAM_BASE	0x40000000
+
+/*
+ * FLASH Configuration
+ */
+#ifdef CONFIG_SYS_FLASH_CFI				/* NOR Flash */
+
+#ifdef CONFIG_FLASH_AST2300
+#define PHYS_FLASH_1			0x20000000 	/* Flash Bank #1 */
+#else
+#define PHYS_FLASH_1			0x10000000 	/* Flash Bank #1 */
+#endif
+
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_1
+#define CONFIG_FLASH_BANKS_LIST 	{ PHYS_FLASH_1 }
+
+#define CONFIG_SYS_MAX_FLASH_BANKS 	1
+#define CONFIG_SYS_MAX_FLASH_SECT	(256)		/* max number of sectors on one chip */
+
+#define CONFIG_ENV_IS_IN_FLASH	1
+#define CONFIG_ENV_OFFSET			0x60000 	/* environment starts here  */
+#define CONFIG_ENV_SIZE			0x20000 	/* Total Size of Environment Sector */
+
+#define CONFIG_SYS_FLASH_CFI_AMD_RESET
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+
+#else						/* SPI Flash */
+
+#ifdef CONFIG_FLASH_AST2300
+#define PHYS_FLASH_1		0x20000000 	/* Flash Bank #1 */
+#else
+#define PHYS_FLASH_1		0x14000000 	/* Flash Bank #1 */
+#define PHYS_FLASH_2		0x14800000 	/* Flash Bank #2 */
+#define PHYS_FLASH_2_BASE	0x10000000
+#endif
+
+#ifdef CONFIG_2SPIFLASH
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_2_BASE
+#define CONFIG_FLASH_BANKS_LIST 	{ PHYS_FLASH_1, PHYS_FLASH_2 }
+#define CONFIG_SYS_MAX_FLASH_BANKS 	2
+#define CONFIG_SYS_MAX_FLASH_SECT	(1024)		/* max number of sectors on one chip */
+
+#define CONFIG_ENV_IS_IN_FLASH		1
+#define CONFIG_ENV_OFFSET		0x7F0000 	/* environment starts here  */
+#define CONFIG_ENV_SIZE			0x010000 	/* Total Size of Environment Sector */
+#else
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_1
+#define CONFIG_FLASH_BANKS_LIST 	{ PHYS_FLASH_1 }
+#define CONFIG_SYS_MAX_FLASH_BANKS 	1
+#define CONFIG_SYS_MAX_FLASH_SECT	(1024)		/* max number of sectors on one chip */
+
+#define CONFIG_ENV_IS_IN_FLASH		1
+#define CONFIG_ENV_OFFSET		0x7F0000 	/* environment starts here  */
+#define CONFIG_ENV_SIZE			0x010000 	/* Total Size of Environment Sector */
+#endif
+
+#endif
+
+#define __LITTLE_ENDIAN
+
+#define CONFIG_MONITOR_BASE		TEXT_BASE
+#define CONFIG_MONITOR_LEN		(192 << 10)
+
+/* timeout values are in ticks */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	(20*CONFIG_SYS_HZ) 	/* Timeout for Flash Erase */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	(20*CONFIG_SYS_HZ) 	/* Timeout for Flash Write */
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP				/* undef to save memory		*/
+
+#define CONFIG_SYS_PROMPT		"boot# " 	/* Monitor Command Prompt	*/
+#define CONFIG_SYS_CBSIZE		256		/* Console I/O Buffer Size	*/
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16) /* Print Buffer Size */
+#define CONFIG_SYS_MAXARGS		16		/* max number of command args	*/
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE	/* Boot Argument Buffer Size	*/
+
+#define CONFIG_SYS_MEMTEST_START	0x40000000	/* memtest works on	*/
+#define CONFIG_SYS_MEMTEST_END		0x44FFFFFF	/* 256 MB in DRAM	*/
+
+#define	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+#undef	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+#define CONFIG_SYS_LOAD_ADDR		0x43000000	/* default load address */
+
+#define CONFIG_SYS_TIMERBASE		0x1E782000	/* use timer 1 */
+#define CONFIG_SYS_HZ			(1*1000*1000)	/* use external clk (1M) */
+
+/*
+ * Serial Configuration
+ */
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	4
+#define CONFIG_SYS_NS16550_CLK		24000000
+#define CONFIG_SYS_NS16550_COM1		0x1e783000
+#define CONFIG_SYS_NS16550_COM2		0x1e784000
+#define	CONFIG_SYS_LOADS_BAUD_CHANGE
+#define CONFIG_SERIAL1			1
+#define CONFIG_CONS_INDEX		2
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/*
+ * USB device configuration
+ */
+/*
+#define CONFIG_USB_DEVICE		1
+#define CONFIG_USB_TTY			1
+
+#define CONFIG_USBD_VENDORID		0x1234
+#define CONFIG_USBD_PRODUCTID		0x5678
+#define CONFIG_USBD_MANUFACTURER	"Siemens"
+#define CONFIG_USBD_PRODUCT_NAME	"SX1"
+*/
+
+/*
+ * I2C configuration
+ */
+#define CONFIG_HARD_I2C
+#define CONFIG_SYS_I2C_SPEED		100000
+#define CONFIG_SYS_I2C_SLAVE		1
+#define CONFIG_DRIVER_ASPEED_I2C
+
+/*
+* EEPROM configuration
+*/
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN 	2
+#define CONFIG_SYS_I2C_EEPROM_ADDR 	0xa0
+
+/*
+ * NIC configuration
+ */
+#define __BYTE_ORDER __LITTLE_ENDIAN
+#define __LITTLE_ENDIAN_BITFIELD
+#define CONFIG_MAC_PARTITION
+#define CONFIG_ASPEEDNIC
+//#define CONFIG_MAC1_PHY_LINK_INTERRUPT
+#define CONFIG_MAC2_ENABLE
+#define CONFIG_MAC2_PHY_LINK_INTERRUPT
+/*
+*-------------------------------------------------------------------------------
+* NOTICE: MAC1 and MAC2 now have their own seperate PHY configuration.
+* We use 2 bits for each MAC in the scratch register(D[15:11] in 0x1E6E2040) to
+* inform kernel driver.
+* The meanings of the 2 bits are:
+* 00(0): Dedicated PHY
+* 01(1): ASPEED's EVA + INTEL's NC-SI PHY chip EVA
+* 10(2): ASPEED's MAC is connected to NC-SI PHY chip directly
+* 11: Reserved
+*
+* We use CONFIG_MAC1_PHY_SETTING and CONFIG_MAC2_PHY_SETTING in U-Boot
+* 0: Dedicated PHY
+* 1: ASPEED's EVA + INTEL's NC-SI PHY chip EVA
+* 2: ASPEED's MAC is connected to NC-SI PHY chip directly
+* 3: Reserved
+*-------------------------------------------------------------------------------
+*/
+#define CONFIG_MAC1_PHY_SETTING		0
+#define CONFIG_MAC2_PHY_SETTING		0
+#define CONFIG_MAC_INTERFACE_CLOCK_DELAY	0x2255
+#define CONFIG_NET_MULTI
+#define CONFIG_ETHACT			aspeednic#0
+#define CONFIG_GATEWAYIP		192.168.0.1
+#define CONFIG_NETMASK			255.255.255.0
+#define CONFIG_IPADDR			192.168.0.188
+#define CONFIG_SERVERIP			192.168.0.106
+#define CONFIG_ETHADDR			00:C0:A8:12:34:56
+#define CONFIG_ETH1ADDR			00:C0:A8:12:34:57
+
+/*
+ * SLT
+ */
+/*
+#define CONFIG_SLT
+#define CFG_CMD_SLT		(CFG_CMD_VIDEOTEST | CFG_CMD_MACTEST | CFG_CMD_HACTEST | CFG_CMD_MICTEST)
+*/
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ast2400.h b/include/configs/ast2400.h
new file mode 100644
index 0000000..670fcfd
--- /dev/null
+++ b/include/configs/ast2400.h
@@ -0,0 +1,328 @@
+/*
+ * (C) Copyright 2004
+ * Peter Chen <peterc@socle-tech.com.tw>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+//#define CONFIG_INIT_CRITICAL			/* define for U-BOOT 1.1.1 */
+#undef  CONFIG_INIT_CRITICAL			/* undef for  U-BOOT 1.1.4 */ 
+//#define CONFIG_FPGA_ASPEED	1
+#define CONFIG_ARM926EJS	1		/* This is an arm926ejs CPU */
+#define	CONFIG_ASPEED		1
+#define CONFIG_AST2400		1
+//#define CONFIG_AST1070		1
+//#define CONFIG_SYS_FLASH_CFI			/* CONFIG_FLASH_CFI, CONFIG_FLASH_SPI is exclusive*/
+#define CONFIG_FLASH_SPI
+//#define CONFIG_2SPIFLASH			/* Boot SPI: CS2, 2nd SPI: CS0 */
+#undef CONFIG_2SPIFLASH
+#undef CONFIG_ASPEED_SLT
+#define CONFIG_FLASH_AST2300
+//#define CONFIG_FLASH_AST2300_DMA
+//#define CONFIG_FLASH_SPIx2_Dummy
+//#define CONFIG_FLASH_SPIx4_Dummy
+#define CONFIG_CRT_DISPLAY	1		/* undef if not support CRT */
+
+//#define CONFIG_USE_IRQ				/* we don't need IRQ/FIQ stuff */
+#define CONFIG_MISC_INIT_R 
+
+/*
+ * DRAM Config
+ *
+ * 1. DRAM Size              //
+ *    CONFIG_DRAM_512MBIT    // 512M bit
+ *    CONFIG_DRAM_1GBIT      // 1G   bit (default)
+ *    CONFIG_DRAM_2GBIT      // 2G   bit
+ *    CONFIG_DRAM_4GBIT      // 4G   bit 
+ * 2. DRAM Speed             //
+ *    CONFIG_DRAM_336        // 336MHz (DDR-667)
+ *    CONFIG_DRAM_408        // 408MHz (DDR-800) (default)
+ * 3. VGA Mode
+ *    CONFIG_CRT_DISPLAY     // define to disable VGA function
+ * 4. ECC Function enable
+ *    CONFIG_DRAM_ECC        // define to enable ECC function
+ * 5. UART Debug Message
+ *    CONFIG_DRAM_UART_OUT   // enable output message at UART5
+ *    CONFIG_DRAM_UART_38400 // set the UART baud rate to 38400, default is 115200
+ */
+ 
+//1. DRAM Size
+//#define    CONFIG_DRAM_512MBIT
+#define    CONFIG_DRAM_1GBIT
+//#define    CONFIG_DRAM_2GBIT
+//#define    CONFIG_DRAM_4GBIT
+//2. DRAM Speed
+//#define    CONFIG_DRAM_336
+#define    CONFIG_DRAM_408
+//3. VGA Mode
+//#define    CONFIG_CRT_DISPLAY
+//4. ECC Function enable
+//#define    CONFIG_DRAM_ECC
+//5. UART Debug Message
+#define    CONFIG_DRAM_UART_OUT
+//#define    CONFIG_DRAM_UART_38400
+
+
+
+/* 
+ * Environment Config
+ */
+#define CONFIG_CMDLINE_TAG	 1		/* enable passing of ATAGs	*/
+#define CONFIG_SETUP_MEMORY_TAGS 1
+#define CONFIG_INITRD_TAG	 1
+#define	CONFIG_BOOTARGS 	"debug console=ttyS0,115200n8 ramdisk_size=16384 root=/dev/ram rw init=/linuxrc mem=80M"
+#define CONFIG_UPDATE           "tftp 40800000 ast2400.scr; so 40800000'"
+
+#define CONFIG_BOOTDELAY	3		/* autoboot after 3 seconds	*/
+#ifdef CONFIG_FLASH_AST2300
+#define CONFIG_BOOTCOMMAND	"bootm 20080000 20300000"
+#else
+#ifdef	CONFIG_SYS_FLASH_CFI 
+#define CONFIG_BOOTCOMMAND	"bootm 10080000 10300000"
+#else
+#define CONFIG_BOOTCOMMAND	"bootm 14080000 14300000"
+#endif
+#endif
+#define CONFIG_BOOTFILE		"all.bin"
+#define CONFIG_ENV_OVERWRITE
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_DFL
+#define CONFIG_CMD_ENV
+#define CONFIG_CMD_FLASH
+#define CONFIG_CMD_NET
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_EEPROM
+#define CONFIG_CMD_NETTEST
+#define CONFIG_CMD_SLT
+
+/* 
+ * CPU Setting
+ */
+#define CPU_CLOCK_RATE		18000000	/* 16.5 MHz clock for the ARM core */
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 768*1024)
+#define CONFIG_SYS_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+
+/*
+ * Stack sizes,  The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128*1024)	/* regular stack */
+#define CONFIG_STACKSIZE_IRQ	(4*1024)	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
+
+/*
+ * Memory Configuration
+ */
+#define CONFIG_NR_DRAM_BANKS	1	   	/* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0x40000000 	/* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE	0x4000000 	/* 64 MB */
+
+#define CONFIG_SYS_SDRAM_BASE	0x40000000
+
+/*
+ * FLASH Configuration
+ */
+#ifdef CONFIG_SYS_FLASH_CFI				/* NOR Flash */
+
+#ifdef CONFIG_FLASH_AST2300
+#define PHYS_FLASH_1			0x20000000 	/* Flash Bank #1 */
+#else
+#define PHYS_FLASH_1			0x10000000 	/* Flash Bank #1 */
+#endif
+
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_1
+#define CONFIG_FLASH_BANKS_LIST 	{ PHYS_FLASH_1 }
+
+#define CONFIG_SYS_MAX_FLASH_BANKS 	1
+#define CONFIG_SYS_MAX_FLASH_SECT	(256)		/* max number of sectors on one chip */
+
+#define CONFIG_ENV_IS_IN_FLASH	1
+#define CONFIG_ENV_OFFSET					0x60000 	/* environment starts here  */
+#define CONFIG_ENV_SIZE					0x20000 	/* Total Size of Environment Sector */
+
+#define CONFIG_SYS_FLASH_CFI_AMD_RESET
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+
+#else						/* SPI Flash */
+
+#ifdef CONFIG_FLASH_AST2300
+#define PHYS_FLASH_1		0x20000000 	/* Flash Bank #1 */
+#else
+#define PHYS_FLASH_1		0x14000000 	/* Flash Bank #1 */
+#define PHYS_FLASH_2		0x14800000 	/* Flash Bank #2 */
+#define PHYS_FLASH_2_BASE	0x10000000
+#endif
+
+#ifdef CONFIG_2SPIFLASH
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_2_BASE
+#define CONFIG_FLASH_BANKS_LIST 	{ PHYS_FLASH_1, PHYS_FLASH_2 }
+#define CONFIG_SYS_MAX_FLASH_BANKS 	2
+#define CONFIG_SYS_MAX_FLASH_SECT	(1024)		/* max number of sectors on one chip */
+
+#define CONFIG_ENV_IS_IN_FLASH		1
+#define CONFIG_ENV_OFFSET		0x7F0000 	/* environment starts here  */
+#define CONFIG_ENV_SIZE			0x010000 	/* Total Size of Environment Sector */
+#else
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_1
+#define CONFIG_FLASH_BANKS_LIST 	{ PHYS_FLASH_1 }
+#define CONFIG_SYS_MAX_FLASH_BANKS 	1
+#define CONFIG_SYS_MAX_FLASH_SECT	(1024)		/* max number of sectors on one chip */
+
+#define CONFIG_ENV_IS_IN_FLASH		1
+#define CONFIG_ENV_OFFSET		0x7F0000 	/* environment starts here  */
+#define CONFIG_ENV_SIZE			0x010000 	/* Total Size of Environment Sector */
+#endif
+
+#endif
+
+#define __LITTLE_ENDIAN
+
+#define CONFIG_MONITOR_BASE		TEXT_BASE
+#define CONFIG_MONITOR_LEN		(192 << 10)
+
+/* timeout values are in ticks */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	(20*CONFIG_SYS_HZ) 	/* Timeout for Flash Erase */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	(20*CONFIG_SYS_HZ) 	/* Timeout for Flash Write */
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP				/* undef to save memory		*/
+
+#define CONFIG_SYS_PROMPT		"boot# " 	/* Monitor Command Prompt	*/
+#define CONFIG_SYS_CBSIZE		256		/* Console I/O Buffer Size	*/
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16) /* Print Buffer Size */
+#define CONFIG_SYS_MAXARGS		16		/* max number of command args	*/
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE	/* Boot Argument Buffer Size	*/
+
+#define CONFIG_SYS_MEMTEST_START	0x40000000	/* memtest works on	*/
+#define CONFIG_SYS_MEMTEST_END		0x44FFFFFF	/* 256 MB in DRAM	*/
+
+#define	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+#undef	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+#define CONFIG_SYS_LOAD_ADDR		0x43000000	/* default load address */
+
+#define CONFIG_SYS_TIMERBASE		0x1E782000	/* use timer 1 */
+#define CONFIG_SYS_HZ			(1*1000*1000)	/* use external clk (1M) */
+
+/*
+ * Serial Configuration
+ */
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	4
+#define CONFIG_SYS_NS16550_CLK		24000000
+#define CONFIG_SYS_NS16550_COM1		0x1e783000
+#define CONFIG_SYS_NS16550_COM2		0x1e784000
+#define	CONFIG_SYS_LOADS_BAUD_CHANGE
+#define CONFIG_SERIAL1			1
+#define CONFIG_CONS_INDEX		2
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/*
+ * USB device configuration
+ */
+/*
+#define CONFIG_USB_DEVICE		1
+#define CONFIG_USB_TTY			1
+
+#define CONFIG_USBD_VENDORID		0x1234
+#define CONFIG_USBD_PRODUCTID		0x5678
+#define CONFIG_USBD_MANUFACTURER	"Siemens"
+#define CONFIG_USBD_PRODUCT_NAME	"SX1"
+*/
+
+/*
+ * I2C configuration
+ */
+#define CONFIG_HARD_I2C
+#define CONFIG_SYS_I2C_SPEED		100000
+#define CONFIG_SYS_I2C_SLAVE		1
+#define CONFIG_DRIVER_ASPEED_I2C
+
+/*
+* EEPROM configuration
+*/
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN 	2
+#define CONFIG_SYS_I2C_EEPROM_ADDR 	0xa0
+
+/*
+ * NIC configuration
+ */
+#define __BYTE_ORDER __LITTLE_ENDIAN
+#define __LITTLE_ENDIAN_BITFIELD
+#define CONFIG_MAC_PARTITION
+#define CONFIG_ASPEEDNIC
+#define CONFIG_MAC1_PHY_LINK_INTERRUPT
+#define CONFIG_MAC2_ENABLE
+#define CONFIG_MAC2_PHY_LINK_INTERRUPT
+/*
+*-------------------------------------------------------------------------------
+* NOTICE: MAC1 and MAC2 now have their own seperate PHY configuration.
+* We use 2 bits for each MAC in the scratch register(D[15:11] in 0x1E6E2040) to
+* inform kernel driver.
+* The meanings of the 2 bits are:
+* 00(0): Dedicated PHY
+* 01(1): ASPEED's EVA + INTEL's NC-SI PHY chip EVA
+* 10(2): ASPEED's MAC is connected to NC-SI PHY chip directly
+* 11: Reserved
+*
+* We use CONFIG_MAC1_PHY_SETTING and CONFIG_MAC2_PHY_SETTING in U-Boot
+* 0: Dedicated PHY
+* 1: ASPEED's EVA + INTEL's NC-SI PHY chip EVA
+* 2: ASPEED's MAC is connected to NC-SI PHY chip directly
+* 3: Reserved
+*-------------------------------------------------------------------------------
+*/
+#define CONFIG_MAC1_PHY_SETTING		0
+#define CONFIG_MAC2_PHY_SETTING		0
+#define CONFIG_MAC_INTERFACE_CLOCK_DELAY	0x2255
+#define CONFIG_NET_MULTI
+#define CONFIG_ETHACT			aspeednic#0
+#define CONFIG_GATEWAYIP		192.168.0.1
+#define CONFIG_NETMASK			255.255.255.0
+#define CONFIG_IPADDR			192.168.0.45
+#define CONFIG_SERVERIP			192.168.0.81
+#define CONFIG_ETHADDR			00:C0:A8:12:34:56
+#define CONFIG_ETH1ADDR			00:C0:A8:12:34:57
+
+/*
+ * SLT
+ */
+/*
+#define CONFIG_SLT
+#define CFG_CMD_SLT		(CFG_CMD_VIDEOTEST | CFG_CMD_MACTEST | CFG_CMD_HACTEST | CFG_CMD_MICTEST)
+*/
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ast2400_ast1070.h b/include/configs/ast2400_ast1070.h
new file mode 100644
index 0000000..df6c44b
--- /dev/null
+++ b/include/configs/ast2400_ast1070.h
@@ -0,0 +1,326 @@
+/*
+ * (C) Copyright 2004
+ * Peter Chen <peterc@socle-tech.com.tw>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+//#define CONFIG_INIT_CRITICAL			/* define for U-BOOT 1.1.1 */
+#undef  CONFIG_INIT_CRITICAL			/* undef for  U-BOOT 1.1.4 */ 
+//#define CONFIG_FPGA_ASPEED	1
+#define CONFIG_ARM926EJS	1		/* This is an arm926ejs CPU */
+#define	CONFIG_ASPEED		1
+#define CONFIG_AST2400		1
+#define CONFIG_AST1070		1
+//#define CONFIG_CALIBRATION	1
+//#define CONFIG_SYS_FLASH_CFI			/* CONFIG_FLASH_CFI, CONFIG_FLASH_SPI is exclusive*/
+#define CONFIG_FLASH_SPI
+//#define CONFIG_2SPIFLASH			/* Boot SPI: CS2, 2nd SPI: CS0 */
+#undef CONFIG_2SPIFLASH
+#undef CONFIG_ASPEED_SLT
+#define CONFIG_FLASH_AST2300
+#define CONFIG_FLASH_AST2300_DMA
+//#define CONFIG_FLASH_SPIx2_Dummy
+//#define CONFIG_FLASH_SPIx4_Dummy
+#define CONFIG_CRT_DISPLAY	1		/* undef if not support CRT */
+
+//#define CONFIG_USE_IRQ				/* we don't need IRQ/FIQ stuff */
+#define CONFIG_MISC_INIT_R 
+
+/*
+ * DRAM Config
+ *
+ * 1. DRAM Size              //
+ *    CONFIG_DRAM_512MBIT    // 512M bit
+ *    CONFIG_DRAM_1GBIT      // 1G   bit (default)
+ *    CONFIG_DRAM_2GBIT      // 2G   bit
+ *    CONFIG_DRAM_4GBIT      // 4G   bit 
+ * 2. DRAM Speed             //
+ *    CONFIG_DRAM_336        // 336MHz (DDR-667)
+ *    CONFIG_DRAM_408        // 408MHz (DDR-800) (default)
+ * 3. VGA Mode
+ *    CONFIG_CRT_DISPLAY     // define to disable VGA function
+ * 4. ECC Function enable
+ *    CONFIG_DRAM_ECC        // define to enable ECC function
+ * 5. UART Debug Message
+ *    CONFIG_DRAM_UART_OUT   // enable output message at UART5
+ *    CONFIG_DRAM_UART_38400 // set the UART baud rate to 38400, default is 115200
+ */
+ 
+//1. DRAM Size
+//#define    CONFIG_DRAM_512MBIT
+#define    CONFIG_DRAM_1GBIT
+//#define    CONFIG_DRAM_2GBIT
+//#define    CONFIG_DRAM_4GBIT
+//2. DRAM Speed
+//#define    CONFIG_DRAM_336
+#define    CONFIG_DRAM_408
+//3. VGA Mode
+//#define    CONFIG_CRT_DISPLAY
+//4. ECC Function enable
+//#define    CONFIG_DRAM_ECC
+//5. UART Debug Message
+#define    CONFIG_DRAM_UART_OUT
+//#define    CONFIG_DRAM_UART_38400
+
+
+
+/* 
+ * Environment Config
+ */
+#define CONFIG_CMDLINE_TAG	 1		/* enable passing of ATAGs	*/
+#define CONFIG_SETUP_MEMORY_TAGS 1
+#define CONFIG_INITRD_TAG	 1
+#define	CONFIG_BOOTARGS 	"debug console=ttyS0,115200n8 ramdisk_size=16384 root=/dev/ram rw init=/linuxrc mem=80M"
+#define CONFIG_BOOTDELAY	3		/* autoboot after 3 seconds	*/
+#ifdef CONFIG_FLASH_AST2300
+#define CONFIG_BOOTCOMMAND	"bootm 20080000 20300000"
+#else
+#ifdef	CONFIG_SYS_FLASH_CFI 
+#define CONFIG_BOOTCOMMAND	"bootm 10080000 10300000"
+#else
+#define CONFIG_BOOTCOMMAND	"bootm 14080000 14300000"
+#endif
+#endif
+#define CONFIG_BOOTFILE		"all.bin"
+#define CONFIG_ENV_OVERWRITE
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_DFL
+#define CONFIG_CMD_ENV
+#define CONFIG_CMD_FLASH
+#define CONFIG_CMD_NET
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_EEPROM
+#define CONFIG_CMD_NETTEST
+
+/* 
+ * CPU Setting
+ */
+#define CPU_CLOCK_RATE		18000000	/* 16.5 MHz clock for the ARM core */
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 768*1024)
+#define CONFIG_SYS_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+
+/*
+ * Stack sizes,  The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128*1024)	/* regular stack */
+#define CONFIG_STACKSIZE_IRQ	(4*1024)	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
+
+/*
+ * Memory Configuration
+ */
+#define CONFIG_NR_DRAM_BANKS	1	   	/* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0x40000000 	/* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE	0x4000000 	/* 64 MB */
+
+#define CONFIG_SYS_SDRAM_BASE	0x40000000
+
+/*
+ * FLASH Configuration
+ */
+#ifdef CONFIG_SYS_FLASH_CFI				/* NOR Flash */
+
+#ifdef CONFIG_FLASH_AST2300
+#define PHYS_FLASH_1			0x20000000 	/* Flash Bank #1 */
+#else
+#define PHYS_FLASH_1			0x10000000 	/* Flash Bank #1 */
+#endif
+
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_1
+#define CONFIG_FLASH_BANKS_LIST 	{ PHYS_FLASH_1 }
+
+#define CONFIG_SYS_MAX_FLASH_BANKS 	1
+#define CONFIG_SYS_MAX_FLASH_SECT	(256)		/* max number of sectors on one chip */
+
+#define CONFIG_ENV_IS_IN_FLASH	1
+#define CONFIG_ENV_OFFSET			0x60000 	/* environment starts here  */
+#define CONFIG_ENV_SIZE			0x20000 	/* Total Size of Environment Sector */
+
+#define CONFIG_SYS_FLASH_CFI_AMD_RESET
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+
+#else						/* SPI Flash */
+
+#ifdef CONFIG_FLASH_AST2300
+#define PHYS_FLASH_1		0x20000000 	/* Flash Bank #1 */
+#else
+#define PHYS_FLASH_1		0x14000000 	/* Flash Bank #1 */
+#define PHYS_FLASH_2		0x14800000 	/* Flash Bank #2 */
+#define PHYS_FLASH_2_BASE	0x10000000
+#endif
+
+#ifdef CONFIG_2SPIFLASH
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_2_BASE
+#define CONFIG_FLASH_BANKS_LIST 	{ PHYS_FLASH_1, PHYS_FLASH_2 }
+#define CONFIG_SYS_MAX_FLASH_BANKS 	2
+#define CONFIG_SYS_MAX_FLASH_SECT	(1024)		/* max number of sectors on one chip */
+
+#define CONFIG_ENV_IS_IN_FLASH		1
+#define CONFIG_ENV_OFFSET		0x7F0000 	/* environment starts here  */
+#define CONFIG_ENV_SIZE			0x010000 	/* Total Size of Environment Sector */
+#else
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_1
+#define CONFIG_FLASH_BANKS_LIST 	{ PHYS_FLASH_1 }
+#define CONFIG_SYS_MAX_FLASH_BANKS 	1
+#define CONFIG_SYS_MAX_FLASH_SECT	(1024)		/* max number of sectors on one chip */
+
+#define CONFIG_ENV_IS_IN_FLASH		1
+#define CONFIG_ENV_OFFSET		0x7F0000 	/* environment starts here  */
+#define CONFIG_ENV_SIZE			0x010000 	/* Total Size of Environment Sector */
+#endif
+
+#endif
+
+#define __LITTLE_ENDIAN
+
+#define CONFIG_MONITOR_BASE		TEXT_BASE
+#define CONFIG_MONITOR_LEN		(192 << 10)
+
+/* timeout values are in ticks */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	(20*CONFIG_SYS_HZ) 	/* Timeout for Flash Erase */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	(20*CONFIG_SYS_HZ) 	/* Timeout for Flash Write */
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP				/* undef to save memory		*/
+
+#define CONFIG_SYS_PROMPT		"boot# " 	/* Monitor Command Prompt	*/
+#define CONFIG_SYS_CBSIZE		256		/* Console I/O Buffer Size	*/
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16) /* Print Buffer Size */
+#define CONFIG_SYS_MAXARGS		16		/* max number of command args	*/
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE	/* Boot Argument Buffer Size	*/
+
+#define CONFIG_SYS_MEMTEST_START	0x40000000	/* memtest works on	*/
+#define CONFIG_SYS_MEMTEST_END		0x44FFFFFF	/* 256 MB in DRAM	*/
+
+#define	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+#undef	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+#define CONFIG_SYS_LOAD_ADDR		0x43000000	/* default load address */
+
+#define CONFIG_SYS_TIMERBASE		0x1E782000	/* use timer 1 */
+#define CONFIG_SYS_HZ			(1*1000*1000)	/* use external clk (1M) */
+
+/*
+ * Serial Configuration
+ */
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	4
+#define CONFIG_SYS_NS16550_CLK		24000000
+#define CONFIG_SYS_NS16550_COM1		0x1e783000
+#define CONFIG_SYS_NS16550_COM2		0x1e784000
+#define	CONFIG_SYS_LOADS_BAUD_CHANGE
+#define CONFIG_SERIAL1			1
+#define CONFIG_CONS_INDEX		2
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/*
+ * USB device configuration
+ */
+/*
+#define CONFIG_USB_DEVICE		1
+#define CONFIG_USB_TTY			1
+
+#define CONFIG_USBD_VENDORID		0x1234
+#define CONFIG_USBD_PRODUCTID		0x5678
+#define CONFIG_USBD_MANUFACTURER	"Siemens"
+#define CONFIG_USBD_PRODUCT_NAME	"SX1"
+*/
+
+/*
+ * I2C configuration
+ */
+#define CONFIG_HARD_I2C
+#define CONFIG_SYS_I2C_SPEED		100000
+#define CONFIG_SYS_I2C_SLAVE		1
+#define CONFIG_DRIVER_ASPEED_I2C
+
+/*
+* EEPROM configuration
+*/
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN 	2
+#define CONFIG_SYS_I2C_EEPROM_ADDR 	0xa0
+
+/*
+ * NIC configuration
+ */
+#define __BYTE_ORDER __LITTLE_ENDIAN
+#define __LITTLE_ENDIAN_BITFIELD
+#define CONFIG_MAC_PARTITION
+#define CONFIG_ASPEEDNIC
+#define CONFIG_MAC1_PHY_LINK_INTERRUPT
+#define CONFIG_MAC2_ENABLE
+#define CONFIG_MAC2_PHY_LINK_INTERRUPT
+/*
+*-------------------------------------------------------------------------------
+* NOTICE: MAC1 and MAC2 now have their own seperate PHY configuration.
+* We use 2 bits for each MAC in the scratch register(D[15:11] in 0x1E6E2040) to
+* inform kernel driver.
+* The meanings of the 2 bits are:
+* 00(0): Dedicated PHY
+* 01(1): ASPEED's EVA + INTEL's NC-SI PHY chip EVA
+* 10(2): ASPEED's MAC is connected to NC-SI PHY chip directly
+* 11: Reserved
+*
+* We use CONFIG_MAC1_PHY_SETTING and CONFIG_MAC2_PHY_SETTING in U-Boot
+* 0: Dedicated PHY
+* 1: ASPEED's EVA + INTEL's NC-SI PHY chip EVA
+* 2: ASPEED's MAC is connected to NC-SI PHY chip directly
+* 3: Reserved
+*-------------------------------------------------------------------------------
+*/
+#define CONFIG_MAC1_PHY_SETTING		0
+#define CONFIG_MAC2_PHY_SETTING		0
+#define CONFIG_MAC_INTERFACE_CLOCK_DELAY	0x2255
+#define CONFIG_NET_MULTI
+#define CONFIG_ETHACT			aspeednic#0
+#define CONFIG_GATEWAYIP		192.168.0.1
+#define CONFIG_NETMASK			255.255.255.0
+#define CONFIG_IPADDR			192.168.0.41
+#define CONFIG_SERVERIP			192.168.0.81
+#define CONFIG_ETHADDR			00:C0:A8:12:34:56
+#define CONFIG_ETH1ADDR			00:C0:A8:12:34:57
+
+/*
+ * SLT
+ */
+/*
+#define CONFIG_SLT
+#define CFG_CMD_SLT		(CFG_CMD_VIDEOTEST | CFG_CMD_MACTEST | CFG_CMD_HACTEST | CFG_CMD_MICTEST)
+*/
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ast2400_ast10701.h b/include/configs/ast2400_ast10701.h
new file mode 100644
index 0000000..4553535
--- /dev/null
+++ b/include/configs/ast2400_ast10701.h
@@ -0,0 +1,327 @@
+/*
+ * (C) Copyright 2004
+ * Peter Chen <peterc@socle-tech.com.tw>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+//#define CONFIG_INIT_CRITICAL			/* define for U-BOOT 1.1.1 */
+#undef  CONFIG_INIT_CRITICAL			/* undef for  U-BOOT 1.1.4 */ 
+//#define CONFIG_FPGA_ASPEED	1
+#define CONFIG_ARM926EJS	1		/* This is an arm926ejs CPU */
+#define	CONFIG_ASPEED		1
+#define CONFIG_AST2400		1
+#define CONFIG_AST1070		1
+#define CONFIG_LPC_PLUS		1
+//#define CONFIG_CALIBRATION	1
+//#define CONFIG_SYS_FLASH_CFI			/* CONFIG_FLASH_CFI, CONFIG_FLASH_SPI is exclusive*/
+#define CONFIG_FLASH_SPI
+//#define CONFIG_2SPIFLASH			/* Boot SPI: CS2, 2nd SPI: CS0 */
+#undef CONFIG_2SPIFLASH
+#undef CONFIG_ASPEED_SLT
+#define CONFIG_FLASH_AST2300
+#define CONFIG_FLASH_AST2300_DMA
+//#define CONFIG_FLASH_SPIx2_Dummy
+//#define CONFIG_FLASH_SPIx4_Dummy
+#define CONFIG_CRT_DISPLAY	1		/* undef if not support CRT */
+
+//#define CONFIG_USE_IRQ				/* we don't need IRQ/FIQ stuff */
+#define CONFIG_MISC_INIT_R 
+
+/*
+ * DRAM Config
+ *
+ * 1. DRAM Size              //
+ *    CONFIG_DRAM_512MBIT    // 512M bit
+ *    CONFIG_DRAM_1GBIT      // 1G   bit (default)
+ *    CONFIG_DRAM_2GBIT      // 2G   bit
+ *    CONFIG_DRAM_4GBIT      // 4G   bit 
+ * 2. DRAM Speed             //
+ *    CONFIG_DRAM_336        // 336MHz (DDR-667)
+ *    CONFIG_DRAM_408        // 408MHz (DDR-800) (default)
+ * 3. VGA Mode
+ *    CONFIG_CRT_DISPLAY     // define to disable VGA function
+ * 4. ECC Function enable
+ *    CONFIG_DRAM_ECC        // define to enable ECC function
+ * 5. UART Debug Message
+ *    CONFIG_DRAM_UART_OUT   // enable output message at UART5
+ *    CONFIG_DRAM_UART_38400 // set the UART baud rate to 38400, default is 115200
+ */
+ 
+//1. DRAM Size
+//#define    CONFIG_DRAM_512MBIT
+#define    CONFIG_DRAM_1GBIT
+//#define    CONFIG_DRAM_2GBIT
+//#define    CONFIG_DRAM_4GBIT
+//2. DRAM Speed
+//#define    CONFIG_DRAM_336
+#define    CONFIG_DRAM_408
+//3. VGA Mode
+//#define    CONFIG_CRT_DISPLAY
+//4. ECC Function enable
+//#define    CONFIG_DRAM_ECC
+//5. UART Debug Message
+#define    CONFIG_DRAM_UART_OUT
+//#define    CONFIG_DRAM_UART_38400
+
+
+
+/* 
+ * Environment Config
+ */
+#define CONFIG_CMDLINE_TAG	 1		/* enable passing of ATAGs	*/
+#define CONFIG_SETUP_MEMORY_TAGS 1
+#define CONFIG_INITRD_TAG	 1
+#define	CONFIG_BOOTARGS 	"debug console=ttyS0,115200n8 ramdisk_size=16384 root=/dev/ram rw init=/linuxrc mem=80M"
+#define CONFIG_BOOTDELAY	3		/* autoboot after 3 seconds	*/
+#ifdef CONFIG_FLASH_AST2300
+#define CONFIG_BOOTCOMMAND	"bootm 20080000 20300000"
+#else
+#ifdef	CONFIG_SYS_FLASH_CFI 
+#define CONFIG_BOOTCOMMAND	"bootm 10080000 10300000"
+#else
+#define CONFIG_BOOTCOMMAND	"bootm 14080000 14300000"
+#endif
+#endif
+#define CONFIG_BOOTFILE		"all.bin"
+#define CONFIG_ENV_OVERWRITE
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_DFL
+#define CONFIG_CMD_ENV
+#define CONFIG_CMD_FLASH
+#define CONFIG_CMD_NET
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_EEPROM
+#define CONFIG_CMD_NETTEST
+
+/* 
+ * CPU Setting
+ */
+#define CPU_CLOCK_RATE		18000000	/* 16.5 MHz clock for the ARM core */
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 768*1024)
+#define CONFIG_SYS_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+
+/*
+ * Stack sizes,  The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128*1024)	/* regular stack */
+#define CONFIG_STACKSIZE_IRQ	(4*1024)	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
+
+/*
+ * Memory Configuration
+ */
+#define CONFIG_NR_DRAM_BANKS	1	   	/* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0x40000000 	/* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE	0x4000000 	/* 64 MB */
+
+#define CONFIG_SYS_SDRAM_BASE	0x40000000
+
+/*
+ * FLASH Configuration
+ */
+#ifdef CONFIG_SYS_FLASH_CFI				/* NOR Flash */
+
+#ifdef CONFIG_FLASH_AST2300
+#define PHYS_FLASH_1			0x20000000 	/* Flash Bank #1 */
+#else
+#define PHYS_FLASH_1			0x10000000 	/* Flash Bank #1 */
+#endif
+
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_1
+#define CONFIG_FLASH_BANKS_LIST 	{ PHYS_FLASH_1 }
+
+#define CONFIG_SYS_MAX_FLASH_BANKS 	1
+#define CONFIG_SYS_MAX_FLASH_SECT	(256)		/* max number of sectors on one chip */
+
+#define CONFIG_ENV_IS_IN_FLASH	1
+#define CONFIG_ENV_OFFSET		0xFE0000 	/* environment starts here  */
+#define CONFIG_ENV_SIZE			0x020000 	/* Total Size of Environment Sector */
+
+#define CONFIG_SYS_FLASH_CFI_AMD_RESET
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+
+#else						/* SPI Flash */
+
+#ifdef CONFIG_FLASH_AST2300
+#define PHYS_FLASH_1		0x20000000 	/* Flash Bank #1 */
+#else
+#define PHYS_FLASH_1		0x14000000 	/* Flash Bank #1 */
+#define PHYS_FLASH_2		0x14800000 	/* Flash Bank #2 */
+#define PHYS_FLASH_2_BASE	0x10000000
+#endif
+
+#ifdef CONFIG_2SPIFLASH
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_2_BASE
+#define CONFIG_FLASH_BANKS_LIST 	{ PHYS_FLASH_1, PHYS_FLASH_2 }
+#define CONFIG_SYS_MAX_FLASH_BANKS 	2
+#define CONFIG_SYS_MAX_FLASH_SECT	(1024)		/* max number of sectors on one chip */
+
+#define CONFIG_ENV_IS_IN_FLASH		1
+#define CONFIG_ENV_OFFSET		0x7F0000 	/* environment starts here  */
+#define CONFIG_ENV_SIZE			0x010000 	/* Total Size of Environment Sector */
+#else
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_1
+#define CONFIG_FLASH_BANKS_LIST 	{ PHYS_FLASH_1 }
+#define CONFIG_SYS_MAX_FLASH_BANKS 	1
+#define CONFIG_SYS_MAX_FLASH_SECT	(1024)		/* max number of sectors on one chip */
+
+#define CONFIG_ENV_IS_IN_FLASH		1
+#define CONFIG_ENV_OFFSET		0x7F0000 	/* environment starts here  */
+#define CONFIG_ENV_SIZE			0x010000 	/* Total Size of Environment Sector */
+#endif
+
+#endif
+
+#define __LITTLE_ENDIAN
+
+#define CONFIG_MONITOR_BASE		TEXT_BASE
+#define CONFIG_MONITOR_LEN		(192 << 10)
+
+/* timeout values are in ticks */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	(20*CONFIG_SYS_HZ) 	/* Timeout for Flash Erase */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	(20*CONFIG_SYS_HZ) 	/* Timeout for Flash Write */
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP				/* undef to save memory		*/
+
+#define CONFIG_SYS_PROMPT		"boot# " 	/* Monitor Command Prompt	*/
+#define CONFIG_SYS_CBSIZE		256		/* Console I/O Buffer Size	*/
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16) /* Print Buffer Size */
+#define CONFIG_SYS_MAXARGS		16		/* max number of command args	*/
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE	/* Boot Argument Buffer Size	*/
+
+#define CONFIG_SYS_MEMTEST_START	0x40000000	/* memtest works on	*/
+#define CONFIG_SYS_MEMTEST_END		0x44FFFFFF	/* 256 MB in DRAM	*/
+
+#define	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+#undef	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+#define CONFIG_SYS_LOAD_ADDR		0x43000000	/* default load address */
+
+#define CONFIG_SYS_TIMERBASE		0x1E782000	/* use timer 1 */
+#define CONFIG_SYS_HZ			(1*1000*1000)	/* use external clk (1M) */
+
+/*
+ * Serial Configuration
+ */
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	4
+#define CONFIG_SYS_NS16550_CLK		24000000
+#define CONFIG_SYS_NS16550_COM1		0x1e783000
+#define CONFIG_SYS_NS16550_COM2		0x1e784000
+#define	CONFIG_SYS_LOADS_BAUD_CHANGE
+#define CONFIG_SERIAL1			1
+#define CONFIG_CONS_INDEX		2
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/*
+ * USB device configuration
+ */
+/*
+#define CONFIG_USB_DEVICE		1
+#define CONFIG_USB_TTY			1
+
+#define CONFIG_USBD_VENDORID		0x1234
+#define CONFIG_USBD_PRODUCTID		0x5678
+#define CONFIG_USBD_MANUFACTURER	"Siemens"
+#define CONFIG_USBD_PRODUCT_NAME	"SX1"
+*/
+
+/*
+ * I2C configuration
+ */
+#define CONFIG_HARD_I2C
+#define CONFIG_SYS_I2C_SPEED		100000
+#define CONFIG_SYS_I2C_SLAVE		1
+#define CONFIG_DRIVER_ASPEED_I2C
+
+/*
+* EEPROM configuration
+*/
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN 	2
+#define CONFIG_SYS_I2C_EEPROM_ADDR 	0xa0
+
+/*
+ * NIC configuration
+ */
+#define __BYTE_ORDER __LITTLE_ENDIAN
+#define __LITTLE_ENDIAN_BITFIELD
+#define CONFIG_MAC_PARTITION
+#define CONFIG_ASPEEDNIC
+#define CONFIG_MAC1_PHY_LINK_INTERRUPT
+#define CONFIG_MAC2_ENABLE
+#define CONFIG_MAC2_PHY_LINK_INTERRUPT
+/*
+*-------------------------------------------------------------------------------
+* NOTICE: MAC1 and MAC2 now have their own seperate PHY configuration.
+* We use 2 bits for each MAC in the scratch register(D[15:11] in 0x1E6E2040) to
+* inform kernel driver.
+* The meanings of the 2 bits are:
+* 00(0): Dedicated PHY
+* 01(1): ASPEED's EVA + INTEL's NC-SI PHY chip EVA
+* 10(2): ASPEED's MAC is connected to NC-SI PHY chip directly
+* 11: Reserved
+*
+* We use CONFIG_MAC1_PHY_SETTING and CONFIG_MAC2_PHY_SETTING in U-Boot
+* 0: Dedicated PHY
+* 1: ASPEED's EVA + INTEL's NC-SI PHY chip EVA
+* 2: ASPEED's MAC is connected to NC-SI PHY chip directly
+* 3: Reserved
+*-------------------------------------------------------------------------------
+*/
+#define CONFIG_MAC1_PHY_SETTING		0
+#define CONFIG_MAC2_PHY_SETTING		0
+#define CONFIG_MAC_INTERFACE_CLOCK_DELAY	0x2255
+#define CONFIG_NET_MULTI
+#define CONFIG_ETHACT			aspeednic#0
+#define CONFIG_GATEWAYIP		192.168.0.1
+#define CONFIG_NETMASK			255.255.255.0
+#define CONFIG_IPADDR			192.168.0.45
+#define CONFIG_SERVERIP			192.168.0.53
+#define CONFIG_ETHADDR			00:C0:A8:12:34:56
+#define CONFIG_ETH1ADDR			00:C0:A8:12:34:57
+
+/*
+ * SLT
+ */
+/*
+#define CONFIG_SLT
+#define CFG_CMD_SLT		(CFG_CMD_VIDEOTEST | CFG_CMD_MACTEST | CFG_CMD_HACTEST | CFG_CMD_MICTEST)
+*/
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ast2400_nor.h b/include/configs/ast2400_nor.h
new file mode 100644
index 0000000..5b10b36
--- /dev/null
+++ b/include/configs/ast2400_nor.h
@@ -0,0 +1,322 @@
+/*
+ * (C) Copyright 2004
+ * Peter Chen <peterc@socle-tech.com.tw>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+//#define CONFIG_INIT_CRITICAL			/* define for U-BOOT 1.1.1 */
+#undef  CONFIG_INIT_CRITICAL			/* undef for  U-BOOT 1.1.4 */ 
+#define CONFIG_ARM926EJS	1		/* This is an arm926ejs CPU */
+#define	CONFIG_ASPEED		1
+#define CONFIG_AST2400		1
+#define CONFIG_SYS_FLASH_CFI			/* CONFIG_FLASH_CFI, CONFIG_FLASH_SPI is exclusive*/
+//#define CONFIG_FLASH_SPI
+//#define CONFIG_2SPIFLASH			/* Boot SPI: CS2, 2nd SPI: CS0 */
+#undef CONFIG_2SPIFLASH
+#undef CONFIG_ASPEED_SLT
+#define CONFIG_FLASH_AST2300
+#define CONFIG_FLASH_AST2300_DMA
+//#define CONFIG_FLASH_SPIx2_Dummy
+//#define CONFIG_FLASH_SPIx4_Dummy
+#define CONFIG_CRT_DISPLAY	1		/* undef if not support CRT */
+
+//#define CONFIG_USE_IRQ				/* we don't need IRQ/FIQ stuff */
+#define CONFIG_MISC_INIT_R 
+
+/*
+ * DRAM Config
+ *
+ * 1. DRAM Size              //
+ *    CONFIG_DRAM_512MBIT    // 512M bit
+ *    CONFIG_DRAM_1GBIT      // 1G   bit (default)
+ *    CONFIG_DRAM_2GBIT      // 2G   bit
+ *    CONFIG_DRAM_4GBIT      // 4G   bit 
+ * 2. DRAM Speed             //
+ *    CONFIG_DRAM_336        // 336MHz (DDR-667)
+ *    CONFIG_DRAM_408        // 408MHz (DDR-800) (default)
+ * 3. VGA Mode
+ *    CONFIG_CRT_DISPLAY     // define to disable VGA function
+ * 4. ECC Function enable
+ *    CONFIG_DRAM_ECC        // define to enable ECC function
+ * 5. UART Debug Message
+ *    CONFIG_DRAM_UART_OUT   // enable output message at UART5
+ *    CONFIG_DRAM_UART_38400 // set the UART baud rate to 38400, default is 115200
+ */
+ 
+//1. DRAM Size
+//#define    CONFIG_DRAM_512MBIT
+#define    CONFIG_DRAM_1GBIT
+//#define    CONFIG_DRAM_2GBIT
+//#define    CONFIG_DRAM_4GBIT
+//2. DRAM Speed
+//#define    CONFIG_DRAM_336
+#define    CONFIG_DRAM_408
+//3. VGA Mode
+//#define    CONFIG_CRT_DISPLAY
+//4. ECC Function enable
+//#define    CONFIG_DRAM_ECC
+//5. UART Debug Message
+#define    CONFIG_DRAM_UART_OUT
+//#define    CONFIG_DRAM_UART_38400
+
+
+
+/* 
+ * Environment Config
+ */
+#define CONFIG_CMDLINE_TAG	 1		/* enable passing of ATAGs	*/
+#define CONFIG_SETUP_MEMORY_TAGS 1
+#define CONFIG_INITRD_TAG	 1
+#define	CONFIG_BOOTARGS 	"debug console=ttyS0,115200n8 ramdisk_size=16384 root=/dev/ram rw init=/linuxrc mem=80M"
+#define CONFIG_BOOTDELAY	3		/* autoboot after 3 seconds	*/
+#ifdef CONFIG_FLASH_AST2300
+#define CONFIG_BOOTCOMMAND	"bootm 20080000 20300000"
+#else
+#ifdef	CONFIG_SYS_FLASH_CFI 
+#define CONFIG_BOOTCOMMAND	"bootm 10080000 10300000"
+#else
+#define CONFIG_BOOTCOMMAND	"bootm 14080000 14300000"
+#endif
+#endif
+#define CONFIG_BOOTFILE		"all.bin"
+#define CONFIG_ENV_OVERWRITE
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_DFL
+#define CONFIG_CMD_ENV
+#define CONFIG_CMD_FLASH
+#define CONFIG_CMD_NET
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_EEPROM
+
+/* 
+ * CPU Setting
+ */
+#define CPU_CLOCK_RATE		18000000	/* 16.5 MHz clock for the ARM core */
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 768*1024)
+#define CONFIG_SYS_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+
+/*
+ * Stack sizes,  The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128*1024)	/* regular stack */
+#define CONFIG_STACKSIZE_IRQ	(4*1024)	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
+
+/*
+ * Memory Configuration
+ */
+#define CONFIG_NR_DRAM_BANKS	1	   	/* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0x40000000 	/* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE	0x4000000 	/* 64 MB */
+
+#define CONFIG_SYS_SDRAM_BASE	0x40000000
+
+/*
+ * FLASH Configuration
+ */
+#ifdef CONFIG_SYS_FLASH_CFI				/* NOR Flash */
+
+#ifdef CONFIG_FLASH_AST2300
+#define PHYS_FLASH_1			0x20000000 	/* Flash Bank #1 */
+#else
+#define PHYS_FLASH_1			0x10000000 	/* Flash Bank #1 */
+#endif
+
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_1
+#define CONFIG_FLASH_BANKS_LIST 	{ PHYS_FLASH_1 }
+
+#define CONFIG_SYS_MAX_FLASH_BANKS 	1
+#define CONFIG_SYS_MAX_FLASH_SECT	(256)		/* max number of sectors on one chip */
+
+#define CONFIG_ENV_IS_IN_FLASH	1
+#define CONFIG_ENV_OFFSET			0x60000 	/* environment starts here  */
+#define CONFIG_ENV_SIZE			0x20000 	/* Total Size of Environment Sector */
+
+#define CONFIG_SYS_FLASH_CFI_AMD_RESET
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+
+#else						/* SPI Flash */
+
+#ifdef CONFIG_FLASH_AST2300
+#define PHYS_FLASH_1		0x20000000 	/* Flash Bank #1 */
+#else
+#define PHYS_FLASH_1		0x14000000 	/* Flash Bank #1 */
+#define PHYS_FLASH_2		0x14800000 	/* Flash Bank #2 */
+#define PHYS_FLASH_2_BASE	0x10000000
+#endif
+
+#ifdef CONFIG_2SPIFLASH
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_2_BASE
+#define CONFIG_FLASH_BANKS_LIST 	{ PHYS_FLASH_1, PHYS_FLASH_2 }
+#define CONFIG_SYS_MAX_FLASH_BANKS 	2
+#define CONFIG_SYS_MAX_FLASH_SECT	(1024)		/* max number of sectors on one chip */
+
+#define CONFIG_ENV_IS_IN_FLASH		1
+#define CONFIG_ENV_OFFSET		0x7F0000 	/* environment starts here  */
+#define CONFIG_ENV_SIZE			0x010000 	/* Total Size of Environment Sector */
+#else
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_1
+#define CONFIG_FLASH_BANKS_LIST 	{ PHYS_FLASH_1 }
+#define CONFIG_SYS_MAX_FLASH_BANKS 	1
+#define CONFIG_SYS_MAX_FLASH_SECT	(1024)		/* max number of sectors on one chip */
+
+#define CONFIG_ENV_IS_IN_FLASH		1
+#define CONFIG_ENV_OFFSET		0x7F0000 	/* environment starts here  */
+#define CONFIG_ENV_SIZE			0x010000 	/* Total Size of Environment Sector */
+#endif
+
+#endif
+
+#define __LITTLE_ENDIAN
+
+#define CONFIG_MONITOR_BASE		TEXT_BASE
+#define CONFIG_MONITOR_LEN		(192 << 10)
+
+/* timeout values are in ticks */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	(20*CONFIG_SYS_HZ) 	/* Timeout for Flash Erase */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	(20*CONFIG_SYS_HZ) 	/* Timeout for Flash Write */
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP				/* undef to save memory		*/
+
+#define CONFIG_SYS_PROMPT		"boot# " 	/* Monitor Command Prompt	*/
+#define CONFIG_SYS_CBSIZE		256		/* Console I/O Buffer Size	*/
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16) /* Print Buffer Size */
+#define CONFIG_SYS_MAXARGS		16		/* max number of command args	*/
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE	/* Boot Argument Buffer Size	*/
+
+#define CONFIG_SYS_MEMTEST_START	0x40000000	/* memtest works on	*/
+#define CONFIG_SYS_MEMTEST_END		0x44FFFFFF	/* 256 MB in DRAM	*/
+
+#define	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+#undef	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+#define CONFIG_SYS_LOAD_ADDR		0x43000000	/* default load address */
+
+#define CONFIG_SYS_TIMERBASE		0x1E782000	/* use timer 1 */
+#define CONFIG_SYS_HZ			(1*1000*1000)	/* use external clk (1M) */
+
+/*
+ * Serial Configuration
+ */
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	4
+#define CONFIG_SYS_NS16550_CLK		24000000
+#define CONFIG_SYS_NS16550_COM1		0x1e783000
+#define CONFIG_SYS_NS16550_COM2		0x1e784000
+#define	CONFIG_SYS_LOADS_BAUD_CHANGE
+#define CONFIG_SERIAL1			1
+#define CONFIG_CONS_INDEX		2
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/*
+ * USB device configuration
+ */
+/*
+#define CONFIG_USB_DEVICE		1
+#define CONFIG_USB_TTY			1
+
+#define CONFIG_USBD_VENDORID		0x1234
+#define CONFIG_USBD_PRODUCTID		0x5678
+#define CONFIG_USBD_MANUFACTURER	"Siemens"
+#define CONFIG_USBD_PRODUCT_NAME	"SX1"
+*/
+
+/*
+ * I2C configuration
+ */
+#define CONFIG_HARD_I2C
+#define CONFIG_SYS_I2C_SPEED		100000
+#define CONFIG_SYS_I2C_SLAVE		1
+#define CONFIG_DRIVER_ASPEED_I2C
+
+/*
+* EEPROM configuration
+*/
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN 	2
+#define CONFIG_SYS_I2C_EEPROM_ADDR 	0xa0
+
+/*
+ * NIC configuration
+ */
+#define __BYTE_ORDER __LITTLE_ENDIAN
+#define __LITTLE_ENDIAN_BITFIELD
+#define CONFIG_MAC_PARTITION
+#define CONFIG_ASPEEDNIC
+#define CONFIG_MAC1_PHY_LINK_INTERRUPT
+#define CONFIG_MAC2_ENABLE
+#define CONFIG_MAC2_PHY_LINK_INTERRUPT
+/*
+*-------------------------------------------------------------------------------
+* NOTICE: MAC1 and MAC2 now have their own seperate PHY configuration.
+* We use 2 bits for each MAC in the scratch register(D[15:11] in 0x1E6E2040) to
+* inform kernel driver.
+* The meanings of the 2 bits are:
+* 00(0): Dedicated PHY
+* 01(1): ASPEED's EVA + INTEL's NC-SI PHY chip EVA
+* 10(2): ASPEED's MAC is connected to NC-SI PHY chip directly
+* 11: Reserved
+*
+* We use CONFIG_MAC1_PHY_SETTING and CONFIG_MAC2_PHY_SETTING in U-Boot
+* 0: Dedicated PHY
+* 1: ASPEED's EVA + INTEL's NC-SI PHY chip EVA
+* 2: ASPEED's MAC is connected to NC-SI PHY chip directly
+* 3: Reserved
+*-------------------------------------------------------------------------------
+*/
+#define CONFIG_MAC1_PHY_SETTING		0
+#define CONFIG_MAC2_PHY_SETTING		0
+#define CONFIG_MAC_INTERFACE_CLOCK_DELAY	0x2255
+#define CONFIG_NET_MULTI
+#define CONFIG_ETHACT			aspeednic#0
+#define CONFIG_GATEWAYIP		192.168.0.1
+#define CONFIG_NETMASK			255.255.255.0
+#define CONFIG_IPADDR			192.168.0.188
+#define CONFIG_SERVERIP			192.168.0.106
+#define CONFIG_ETHADDR			00:C0:A8:12:34:56
+#define CONFIG_ETH1ADDR			00:C0:A8:12:34:57
+
+/*
+ * SLT
+ */
+/*
+#define CONFIG_SLT
+#define CFG_CMD_SLT		(CFG_CMD_VIDEOTEST | CFG_CMD_MACTEST | CFG_CMD_HACTEST | CFG_CMD_MICTEST)
+*/
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ast2400_slt.h b/include/configs/ast2400_slt.h
new file mode 100644
index 0000000..cfa1c31
--- /dev/null
+++ b/include/configs/ast2400_slt.h
@@ -0,0 +1,329 @@
+/*
+ * (C) Copyright 2004
+ * Peter Chen <peterc@socle-tech.com.tw>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+//#define CONFIG_INIT_CRITICAL			/* define for U-BOOT 1.1.1 */
+#undef  CONFIG_INIT_CRITICAL			/* undef for  U-BOOT 1.1.4 */ 
+//#define CONFIG_FPGA_ASPEED	1
+#define CONFIG_ARM926EJS	1		/* This is an arm926ejs CPU */
+#define	CONFIG_ASPEED		1
+#define CONFIG_AST2400		1
+#define CONFIG_SLT_ASPEED	1
+//#define CONFIG_AST1070		1
+//#define CONFIG_SYS_FLASH_CFI			/* CONFIG_FLASH_CFI, CONFIG_FLASH_SPI is exclusive*/
+#define CONFIG_FLASH_SPI
+//#define CONFIG_2SPIFLASH			/* Boot SPI: CS2, 2nd SPI: CS0 */
+#undef CONFIG_2SPIFLASH
+#undef CONFIG_ASPEED_SLT
+#define CONFIG_FLASH_AST2300
+//#define CONFIG_FLASH_AST2300_DMA
+//#define CONFIG_FLASH_SPIx2_Dummy
+//#define CONFIG_FLASH_SPIx4_Dummy
+#define CONFIG_CRT_DISPLAY	1		/* undef if not support CRT */
+
+//#define CONFIG_USE_IRQ				/* we don't need IRQ/FIQ stuff */
+#define CONFIG_MISC_INIT_R 
+
+/*
+ * DRAM Config
+ *
+ * 1. DRAM Size              //
+ *    CONFIG_DRAM_512MBIT    // 512M bit
+ *    CONFIG_DRAM_1GBIT      // 1G   bit (default)
+ *    CONFIG_DRAM_2GBIT      // 2G   bit
+ *    CONFIG_DRAM_4GBIT      // 4G   bit 
+ * 2. DRAM Speed             //
+ *    CONFIG_DRAM_336        // 336MHz (DDR-667)
+ *    CONFIG_DRAM_408        // 408MHz (DDR-800) (default)
+ * 3. VGA Mode
+ *    CONFIG_CRT_DISPLAY     // define to disable VGA function
+ * 4. ECC Function enable
+ *    CONFIG_DRAM_ECC        // define to enable ECC function
+ * 5. UART Debug Message
+ *    CONFIG_DRAM_UART_OUT   // enable output message at UART5
+ *    CONFIG_DRAM_UART_38400 // set the UART baud rate to 38400, default is 115200
+ */
+ 
+//1. DRAM Size
+//#define    CONFIG_DRAM_512MBIT
+#define    CONFIG_DRAM_1GBIT
+//#define    CONFIG_DRAM_2GBIT
+//#define    CONFIG_DRAM_4GBIT
+//2. DRAM Speed
+//#define    CONFIG_DRAM_336
+#define    CONFIG_DRAM_408
+//3. VGA Mode
+//#define    CONFIG_CRT_DISPLAY
+//4. ECC Function enable
+//#define    CONFIG_DRAM_ECC
+//5. UART Debug Message
+#define    CONFIG_DRAM_UART_OUT
+//#define    CONFIG_DRAM_UART_38400
+
+
+
+/* 
+ * Environment Config
+ */
+#define CONFIG_CMDLINE_TAG	 1		/* enable passing of ATAGs	*/
+#define CONFIG_SETUP_MEMORY_TAGS 1
+#define CONFIG_INITRD_TAG	 1
+#define	CONFIG_BOOTARGS 	"debug console=ttyS0,115200n8 ramdisk_size=16384 root=/dev/ram rw init=/linuxrc mem=32M"
+#define CONFIG_UPDATE           "tftp 40800000 ast2400.scr; so 40800000'"
+
+#define CONFIG_BOOTDELAY	0		/* autoboot after 3 seconds	*/
+#ifdef CONFIG_FLASH_AST2300
+#define CONFIG_BOOTCOMMAND	"mactest 0 0 24 2 0 0 0; mactest 1 0 24 2 0 0 0; bootm 20080000 20300000"
+#else
+#ifdef	CONFIG_SYS_FLASH_CFI 
+#define CONFIG_BOOTCOMMAND	"bootm 10080000 10300000"
+#else
+#define CONFIG_BOOTCOMMAND	"bootm 14080000 14300000"
+#endif
+#endif
+#define CONFIG_BOOTFILE		"all.bin"
+#define CONFIG_ENV_OVERWRITE
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_DFL
+#define CONFIG_CMD_ENV
+#define CONFIG_CMD_FLASH
+#define CONFIG_CMD_NET
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_EEPROM
+#define CONFIG_CMD_NETTEST
+#define CONFIG_CMD_SLT
+
+/* 
+ * CPU Setting
+ */
+#define CPU_CLOCK_RATE		18000000	/* 16.5 MHz clock for the ARM core */
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 768*1024)
+#define CONFIG_SYS_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+
+/*
+ * Stack sizes,  The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128*1024)	/* regular stack */
+#define CONFIG_STACKSIZE_IRQ	(4*1024)	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
+
+/*
+ * Memory Configuration
+ */
+#define CONFIG_NR_DRAM_BANKS	1	   	/* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0x40000000 	/* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE	0x4000000 	/* 64 MB */
+
+#define CONFIG_SYS_SDRAM_BASE	0x40000000
+
+/*
+ * FLASH Configuration
+ */
+#ifdef CONFIG_SYS_FLASH_CFI				/* NOR Flash */
+
+#ifdef CONFIG_FLASH_AST2300
+#define PHYS_FLASH_1			0x20000000 	/* Flash Bank #1 */
+#else
+#define PHYS_FLASH_1			0x10000000 	/* Flash Bank #1 */
+#endif
+
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_1
+#define CONFIG_FLASH_BANKS_LIST 	{ PHYS_FLASH_1 }
+
+#define CONFIG_SYS_MAX_FLASH_BANKS 	1
+#define CONFIG_SYS_MAX_FLASH_SECT	(256)		/* max number of sectors on one chip */
+
+#define CONFIG_ENV_IS_IN_FLASH	1
+#define CONFIG_ENV_OFFSET		0xFE0000 	/* environment starts here  */
+#define CONFIG_ENV_SIZE			0x020000 	/* Total Size of Environment Sector */
+
+#define CONFIG_SYS_FLASH_CFI_AMD_RESET
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+
+#else						/* SPI Flash */
+
+#ifdef CONFIG_FLASH_AST2300
+#define PHYS_FLASH_1		0x20000000 	/* Flash Bank #1 */
+#else
+#define PHYS_FLASH_1		0x14000000 	/* Flash Bank #1 */
+#define PHYS_FLASH_2		0x14800000 	/* Flash Bank #2 */
+#define PHYS_FLASH_2_BASE	0x10000000
+#endif
+
+#ifdef CONFIG_2SPIFLASH
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_2_BASE
+#define CONFIG_FLASH_BANKS_LIST 	{ PHYS_FLASH_1, PHYS_FLASH_2 }
+#define CONFIG_SYS_MAX_FLASH_BANKS 	2
+#define CONFIG_SYS_MAX_FLASH_SECT	(1024)		/* max number of sectors on one chip */
+
+#define CONFIG_ENV_IS_IN_FLASH		1
+#define CONFIG_ENV_OFFSET		0x7F0000 	/* environment starts here  */
+#define CONFIG_ENV_SIZE			0x010000 	/* Total Size of Environment Sector */
+#else
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_1
+#define CONFIG_FLASH_BANKS_LIST 	{ PHYS_FLASH_1 }
+#define CONFIG_SYS_MAX_FLASH_BANKS 	1
+#define CONFIG_SYS_MAX_FLASH_SECT	(1024)		/* max number of sectors on one chip */
+
+#define CONFIG_ENV_IS_IN_FLASH		1
+#define CONFIG_ENV_OFFSET		0x7F0000 	/* environment starts here  */
+#define CONFIG_ENV_SIZE			0x010000 	/* Total Size of Environment Sector */
+#endif
+
+#endif
+
+#define __LITTLE_ENDIAN
+
+#define CONFIG_MONITOR_BASE		TEXT_BASE
+#define CONFIG_MONITOR_LEN		(192 << 10)
+
+/* timeout values are in ticks */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	(20*CONFIG_SYS_HZ) 	/* Timeout for Flash Erase */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	(20*CONFIG_SYS_HZ) 	/* Timeout for Flash Write */
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP				/* undef to save memory		*/
+
+#define CONFIG_SYS_PROMPT		"boot# " 	/* Monitor Command Prompt	*/
+#define CONFIG_SYS_CBSIZE		256		/* Console I/O Buffer Size	*/
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16) /* Print Buffer Size */
+#define CONFIG_SYS_MAXARGS		16		/* max number of command args	*/
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE	/* Boot Argument Buffer Size	*/
+
+#define CONFIG_SYS_MEMTEST_START	0x40000000	/* memtest works on	*/
+#define CONFIG_SYS_MEMTEST_END		0x44FFFFFF	/* 256 MB in DRAM	*/
+
+#define	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+#undef	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+#define CONFIG_SYS_LOAD_ADDR		0x43000000	/* default load address */
+
+#define CONFIG_SYS_TIMERBASE		0x1E782000	/* use timer 1 */
+#define CONFIG_SYS_HZ			(1*1000*1000)	/* use external clk (1M) */
+
+/*
+ * Serial Configuration
+ */
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	4
+#define CONFIG_SYS_NS16550_CLK		24000000
+#define CONFIG_SYS_NS16550_COM1		0x1e783000
+#define CONFIG_SYS_NS16550_COM2		0x1e784000
+#define	CONFIG_SYS_LOADS_BAUD_CHANGE
+#define CONFIG_SERIAL1			1
+#define CONFIG_CONS_INDEX		2
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/*
+ * USB device configuration
+ */
+/*
+#define CONFIG_USB_DEVICE		1
+#define CONFIG_USB_TTY			1
+
+#define CONFIG_USBD_VENDORID		0x1234
+#define CONFIG_USBD_PRODUCTID		0x5678
+#define CONFIG_USBD_MANUFACTURER	"Siemens"
+#define CONFIG_USBD_PRODUCT_NAME	"SX1"
+*/
+
+/*
+ * I2C configuration
+ */
+#define CONFIG_HARD_I2C
+#define CONFIG_SYS_I2C_SPEED		100000
+#define CONFIG_SYS_I2C_SLAVE		1
+#define CONFIG_DRIVER_ASPEED_I2C
+
+/*
+* EEPROM configuration
+*/
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN 	2
+#define CONFIG_SYS_I2C_EEPROM_ADDR 	0xa0
+
+/*
+ * NIC configuration
+ */
+#define __BYTE_ORDER __LITTLE_ENDIAN
+#define __LITTLE_ENDIAN_BITFIELD
+#define CONFIG_MAC_PARTITION
+/*#define CONFIG_ASPEEDNIC*/
+#define CONFIG_MAC1_PHY_LINK_INTERRUPT
+#define CONFIG_MAC2_ENABLE
+#define CONFIG_MAC2_PHY_LINK_INTERRUPT
+/*
+*-------------------------------------------------------------------------------
+* NOTICE: MAC1 and MAC2 now have their own seperate PHY configuration.
+* We use 2 bits for each MAC in the scratch register(D[15:11] in 0x1E6E2040) to
+* inform kernel driver.
+* The meanings of the 2 bits are:
+* 00(0): Dedicated PHY
+* 01(1): ASPEED's EVA + INTEL's NC-SI PHY chip EVA
+* 10(2): ASPEED's MAC is connected to NC-SI PHY chip directly
+* 11: Reserved
+*
+* We use CONFIG_MAC1_PHY_SETTING and CONFIG_MAC2_PHY_SETTING in U-Boot
+* 0: Dedicated PHY
+* 1: ASPEED's EVA + INTEL's NC-SI PHY chip EVA
+* 2: ASPEED's MAC is connected to NC-SI PHY chip directly
+* 3: Reserved
+*-------------------------------------------------------------------------------
+*/
+#define CONFIG_MAC1_PHY_SETTING		0
+#define CONFIG_MAC2_PHY_SETTING		0
+#define CONFIG_MAC_INTERFACE_CLOCK_DELAY	0x2255
+#define CONFIG_NET_MULTI
+#define CONFIG_ETHACT			aspeednic#0
+#define CONFIG_GATEWAYIP		192.168.0.1
+#define CONFIG_NETMASK			255.255.255.0
+#define CONFIG_IPADDR			192.168.0.45
+#define CONFIG_SERVERIP			192.168.0.81
+#define CONFIG_ETHADDR			00:C0:A8:12:34:56
+#define CONFIG_ETH1ADDR			00:C0:A8:12:34:57
+
+/*
+ * SLT
+ */
+/*
+#define CONFIG_SLT
+#define CFG_CMD_SLT		(CFG_CMD_VIDEOTEST | CFG_CMD_MACTEST | CFG_CMD_HACTEST | CFG_CMD_MICTEST)
+*/
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ast2400_spi.h b/include/configs/ast2400_spi.h
new file mode 100644
index 0000000..398e168
--- /dev/null
+++ b/include/configs/ast2400_spi.h
@@ -0,0 +1,322 @@
+/*
+ * (C) Copyright 2004
+ * Peter Chen <peterc@socle-tech.com.tw>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+//#define CONFIG_INIT_CRITICAL			/* define for U-BOOT 1.1.1 */
+#undef  CONFIG_INIT_CRITICAL			/* undef for  U-BOOT 1.1.4 */ 
+#define CONFIG_ARM926EJS	1		/* This is an arm926ejs CPU */
+#define	CONFIG_ASPEED		1
+#define CONFIG_AST2400		1
+//#define CONFIG_SYS_FLASH_CFI			/* CONFIG_FLASH_CFI, CONFIG_FLASH_SPI is exclusive*/
+#define CONFIG_FLASH_SPI
+//#define CONFIG_2SPIFLASH			/* Boot SPI: CS2, 2nd SPI: CS0 */
+#undef CONFIG_2SPIFLASH
+#undef CONFIG_ASPEED_SLT
+#define CONFIG_FLASH_AST2300
+#define CONFIG_FLASH_AST2300_DMA
+//#define CONFIG_FLASH_SPIx2_Dummy
+//#define CONFIG_FLASH_SPIx4_Dummy
+#define CONFIG_CRT_DISPLAY	1		/* undef if not support CRT */
+
+//#define CONFIG_USE_IRQ				/* we don't need IRQ/FIQ stuff */
+#define CONFIG_MISC_INIT_R 
+
+/*
+ * DRAM Config
+ *
+ * 1. DRAM Size              //
+ *    CONFIG_DRAM_512MBIT    // 512M bit
+ *    CONFIG_DRAM_1GBIT      // 1G   bit (default)
+ *    CONFIG_DRAM_2GBIT      // 2G   bit
+ *    CONFIG_DRAM_4GBIT      // 4G   bit 
+ * 2. DRAM Speed             //
+ *    CONFIG_DRAM_336        // 336MHz (DDR-667)
+ *    CONFIG_DRAM_408        // 408MHz (DDR-800) (default)
+ * 3. VGA Mode
+ *    CONFIG_CRT_DISPLAY     // define to disable VGA function
+ * 4. ECC Function enable
+ *    CONFIG_DRAM_ECC        // define to enable ECC function
+ * 5. UART Debug Message
+ *    CONFIG_DRAM_UART_OUT   // enable output message at UART5
+ *    CONFIG_DRAM_UART_38400 // set the UART baud rate to 38400, default is 115200
+ */
+ 
+//1. DRAM Size
+//#define    CONFIG_DRAM_512MBIT
+#define    CONFIG_DRAM_1GBIT
+//#define    CONFIG_DRAM_2GBIT
+//#define    CONFIG_DRAM_4GBIT
+//2. DRAM Speed
+//#define    CONFIG_DRAM_336
+#define    CONFIG_DRAM_408
+//3. VGA Mode
+//#define    CONFIG_CRT_DISPLAY
+//4. ECC Function enable
+//#define    CONFIG_DRAM_ECC
+//5. UART Debug Message
+#define    CONFIG_DRAM_UART_OUT
+//#define    CONFIG_DRAM_UART_38400
+
+
+
+/* 
+ * Environment Config
+ */
+#define CONFIG_CMDLINE_TAG	 1		/* enable passing of ATAGs	*/
+#define CONFIG_SETUP_MEMORY_TAGS 1
+#define CONFIG_INITRD_TAG	 1
+#define	CONFIG_BOOTARGS 	"debug console=ttyS0,115200n8 ramdisk_size=16384 root=/dev/ram rw init=/linuxrc mem=80M"
+#define CONFIG_BOOTDELAY	3		/* autoboot after 3 seconds	*/
+#ifdef CONFIG_FLASH_AST2300
+#define CONFIG_BOOTCOMMAND	"bootm 20080000 20300000"
+#else
+#ifdef	CONFIG_SYS_FLASH_CFI 
+#define CONFIG_BOOTCOMMAND	"bootm 10080000 10300000"
+#else
+#define CONFIG_BOOTCOMMAND	"bootm 14080000 14300000"
+#endif
+#endif
+#define CONFIG_BOOTFILE		"all.bin"
+#define CONFIG_ENV_OVERWRITE
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_DFL
+#define CONFIG_CMD_ENV
+#define CONFIG_CMD_FLASH
+#define CONFIG_CMD_NET
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_EEPROM
+
+/* 
+ * CPU Setting
+ */
+#define CPU_CLOCK_RATE		18000000	/* 16.5 MHz clock for the ARM core */
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 768*1024)
+#define CONFIG_SYS_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+
+/*
+ * Stack sizes,  The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128*1024)	/* regular stack */
+#define CONFIG_STACKSIZE_IRQ	(4*1024)	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
+
+/*
+ * Memory Configuration
+ */
+#define CONFIG_NR_DRAM_BANKS	1	   	/* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0x40000000 	/* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE	0x4000000 	/* 64 MB */
+
+#define CONFIG_SYS_SDRAM_BASE	0x40000000
+
+/*
+ * FLASH Configuration
+ */
+#ifdef CONFIG_SYS_FLASH_CFI				/* NOR Flash */
+
+#ifdef CONFIG_FLASH_AST2300
+#define PHYS_FLASH_1			0x20000000 	/* Flash Bank #1 */
+#else
+#define PHYS_FLASH_1			0x10000000 	/* Flash Bank #1 */
+#endif
+
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_1
+#define CONFIG_FLASH_BANKS_LIST 	{ PHYS_FLASH_1 }
+
+#define CONFIG_SYS_MAX_FLASH_BANKS 	1
+#define CONFIG_SYS_MAX_FLASH_SECT	(256)		/* max number of sectors on one chip */
+
+#define CONFIG_ENV_IS_IN_FLASH	1
+#define CONFIG_ENV_OFFSET			0x60000 	/* environment starts here  */
+#define CONFIG_ENV_SIZE			0x20000 	/* Total Size of Environment Sector */
+
+#define CONFIG_SYS_FLASH_CFI_AMD_RESET
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+
+#else						/* SPI Flash */
+
+#ifdef CONFIG_FLASH_AST2300
+#define PHYS_FLASH_1		0x20000000 	/* Flash Bank #1 */
+#else
+#define PHYS_FLASH_1		0x14000000 	/* Flash Bank #1 */
+#define PHYS_FLASH_2		0x14800000 	/* Flash Bank #2 */
+#define PHYS_FLASH_2_BASE	0x10000000
+#endif
+
+#ifdef CONFIG_2SPIFLASH
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_2_BASE
+#define CONFIG_FLASH_BANKS_LIST 	{ PHYS_FLASH_1, PHYS_FLASH_2 }
+#define CONFIG_SYS_MAX_FLASH_BANKS 	2
+#define CONFIG_SYS_MAX_FLASH_SECT	(1024)		/* max number of sectors on one chip */
+
+#define CONFIG_ENV_IS_IN_FLASH		1
+#define CONFIG_ENV_OFFSET		0x7F0000 	/* environment starts here  */
+#define CONFIG_ENV_SIZE			0x010000 	/* Total Size of Environment Sector */
+#else
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_1
+#define CONFIG_FLASH_BANKS_LIST 	{ PHYS_FLASH_1 }
+#define CONFIG_SYS_MAX_FLASH_BANKS 	1
+#define CONFIG_SYS_MAX_FLASH_SECT	(1024)		/* max number of sectors on one chip */
+
+#define CONFIG_ENV_IS_IN_FLASH		1
+#define CONFIG_ENV_OFFSET		0x7F0000 	/* environment starts here  */
+#define CONFIG_ENV_SIZE			0x010000 	/* Total Size of Environment Sector */
+#endif
+
+#endif
+
+#define __LITTLE_ENDIAN
+
+#define CONFIG_MONITOR_BASE		TEXT_BASE
+#define CONFIG_MONITOR_LEN		(192 << 10)
+
+/* timeout values are in ticks */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	(20*CONFIG_SYS_HZ) 	/* Timeout for Flash Erase */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	(20*CONFIG_SYS_HZ) 	/* Timeout for Flash Write */
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP				/* undef to save memory		*/
+
+#define CONFIG_SYS_PROMPT		"boot# " 	/* Monitor Command Prompt	*/
+#define CONFIG_SYS_CBSIZE		256		/* Console I/O Buffer Size	*/
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16) /* Print Buffer Size */
+#define CONFIG_SYS_MAXARGS		16		/* max number of command args	*/
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE	/* Boot Argument Buffer Size	*/
+
+#define CONFIG_SYS_MEMTEST_START	0x40000000	/* memtest works on	*/
+#define CONFIG_SYS_MEMTEST_END		0x44FFFFFF	/* 256 MB in DRAM	*/
+
+#define	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+#undef	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+#define CONFIG_SYS_LOAD_ADDR		0x43000000	/* default load address */
+
+#define CONFIG_SYS_TIMERBASE		0x1E782000	/* use timer 1 */
+#define CONFIG_SYS_HZ			(1*1000*1000)	/* use external clk (1M) */
+
+/*
+ * Serial Configuration
+ */
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	4
+#define CONFIG_SYS_NS16550_CLK		24000000
+#define CONFIG_SYS_NS16550_COM1		0x1e783000
+#define CONFIG_SYS_NS16550_COM2		0x1e784000
+#define	CONFIG_SYS_LOADS_BAUD_CHANGE
+#define CONFIG_SERIAL1			1
+#define CONFIG_CONS_INDEX		2
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/*
+ * USB device configuration
+ */
+/*
+#define CONFIG_USB_DEVICE		1
+#define CONFIG_USB_TTY			1
+
+#define CONFIG_USBD_VENDORID		0x1234
+#define CONFIG_USBD_PRODUCTID		0x5678
+#define CONFIG_USBD_MANUFACTURER	"Siemens"
+#define CONFIG_USBD_PRODUCT_NAME	"SX1"
+*/
+
+/*
+ * I2C configuration
+ */
+#define CONFIG_HARD_I2C
+#define CONFIG_SYS_I2C_SPEED		100000
+#define CONFIG_SYS_I2C_SLAVE		1
+#define CONFIG_DRIVER_ASPEED_I2C
+
+/*
+* EEPROM configuration
+*/
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN 	2
+#define CONFIG_SYS_I2C_EEPROM_ADDR 	0xa0
+
+/*
+ * NIC configuration
+ */
+#define __BYTE_ORDER __LITTLE_ENDIAN
+#define __LITTLE_ENDIAN_BITFIELD
+#define CONFIG_MAC_PARTITION
+#define CONFIG_ASPEEDNIC
+#define CONFIG_MAC1_PHY_LINK_INTERRUPT
+#define CONFIG_MAC2_ENABLE
+#define CONFIG_MAC2_PHY_LINK_INTERRUPT
+/*
+*-------------------------------------------------------------------------------
+* NOTICE: MAC1 and MAC2 now have their own seperate PHY configuration.
+* We use 2 bits for each MAC in the scratch register(D[15:11] in 0x1E6E2040) to
+* inform kernel driver.
+* The meanings of the 2 bits are:
+* 00(0): Dedicated PHY
+* 01(1): ASPEED's EVA + INTEL's NC-SI PHY chip EVA
+* 10(2): ASPEED's MAC is connected to NC-SI PHY chip directly
+* 11: Reserved
+*
+* We use CONFIG_MAC1_PHY_SETTING and CONFIG_MAC2_PHY_SETTING in U-Boot
+* 0: Dedicated PHY
+* 1: ASPEED's EVA + INTEL's NC-SI PHY chip EVA
+* 2: ASPEED's MAC is connected to NC-SI PHY chip directly
+* 3: Reserved
+*-------------------------------------------------------------------------------
+*/
+#define CONFIG_MAC1_PHY_SETTING		0
+#define CONFIG_MAC2_PHY_SETTING		0
+#define CONFIG_MAC_INTERFACE_CLOCK_DELAY	0x2255
+#define CONFIG_NET_MULTI
+#define CONFIG_ETHACT			aspeednic#0
+#define CONFIG_GATEWAYIP		192.168.0.1
+#define CONFIG_NETMASK			255.255.255.0
+#define CONFIG_IPADDR			192.168.0.45
+#define CONFIG_SERVERIP			192.168.0.81
+#define CONFIG_ETHADDR			00:C0:A8:12:34:56
+#define CONFIG_ETH1ADDR			00:C0:A8:12:34:57
+
+/*
+ * SLT
+ */
+/*
+#define CONFIG_SLT
+#define CFG_CMD_SLT		(CFG_CMD_VIDEOTEST | CFG_CMD_MACTEST | CFG_CMD_HACTEST | CFG_CMD_MICTEST)
+*/
+
+#endif	/* __CONFIG_H */
diff --git a/include/configs/ast3100.h b/include/configs/ast3100.h
new file mode 100644
index 0000000..f2a2aed
--- /dev/null
+++ b/include/configs/ast3100.h
@@ -0,0 +1,325 @@
+/*
+ * (C) Copyright 2004
+ * Peter Chen <peterc@socle-tech.com.tw>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/*
+ * High Level Configuration Options
+ * (easy to change)
+ */
+//#define CONFIG_INIT_CRITICAL			/* define for U-BOOT 1.1.1 */
+#undef  CONFIG_INIT_CRITICAL			/* undef for  U-BOOT 1.1.4 */ 
+#define CONFIG_ARM926EJS	1		/* This is an arm926ejs CPU */
+#define	CONFIG_ASPEED		1
+//#define CONFIG_AST2300		    1
+#define CONFIG_AST3100	1
+#define CONFIG_AST3100_D200         1   /* Clientron D200*/
+//#define CONFIG_SYS_FLASH_CFI			/* CONFIG_FLASH_CFI, CONFIG_FLASH_SPI is exclusive*/
+#define CONFIG_FLASH_SPI
+//#define CONFIG_2SPIFLASH			/* Boot SPI: CS2, 2nd SPI: CS0 */
+#undef CONFIG_2SPIFLASH
+#undef CONFIG_ASPEED_SLT
+#define CONFIG_FLASH_AST2300
+//#define CONFIG_FLASH_AST2300_DMA
+//#define CONFIG_FLASH_SPIx2_Dummy
+//#define CONFIG_FLASH_SPIx4_Dummy
+#define CONFIG_CRT_DISPLAY	1		/* undef if not support CRT */
+
+//#define CONFIG_USE_IRQ				/* we don't need IRQ/FIQ stuff */
+#define CONFIG_MISC_INIT_R 
+
+/* 
+ * DRAM Config
+ *
+ * 1. DRAM Size              //
+ *    CONFIG_DRAM_512MBIT    // 512M bit
+ *    CONFIG_DRAM_1GBIT      // 1G   bit (default)
+ *    CONFIG_DRAM_2GBIT      // 2G   bit
+ *    CONFIG_DRAM_4GBIT      // 4G   bit 
+ * 2. DRAM Speed             //
+ *    CONFIG_DRAM_336        // 336MHz (DDR-667)
+ *    CONFIG_DRAM_408        // 408MHz (DDR-800) (default)
+ * 3. VGA Mode
+ *    CONFIG_CRT_DISPLAY     // define to disable VGA function
+ * 4. ECC Function enable
+ *    CONFIG_DRAM_ECC        // define to enable ECC function
+ * 5. UART Debug Message
+ *    CONFIG_DRAM_UART_OUT   // enable output message at UART5
+ *    CONFIG_DRAM_UART_38400 // set the UART baud rate to 38400, default is 115200
+ */
+ 
+//1. DRAM Size
+//#define    CONFIG_DRAM_512MBIT
+#define    CONFIG_DRAM_1GBIT
+//#define    CONFIG_DRAM_2GBIT
+//#define    CONFIG_DRAM_4GBIT
+//2. DRAM Speed
+//#define    CONFIG_DRAM_336
+#define    CONFIG_DRAM_408
+//3. VGA Mode
+//#define    CONFIG_CRT_DISPLAY
+//4. ECC Function enable
+//#define    CONFIG_DRAM_ECC
+//5. UART Debug Message
+#define    CONFIG_DRAM_UART_OUT
+//#define    CONFIG_DRAM_UART_38400
+
+
+
+/* 
+ * Environment Config
+ */
+#define CONFIG_CMDLINE_TAG	 1		/* enable passing of ATAGs	*/
+#define CONFIG_SETUP_MEMORY_TAGS 1
+#define CONFIG_INITRD_TAG	 1
+#define	CONFIG_BOOTARGS 	"debug console=ttyS1,115200n8 ramdisk_size=16384 root=/dev/ram rw init=/linuxrc mem=80M"
+#define CONFIG_BOOTDELAY	4		/* autoboot after 4 seconds	*/
+#ifdef CONFIG_FLASH_AST2300
+#define CONFIG_BOOTCOMMAND	"bootm 20080000 20300000"
+#else
+#ifdef	CONFIG_SYS_FLASH_CFI 
+#define CONFIG_BOOTCOMMAND	"bootm 10080000 10300000"
+#else
+#define CONFIG_BOOTCOMMAND	"bootm 14080000 14300000"
+#endif
+#endif
+#define CONFIG_BOOTFILE		"allc.bin"
+#define CONFIG_ENV_OVERWRITE
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_DFL
+#define CONFIG_CMD_ENV
+#define CONFIG_CMD_FLASH
+#define CONFIG_CMD_NET
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_EEPROM
+
+/* 
+ * CPU Setting
+ */
+#define CPU_CLOCK_RATE		18000000	/* 16.5 MHz clock for the ARM core */
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 768*1024)
+#define CONFIG_SYS_GBL_DATA_SIZE	128	/* size in bytes reserved for initial data */
+
+/*
+ * Stack sizes,  The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE	(128*1024)	/* regular stack */
+#define CONFIG_STACKSIZE_IRQ	(4*1024)	/* IRQ stack */
+#define CONFIG_STACKSIZE_FIQ	(4*1024)	/* FIQ stack */
+
+/*
+ * Memory Configuration
+ */
+#define CONFIG_DRAM_528 
+#define CONFIG_NR_DRAM_BANKS	1	   	/* we have 1 bank of DRAM */
+#define PHYS_SDRAM_1		0x40000000 	/* SDRAM Bank #1 */
+#define PHYS_SDRAM_1_SIZE	0x4000000 	/* 64 MB */
+
+#define CONFIG_SYS_SDRAM_BASE	0x40000000
+
+/*
+ * FLASH Configuration
+ */
+#ifdef CONFIG_SYS_FLASH_CFI				/* NOR Flash */
+
+#ifdef CONFIG_FLASH_AST2300
+#define PHYS_FLASH_1			0x20000000 	/* Flash Bank #1 */
+#else
+#define PHYS_FLASH_1			0x10000000 	/* Flash Bank #1 */
+#endif
+
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_1
+#define CONFIG_FLASH_BANKS_LIST 	{ PHYS_FLASH_1 }
+
+#define CONFIG_SYS_MAX_FLASH_BANKS 	1
+#define CONFIG_SYS_MAX_FLASH_SECT	(256)		/* max number of sectors on one chip */
+
+#define CONFIG_ENV_IS_IN_FLASH	1
+#define CONFIG_ENV_OFFSET			0x60000 	/* environment starts here  */
+#define CONFIG_ENV_SIZE			0x20000 	/* Total Size of Environment Sector */
+
+#define CONFIG_SYS_FLASH_CFI_AMD_RESET
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+
+#else						/* SPI Flash */
+
+#ifdef CONFIG_FLASH_AST2300
+#define PHYS_FLASH_1		0x20000000 	/* Flash Bank #1 */
+#else
+#define PHYS_FLASH_1		0x14000000 	/* Flash Bank #1 */
+#define PHYS_FLASH_2		0x14800000 	/* Flash Bank #2 */
+#define PHYS_FLASH_2_BASE	0x10000000
+#endif
+
+#ifdef CONFIG_2SPIFLASH
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_2_BASE
+#define CONFIG_FLASH_BANKS_LIST 	{ PHYS_FLASH_1, PHYS_FLASH_2 }
+#define CONFIG_SYS_MAX_FLASH_BANKS 	2
+#define CONFIG_SYS_MAX_FLASH_SECT	(512)		/* max number of sectors on one chip */
+
+#define CONFIG_ENV_IS_IN_FLASH		1
+#define CONFIG_ENV_OFFSET		0x7F0000 	/* environment starts here  */
+#define CONFIG_ENV_SIZE			0x010000 	/* Total Size of Environment Sector */
+#else
+#define CONFIG_SYS_FLASH_BASE		PHYS_FLASH_1
+#define CONFIG_FLASH_BANKS_LIST 	{ PHYS_FLASH_1 }
+#define CONFIG_SYS_MAX_FLASH_BANKS 	1
+#define CONFIG_SYS_MAX_FLASH_SECT	(512)		/* max number of sectors on one chip */
+
+#define CONFIG_ENV_IS_IN_FLASH		1
+#define CONFIG_ENV_OFFSET		0x7F0000 	/* environment starts here  */
+#define CONFIG_ENV_SIZE			0x010000 	/* Total Size of Environment Sector */
+#endif
+
+#endif
+
+#define __LITTLE_ENDIAN
+
+#define CONFIG_MONITOR_BASE		TEXT_BASE
+#define CONFIG_MONITOR_LEN		(192 << 10)
+
+/* timeout values are in ticks */
+#define CONFIG_SYS_FLASH_ERASE_TOUT	(20*CONFIG_SYS_HZ) 	/* Timeout for Flash Erase */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	(20*CONFIG_SYS_HZ) 	/* Timeout for Flash Write */
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LONGHELP				/* undef to save memory		*/
+
+#define CONFIG_SYS_PROMPT		"boot# " 	/* Monitor Command Prompt	*/
+#define CONFIG_SYS_CBSIZE		256		/* Console I/O Buffer Size	*/
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16) /* Print Buffer Size */
+#define CONFIG_SYS_MAXARGS		16		/* max number of command args	*/
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE	/* Boot Argument Buffer Size	*/
+
+#define CONFIG_SYS_MEMTEST_START	0x40000000	/* memtest works on	*/
+#define CONFIG_SYS_MEMTEST_END		0x44FFFFFF	/* 256 MB in DRAM	*/
+
+#define	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+#undef	CONFIG_SYS_CLKS_IN_HZ		/* everything, incl board info, in Hz */
+
+#define CONFIG_SYS_LOAD_ADDR		0x43000000	/* default load address */
+
+#define CONFIG_SYS_TIMERBASE		0x1E782000	/* use timer 1 */
+#define CONFIG_SYS_HZ			(1*1000*1000)	/* use external clk (1M) */
+
+/*
+ * Serial Configuration
+ */
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	4
+#define CONFIG_SYS_NS16550_CLK		24000000
+#define CONFIG_SYS_NS16550_COM1		0x1e783000
+#define CONFIG_SYS_NS16550_COM2		0x1e784000
+#define	CONFIG_SYS_LOADS_BAUD_CHANGE
+#define CONFIG_SERIAL1			1
+#define CONFIG_CONS_INDEX		2
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/*
+ * USB device configuration
+ */
+/*
+#define CONFIG_USB_DEVICE		1
+#define CONFIG_USB_TTY			1
+
+#define CONFIG_USBD_VENDORID		0x1234
+#define CONFIG_USBD_PRODUCTID		0x5678
+#define CONFIG_USBD_MANUFACTURER	"Siemens"
+#define CONFIG_USBD_PRODUCT_NAME	"SX1"
+*/
+
+/*
+ * I2C configuration
+ */
+#define CONFIG_HARD_I2C
+#define CONFIG_SYS_I2C_SPEED		100000
+#define CONFIG_SYS_I2C_SLAVE		1
+#define CONFIG_DRIVER_ASPEED_I2C
+
+/*
+* EEPROM configuration
+*/
+#define CONFIG_SYS_I2C_EEPROM_ADDR_LEN 	2
+#define CONFIG_SYS_I2C_EEPROM_ADDR 	0xa0
+
+/*
+ * NIC configuration
+ */
+#define __BYTE_ORDER __LITTLE_ENDIAN
+#define __LITTLE_ENDIAN_BITFIELD
+#define CONFIG_MAC_PARTITION
+#define CONFIG_ASPEEDNIC
+//#define CONFIG_MAC1_PHY_LINK_INTERRUPT
+#define CONFIG_MAC2_ENABLE
+#define CONFIG_MAC2_PHY_LINK_INTERRUPT
+/*
+*-------------------------------------------------------------------------------
+* NOTICE: MAC1 and MAC2 now have their own seperate PHY configuration.
+* We use 2 bits for each MAC in the scratch register(D[15:11] in 0x1E6E2040) to
+* inform kernel driver.
+* The meanings of the 2 bits are:
+* 00(0): Dedicated PHY
+* 01(1): ASPEED's EVA + INTEL's NC-SI PHY chip EVA
+* 10(2): ASPEED's MAC is connected to NC-SI PHY chip directly
+* 11: Reserved
+*
+* We use CONFIG_MAC1_PHY_SETTING and CONFIG_MAC2_PHY_SETTING in U-Boot
+* 0: Dedicated PHY
+* 1: ASPEED's EVA + INTEL's NC-SI PHY chip EVA
+* 2: ASPEED's MAC is connected to NC-SI PHY chip directly
+* 3: Reserved
+*-------------------------------------------------------------------------------
+*/
+#define CONFIG_MAC1_PHY_SETTING		0
+#define CONFIG_MAC2_PHY_SETTING		0
+#define CONFIG_MAC_INTERFACE_CLOCK_DELAY	0x2255
+#define CONFIG_NET_MULTI
+#define CONFIG_ETHACT			aspeednic#0
+#define CONFIG_GATEWAYIP		192.168.0.1
+#define CONFIG_NETMASK			255.255.255.0
+#define CONFIG_IPADDR			192.168.0.249
+#define CONFIG_SERVERIP			192.168.0.156
+#define CONFIG_ETHADDR			00:D0:A8:12:34:58
+#define CONFIG_ETH1ADDR			00:D0:A8:12:34:59
+
+/*
+ * SLT
+ */
+/*
+#define CONFIG_SLT
+#define CFG_CMD_SLT		(CFG_CMD_VIDEOTEST | CFG_CMD_MACTEST | CFG_CMD_HACTEST | CFG_CMD_MICTEST)
+*/
+
+#endif	/* __CONFIG_H */
diff --git a/include/flash.h b/include/flash.h
index c7acc97..e77be1f 100644
--- a/include/flash.h
+++ b/include/flash.h
@@ -57,6 +57,21 @@ typedef struct {
 	ulong   addr_unlock2;		/* unlock address 2 for AMD flash roms  */
 	const char *name;		/* human-readable name	                */
 #endif
+#ifdef CONFIG_FLASH_SPI
+  ulong   readcmd;
+  ulong   dualport;
+  ulong   dummybyte;
+  ulong   tCK_Write;
+  ulong   tCK_Erase;
+  ulong   tCK_Read;
+  ulong   CE;
+  ulong   iomode;
+  ulong   address32;
+  ulong   quadport;
+  ulong   dummydata;
+  ulong   buffersize;
+  ulong   specificspi;
+#endif
 } flash_info_t;
 
 extern flash_info_t flash_info[]; /* info for FLASH chips	*/
