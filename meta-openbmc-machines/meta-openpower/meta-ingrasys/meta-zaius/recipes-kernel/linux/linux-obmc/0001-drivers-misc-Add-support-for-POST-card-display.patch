From 7502d570bf16f0be6f259cc736f897145b592fc7 Mon Sep 17 00:00:00 2001
From: Jaghathiswari Rankappagounder Natarajan <jaghu@google.com>
Date: Fri, 7 Oct 2016 10:26:44 -0700
Subject: [PATCH] drivers: misc: Add support for POST card display

Added character and led drivers to display Port80 codes(written by the host)
and additional codes(generated by the EC) to two seven segment LEDs.
Tested that postcodes are displayed properly by attaching a postcard to
AST2500 evb board.

Signed-off-by: Jaghathiswari Rankappagounder Natarajan <jaghu@google.com>
---
 drivers/misc/Makefile              |   2 +
 drivers/misc/update_bmc_postcode.c | 117 ++++++++++++++++++++
 drivers/misc/update_postcard.c     | 218 +++++++++++++++++++++++++++++++++++++
 drivers/misc/update_postcard.h     |   1 +
 4 files changed, 338 insertions(+)
 create mode 100644 drivers/misc/update_bmc_postcode.c
 create mode 100644 drivers/misc/update_postcard.c
 create mode 100644 drivers/misc/update_postcard.h

diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 724861b..363f76a 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -58,3 +58,5 @@ obj-$(CONFIG_VEXPRESS_SYSCFG)	+= vexpress-syscfg.o
 obj-$(CONFIG_CXL_BASE)		+= cxl/
 obj-$(CONFIG_PANEL)             += panel.o
 obj-$(CONFIG_ASPEED_BT_IPMI_HOST)	+= bt-host.o
+obj-y				+= update_bmc_postcode.o
+obj-y				+= update_postcard.o
diff --git a/drivers/misc/update_bmc_postcode.c b/drivers/misc/update_bmc_postcode.c
new file mode 100644
index 0000000..511c09d
--- /dev/null
+++ b/drivers/misc/update_bmc_postcode.c
@@ -0,0 +1,117 @@
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/kdev_t.h>
+#include <linux/fs.h>
+#include <linux/device.h>
+#include <linux/cdev.h>
+#include <linux/uaccess.h>
+#include <linux/ctype.h>
+
+#include "update_postcard.h"
+
+#define MAX_POSTCODE_SIZE 3
+
+static dev_t bmc_state_dev;
+static struct cdev c_dev;
+static struct class *bmc_state_class;
+
+static int bmc_state_open(struct inode *i, struct file *f)
+{
+	return 0;
+}
+
+static int bmc_state_close(struct inode *i, struct file *f)
+{
+	return 0;
+}
+
+static ssize_t bmc_state_read(struct file *f, char __user *buf, size_t
+				len, loff_t *off)
+{
+	return 0;
+}
+
+/* Write post code from bmc to the correct variable */
+static ssize_t bmc_state_write(struct file *f, const char __user *buf,
+				size_t len, loff_t *off)
+{
+	char tmp[MAX_POSTCODE_SIZE];
+	int length = len - 1;
+	int i;
+
+	if (length != MAX_POSTCODE_SIZE) {
+		return -EINVAL;
+	}
+
+	if (copy_from_user(tmp, buf, length) != 0) {
+		return -EFAULT;
+	}
+
+	for (i = 0; i < MAX_POSTCODE_SIZE; i++) {
+		if (!isxdigit(tmp[i]))
+			return -EINVAL;
+	}
+
+	update_postcode(tmp);
+	return len;
+}
+
+static const struct file_operations bmc_state_fops = {
+
+	.owner = THIS_MODULE,
+	.open = bmc_state_open,
+	.release = bmc_state_close,
+	.read = bmc_state_read,
+	.write = bmc_state_write
+};
+
+static int __init update_bmc_pc_init(void) /* Constructor */
+{
+	if (alloc_chrdev_region(&bmc_state_dev, 0, 1, "bmc_state") < 0) {
+		return -1;
+	}
+
+	bmc_state_class = class_create(THIS_MODULE, "bmc_state");
+	if (bmc_state_class == NULL) {
+		goto unregister;
+		return -1;
+	}
+
+	if (device_create(bmc_state_class, NULL, bmc_state_dev,
+		NULL, "current_state") == NULL) {
+		goto class_destroy;
+		return -1;
+	}
+
+	cdev_init(&c_dev, &bmc_state_fops);
+	if (cdev_add(&c_dev, bmc_state_dev, 1) == -1) {
+		goto device_destroy;
+		return -1;
+	}
+
+	return 0;
+
+device_destroy:
+		device_destroy(bmc_state_class, bmc_state_dev);
+class_destroy:
+		class_destroy(bmc_state_class);
+unregister:
+		unregister_chrdev_region(bmc_state_dev, 1);
+	return -1;
+}
+
+static void __exit update_bmc_pc_exit(void)
+{
+	cdev_del(&c_dev);
+	device_destroy(bmc_state_class, bmc_state_dev);
+	class_destroy(bmc_state_class);
+	unregister_chrdev_region(bmc_state_dev, 1);
+}
+
+module_init(update_bmc_pc_init);
+module_exit(update_bmc_pc_exit);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Jaghathiswari Rankappagounder Natarajan <jaghu@google.com>");
+MODULE_DESCRIPTION("Character driver - update bmc postcode");
diff --git a/drivers/misc/update_postcard.c b/drivers/misc/update_postcard.c
new file mode 100644
index 0000000..1306f7b
--- /dev/null
+++ b/drivers/misc/update_postcard.c
@@ -0,0 +1,218 @@
+/* Display Port80 codes (written by the host) and
+ * additional codes (generated by the EC) to two seven segment LEDs
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/timer.h>
+#include <linux/jiffies.h>
+#include <linux/sizes.h>
+#include <linux/map_to_7segment.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/uaccess.h>
+#include <linux/mutex.h>
+
+#define POST_CODE_UPDATE_INTVL 1000
+
+#define MAX_PC_SIZE 3
+
+#define LED_DOT 0x01
+
+#define GPIOBASE 0x1E780000
+#define GPIO070 (GPIOBASE + 0x070)
+#define GPIO074 (GPIOBASE + 0x074)
+#define GPIO0C8 (GPIOBASE + 0x0C8)
+
+#define CLOCK 8
+#define CLEAR 9
+#define DATA 10
+
+static struct mutex mutex;
+
+static void __iomem *gpio_direction;
+static void __iomem *gpio_write_value;
+static void __iomem *gpio_read_value;
+
+static struct timer_list update_timer;
+
+static char curr_postcode[3];
+static u8 pc_valid;
+
+/*
+ * 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+ *  _       _   _       _   _   _   _   _   _       _       _   _
+ * | |   |  _|  _| |_| |_  |_    | |_| |_| |_| |_  |    _| |_  |_
+ * |_|   | |_   _|   |  _| |_|   | |_|   | | | |_| |_  |_| |_  |
+ *
+ * data[7:1] = led[a:g]
+ * lookup table used for both bytes of lpc post code and lower byte of
+ * bmc post code
+ */
+const u8 seven_seg_bits[] = {
+			0x00, 0x9C, 0x1E, 0xCE, 0x8E, 0x02, 0x02, 0x02,
+			0x02, 0x02, 0x02, 0x02, 0xB6, 0x7A, 0x7A, 0xEC
+			};
+
+/*
+ * 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+ *      _       _   _                              _            _
+ *     |   |_  |_| |_  _   _   _   _   _   _   _  |_    _|  _| | |
+ *     |_  |_  |   |                               _|  |_| |_| | |
+ *
+ * data[7:1] = led[a:g]
+ * lookup table used for higher byte of bmc post code
+ */
+const u8 special_seven_seg_bits[] = {
+			0xFC, 0x60, 0xDA, 0xF2, 0x66, 0xB6, 0xBE, 0xE0,
+			0xFE, 0xF6, 0xEE, 0x3E, 0x9C, 0x7A, 0x9E, 0x8E
+			};
+
+void update_postcode(char *buf)
+{
+	mutex_lock(&mutex);
+	strncpy(curr_postcode, buf, sizeof(curr_postcode));
+	mutex_unlock(&mutex);
+	pc_valid = 1;
+}
+EXPORT_SYMBOL(update_postcode);
+
+/* convert postcode to led pattern
+ * 7-bits used for each 7-seg display and
+ * 1 bit used for the 'dot' on both digits.
+ *
+ *  @param N/A
+ *  @return N/A
+ */
+static u16 postcode_to_led_signal(void)
+{
+	u8 low_display;
+	u8 high_display;
+	u16 led_value;
+	char buf[3];
+
+	mutex_lock(&mutex);
+	strncpy(buf, curr_postcode, sizeof(buf));
+	mutex_unlock(&mutex);
+
+	low_display = seven_seg_bits[hex_to_bin(buf[2])];
+
+	high_display = (buf[0] == '1') ?
+		special_seven_seg_bits[hex_to_bin(buf[1])] :
+		seven_seg_bits[hex_to_bin(buf[1])];
+
+	led_value = low_display | (high_display << 8);
+	if (buf[0] == '1') {
+		led_value |= LED_DOT | (LED_DOT << 8);
+	}
+
+	return led_value;
+}
+
+static void update_sgpio(void)
+{
+	u16 led_signal;
+	u32 tmp;
+	int i;
+
+	/* Convert two bytes of post code to 16 bit led pattern */
+	led_signal = postcode_to_led_signal();
+
+	/* Send the clear signal */
+	tmp = ioread32(gpio_read_value);
+	tmp &= ~(BIT(CLEAR));
+	iowrite32(tmp, gpio_write_value);
+	udelay(1);
+
+	tmp = ioread32(gpio_read_value);
+	tmp |= BIT(CLEAR);
+	iowrite32(tmp, gpio_write_value);
+
+	/* Bitbang the 16 bit led pattern
+	 * 7-bits used for each 7-seg display
+	 * 1 bit used for the 'dot' on both digits
+	 */
+	for (i = 0; i < 16; i++) {
+		tmp = ioread32(gpio_read_value);
+		if (led_signal & 0x01) {
+			/* Set data to high */
+			tmp |= BIT(DATA);
+		} else {
+			/* Set data to low */
+			tmp &= (~(BIT(DATA)));
+		}
+		/* Set clock to low */
+		tmp &= ~(BIT(CLOCK));
+		iowrite32(tmp, gpio_write_value);
+		udelay(1);
+
+		tmp = ioread32(gpio_read_value);
+		/* Set clock to high */
+		tmp |= BIT(CLOCK);
+		iowrite32(tmp, gpio_write_value);
+		udelay(1);
+
+		led_signal >>= 1;
+	}
+}
+
+static void update_timer_handler(unsigned long data)
+{
+	if (pc_valid == 1) {
+		update_sgpio();
+	}
+	mod_timer(&update_timer,
+		jiffies + msecs_to_jiffies(POST_CODE_UPDATE_INTVL));
+}
+
+static int __init pc_update_init(void)
+{
+	u32 dir_output;
+	int result;
+
+	gpio_direction = ioremap(GPIO074, SZ_4K);
+	if (gpio_direction  == NULL) {
+		return -1;
+	}
+
+	gpio_write_value = ioremap(GPIO070, SZ_4K);
+	if (gpio_write_value == NULL) {
+		return -1;
+	}
+
+	gpio_read_value = ioreamp(GPIO0C8, SZ_4K;
+	if (gpio_read_value == NULL) {
+		return -1;
+	}
+
+	/* Set GPIOJ0, GPIOJ1 and GPIOJ2 pins to output mode */
+	dir_output = ioread32(gpio_direction);
+	dir_output |= BIT(DATA) | BIT(CLOCK) | BIT(CLEAR);
+	iowrite32(dir_output, gpio_direction);
+
+	/* Start timer to update post code every second */
+	setup_timer(&update_timer, update_timer_handler, 0);
+	result = mod_timer(&update_timer,
+		jiffies + msecs_to_jiffies(POST_CODE_UPDATE_INTVL));
+
+	if (result)
+		return result;
+
+	mutex_init(&mutex);
+
+	return 0;
+}
+
+static void __exit pc_update_exit(void)
+{
+	del_timer(&update_timer);
+	iounmap(gpio_direction);
+	iounmap(gpio_write_value);
+	iounmap(gpio_read_value);
+}
+
+module_init(pc_update_init);
+module_exit(pc_update_exit);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Jaghathiswari Rankappagounder Natarajan <jaghu@google.com>");
+MODULE_DESCRIPTION("Post card display update driver");
diff --git a/drivers/misc/update_postcard.h b/drivers/misc/update_postcard.h
new file mode 100644
index 0000000..ef82e9091d
--- /dev/null
+++ b/drivers/misc/update_postcard.h
@@ -0,0 +1 @@
+void update_postcode(char *buf);
--
2.8.0.rc3.226.g39d4020

