From 1a39b8312eb2991aac3f657033db7e54da6342ee Mon Sep 17 00:00:00 2001
From: Yi Li <adamliyi@msn.com>
Date: Wed, 31 Aug 2016 17:56:46 +0800
Subject: [PATCH] Add power control support for the Garrison system

Add fix for openbmc/openbmc#315

Change-Id: I4a6ddb77c32c170833c4c4dd54f7b59440149f88
Signed-off-by: Brad Bishop <bradleyb@fuzziesquirrel.com>
Signed-off-by: Yi Li <adamliyi@msn.com>
---
 op-pwrctl/power_control_obj.c | 128 +++++++++++++++++++++++++++++++++++-------
 1 file changed, 108 insertions(+), 20 deletions(-)

diff --git a/power_control_obj.c b/power_control_obj.c
index dfc7fa9..2f0d124 100644
--- a/power_control_obj.c
+++ b/power_control_obj.c
@@ -17,11 +17,15 @@ static const gchar* instance_name = "power0";
 static const gchar* dbus_name = "org.openbmc.control.Power";
 
 //This object will use these GPIOs
-GPIO power_pin    = (GPIO){ "POWER_PIN" };
-GPIO pgood        = (GPIO){ "PGOOD" };
-GPIO usb_reset    = (GPIO){ "USB_RESET" };
-GPIO pcie_reset   = (GPIO){ "PCIE_RESET" };
-
+GPIO power_pin = (GPIO){ "BMC_POWER_UP" };
+GPIO pgood = (GPIO){ "SYS_PWROK_BUFF" };
+GPIO bmc_wd_clear_pulse_n = (GPIO){ "BMC_WD_CLEAR_PULSE_N" };
+GPIO cm1_oe_r_n = (GPIO){ "CM1_OE_R_N" };
+GPIO bmc_cp0_reset_n = (GPIO){ "BMC_CP0_RESET_N" };
+GPIO bmc_cfam_reset_n_r = (GPIO){ "BMC_CFAM_RESET_N_R" };
+GPIO pcie_reset = (GPIO){ "PEX8718_DEVICES_RESET_N" };
+GPIO cp0_devices_reset_n = (GPIO){ "CP0_DEVICES_RESET_N" };
+GPIO cp1_devices_reset_n = (GPIO){ "CP1_DEVICES_RESET_N" };
 
 static GDBusObjectManagerServer *manager = NULL;
 
@@ -67,26 +71,44 @@ poll_pgood(gpointer user_data)
 			{
 				control_power_emit_power_lost(control_power);
 				control_emit_goto_system_state(control,"HOST_POWERED_OFF");
-				rc = gpio_open(&pcie_reset);
-				rc = gpio_write(&pcie_reset,0);
-				gpio_close(&pcie_reset);
-
-				rc = gpio_open(&usb_reset);
-				rc = gpio_write(&usb_reset,0);
-				gpio_close(&usb_reset);
-
 			}
 			else
 			{
 				control_power_emit_power_good(control_power);
 				control_emit_goto_system_state(control,"HOST_POWERED_ON");
-				rc = gpio_open(&pcie_reset);
-				rc = gpio_write(&pcie_reset,1);
+			}
+
+			gpio_open(&cm1_oe_r_n);
+			gpio_write(&cm1_oe_r_n, !gpio);
+			gpio_close(&cm1_oe_r_n);
+
+			gpio_open(&bmc_cp0_reset_n);
+			gpio_write(&bmc_cp0_reset_n, gpio);
+			gpio_close(&bmc_cp0_reset_n);
+
+			gpio_open(&bmc_cfam_reset_n_r);
+			gpio_write(&bmc_cfam_reset_n_r, gpio);
+			gpio_close(&bmc_cfam_reset_n_r);
+
+			/*
+			 * Reset PCIE devices as usual when powering off.
+			 * When powering on, hold PCIE reset until
+			 * the processor can forward clocks and control reset.
+			 * This is specific to Firestone and Garrison.
+			 */
+			if(gpio==0)
+			{
+				gpio_open(&pcie_reset);
+				gpio_write(&pcie_reset, gpio);
 				gpio_close(&pcie_reset);
 
-				rc = gpio_open(&usb_reset);
-				rc = gpio_write(&usb_reset,1);
-				gpio_close(&usb_reset);
+				gpio_open(&cp0_devices_reset_n);
+				gpio_write(&cp0_devices_reset_n, gpio);
+				gpio_close(&cp0_devices_reset_n);
+
+				gpio_open(&cp1_devices_reset_n);
+				gpio_write(&cp1_devices_reset_n, gpio);
+				gpio_close(&cp1_devices_reset_n);
 			}
 		}
 	} else {
@@ -138,11 +160,13 @@ on_set_power_state(ControlPower *pwr,
 			} else {
 				control_emit_goto_system_state(control,"HOST_POWERING_OFF");
 			}
+
 			error = gpio_open(&power_pin);
 			if(error != GPIO_OK) { break;	}
-			error = gpio_write(&power_pin,!state);
+			error = gpio_write(&power_pin, state);
 			if(error != GPIO_OK) { break;	}
 			gpio_close(&power_pin);
+
 			control_power_set_state(pwr,state);
 		} while(0);
 		if(error != GPIO_OK)
@@ -175,6 +199,48 @@ on_get_power_state(ControlPower *pwr,
 	return TRUE;
 }
 
+/* Handler for BootProgress signal from BootProgress sensor */
+static void
+on_boot_progress(GDBusConnection *connection,
+		const gchar *sender_name,
+		const gchar *object_path,
+		const gchar *interface_name,
+		const gchar *signal_name,
+		GVariant *parameters,
+		gpointer user_data)
+{
+	gchar *boot_progress;
+	int rc;
+	uint8_t gpio;
+
+	if(!parameters)
+		return;
+
+	g_variant_get(parameters,"(s)",&boot_progress);
+	if(strcmp(boot_progress,"FW Progress, Memory Init") == 0)
+	{
+		rc = gpio_open(&pgood);
+		rc = gpio_read(&pgood,&gpio);
+		gpio_close(&pgood);
+		if(rc != GPIO_OK || gpio != 1)
+			return;
+
+		printf("FW Progress: Memory Init - Releasing PCIE reset\n");
+		//Releasing PCIE reset
+		gpio_open(&pcie_reset);
+		gpio_write(&pcie_reset, 1);
+		gpio_close(&pcie_reset);
+
+		gpio_open(&cp0_devices_reset_n);
+		gpio_write(&cp0_devices_reset_n, 1);
+		gpio_close(&cp0_devices_reset_n);
+
+		gpio_open(&cp1_devices_reset_n);
+		gpio_write(&cp1_devices_reset_n, 1);
+		gpio_close(&cp1_devices_reset_n);
+	}
+}
+
 static void
 on_bus_acquired(GDBusConnection *connection,
 		const gchar *name,
@@ -217,6 +283,17 @@ on_bus_acquired(GDBusConnection *connection,
 			G_CALLBACK(on_init),
 			object); /* user_data */
 
+	/* Listen for BootProgress signal from BootProgress sensor */
+	g_dbus_connection_signal_subscribe(connection,
+			NULL, /* service */
+			NULL, /* interface_name */
+			"BootProgress", /* member: name of the signal */
+			"/org/openbmc/sensors/host/BootProgress", /* obj path */
+			NULL, /* arg0 */
+			G_DBUS_SIGNAL_FLAGS_NONE,
+			(GDBusSignalCallback) on_boot_progress,
+			object, /* user data */
+			NULL );
 
 	/* Export the object (@manager takes its own reference to @object) */
 	g_dbus_object_manager_server_set_connection(manager, connection);
@@ -230,10 +307,21 @@ on_bus_acquired(GDBusConnection *connection,
 		if(rc != GPIO_OK) { break; }
 		rc = gpio_init(connection,&pgood);
 		if(rc != GPIO_OK) { break; }
+		rc = gpio_init(connection,&bmc_wd_clear_pulse_n);
+		if(rc != GPIO_OK) { break; }
+		rc = gpio_init(connection,&cm1_oe_r_n);
+		if(rc != GPIO_OK) { break; }
+		rc = gpio_init(connection,&bmc_cp0_reset_n);
+		if(rc != GPIO_OK) { break; }
+		rc = gpio_init(connection,&bmc_cfam_reset_n_r);
+		if(rc != GPIO_OK) { break; }
 		rc = gpio_init(connection,&pcie_reset);
 		if(rc != GPIO_OK) { break; }
-		rc = gpio_init(connection,&usb_reset);
+		rc = gpio_init(connection,&cp0_devices_reset_n);
 		if(rc != GPIO_OK) { break; }
+		rc = gpio_init(connection,&cp1_devices_reset_n );
+		if(rc != GPIO_OK) { break; }
+
 
 		uint8_t gpio;
 		rc = gpio_open(&pgood);
-- 
1.9.1

