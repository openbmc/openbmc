Search target sysroot gcc version specific dirs with multilib.

We install the gcc libraries (such as crtbegin.p) into
<sysroot><libdir>/<target-sys>/5.2.0/
which is a default search path for GCC (aka multi_suffix in the 
code below). <target-sys> is 'machine' in gcc's terminology. We use
these directories so that multiple gcc versions could in theory 
co-exist on target.

We only want to build one gcc-cross-canadian per arch and have this work 
for all multilibs. <target-sys> can be handled by mapping the multilib
<target-sys> to the one used by gcc-cross-canadian, e.g. mips64-polkmllib32-linux 
is symlinked to by mips64-poky-linux.

The default gcc search path in the target sysroot for a "lib64" mutlilib is:

<sysroot>/lib32/mips64-poky-linux/5.2.0/
<sysroot>/lib32/../lib64/
<sysroot>/usr/lib32/mips64-poky-linux/5.2.0/
<sysroot>/usr/lib32/../lib64/
<sysroot>/lib32/
<sysroot>/usr/lib32/

which means that the lib32 crtbegin.o will be found and the lib64 ones
will not which leads to compiler failures.

This patch injects a multilib version of that path first so the lib64
binaries can be found first. With this change the search path becomes:

<sysroot>/lib32/../lib64/mips64-poky-linux/5.2.0/
<sysroot>/lib32/mips64-poky-linux/5.2.0/
<sysroot>/lib32/../lib64/
<sysroot>/usr/lib32/../lib64/mips64-poky-linux/5.2.0/
<sysroot>/usr/lib32/mips64-poky-linux/5.2.0/
<sysroot>/usr/lib32/../lib64/
<sysroot>/lib32/
<sysroot>/usr/lib32/

Upstream-Status: Pending
RP 2015/7/31

Index: gcc-5.2.0/gcc/gcc.c
===================================================================
--- gcc-5.2.0.orig/gcc/gcc.c
+++ gcc-5.2.0/gcc/gcc.c
@@ -2305,7 +2305,7 @@ for_each_path (const struct path_prefix
       if (path == NULL)
 	{
 	  len = paths->max_len + extra_space + 1;
-	  len += MAX (MAX (suffix_len, multi_os_dir_len), multiarch_len);
+	  len += MAX ((suffix_len + multi_os_dir_len), multiarch_len);
 	  path = XNEWVEC (char, len);
 	}
 
@@ -2317,6 +2317,33 @@ for_each_path (const struct path_prefix
 	  /* Look first in MACHINE/VERSION subdirectory.  */
 	  if (!skip_multi_dir)
 	    {
+	      if (!(pl->os_multilib ? skip_multi_os_dir : skip_multi_dir))
+	        {
+	          const char *this_multi;
+	          size_t this_multi_len;
+
+	          if (pl->os_multilib)
+		    {
+		      this_multi = multi_os_dir;
+		      this_multi_len = multi_os_dir_len;
+		    }
+	          else
+		    {
+		      this_multi = multi_dir;
+		      this_multi_len = multi_dir_len;
+		    }
+
+	          /* Look in multilib MACHINE/VERSION subdirectory first */
+	          if (this_multi_len)
+	            {
+		      memcpy (path + len, this_multi, this_multi_len + 1);
+	              memcpy (path + len + this_multi_len, multi_suffix, suffix_len + 1);
+	              ret = callback (path, callback_info);
+	                if (ret)
+		          break;
+	            }
+	        }
+
 	      memcpy (path + len, multi_suffix, suffix_len + 1);
 	      ret = callback (path, callback_info);
 	      if (ret)
