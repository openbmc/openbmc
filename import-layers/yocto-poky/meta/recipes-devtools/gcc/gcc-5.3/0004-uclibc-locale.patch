From bd9dd472d162fc72522f96f70f6391c7c63d2bf7 Mon Sep 17 00:00:00 2001
From: Khem Raj <raj.khem@gmail.com>
Date: Fri, 29 Mar 2013 08:41:39 +0400
Subject: [PATCH 04/46] uclibc-locale

Signed-off-by: Khem Raj <raj.khem@gmail.com>

Upstream-Status: Pending
---
 libstdc++-v3/acinclude.m4                          |  37 ++
 .../config/locale/uclibc/c++locale_internal.h      |  63 ++
 libstdc++-v3/config/locale/uclibc/c_locale.cc      | 160 +++++
 libstdc++-v3/config/locale/uclibc/c_locale.h       | 117 ++++
 .../config/locale/uclibc/codecvt_members.cc        | 308 +++++++++
 .../config/locale/uclibc/collate_members.cc        |  80 +++
 libstdc++-v3/config/locale/uclibc/ctype_members.cc | 300 +++++++++
 .../config/locale/uclibc/messages_members.cc       | 100 +++
 .../config/locale/uclibc/messages_members.h        | 118 ++++
 .../config/locale/uclibc/monetary_members.cc       | 692 +++++++++++++++++++++
 .../config/locale/uclibc/numeric_members.cc        | 160 +++++
 libstdc++-v3/config/locale/uclibc/time_members.cc  | 406 ++++++++++++
 libstdc++-v3/config/locale/uclibc/time_members.h   |  68 ++
 libstdc++-v3/configure                             |  75 +++
 libstdc++-v3/include/c_compatibility/wchar.h       |   2 +
 libstdc++-v3/include/c_std/cwchar                  |   2 +
 16 files changed, 2688 insertions(+)
 create mode 100644 libstdc++-v3/config/locale/uclibc/c++locale_internal.h
 create mode 100644 libstdc++-v3/config/locale/uclibc/c_locale.cc
 create mode 100644 libstdc++-v3/config/locale/uclibc/c_locale.h
 create mode 100644 libstdc++-v3/config/locale/uclibc/codecvt_members.cc
 create mode 100644 libstdc++-v3/config/locale/uclibc/collate_members.cc
 create mode 100644 libstdc++-v3/config/locale/uclibc/ctype_members.cc
 create mode 100644 libstdc++-v3/config/locale/uclibc/messages_members.cc
 create mode 100644 libstdc++-v3/config/locale/uclibc/messages_members.h
 create mode 100644 libstdc++-v3/config/locale/uclibc/monetary_members.cc
 create mode 100644 libstdc++-v3/config/locale/uclibc/numeric_members.cc
 create mode 100644 libstdc++-v3/config/locale/uclibc/time_members.cc
 create mode 100644 libstdc++-v3/config/locale/uclibc/time_members.h

diff --git a/libstdc++-v3/acinclude.m4 b/libstdc++-v3/acinclude.m4
index 826ef86..79cc716 100644
--- a/libstdc++-v3/acinclude.m4
+++ b/libstdc++-v3/acinclude.m4
@@ -2029,6 +2029,9 @@ AC_DEFUN([GLIBCXX_ENABLE_CLOCALE], [
   # Default to "generic".
   if test $enable_clocale_flag = auto; then
     case ${target_os} in
+      *-uclibc*)
+        enable_clocale_flag=uclibc
+        ;;
       linux* | gnu* | kfreebsd*-gnu | knetbsd*-gnu)
 	enable_clocale_flag=gnu
 	;;
@@ -2213,6 +2216,40 @@ AC_DEFUN([GLIBCXX_ENABLE_CLOCALE], [
       CTIME_CC=config/locale/generic/time_members.cc
       CLOCALE_INTERNAL_H=config/locale/generic/c++locale_internal.h
       ;;
+    uclibc)
+      AC_MSG_RESULT(uclibc)
+
+      # Declare intention to use gettext, and add support for specific
+      # languages.
+      # For some reason, ALL_LINGUAS has to be before AM-GNU-GETTEXT
+      ALL_LINGUAS="de fr"
+
+      # Don't call AM-GNU-GETTEXT here. Instead, assume glibc.
+      AC_CHECK_PROG(check_msgfmt, msgfmt, yes, no)
+      if test x"$check_msgfmt" = x"yes" && test x"$enable_nls" = x"yes"; then
+        USE_NLS=yes
+      fi
+      # Export the build objects.
+      for ling in $ALL_LINGUAS; do \
+        glibcxx_MOFILES="$glibcxx_MOFILES $ling.mo"; \
+        glibcxx_POFILES="$glibcxx_POFILES $ling.po"; \
+      done
+      AC_SUBST(glibcxx_MOFILES)
+      AC_SUBST(glibcxx_POFILES)
+
+      CLOCALE_H=config/locale/uclibc/c_locale.h
+      CLOCALE_CC=config/locale/uclibc/c_locale.cc
+      CCODECVT_CC=config/locale/uclibc/codecvt_members.cc
+      CCOLLATE_CC=config/locale/uclibc/collate_members.cc
+      CCTYPE_CC=config/locale/uclibc/ctype_members.cc
+      CMESSAGES_H=config/locale/uclibc/messages_members.h
+      CMESSAGES_CC=config/locale/uclibc/messages_members.cc
+      CMONEY_CC=config/locale/uclibc/monetary_members.cc
+      CNUMERIC_CC=config/locale/uclibc/numeric_members.cc
+      CTIME_H=config/locale/uclibc/time_members.h
+      CTIME_CC=config/locale/uclibc/time_members.cc
+      CLOCALE_INTERNAL_H=config/locale/uclibc/c++locale_internal.h
+      ;;
   esac
 
   # This is where the testsuite looks for locale catalogs, using the
diff --git a/libstdc++-v3/config/locale/uclibc/c++locale_internal.h b/libstdc++-v3/config/locale/uclibc/c++locale_internal.h
new file mode 100644
index 0000000..2ae3e4a
--- /dev/null
+++ b/libstdc++-v3/config/locale/uclibc/c++locale_internal.h
@@ -0,0 +1,63 @@
+// Prototypes for GLIBC thread locale __-prefixed functions -*- C++ -*-
+
+// Copyright (C) 2002, 2004, 2005 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 2, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING.  If not, write to the Free
+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+// USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+// Written by Jakub Jelinek <jakub@redhat.com>
+
+#include <bits/c++config.h>
+#include <clocale>
+
+#ifdef __UCLIBC_MJN3_ONLY__
+#warning clean this up
+#endif
+
+#ifdef __UCLIBC_HAS_XLOCALE__
+
+extern "C" __typeof(nl_langinfo_l) __nl_langinfo_l;
+extern "C" __typeof(strcoll_l) __strcoll_l;
+extern "C" __typeof(strftime_l) __strftime_l;
+extern "C" __typeof(strtod_l) __strtod_l;
+extern "C" __typeof(strtof_l) __strtof_l;
+extern "C" __typeof(strtold_l) __strtold_l;
+extern "C" __typeof(strxfrm_l) __strxfrm_l;
+extern "C" __typeof(newlocale) __newlocale;
+extern "C" __typeof(freelocale) __freelocale;
+extern "C" __typeof(duplocale) __duplocale;
+extern "C" __typeof(uselocale) __uselocale;
+
+#ifdef _GLIBCXX_USE_WCHAR_T
+extern "C" __typeof(iswctype_l) __iswctype_l;
+extern "C" __typeof(towlower_l) __towlower_l;
+extern "C" __typeof(towupper_l) __towupper_l;
+extern "C" __typeof(wcscoll_l) __wcscoll_l;
+extern "C" __typeof(wcsftime_l) __wcsftime_l;
+extern "C" __typeof(wcsxfrm_l) __wcsxfrm_l;
+extern "C" __typeof(wctype_l) __wctype_l;
+#endif
+
+#endif // GLIBC 2.3 and later
diff --git a/libstdc++-v3/config/locale/uclibc/c_locale.cc b/libstdc++-v3/config/locale/uclibc/c_locale.cc
new file mode 100644
index 0000000..5081dc1
--- /dev/null
+++ b/libstdc++-v3/config/locale/uclibc/c_locale.cc
@@ -0,0 +1,160 @@
+// Wrapper for underlying C-language localization -*- C++ -*-
+
+// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 2, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING.  If not, write to the Free
+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+// USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+//
+// ISO C++ 14882: 22.8  Standard locale categories.
+//
+
+// Written by Benjamin Kosnik <bkoz@redhat.com>
+
+#include <cerrno>  // For errno
+#include <locale>
+#include <stdexcept>
+#include <langinfo.h>
+#include <bits/c++locale_internal.h>
+
+#ifndef __UCLIBC_HAS_XLOCALE__
+#define __strtol_l(S, E, B, L)      strtol((S), (E), (B))
+#define __strtoul_l(S, E, B, L)     strtoul((S), (E), (B))
+#define __strtoll_l(S, E, B, L)     strtoll((S), (E), (B))
+#define __strtoull_l(S, E, B, L)    strtoull((S), (E), (B))
+#define __strtof_l(S, E, L)         strtof((S), (E))
+#define __strtod_l(S, E, L)         strtod((S), (E))
+#define __strtold_l(S, E, L)        strtold((S), (E))
+#warning should dummy __newlocale check for C|POSIX ?
+#define __newlocale(a, b, c)        NULL
+#define __freelocale(a)             ((void)0)
+#define __duplocale(a)              __c_locale()
+#endif
+
+namespace std
+{
+  template<>
+    void
+    __convert_to_v(const char* __s, float& __v, ios_base::iostate& __err,
+		   const __c_locale& __cloc)
+    {
+      if (!(__err & ios_base::failbit))
+	{
+	  char* __sanity;
+	  errno = 0;
+	  float __f = __strtof_l(__s, &__sanity, __cloc);
+          if (__sanity != __s && errno != ERANGE)
+	    __v = __f;
+	  else
+	    __err |= ios_base::failbit;
+	}
+    }
+
+  template<>
+    void
+    __convert_to_v(const char* __s, double& __v, ios_base::iostate& __err,
+		   const __c_locale& __cloc)
+    {
+      if (!(__err & ios_base::failbit))
+	{
+	  char* __sanity;
+	  errno = 0;
+	  double __d = __strtod_l(__s, &__sanity, __cloc);
+          if (__sanity != __s && errno != ERANGE)
+	    __v = __d;
+	  else
+	    __err |= ios_base::failbit;
+	}
+    }
+
+  template<>
+    void
+    __convert_to_v(const char* __s, long double& __v, ios_base::iostate& __err,
+		   const __c_locale& __cloc)
+    {
+      if (!(__err & ios_base::failbit))
+	{
+	  char* __sanity;
+	  errno = 0;
+	  long double __ld = __strtold_l(__s, &__sanity, __cloc);
+          if (__sanity != __s && errno != ERANGE)
+	    __v = __ld;
+	  else
+	    __err |= ios_base::failbit;
+	}
+    }
+
+  void
+  locale::facet::_S_create_c_locale(__c_locale& __cloc, const char* __s,
+				    __c_locale __old)
+  {
+    __cloc = __newlocale(1 << LC_ALL, __s, __old);
+#ifdef __UCLIBC_HAS_XLOCALE__
+    if (!__cloc)
+      {
+	// This named locale is not supported by the underlying OS.
+	__throw_runtime_error(__N("locale::facet::_S_create_c_locale "
+			      "name not valid"));
+      }
+#endif
+  }
+
+  void
+  locale::facet::_S_destroy_c_locale(__c_locale& __cloc)
+  {
+    if (_S_get_c_locale() != __cloc)
+      __freelocale(__cloc);
+  }
+
+  __c_locale
+  locale::facet::_S_clone_c_locale(__c_locale& __cloc)
+  { return __duplocale(__cloc); }
+} // namespace std
+
+namespace __gnu_cxx
+{
+  const char* const category_names[6 + _GLIBCXX_NUM_CATEGORIES] =
+    {
+      "LC_CTYPE",
+      "LC_NUMERIC",
+      "LC_TIME",
+      "LC_COLLATE",
+      "LC_MONETARY",
+      "LC_MESSAGES",
+#if _GLIBCXX_NUM_CATEGORIES != 0
+      "LC_PAPER",
+      "LC_NAME",
+      "LC_ADDRESS",
+      "LC_TELEPHONE",
+      "LC_MEASUREMENT",
+      "LC_IDENTIFICATION"
+#endif
+    };
+}
+
+namespace std
+{
+  const char* const* const locale::_S_categories = __gnu_cxx::category_names;
+}  // namespace std
diff --git a/libstdc++-v3/config/locale/uclibc/c_locale.h b/libstdc++-v3/config/locale/uclibc/c_locale.h
new file mode 100644
index 0000000..da07c1f
--- /dev/null
+++ b/libstdc++-v3/config/locale/uclibc/c_locale.h
@@ -0,0 +1,117 @@
+// Wrapper for underlying C-language localization -*- C++ -*-
+
+// Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 2, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING.  If not, write to the Free
+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+// USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+//
+// ISO C++ 14882: 22.8  Standard locale categories.
+//
+
+// Written by Benjamin Kosnik <bkoz@redhat.com>
+
+#ifndef _C_LOCALE_H
+#define _C_LOCALE_H 1
+
+#pragma GCC system_header
+
+#include <cstring>              // get std::strlen
+#include <cstdio>               // get std::snprintf or std::sprintf
+#include <clocale>
+#include <langinfo.h>		// For codecvt
+#ifdef __UCLIBC_MJN3_ONLY__
+#warning fix this
+#endif
+#ifdef __UCLIBC_HAS_LOCALE__
+#include <iconv.h>		// For codecvt using iconv, iconv_t
+#endif
+#ifdef __UCLIBC_HAS_GETTEXT_AWARENESS__
+#include <libintl.h> 		// For messages
+#endif
+
+#ifdef __UCLIBC_MJN3_ONLY__
+#warning what is _GLIBCXX_C_LOCALE_GNU for
+#endif
+#define _GLIBCXX_C_LOCALE_GNU 1
+
+#ifdef __UCLIBC_MJN3_ONLY__
+#warning fix categories
+#endif
+// #define _GLIBCXX_NUM_CATEGORIES 6
+#define _GLIBCXX_NUM_CATEGORIES 0
+
+#ifdef __UCLIBC_HAS_XLOCALE__
+namespace __gnu_cxx
+{
+  extern "C" __typeof(uselocale) __uselocale;
+}
+#endif
+
+namespace std
+{
+#ifdef __UCLIBC_HAS_XLOCALE__
+  typedef __locale_t		__c_locale;
+#else
+  typedef int*			__c_locale;
+#endif
+
+  // Convert numeric value of type _Tv to string and return length of
+  // string.  If snprintf is available use it, otherwise fall back to
+  // the unsafe sprintf which, in general, can be dangerous and should
+  // be avoided.
+  template<typename _Tv>
+    int
+    __convert_from_v(char* __out,
+		     const int __size __attribute__ ((__unused__)),
+		     const char* __fmt,
+#ifdef __UCLIBC_HAS_XCLOCALE__
+		     _Tv __v, const __c_locale& __cloc, int __prec)
+    {
+      __c_locale __old = __gnu_cxx::__uselocale(__cloc);
+#else
+		     _Tv __v, const __c_locale&, int __prec)
+    {
+# ifdef __UCLIBC_HAS_LOCALE__
+      char* __old = std::setlocale(LC_ALL, NULL);
+      char* __sav = new char[std::strlen(__old) + 1];
+      std::strcpy(__sav, __old);
+      std::setlocale(LC_ALL, "C");
+# endif
+#endif
+
+      const int __ret = std::snprintf(__out, __size, __fmt, __prec, __v);
+
+#ifdef __UCLIBC_HAS_XCLOCALE__
+      __gnu_cxx::__uselocale(__old);
+#elif defined __UCLIBC_HAS_LOCALE__
+      std::setlocale(LC_ALL, __sav);
+      delete [] __sav;
+#endif
+      return __ret;
+    }
+}
+
+#endif
diff --git a/libstdc++-v3/config/locale/uclibc/codecvt_members.cc b/libstdc++-v3/config/locale/uclibc/codecvt_members.cc
new file mode 100644
index 0000000..64aa962
--- /dev/null
+++ b/libstdc++-v3/config/locale/uclibc/codecvt_members.cc
@@ -0,0 +1,308 @@
+// std::codecvt implementation details, GNU version -*- C++ -*-
+
+// Copyright (C) 2002, 2003 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 2, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING.  If not, write to the Free
+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+// USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+//
+// ISO C++ 14882: 22.2.1.5 - Template class codecvt
+//
+
+// Written by Benjamin Kosnik <bkoz@redhat.com>
+
+#include <locale>
+#include <cstdlib>  // For MB_CUR_MAX
+#include <climits>  // For MB_LEN_MAX
+#include <bits/c++locale_internal.h>
+
+namespace std
+{
+  // Specializations.
+#ifdef _GLIBCXX_USE_WCHAR_T
+  codecvt_base::result
+  codecvt<wchar_t, char, mbstate_t>::
+  do_out(state_type& __state, const intern_type* __from,
+	 const intern_type* __from_end, const intern_type*& __from_next,
+	 extern_type* __to, extern_type* __to_end,
+	 extern_type*& __to_next) const
+  {
+    result __ret = ok;
+    state_type __tmp_state(__state);
+
+#ifdef __UCLIBC_HAS_XLOCALE__
+    __c_locale __old = __uselocale(_M_c_locale_codecvt);
+#endif
+
+    // wcsnrtombs is *very* fast but stops if encounters NUL characters:
+    // in case we fall back to wcrtomb and then continue, in a loop.
+    // NB: wcsnrtombs is a GNU extension
+    for (__from_next = __from, __to_next = __to;
+	 __from_next < __from_end && __to_next < __to_end
+	 && __ret == ok;)
+      {
+	const intern_type* __from_chunk_end = wmemchr(__from_next, L'\0',
+						      __from_end - __from_next);
+	if (!__from_chunk_end)
+	  __from_chunk_end = __from_end;
+
+	__from = __from_next;
+	const size_t __conv = wcsnrtombs(__to_next, &__from_next,
+					 __from_chunk_end - __from_next,
+					 __to_end - __to_next, &__state);
+	if (__conv == static_cast<size_t>(-1))
+	  {
+	    // In case of error, in order to stop at the exact place we
+	    // have to start again from the beginning with a series of
+	    // wcrtomb.
+	    for (; __from < __from_next; ++__from)
+	      __to_next += wcrtomb(__to_next, *__from, &__tmp_state);
+	    __state = __tmp_state;
+	    __ret = error;
+	  }
+	else if (__from_next && __from_next < __from_chunk_end)
+	  {
+	    __to_next += __conv;
+	    __ret = partial;
+	  }
+	else
+	  {
+	    __from_next = __from_chunk_end;
+	    __to_next += __conv;
+	  }
+
+	if (__from_next < __from_end && __ret == ok)
+	  {
+	    extern_type __buf[MB_LEN_MAX];
+	    __tmp_state = __state;
+	    const size_t __conv = wcrtomb(__buf, *__from_next, &__tmp_state);
+	    if (__conv > static_cast<size_t>(__to_end - __to_next))
+	      __ret = partial;
+	    else
+	      {
+		memcpy(__to_next, __buf, __conv);
+		__state = __tmp_state;
+		__to_next += __conv;
+		++__from_next;
+	      }
+	  }
+      }
+
+#ifdef __UCLIBC_HAS_XLOCALE__
+    __uselocale(__old);
+#endif
+
+    return __ret;
+  }
+
+  codecvt_base::result
+  codecvt<wchar_t, char, mbstate_t>::
+  do_in(state_type& __state, const extern_type* __from,
+	const extern_type* __from_end, const extern_type*& __from_next,
+	intern_type* __to, intern_type* __to_end,
+	intern_type*& __to_next) const
+  {
+    result __ret = ok;
+    state_type __tmp_state(__state);
+
+#ifdef __UCLIBC_HAS_XLOCALE__
+    __c_locale __old = __uselocale(_M_c_locale_codecvt);
+#endif
+
+    // mbsnrtowcs is *very* fast but stops if encounters NUL characters:
+    // in case we store a L'\0' and then continue, in a loop.
+    // NB: mbsnrtowcs is a GNU extension
+    for (__from_next = __from, __to_next = __to;
+	 __from_next < __from_end && __to_next < __to_end
+	 && __ret == ok;)
+      {
+	const extern_type* __from_chunk_end;
+	__from_chunk_end = static_cast<const extern_type*>(memchr(__from_next, '\0',
+								  __from_end
+								  - __from_next));
+	if (!__from_chunk_end)
+	  __from_chunk_end = __from_end;
+
+	__from = __from_next;
+	size_t __conv = mbsnrtowcs(__to_next, &__from_next,
+				   __from_chunk_end - __from_next,
+				   __to_end - __to_next, &__state);
+	if (__conv == static_cast<size_t>(-1))
+	  {
+	    // In case of error, in order to stop at the exact place we
+	    // have to start again from the beginning with a series of
+	    // mbrtowc.
+	    for (;; ++__to_next, __from += __conv)
+	      {
+		__conv = mbrtowc(__to_next, __from, __from_end - __from,
+				 &__tmp_state);
+		if (__conv == static_cast<size_t>(-1)
+		    || __conv == static_cast<size_t>(-2))
+		  break;
+	      }
+	    __from_next = __from;
+	    __state = __tmp_state;
+	    __ret = error;
+	  }
+	else if (__from_next && __from_next < __from_chunk_end)
+	  {
+	    // It is unclear what to return in this case (see DR 382).
+	    __to_next += __conv;
+	    __ret = partial;
+	  }
+	else
+	  {
+	    __from_next = __from_chunk_end;
+	    __to_next += __conv;
+	  }
+
+	if (__from_next < __from_end && __ret == ok)
+	  {
+	    if (__to_next < __to_end)
+	      {
+		// XXX Probably wrong for stateful encodings
+		__tmp_state = __state;
+		++__from_next;
+		*__to_next++ = L'\0';
+	      }
+	    else
+	      __ret = partial;
+	  }
+      }
+
+#ifdef __UCLIBC_HAS_XLOCALE__
+    __uselocale(__old);
+#endif
+
+    return __ret;
+  }
+
+  int
+  codecvt<wchar_t, char, mbstate_t>::
+  do_encoding() const throw()
+  {
+    // XXX This implementation assumes that the encoding is
+    // stateless and is either single-byte or variable-width.
+    int __ret = 0;
+#ifdef __UCLIBC_HAS_XLOCALE__
+    __c_locale __old = __uselocale(_M_c_locale_codecvt);
+#endif
+    if (MB_CUR_MAX == 1)
+      __ret = 1;
+#ifdef __UCLIBC_HAS_XLOCALE__
+    __uselocale(__old);
+#endif
+    return __ret;
+  }
+
+  int
+  codecvt<wchar_t, char, mbstate_t>::
+  do_max_length() const throw()
+  {
+#ifdef __UCLIBC_HAS_XLOCALE__
+    __c_locale __old = __uselocale(_M_c_locale_codecvt);
+#endif
+    // XXX Probably wrong for stateful encodings.
+    int __ret = MB_CUR_MAX;
+#ifdef __UCLIBC_HAS_XLOCALE__
+    __uselocale(__old);
+#endif
+    return __ret;
+  }
+
+  int
+  codecvt<wchar_t, char, mbstate_t>::
+  do_length(state_type& __state, const extern_type* __from,
+	    const extern_type* __end, size_t __max) const
+  {
+    int __ret = 0;
+    state_type __tmp_state(__state);
+
+#ifdef __UCLIBC_HAS_XLOCALE__
+    __c_locale __old = __uselocale(_M_c_locale_codecvt);
+#endif
+
+    // mbsnrtowcs is *very* fast but stops if encounters NUL characters:
+    // in case we advance past it and then continue, in a loop.
+    // NB: mbsnrtowcs is a GNU extension
+
+    // A dummy internal buffer is needed in order for mbsnrtocws to consider
+    // its fourth parameter (it wouldn't with NULL as first parameter).
+    wchar_t* __to = static_cast<wchar_t*>(__builtin_alloca(sizeof(wchar_t)
+							   * __max));
+    while (__from < __end && __max)
+      {
+	const extern_type* __from_chunk_end;
+	__from_chunk_end = static_cast<const extern_type*>(memchr(__from, '\0',
+								  __end
+								  - __from));
+	if (!__from_chunk_end)
+	  __from_chunk_end = __end;
+
+	const extern_type* __tmp_from = __from;
+	size_t __conv = mbsnrtowcs(__to, &__from,
+				   __from_chunk_end - __from,
+				   __max, &__state);
+	if (__conv == static_cast<size_t>(-1))
+	  {
+	    // In case of error, in order to stop at the exact place we
+	    // have to start again from the beginning with a series of
+	    // mbrtowc.
+	    for (__from = __tmp_from;; __from += __conv)
+	      {
+		__conv = mbrtowc(NULL, __from, __end - __from,
+				 &__tmp_state);
+		if (__conv == static_cast<size_t>(-1)
+		    || __conv == static_cast<size_t>(-2))
+		  break;
+	      }
+	    __state = __tmp_state;
+	    __ret += __from - __tmp_from;
+	    break;
+	  }
+	if (!__from)
+	  __from = __from_chunk_end;
+
+	__ret += __from - __tmp_from;
+	__max -= __conv;
+
+	if (__from < __end && __max)
+	  {
+	    // XXX Probably wrong for stateful encodings
+	    __tmp_state = __state;
+	    ++__from;
+	    ++__ret;
+	    --__max;
+	  }
+      }
+
+#ifdef __UCLIBC_HAS_XLOCALE__
+    __uselocale(__old);
+#endif
+
+    return __ret;
+  }
+#endif
+}
diff --git a/libstdc++-v3/config/locale/uclibc/collate_members.cc b/libstdc++-v3/config/locale/uclibc/collate_members.cc
new file mode 100644
index 0000000..c2664a7
--- /dev/null
+++ b/libstdc++-v3/config/locale/uclibc/collate_members.cc
@@ -0,0 +1,80 @@
+// std::collate implementation details, GNU version -*- C++ -*-
+
+// Copyright (C) 2001, 2002 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 2, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING.  If not, write to the Free
+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+// USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+//
+// ISO C++ 14882: 22.2.4.1.2  collate virtual functions
+//
+
+// Written by Benjamin Kosnik <bkoz@redhat.com>
+
+#include <locale>
+#include <bits/c++locale_internal.h>
+
+#ifndef __UCLIBC_HAS_XLOCALE__
+#define __strcoll_l(S1, S2, L)      strcoll((S1), (S2))
+#define __strxfrm_l(S1, S2, N, L)   strxfrm((S1), (S2), (N))
+#define __wcscoll_l(S1, S2, L)      wcscoll((S1), (S2))
+#define __wcsxfrm_l(S1, S2, N, L)   wcsxfrm((S1), (S2), (N))
+#endif
+
+namespace std
+{
+  // These are basically extensions to char_traits, and perhaps should
+  // be put there instead of here.
+  template<>
+    int
+    collate<char>::_M_compare(const char* __one, const char* __two) const
+    {
+      int __cmp = __strcoll_l(__one, __two, _M_c_locale_collate);
+      return (__cmp >> (8 * sizeof (int) - 2)) | (__cmp != 0);
+    }
+
+  template<>
+    size_t
+    collate<char>::_M_transform(char* __to, const char* __from,
+				size_t __n) const
+    { return __strxfrm_l(__to, __from, __n, _M_c_locale_collate); }
+
+#ifdef _GLIBCXX_USE_WCHAR_T
+  template<>
+    int
+    collate<wchar_t>::_M_compare(const wchar_t* __one,
+				 const wchar_t* __two) const
+    {
+      int __cmp = __wcscoll_l(__one, __two, _M_c_locale_collate);
+      return (__cmp >> (8 * sizeof (int) - 2)) | (__cmp != 0);
+    }
+
+  template<>
+    size_t
+    collate<wchar_t>::_M_transform(wchar_t* __to, const wchar_t* __from,
+				   size_t __n) const
+    { return __wcsxfrm_l(__to, __from, __n, _M_c_locale_collate); }
+#endif
+}
diff --git a/libstdc++-v3/config/locale/uclibc/ctype_members.cc b/libstdc++-v3/config/locale/uclibc/ctype_members.cc
new file mode 100644
index 0000000..7294e3a
--- /dev/null
+++ b/libstdc++-v3/config/locale/uclibc/ctype_members.cc
@@ -0,0 +1,300 @@
+// std::ctype implementation details, GNU version -*- C++ -*-
+
+// Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 2, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING.  If not, write to the Free
+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+// USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+//
+// ISO C++ 14882: 22.2.1.1.2  ctype virtual functions.
+//
+
+// Written by Benjamin Kosnik <bkoz@redhat.com>
+
+#define _LIBC
+#include <locale>
+#undef _LIBC
+#include <bits/c++locale_internal.h>
+
+#ifndef __UCLIBC_HAS_XLOCALE__
+#define __wctype_l(S, L)           wctype((S))
+#define __towupper_l(C, L)         towupper((C))
+#define __towlower_l(C, L)         towlower((C))
+#define __iswctype_l(C, M, L)      iswctype((C), (M))
+#endif
+
+namespace std
+{
+  // NB: The other ctype<char> specializations are in src/locale.cc and
+  // various /config/os/* files.
+  template<>
+    ctype_byname<char>::ctype_byname(const char* __s, size_t __refs)
+    : ctype<char>(0, false, __refs)
+    {
+      if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0)
+	{
+	  this->_S_destroy_c_locale(this->_M_c_locale_ctype);
+	  this->_S_create_c_locale(this->_M_c_locale_ctype, __s);
+#ifdef __UCLIBC_HAS_XLOCALE__
+	  this->_M_toupper = this->_M_c_locale_ctype->__ctype_toupper;
+	  this->_M_tolower = this->_M_c_locale_ctype->__ctype_tolower;
+	  this->_M_table = this->_M_c_locale_ctype->__ctype_b;
+#endif
+	}
+    }
+
+#ifdef _GLIBCXX_USE_WCHAR_T
+  ctype<wchar_t>::__wmask_type
+  ctype<wchar_t>::_M_convert_to_wmask(const mask __m) const
+  {
+    __wmask_type __ret;
+    switch (__m)
+      {
+      case space:
+	__ret = __wctype_l("space", _M_c_locale_ctype);
+	break;
+      case print:
+	__ret = __wctype_l("print", _M_c_locale_ctype);
+	break;
+      case cntrl:
+	__ret = __wctype_l("cntrl", _M_c_locale_ctype);
+	break;
+      case upper:
+	__ret = __wctype_l("upper", _M_c_locale_ctype);
+	break;
+      case lower:
+	__ret = __wctype_l("lower", _M_c_locale_ctype);
+	break;
+      case alpha:
+	__ret = __wctype_l("alpha", _M_c_locale_ctype);
+	break;
+      case digit:
+	__ret = __wctype_l("digit", _M_c_locale_ctype);
+	break;
+      case punct:
+	__ret = __wctype_l("punct", _M_c_locale_ctype);
+	break;
+      case xdigit:
+	__ret = __wctype_l("xdigit", _M_c_locale_ctype);
+	break;
+      case alnum:
+	__ret = __wctype_l("alnum", _M_c_locale_ctype);
+	break;
+      case graph:
+	__ret = __wctype_l("graph", _M_c_locale_ctype);
+	break;
+      default:
+	__ret = __wmask_type();
+      }
+    return __ret;
+  }
+
+  wchar_t
+  ctype<wchar_t>::do_toupper(wchar_t __c) const
+  { return __towupper_l(__c, _M_c_locale_ctype); }
+
+  const wchar_t*
+  ctype<wchar_t>::do_toupper(wchar_t* __lo, const wchar_t* __hi) const
+  {
+    while (__lo < __hi)
+      {
+        *__lo = __towupper_l(*__lo, _M_c_locale_ctype);
+        ++__lo;
+      }
+    return __hi;
+  }
+
+  wchar_t
+  ctype<wchar_t>::do_tolower(wchar_t __c) const
+  { return __towlower_l(__c, _M_c_locale_ctype); }
+
+  const wchar_t*
+  ctype<wchar_t>::do_tolower(wchar_t* __lo, const wchar_t* __hi) const
+  {
+    while (__lo < __hi)
+      {
+        *__lo = __towlower_l(*__lo, _M_c_locale_ctype);
+        ++__lo;
+      }
+    return __hi;
+  }
+
+  bool
+  ctype<wchar_t>::
+  do_is(mask __m, wchar_t __c) const
+  {
+    // Highest bitmask in ctype_base == 10, but extra in "C"
+    // library for blank.
+    bool __ret = false;
+    const size_t __bitmasksize = 11;
+    for (size_t __bitcur = 0; __bitcur <= __bitmasksize; ++__bitcur)
+      if (__m & _M_bit[__bitcur]
+	  && __iswctype_l(__c, _M_wmask[__bitcur], _M_c_locale_ctype))
+	{
+	  __ret = true;
+	  break;
+	}
+    return __ret;
+  }
+
+  const wchar_t*
+  ctype<wchar_t>::
+  do_is(const wchar_t* __lo, const wchar_t* __hi, mask* __vec) const
+  {
+    for (; __lo < __hi; ++__vec, ++__lo)
+      {
+	// Highest bitmask in ctype_base == 10, but extra in "C"
+	// library for blank.
+	const size_t __bitmasksize = 11;
+	mask __m = 0;
+	for (size_t __bitcur = 0; __bitcur <= __bitmasksize; ++__bitcur)
+	  if (__iswctype_l(*__lo, _M_wmask[__bitcur], _M_c_locale_ctype))
+	    __m |= _M_bit[__bitcur];
+	*__vec = __m;
+      }
+    return __hi;
+  }
+
+  const wchar_t*
+  ctype<wchar_t>::
+  do_scan_is(mask __m, const wchar_t* __lo, const wchar_t* __hi) const
+  {
+    while (__lo < __hi && !this->do_is(__m, *__lo))
+      ++__lo;
+    return __lo;
+  }
+
+  const wchar_t*
+  ctype<wchar_t>::
+  do_scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
+  {
+    while (__lo < __hi && this->do_is(__m, *__lo) != 0)
+      ++__lo;
+    return __lo;
+  }
+
+  wchar_t
+  ctype<wchar_t>::
+  do_widen(char __c) const
+  { return _M_widen[static_cast<unsigned char>(__c)]; }
+
+  const char*
+  ctype<wchar_t>::
+  do_widen(const char* __lo, const char* __hi, wchar_t* __dest) const
+  {
+    while (__lo < __hi)
+      {
+	*__dest = _M_widen[static_cast<unsigned char>(*__lo)];
+	++__lo;
+	++__dest;
+      }
+    return __hi;
+  }
+
+  char
+  ctype<wchar_t>::
+  do_narrow(wchar_t __wc, char __dfault) const
+  {
+    if (__wc >= 0 && __wc < 128 && _M_narrow_ok)
+      return _M_narrow[__wc];
+#ifdef __UCLIBC_HAS_XLOCALE__
+    __c_locale __old = __uselocale(_M_c_locale_ctype);
+#endif
+    const int __c = wctob(__wc);
+#ifdef __UCLIBC_HAS_XLOCALE__
+    __uselocale(__old);
+#endif
+    return (__c == EOF ? __dfault : static_cast<char>(__c));
+  }
+
+  const wchar_t*
+  ctype<wchar_t>::
+  do_narrow(const wchar_t* __lo, const wchar_t* __hi, char __dfault,
+	    char* __dest) const
+  {
+#ifdef __UCLIBC_HAS_XLOCALE__
+    __c_locale __old = __uselocale(_M_c_locale_ctype);
+#endif
+    if (_M_narrow_ok)
+      while (__lo < __hi)
+	{
+	  if (*__lo >= 0 && *__lo < 128)
+	    *__dest = _M_narrow[*__lo];
+	  else
+	    {
+	      const int __c = wctob(*__lo);
+	      *__dest = (__c == EOF ? __dfault : static_cast<char>(__c));
+	    }
+	  ++__lo;
+	  ++__dest;
+	}
+    else
+      while (__lo < __hi)
+	{
+	  const int __c = wctob(*__lo);
+	  *__dest = (__c == EOF ? __dfault : static_cast<char>(__c));
+	  ++__lo;
+	  ++__dest;
+	}
+#ifdef __UCLIBC_HAS_XLOCALE__
+    __uselocale(__old);
+#endif
+    return __hi;
+  }
+
+  void
+  ctype<wchar_t>::_M_initialize_ctype()
+  {
+#ifdef __UCLIBC_HAS_XLOCALE__
+    __c_locale __old = __uselocale(_M_c_locale_ctype);
+#endif
+    wint_t __i;
+    for (__i = 0; __i < 128; ++__i)
+      {
+	const int __c = wctob(__i);
+	if (__c == EOF)
+	  break;
+	else
+	  _M_narrow[__i] = static_cast<char>(__c);
+      }
+    if (__i == 128)
+      _M_narrow_ok = true;
+    else
+      _M_narrow_ok = false;
+    for (size_t __j = 0;
+	 __j < sizeof(_M_widen) / sizeof(wint_t); ++__j)
+      _M_widen[__j] = btowc(__j);
+
+    for (size_t __k = 0; __k <= 11; ++__k)
+      {
+	_M_bit[__k] = static_cast<mask>(_ISbit(__k));
+	_M_wmask[__k] = _M_convert_to_wmask(_M_bit[__k]);
+      }
+#ifdef __UCLIBC_HAS_XLOCALE__
+    __uselocale(__old);
+#endif
+  }
+#endif //  _GLIBCXX_USE_WCHAR_T
+}
diff --git a/libstdc++-v3/config/locale/uclibc/messages_members.cc b/libstdc++-v3/config/locale/uclibc/messages_members.cc
new file mode 100644
index 0000000..13594d9
--- /dev/null
+++ b/libstdc++-v3/config/locale/uclibc/messages_members.cc
@@ -0,0 +1,100 @@
+// std::messages implementation details, GNU version -*- C++ -*-
+
+// Copyright (C) 2001, 2002 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 2, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING.  If not, write to the Free
+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+// USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+//
+// ISO C++ 14882: 22.2.7.1.2  messages virtual functions
+//
+
+// Written by Benjamin Kosnik <bkoz@redhat.com>
+
+#include <locale>
+#include <bits/c++locale_internal.h>
+
+#ifdef __UCLIBC_MJN3_ONLY__
+#warning fix gettext stuff
+#endif
+#ifdef __UCLIBC_HAS_GETTEXT_AWARENESS__
+extern "C" char *__dcgettext(const char *domainname,
+			     const char *msgid, int category);
+#undef gettext
+#define gettext(msgid) __dcgettext(NULL, msgid, LC_MESSAGES)
+#else
+#undef gettext
+#define gettext(msgid) (msgid)
+#endif
+
+namespace std
+{
+  // Specializations.
+  template<>
+    string
+    messages<char>::do_get(catalog, int, int, const string& __dfault) const
+    {
+#ifdef __UCLIBC_HAS_XLOCALE__
+      __c_locale __old = __uselocale(_M_c_locale_messages);
+      const char* __msg = const_cast<const char*>(gettext(__dfault.c_str()));
+      __uselocale(__old);
+      return string(__msg);
+#elif defined __UCLIBC_HAS_LOCALE__
+      char* __old = strdup(setlocale(LC_ALL, NULL));
+      setlocale(LC_ALL, _M_name_messages);
+      const char* __msg = gettext(__dfault.c_str());
+      setlocale(LC_ALL, __old);
+      free(__old);
+      return string(__msg);
+#else
+      const char* __msg = gettext(__dfault.c_str());
+      return string(__msg);
+#endif
+    }
+
+#ifdef _GLIBCXX_USE_WCHAR_T
+  template<>
+    wstring
+    messages<wchar_t>::do_get(catalog, int, int, const wstring& __dfault) const
+    {
+# ifdef __UCLIBC_HAS_XLOCALE__
+      __c_locale __old = __uselocale(_M_c_locale_messages);
+      char* __msg = gettext(_M_convert_to_char(__dfault));
+      __uselocale(__old);
+      return _M_convert_from_char(__msg);
+# elif defined __UCLIBC_HAS_LOCALE__
+      char* __old = strdup(setlocale(LC_ALL, NULL));
+      setlocale(LC_ALL, _M_name_messages);
+      char* __msg = gettext(_M_convert_to_char(__dfault));
+      setlocale(LC_ALL, __old);
+      free(__old);
+      return _M_convert_from_char(__msg);
+# else
+      char* __msg = gettext(_M_convert_to_char(__dfault));
+      return _M_convert_from_char(__msg);
+# endif
+    }
+#endif
+}
diff --git a/libstdc++-v3/config/locale/uclibc/messages_members.h b/libstdc++-v3/config/locale/uclibc/messages_members.h
new file mode 100644
index 0000000..1424078
--- /dev/null
+++ b/libstdc++-v3/config/locale/uclibc/messages_members.h
@@ -0,0 +1,118 @@
+// std::messages implementation details, GNU version -*- C++ -*-
+
+// Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 2, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING.  If not, write to the Free
+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+// USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+//
+// ISO C++ 14882: 22.2.7.1.2  messages functions
+//
+
+// Written by Benjamin Kosnik <bkoz@redhat.com>
+
+#ifdef __UCLIBC_MJN3_ONLY__
+#warning fix prototypes for *textdomain funcs
+#endif
+#ifdef __UCLIBC_HAS_GETTEXT_AWARENESS__
+extern "C" char *__textdomain(const char *domainname);
+extern "C" char *__bindtextdomain(const char *domainname,
+				  const char *dirname);
+#else
+#undef __textdomain
+#undef __bindtextdomain
+#define __textdomain(D)           ((void)0)
+#define __bindtextdomain(D,P)     ((void)0)
+#endif
+
+  // Non-virtual member functions.
+  template<typename _CharT>
+     messages<_CharT>::messages(size_t __refs)
+     : facet(__refs), _M_c_locale_messages(_S_get_c_locale()),
+     _M_name_messages(_S_get_c_name())
+     { }
+
+  template<typename _CharT>
+     messages<_CharT>::messages(__c_locale __cloc, const char* __s,
+				size_t __refs)
+     : facet(__refs), _M_c_locale_messages(_S_clone_c_locale(__cloc)),
+     _M_name_messages(__s)
+     {
+       char* __tmp = new char[std::strlen(__s) + 1];
+       std::strcpy(__tmp, __s);
+       _M_name_messages = __tmp;
+     }
+
+  template<typename _CharT>
+    typename messages<_CharT>::catalog
+    messages<_CharT>::open(const basic_string<char>& __s, const locale& __loc,
+			   const char* __dir) const
+    {
+      __bindtextdomain(__s.c_str(), __dir);
+      return this->do_open(__s, __loc);
+    }
+
+  // Virtual member functions.
+  template<typename _CharT>
+    messages<_CharT>::~messages()
+    {
+      if (_M_name_messages != _S_get_c_name())
+	delete [] _M_name_messages;
+      _S_destroy_c_locale(_M_c_locale_messages);
+    }
+
+  template<typename _CharT>
+    typename messages<_CharT>::catalog
+    messages<_CharT>::do_open(const basic_string<char>& __s,
+			      const locale&) const
+    {
+      // No error checking is done, assume the catalog exists and can
+      // be used.
+      __textdomain(__s.c_str());
+      return 0;
+    }
+
+  template<typename _CharT>
+    void
+    messages<_CharT>::do_close(catalog) const
+    { }
+
+   // messages_byname
+   template<typename _CharT>
+     messages_byname<_CharT>::messages_byname(const char* __s, size_t __refs)
+     : messages<_CharT>(__refs)
+     {
+       if (this->_M_name_messages != locale::facet::_S_get_c_name())
+	 delete [] this->_M_name_messages;
+       char* __tmp = new char[std::strlen(__s) + 1];
+       std::strcpy(__tmp, __s);
+       this->_M_name_messages = __tmp;
+
+       if (std::strcmp(__s, "C") != 0 && std::strcmp(__s, "POSIX") != 0)
+	 {
+	   this->_S_destroy_c_locale(this->_M_c_locale_messages);
+	   this->_S_create_c_locale(this->_M_c_locale_messages, __s);
+	 }
+     }
diff --git a/libstdc++-v3/config/locale/uclibc/monetary_members.cc b/libstdc++-v3/config/locale/uclibc/monetary_members.cc
new file mode 100644
index 0000000..aa52731
--- /dev/null
+++ b/libstdc++-v3/config/locale/uclibc/monetary_members.cc
@@ -0,0 +1,692 @@
+// std::moneypunct implementation details, GNU version -*- C++ -*-
+
+// Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 2, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING.  If not, write to the Free
+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+// USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+//
+// ISO C++ 14882: 22.2.6.3.2  moneypunct virtual functions
+//
+
+// Written by Benjamin Kosnik <bkoz@redhat.com>
+
+#define _LIBC
+#include <locale>
+#undef _LIBC
+#include <bits/c++locale_internal.h>
+
+#ifdef __UCLIBC_MJN3_ONLY__
+#warning optimize this for uclibc
+#warning tailor for stub locale support
+#endif
+
+#ifndef __UCLIBC_HAS_XLOCALE__
+#define __nl_langinfo_l(N, L)         nl_langinfo((N))
+#endif
+
+namespace std
+{
+  // Construct and return valid pattern consisting of some combination of:
+  // space none symbol sign value
+  money_base::pattern
+  money_base::_S_construct_pattern(char __precedes, char __space, char __posn)
+  {
+    pattern __ret;
+
+    // This insanely complicated routine attempts to construct a valid
+    // pattern for use with monyepunct. A couple of invariants:
+
+    // if (__precedes) symbol -> value
+    // else value -> symbol
+
+    // if (__space) space
+    // else none
+
+    // none == never first
+    // space never first or last
+
+    // Any elegant implementations of this are welcome.
+    switch (__posn)
+      {
+      case 0:
+      case 1:
+	// 1 The sign precedes the value and symbol.
+	__ret.field[0] = sign;
+	if (__space)
+	  {
+	    // Pattern starts with sign.
+	    if (__precedes)
+	      {
+		__ret.field[1] = symbol;
+		__ret.field[3] = value;
+	      }
+	    else
+	      {
+		__ret.field[1] = value;
+		__ret.field[3] = symbol;
+	      }
+	    __ret.field[2] = space;
+	  }
+	else
+	  {
+	    // Pattern starts with sign and ends with none.
+	    if (__precedes)
+	      {
+		__ret.field[1] = symbol;
+		__ret.field[2] = value;
+	      }
+	    else
+	      {
+		__ret.field[1] = value;
+		__ret.field[2] = symbol;
+	      }
+	    __ret.field[3] = none;
+	  }
+	break;
+      case 2:
+	// 2 The sign follows the value and symbol.
+	if (__space)
+	  {
+	    // Pattern either ends with sign.
+	    if (__precedes)
+	      {
+		__ret.field[0] = symbol;
+		__ret.field[2] = value;
+	      }
+	    else
+	      {
+		__ret.field[0] = value;
+		__ret.field[2] = symbol;
+	      }
+	    __ret.field[1] = space;
+	    __ret.field[3] = sign;
+	  }
+	else
+	  {
+	    // Pattern ends with sign then none.
+	    if (__precedes)
+	      {
+		__ret.field[0] = symbol;
+		__ret.field[1] = value;
+	      }
+	    else
+	      {
+		__ret.field[0] = value;
+		__ret.field[1] = symbol;
+	      }
+	    __ret.field[2] = sign;
+	    __ret.field[3] = none;
+	  }
+	break;
+      case 3:
+	// 3 The sign immediately precedes the symbol.
+	if (__precedes)
+	  {
+	    __ret.field[0] = sign;
+	    __ret.field[1] = symbol;
+	    if (__space)
+	      {
+		__ret.field[2] = space;
+		__ret.field[3] = value;
+	      }
+	    else
+	      {
+		__ret.field[2] = value;
+		__ret.field[3] = none;
+	      }
+	  }
+	else
+	  {
+	    __ret.field[0] = value;
+	    if (__space)
+	      {
+		__ret.field[1] = space;
+		__ret.field[2] = sign;
+		__ret.field[3] = symbol;
+	      }
+	    else
+	      {
+		__ret.field[1] = sign;
+		__ret.field[2] = symbol;
+		__ret.field[3] = none;
+	      }
+	  }
+	break;
+      case 4:
+	// 4 The sign immediately follows the symbol.
+	if (__precedes)
+	  {
+	    __ret.field[0] = symbol;
+	    __ret.field[1] = sign;
+	    if (__space)
+	      {
+		__ret.field[2] = space;
+		__ret.field[3] = value;
+	      }
+	    else
+	      {
+		__ret.field[2] = value;
+		__ret.field[3] = none;
+	      }
+	  }
+	else
+	  {
+	    __ret.field[0] = value;
+	    if (__space)
+	      {
+		__ret.field[1] = space;
+		__ret.field[2] = symbol;
+		__ret.field[3] = sign;
+	      }
+	    else
+	      {
+		__ret.field[1] = symbol;
+		__ret.field[2] = sign;
+		__ret.field[3] = none;
+	      }
+	  }
+	break;
+      default:
+	;
+      }
+    return __ret;
+  }
+
+  template<>
+    void
+    moneypunct<char, true>::_M_initialize_moneypunct(__c_locale __cloc,
+						     const char*)
+    {
+      if (!_M_data)
+	_M_data = new __moneypunct_cache<char, true>;
+
+      if (!__cloc)
+	{
+	  // "C" locale
+	  _M_data->_M_decimal_point = '.';
+	  _M_data->_M_thousands_sep = ',';
+	  _M_data->_M_grouping = "";
+	  _M_data->_M_grouping_size = 0;
+	  _M_data->_M_curr_symbol = "";
+	  _M_data->_M_curr_symbol_size = 0;
+	  _M_data->_M_positive_sign = "";
+	  _M_data->_M_positive_sign_size = 0;
+	  _M_data->_M_negative_sign = "";
+	  _M_data->_M_negative_sign_size = 0;
+	  _M_data->_M_frac_digits = 0;
+	  _M_data->_M_pos_format = money_base::_S_default_pattern;
+	  _M_data->_M_neg_format = money_base::_S_default_pattern;
+
+	  for (size_t __i = 0; __i < money_base::_S_end; ++__i)
+	    _M_data->_M_atoms[__i] = money_base::_S_atoms[__i];
+	}
+      else
+	{
+	  // Named locale.
+	  _M_data->_M_decimal_point = *(__nl_langinfo_l(__MON_DECIMAL_POINT,
+							__cloc));
+	  _M_data->_M_thousands_sep = *(__nl_langinfo_l(__MON_THOUSANDS_SEP,
+							__cloc));
+	  _M_data->_M_grouping = __nl_langinfo_l(__MON_GROUPING, __cloc);
+	  _M_data->_M_grouping_size = strlen(_M_data->_M_grouping);
+	  _M_data->_M_positive_sign = __nl_langinfo_l(__POSITIVE_SIGN, __cloc);
+	  _M_data->_M_positive_sign_size = strlen(_M_data->_M_positive_sign);
+
+	  char __nposn = *(__nl_langinfo_l(__INT_N_SIGN_POSN, __cloc));
+	  if (!__nposn)
+	    _M_data->_M_negative_sign = "()";
+	  else
+	    _M_data->_M_negative_sign = __nl_langinfo_l(__NEGATIVE_SIGN,
+							__cloc);
+	  _M_data->_M_negative_sign_size = strlen(_M_data->_M_negative_sign);
+
+	  // _Intl == true
+	  _M_data->_M_curr_symbol = __nl_langinfo_l(__INT_CURR_SYMBOL, __cloc);
+	  _M_data->_M_curr_symbol_size = strlen(_M_data->_M_curr_symbol);
+	  _M_data->_M_frac_digits = *(__nl_langinfo_l(__INT_FRAC_DIGITS,
+						      __cloc));
+	  char __pprecedes = *(__nl_langinfo_l(__INT_P_CS_PRECEDES, __cloc));
+	  char __pspace = *(__nl_langinfo_l(__INT_P_SEP_BY_SPACE, __cloc));
+	  char __pposn = *(__nl_langinfo_l(__INT_P_SIGN_POSN, __cloc));
+	  _M_data->_M_pos_format = _S_construct_pattern(__pprecedes, __pspace,
+							__pposn);
+	  char __nprecedes = *(__nl_langinfo_l(__INT_N_CS_PRECEDES, __cloc));
+	  char __nspace = *(__nl_langinfo_l(__INT_N_SEP_BY_SPACE, __cloc));
+	  _M_data->_M_neg_format = _S_construct_pattern(__nprecedes, __nspace,
+							__nposn);
+	}
+    }
+
+  template<>
+    void
+    moneypunct<char, false>::_M_initialize_moneypunct(__c_locale __cloc,
+						      const char*)
+    {
+      if (!_M_data)
+	_M_data = new __moneypunct_cache<char, false>;
+
+      if (!__cloc)
+	{
+	  // "C" locale
+	  _M_data->_M_decimal_point = '.';
+	  _M_data->_M_thousands_sep = ',';
+	  _M_data->_M_grouping = "";
+	  _M_data->_M_grouping_size = 0;
+	  _M_data->_M_curr_symbol = "";
+	  _M_data->_M_curr_symbol_size = 0;
+	  _M_data->_M_positive_sign = "";
+	  _M_data->_M_positive_sign_size = 0;
+	  _M_data->_M_negative_sign = "";
+	  _M_data->_M_negative_sign_size = 0;
+	  _M_data->_M_frac_digits = 0;
+	  _M_data->_M_pos_format = money_base::_S_default_pattern;
+	  _M_data->_M_neg_format = money_base::_S_default_pattern;
+
+	  for (size_t __i = 0; __i < money_base::_S_end; ++__i)
+	    _M_data->_M_atoms[__i] = money_base::_S_atoms[__i];
+	}
+      else
+	{
+	  // Named locale.
+	  _M_data->_M_decimal_point = *(__nl_langinfo_l(__MON_DECIMAL_POINT,
+							__cloc));
+	  _M_data->_M_thousands_sep = *(__nl_langinfo_l(__MON_THOUSANDS_SEP,
+							__cloc));
+	  _M_data->_M_grouping = __nl_langinfo_l(__MON_GROUPING, __cloc);
+	  _M_data->_M_grouping_size = strlen(_M_data->_M_grouping);
+	  _M_data->_M_positive_sign = __nl_langinfo_l(__POSITIVE_SIGN, __cloc);
+	  _M_data->_M_positive_sign_size = strlen(_M_data->_M_positive_sign);
+
+	  char __nposn = *(__nl_langinfo_l(__N_SIGN_POSN, __cloc));
+	  if (!__nposn)
+	    _M_data->_M_negative_sign = "()";
+	  else
+	    _M_data->_M_negative_sign = __nl_langinfo_l(__NEGATIVE_SIGN,
+							__cloc);
+	  _M_data->_M_negative_sign_size = strlen(_M_data->_M_negative_sign);
+
+	  // _Intl == false
+	  _M_data->_M_curr_symbol = __nl_langinfo_l(__CURRENCY_SYMBOL, __cloc);
+	  _M_data->_M_curr_symbol_size = strlen(_M_data->_M_curr_symbol);
+	  _M_data->_M_frac_digits = *(__nl_langinfo_l(__FRAC_DIGITS, __cloc));
+	  char __pprecedes = *(__nl_langinfo_l(__P_CS_PRECEDES, __cloc));
+	  char __pspace = *(__nl_langinfo_l(__P_SEP_BY_SPACE, __cloc));
+	  char __pposn = *(__nl_langinfo_l(__P_SIGN_POSN, __cloc));
+	  _M_data->_M_pos_format = _S_construct_pattern(__pprecedes, __pspace,
+							__pposn);
+	  char __nprecedes = *(__nl_langinfo_l(__N_CS_PRECEDES, __cloc));
+	  char __nspace = *(__nl_langinfo_l(__N_SEP_BY_SPACE, __cloc));
+	  _M_data->_M_neg_format = _S_construct_pattern(__nprecedes, __nspace,
+							__nposn);
+	}
+    }
+
+  template<>
+    moneypunct<char, true>::~moneypunct()
+    { delete _M_data; }
+
+  template<>
+    moneypunct<char, false>::~moneypunct()
+    { delete _M_data; }
+
+#ifdef _GLIBCXX_USE_WCHAR_T
+  template<>
+    void
+    moneypunct<wchar_t, true>::_M_initialize_moneypunct(__c_locale __cloc,
+#ifdef __UCLIBC_HAS_XLOCALE__
+							const char*)
+#else
+							const char* __name)
+#endif
+    {
+      if (!_M_data)
+	_M_data = new __moneypunct_cache<wchar_t, true>;
+
+      if (!__cloc)
+	{
+	  // "C" locale
+	  _M_data->_M_decimal_point = L'.';
+	  _M_data->_M_thousands_sep = L',';
+	  _M_data->_M_grouping = "";
+	  _M_data->_M_grouping_size = 0;
+	  _M_data->_M_curr_symbol = L"";
+	  _M_data->_M_curr_symbol_size = 0;
+	  _M_data->_M_positive_sign = L"";
+	  _M_data->_M_positive_sign_size = 0;
+	  _M_data->_M_negative_sign = L"";
+	  _M_data->_M_negative_sign_size = 0;
+	  _M_data->_M_frac_digits = 0;
+	  _M_data->_M_pos_format = money_base::_S_default_pattern;
+	  _M_data->_M_neg_format = money_base::_S_default_pattern;
+
+	  // Use ctype::widen code without the facet...
+	  for (size_t __i = 0; __i < money_base::_S_end; ++__i)
+	    _M_data->_M_atoms[__i] =
+	      static_cast<wchar_t>(money_base::_S_atoms[__i]);
+	}
+      else
+	{
+	  // Named locale.
+#ifdef __UCLIBC_HAS_XLOCALE__
+	  __c_locale __old = __uselocale(__cloc);
+#else
+	  // Switch to named locale so that mbsrtowcs will work.
+	  char* __old = strdup(setlocale(LC_ALL, NULL));
+	  setlocale(LC_ALL, __name);
+#endif
+
+#ifdef __UCLIBC_MJN3_ONLY__
+#warning fix this... should be monetary
+#endif
+#ifdef __UCLIBC__
+# ifdef __UCLIBC_HAS_XLOCALE__
+	  _M_data->_M_decimal_point = __cloc->decimal_point_wc;
+	  _M_data->_M_thousands_sep = __cloc->thousands_sep_wc;
+# else
+	  _M_data->_M_decimal_point = __global_locale->decimal_point_wc;
+	  _M_data->_M_thousands_sep = __global_locale->thousands_sep_wc;
+# endif
+#else
+	  union { char *__s; wchar_t __w; } __u;
+	  __u.__s = __nl_langinfo_l(_NL_MONETARY_DECIMAL_POINT_WC, __cloc);
+	  _M_data->_M_decimal_point = __u.__w;
+
+	  __u.__s = __nl_langinfo_l(_NL_MONETARY_THOUSANDS_SEP_WC, __cloc);
+	  _M_data->_M_thousands_sep = __u.__w;
+#endif
+	  _M_data->_M_grouping = __nl_langinfo_l(__MON_GROUPING, __cloc);
+	  _M_data->_M_grouping_size = strlen(_M_data->_M_grouping);
+
+	  const char* __cpossign = __nl_langinfo_l(__POSITIVE_SIGN, __cloc);
+	  const char* __cnegsign = __nl_langinfo_l(__NEGATIVE_SIGN, __cloc);
+	  const char* __ccurr = __nl_langinfo_l(__INT_CURR_SYMBOL, __cloc);
+
+	  wchar_t* __wcs_ps = 0;
+	  wchar_t* __wcs_ns = 0;
+	  const char __nposn = *(__nl_langinfo_l(__INT_N_SIGN_POSN, __cloc));
+	  try
+	    {
+	      mbstate_t __state;
+	      size_t __len = strlen(__cpossign);
+	      if (__len)
+		{
+		  ++__len;
+		  memset(&__state, 0, sizeof(mbstate_t));
+		  __wcs_ps = new wchar_t[__len];
+		  mbsrtowcs(__wcs_ps, &__cpossign, __len, &__state);
+		  _M_data->_M_positive_sign = __wcs_ps;
+		}
+	      else
+		_M_data->_M_positive_sign = L"";
+	      _M_data->_M_positive_sign_size = wcslen(_M_data->_M_positive_sign);
+
+	      __len = strlen(__cnegsign);
+	      if (!__nposn)
+		_M_data->_M_negative_sign = L"()";
+	      else if (__len)
+		{
+		  ++__len;
+		  memset(&__state, 0, sizeof(mbstate_t));
+		  __wcs_ns = new wchar_t[__len];
+		  mbsrtowcs(__wcs_ns, &__cnegsign, __len, &__state);
+		  _M_data->_M_negative_sign = __wcs_ns;
+		}
+	      else
+		_M_data->_M_negative_sign = L"";
+	      _M_data->_M_negative_sign_size = wcslen(_M_data->_M_negative_sign);
+
+	      // _Intl == true.
+	      __len = strlen(__ccurr);
+	      if (__len)
+		{
+		  ++__len;
+		  memset(&__state, 0, sizeof(mbstate_t));
+		  wchar_t* __wcs = new wchar_t[__len];
+		  mbsrtowcs(__wcs, &__ccurr, __len, &__state);
+		  _M_data->_M_curr_symbol = __wcs;
+		}
+	      else
+		_M_data->_M_curr_symbol = L"";
+	      _M_data->_M_curr_symbol_size = wcslen(_M_data->_M_curr_symbol);
+	    }
+	  catch (...)
+	    {
+	      delete _M_data;
+	      _M_data = 0;
+	      delete __wcs_ps;
+	      delete __wcs_ns;
+#ifdef __UCLIBC_HAS_XLOCALE__
+	      __uselocale(__old);
+#else
+	      setlocale(LC_ALL, __old);
+	      free(__old);
+#endif
+	      __throw_exception_again;
+	    }
+
+	  _M_data->_M_frac_digits = *(__nl_langinfo_l(__INT_FRAC_DIGITS,
+						      __cloc));
+	  char __pprecedes = *(__nl_langinfo_l(__INT_P_CS_PRECEDES, __cloc));
+	  char __pspace = *(__nl_langinfo_l(__INT_P_SEP_BY_SPACE, __cloc));
+	  char __pposn = *(__nl_langinfo_l(__INT_P_SIGN_POSN, __cloc));
+	  _M_data->_M_pos_format = _S_construct_pattern(__pprecedes, __pspace,
+							__pposn);
+	  char __nprecedes = *(__nl_langinfo_l(__INT_N_CS_PRECEDES, __cloc));
+	  char __nspace = *(__nl_langinfo_l(__INT_N_SEP_BY_SPACE, __cloc));
+	  _M_data->_M_neg_format = _S_construct_pattern(__nprecedes, __nspace,
+							__nposn);
+
+#ifdef __UCLIBC_HAS_XLOCALE__
+	  __uselocale(__old);
+#else
+	  setlocale(LC_ALL, __old);
+	  free(__old);
+#endif
+	}
+    }
+
+  template<>
+  void
+  moneypunct<wchar_t, false>::_M_initialize_moneypunct(__c_locale __cloc,
+#ifdef __UCLIBC_HAS_XLOCALE__
+						       const char*)
+#else
+                                                       const char* __name)
+#endif
+  {
+    if (!_M_data)
+      _M_data = new __moneypunct_cache<wchar_t, false>;
+
+    if (!__cloc)
+	{
+	  // "C" locale
+	  _M_data->_M_decimal_point = L'.';
+	  _M_data->_M_thousands_sep = L',';
+	  _M_data->_M_grouping = "";
+          _M_data->_M_grouping_size = 0;
+	  _M_data->_M_curr_symbol = L"";
+	  _M_data->_M_curr_symbol_size = 0;
+	  _M_data->_M_positive_sign = L"";
+	  _M_data->_M_positive_sign_size = 0;
+	  _M_data->_M_negative_sign = L"";
+	  _M_data->_M_negative_sign_size = 0;
+	  _M_data->_M_frac_digits = 0;
+	  _M_data->_M_pos_format = money_base::_S_default_pattern;
+	  _M_data->_M_neg_format = money_base::_S_default_pattern;
+
+	  // Use ctype::widen code without the facet...
+	  for (size_t __i = 0; __i < money_base::_S_end; ++__i)
+	    _M_data->_M_atoms[__i] =
+	      static_cast<wchar_t>(money_base::_S_atoms[__i]);
+	}
+      else
+	{
+	  // Named locale.
+#ifdef __UCLIBC_HAS_XLOCALE__
+	  __c_locale __old = __uselocale(__cloc);
+#else
+	  // Switch to named locale so that mbsrtowcs will work.
+	  char* __old = strdup(setlocale(LC_ALL, NULL));
+	  setlocale(LC_ALL, __name);
+#endif
+
+#ifdef __UCLIBC_MJN3_ONLY__
+#warning fix this... should be monetary
+#endif
+#ifdef __UCLIBC__
+# ifdef __UCLIBC_HAS_XLOCALE__
+	  _M_data->_M_decimal_point = __cloc->decimal_point_wc;
+	  _M_data->_M_thousands_sep = __cloc->thousands_sep_wc;
+# else
+	  _M_data->_M_decimal_point = __global_locale->decimal_point_wc;
+	  _M_data->_M_thousands_sep = __global_locale->thousands_sep_wc;
+# endif
+#else
+          union { char *__s; wchar_t __w; } __u;
+	  __u.__s = __nl_langinfo_l(_NL_MONETARY_DECIMAL_POINT_WC, __cloc);
+	  _M_data->_M_decimal_point = __u.__w;
+
+	  __u.__s = __nl_langinfo_l(_NL_MONETARY_THOUSANDS_SEP_WC, __cloc);
+	  _M_data->_M_thousands_sep = __u.__w;
+#endif
+	  _M_data->_M_grouping = __nl_langinfo_l(__MON_GROUPING, __cloc);
+          _M_data->_M_grouping_size = strlen(_M_data->_M_grouping);
+
+	  const char* __cpossign = __nl_langinfo_l(__POSITIVE_SIGN, __cloc);
+	  const char* __cnegsign = __nl_langinfo_l(__NEGATIVE_SIGN, __cloc);
+	  const char* __ccurr = __nl_langinfo_l(__CURRENCY_SYMBOL, __cloc);
+
+	  wchar_t* __wcs_ps = 0;
+	  wchar_t* __wcs_ns = 0;
+	  const char __nposn = *(__nl_langinfo_l(__N_SIGN_POSN, __cloc));
+	  try
+            {
+              mbstate_t __state;
+              size_t __len;
+              __len = strlen(__cpossign);
+              if (__len)
+                {
+		  ++__len;
+		  memset(&__state, 0, sizeof(mbstate_t));
+		  __wcs_ps = new wchar_t[__len];
+		  mbsrtowcs(__wcs_ps, &__cpossign, __len, &__state);
+		  _M_data->_M_positive_sign = __wcs_ps;
+		}
+	      else
+		_M_data->_M_positive_sign = L"";
+              _M_data->_M_positive_sign_size = wcslen(_M_data->_M_positive_sign);
+
+	      __len = strlen(__cnegsign);
+	      if (!__nposn)
+		_M_data->_M_negative_sign = L"()";
+	      else if (__len)
+		{
+		  ++__len;
+		  memset(&__state, 0, sizeof(mbstate_t));
+		  __wcs_ns = new wchar_t[__len];
+		  mbsrtowcs(__wcs_ns, &__cnegsign, __len, &__state);
+		  _M_data->_M_negative_sign = __wcs_ns;
+		}
+	      else
+		_M_data->_M_negative_sign = L"";
+              _M_data->_M_negative_sign_size = wcslen(_M_data->_M_negative_sign);
+
+	      // _Intl == true.
+	      __len = strlen(__ccurr);
+	      if (__len)
+		{
+		  ++__len;
+		  memset(&__state, 0, sizeof(mbstate_t));
+		  wchar_t* __wcs = new wchar_t[__len];
+		  mbsrtowcs(__wcs, &__ccurr, __len, &__state);
+		  _M_data->_M_curr_symbol = __wcs;
+		}
+	      else
+		_M_data->_M_curr_symbol = L"";
+              _M_data->_M_curr_symbol_size = wcslen(_M_data->_M_curr_symbol);
+	    }
+          catch (...)
+	    {
+	      delete _M_data;
+              _M_data = 0;
+	      delete __wcs_ps;
+	      delete __wcs_ns;
+#ifdef __UCLIBC_HAS_XLOCALE__
+	      __uselocale(__old);
+#else
+	      setlocale(LC_ALL, __old);
+	      free(__old);
+#endif
+              __throw_exception_again;
+	    }
+
+	  _M_data->_M_frac_digits = *(__nl_langinfo_l(__FRAC_DIGITS, __cloc));
+	  char __pprecedes = *(__nl_langinfo_l(__P_CS_PRECEDES, __cloc));
+	  char __pspace = *(__nl_langinfo_l(__P_SEP_BY_SPACE, __cloc));
+	  char __pposn = *(__nl_langinfo_l(__P_SIGN_POSN, __cloc));
+	  _M_data->_M_pos_format = _S_construct_pattern(__pprecedes, __pspace,
+	                                                __pposn);
+	  char __nprecedes = *(__nl_langinfo_l(__N_CS_PRECEDES, __cloc));
+	  char __nspace = *(__nl_langinfo_l(__N_SEP_BY_SPACE, __cloc));
+	  _M_data->_M_neg_format = _S_construct_pattern(__nprecedes, __nspace,
+	                                                __nposn);
+
+#ifdef __UCLIBC_HAS_XLOCALE__
+	  __uselocale(__old);
+#else
+	  setlocale(LC_ALL, __old);
+	  free(__old);
+#endif
+	}
+    }
+
+  template<>
+    moneypunct<wchar_t, true>::~moneypunct()
+    {
+      if (_M_data->_M_positive_sign_size)
+	delete [] _M_data->_M_positive_sign;
+      if (_M_data->_M_negative_sign_size
+          && wcscmp(_M_data->_M_negative_sign, L"()") != 0)
+	delete [] _M_data->_M_negative_sign;
+      if (_M_data->_M_curr_symbol_size)
+	delete [] _M_data->_M_curr_symbol;
+      delete _M_data;
+    }
+
+  template<>
+    moneypunct<wchar_t, false>::~moneypunct()
+    {
+      if (_M_data->_M_positive_sign_size)
+	delete [] _M_data->_M_positive_sign;
+      if (_M_data->_M_negative_sign_size
+          && wcscmp(_M_data->_M_negative_sign, L"()") != 0)
+	delete [] _M_data->_M_negative_sign;
+      if (_M_data->_M_curr_symbol_size)
+	delete [] _M_data->_M_curr_symbol;
+      delete _M_data;
+    }
+#endif
+}
diff --git a/libstdc++-v3/config/locale/uclibc/numeric_members.cc b/libstdc++-v3/config/locale/uclibc/numeric_members.cc
new file mode 100644
index 0000000..883ec1a
--- /dev/null
+++ b/libstdc++-v3/config/locale/uclibc/numeric_members.cc
@@ -0,0 +1,160 @@
+// std::numpunct implementation details, GNU version -*- C++ -*-
+
+// Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 2, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING.  If not, write to the Free
+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+// USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+//
+// ISO C++ 14882: 22.2.3.1.2  numpunct virtual functions
+//
+
+// Written by Benjamin Kosnik <bkoz@redhat.com>
+
+#define _LIBC
+#include <locale>
+#undef _LIBC
+#include <bits/c++locale_internal.h>
+
+#ifdef __UCLIBC_MJN3_ONLY__
+#warning tailor for stub locale support
+#endif
+#ifndef __UCLIBC_HAS_XLOCALE__
+#define __nl_langinfo_l(N, L)         nl_langinfo((N))
+#endif
+
+namespace std
+{
+  template<>
+    void
+    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc)
+    {
+      if (!_M_data)
+	_M_data = new __numpunct_cache<char>;
+
+      if (!__cloc)
+	{
+	  // "C" locale
+	  _M_data->_M_grouping = "";
+	  _M_data->_M_grouping_size = 0;
+	  _M_data->_M_use_grouping = false;
+
+	  _M_data->_M_decimal_point = '.';
+	  _M_data->_M_thousands_sep = ',';
+
+	  for (size_t __i = 0; __i < __num_base::_S_oend; ++__i)
+	    _M_data->_M_atoms_out[__i] = __num_base::_S_atoms_out[__i];
+
+	  for (size_t __j = 0; __j < __num_base::_S_iend; ++__j)
+	    _M_data->_M_atoms_in[__j] = __num_base::_S_atoms_in[__j];
+	}
+      else
+	{
+	  // Named locale.
+	  _M_data->_M_decimal_point = *(__nl_langinfo_l(DECIMAL_POINT,
+							__cloc));
+	  _M_data->_M_thousands_sep = *(__nl_langinfo_l(THOUSANDS_SEP,
+							__cloc));
+
+	  // Check for NULL, which implies no grouping.
+	  if (_M_data->_M_thousands_sep == '\0')
+	    _M_data->_M_grouping = "";
+	  else
+	    _M_data->_M_grouping = __nl_langinfo_l(GROUPING, __cloc);
+	  _M_data->_M_grouping_size = strlen(_M_data->_M_grouping);
+	}
+
+      // NB: There is no way to extact this info from posix locales.
+      // _M_truename = __nl_langinfo_l(YESSTR, __cloc);
+      _M_data->_M_truename = "true";
+      _M_data->_M_truename_size = 4;
+      // _M_falsename = __nl_langinfo_l(NOSTR, __cloc);
+      _M_data->_M_falsename = "false";
+      _M_data->_M_falsename_size = 5;
+    }
+
+  template<>
+    numpunct<char>::~numpunct()
+    { delete _M_data; }
+
+#ifdef _GLIBCXX_USE_WCHAR_T
+  template<>
+    void
+    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc)
+    {
+      if (!_M_data)
+	_M_data = new __numpunct_cache<wchar_t>;
+
+      if (!__cloc)
+	{
+	  // "C" locale
+	  _M_data->_M_grouping = "";
+	  _M_data->_M_grouping_size = 0;
+	  _M_data->_M_use_grouping = false;
+
+	  _M_data->_M_decimal_point = L'.';
+	  _M_data->_M_thousands_sep = L',';
+
+	  // Use ctype::widen code without the facet...
+	  for (size_t __i = 0; __i < __num_base::_S_oend; ++__i)
+	    _M_data->_M_atoms_out[__i] =
+	      static_cast<wchar_t>(__num_base::_S_atoms_out[__i]);
+
+	  for (size_t __j = 0; __j < __num_base::_S_iend; ++__j)
+	    _M_data->_M_atoms_in[__j] =
+	      static_cast<wchar_t>(__num_base::_S_atoms_in[__j]);
+	}
+      else
+	{
+	  // Named locale.
+	  // NB: In the GNU model wchar_t is always 32 bit wide.
+	  union { char *__s; wchar_t __w; } __u;
+	  __u.__s = __nl_langinfo_l(_NL_NUMERIC_DECIMAL_POINT_WC, __cloc);
+	  _M_data->_M_decimal_point = __u.__w;
+
+	  __u.__s = __nl_langinfo_l(_NL_NUMERIC_THOUSANDS_SEP_WC, __cloc);
+	  _M_data->_M_thousands_sep = __u.__w;
+
+	  if (_M_data->_M_thousands_sep == L'\0')
+	    _M_data->_M_grouping = "";
+	  else
+	    _M_data->_M_grouping = __nl_langinfo_l(GROUPING, __cloc);
+	  _M_data->_M_grouping_size = strlen(_M_data->_M_grouping);
+	}
+
+      // NB: There is no way to extact this info from posix locales.
+      // _M_truename = __nl_langinfo_l(YESSTR, __cloc);
+      _M_data->_M_truename = L"true";
+      _M_data->_M_truename_size = 4;
+      // _M_falsename = __nl_langinfo_l(NOSTR, __cloc);
+      _M_data->_M_falsename = L"false";
+      _M_data->_M_falsename_size = 5;
+    }
+
+  template<>
+    numpunct<wchar_t>::~numpunct()
+    { delete _M_data; }
+ #endif
+}
diff --git a/libstdc++-v3/config/locale/uclibc/time_members.cc b/libstdc++-v3/config/locale/uclibc/time_members.cc
new file mode 100644
index 0000000..e0707d7
--- /dev/null
+++ b/libstdc++-v3/config/locale/uclibc/time_members.cc
@@ -0,0 +1,406 @@
+// std::time_get, std::time_put implementation, GNU version -*- C++ -*-
+
+// Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 2, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING.  If not, write to the Free
+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+// USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+//
+// ISO C++ 14882: 22.2.5.1.2 - time_get virtual functions
+// ISO C++ 14882: 22.2.5.3.2 - time_put virtual functions
+//
+
+// Written by Benjamin Kosnik <bkoz@redhat.com>
+
+#include <locale>
+#include <bits/c++locale_internal.h>
+
+#ifdef __UCLIBC_MJN3_ONLY__
+#warning tailor for stub locale support
+#endif
+#ifndef __UCLIBC_HAS_XLOCALE__
+#define __nl_langinfo_l(N, L)         nl_langinfo((N))
+#endif
+
+namespace std
+{
+  template<>
+    void
+    __timepunct<char>::
+    _M_put(char* __s, size_t __maxlen, const char* __format,
+	   const tm* __tm) const
+    {
+#ifdef __UCLIBC_HAS_XLOCALE__
+      const size_t __len = __strftime_l(__s, __maxlen, __format, __tm,
+					_M_c_locale_timepunct);
+#else
+      char* __old = strdup(setlocale(LC_ALL, NULL));
+      setlocale(LC_ALL, _M_name_timepunct);
+      const size_t __len = strftime(__s, __maxlen, __format, __tm);
+      setlocale(LC_ALL, __old);
+      free(__old);
+#endif
+      // Make sure __s is null terminated.
+      if (__len == 0)
+	__s[0] = '\0';
+    }
+
+  template<>
+    void
+    __timepunct<char>::_M_initialize_timepunct(__c_locale __cloc)
+    {
+      if (!_M_data)
+	_M_data = new __timepunct_cache<char>;
+
+      if (!__cloc)
+	{
+	  // "C" locale
+	  _M_c_locale_timepunct = _S_get_c_locale();
+
+	  _M_data->_M_date_format = "%m/%d/%y";
+	  _M_data->_M_date_era_format = "%m/%d/%y";
+	  _M_data->_M_time_format = "%H:%M:%S";
+	  _M_data->_M_time_era_format = "%H:%M:%S";
+	  _M_data->_M_date_time_format = "";
+	  _M_data->_M_date_time_era_format = "";
+	  _M_data->_M_am = "AM";
+	  _M_data->_M_pm = "PM";
+	  _M_data->_M_am_pm_format = "";
+
+	  // Day names, starting with "C"'s Sunday.
+	  _M_data->_M_day1 = "Sunday";
+	  _M_data->_M_day2 = "Monday";
+	  _M_data->_M_day3 = "Tuesday";
+	  _M_data->_M_day4 = "Wednesday";
+	  _M_data->_M_day5 = "Thursday";
+	  _M_data->_M_day6 = "Friday";
+	  _M_data->_M_day7 = "Saturday";
+
+	  // Abbreviated day names, starting with "C"'s Sun.
+	  _M_data->_M_aday1 = "Sun";
+	  _M_data->_M_aday2 = "Mon";
+	  _M_data->_M_aday3 = "Tue";
+	  _M_data->_M_aday4 = "Wed";
+	  _M_data->_M_aday5 = "Thu";
+	  _M_data->_M_aday6 = "Fri";
+	  _M_data->_M_aday7 = "Sat";
+
+	  // Month names, starting with "C"'s January.
+	  _M_data->_M_month01 = "January";
+	  _M_data->_M_month02 = "February";
+	  _M_data->_M_month03 = "March";
+	  _M_data->_M_month04 = "April";
+	  _M_data->_M_month05 = "May";
+	  _M_data->_M_month06 = "June";
+	  _M_data->_M_month07 = "July";
+	  _M_data->_M_month08 = "August";
+	  _M_data->_M_month09 = "September";
+	  _M_data->_M_month10 = "October";
+	  _M_data->_M_month11 = "November";
+	  _M_data->_M_month12 = "December";
+
+	  // Abbreviated month names, starting with "C"'s Jan.
+	  _M_data->_M_amonth01 = "Jan";
+	  _M_data->_M_amonth02 = "Feb";
+	  _M_data->_M_amonth03 = "Mar";
+	  _M_data->_M_amonth04 = "Apr";
+	  _M_data->_M_amonth05 = "May";
+	  _M_data->_M_amonth06 = "Jun";
+	  _M_data->_M_amonth07 = "Jul";
+	  _M_data->_M_amonth08 = "Aug";
+	  _M_data->_M_amonth09 = "Sep";
+	  _M_data->_M_amonth10 = "Oct";
+	  _M_data->_M_amonth11 = "Nov";
+	  _M_data->_M_amonth12 = "Dec";
+	}
+      else
+	{
+	  _M_c_locale_timepunct = _S_clone_c_locale(__cloc);
+
+	  _M_data->_M_date_format = __nl_langinfo_l(D_FMT, __cloc);
+	  _M_data->_M_date_era_format = __nl_langinfo_l(ERA_D_FMT, __cloc);
+	  _M_data->_M_time_format = __nl_langinfo_l(T_FMT, __cloc);
+	  _M_data->_M_time_era_format = __nl_langinfo_l(ERA_T_FMT, __cloc);
+	  _M_data->_M_date_time_format = __nl_langinfo_l(D_T_FMT, __cloc);
+	  _M_data->_M_date_time_era_format = __nl_langinfo_l(ERA_D_T_FMT,
+							     __cloc);
+	  _M_data->_M_am = __nl_langinfo_l(AM_STR, __cloc);
+	  _M_data->_M_pm = __nl_langinfo_l(PM_STR, __cloc);
+	  _M_data->_M_am_pm_format = __nl_langinfo_l(T_FMT_AMPM, __cloc);
+
+	  // Day names, starting with "C"'s Sunday.
+	  _M_data->_M_day1 = __nl_langinfo_l(DAY_1, __cloc);
+	  _M_data->_M_day2 = __nl_langinfo_l(DAY_2, __cloc);
+	  _M_data->_M_day3 = __nl_langinfo_l(DAY_3, __cloc);
+	  _M_data->_M_day4 = __nl_langinfo_l(DAY_4, __cloc);
+	  _M_data->_M_day5 = __nl_langinfo_l(DAY_5, __cloc);
+	  _M_data->_M_day6 = __nl_langinfo_l(DAY_6, __cloc);
+	  _M_data->_M_day7 = __nl_langinfo_l(DAY_7, __cloc);
+
+	  // Abbreviated day names, starting with "C"'s Sun.
+	  _M_data->_M_aday1 = __nl_langinfo_l(ABDAY_1, __cloc);
+	  _M_data->_M_aday2 = __nl_langinfo_l(ABDAY_2, __cloc);
+	  _M_data->_M_aday3 = __nl_langinfo_l(ABDAY_3, __cloc);
+	  _M_data->_M_aday4 = __nl_langinfo_l(ABDAY_4, __cloc);
+	  _M_data->_M_aday5 = __nl_langinfo_l(ABDAY_5, __cloc);
+	  _M_data->_M_aday6 = __nl_langinfo_l(ABDAY_6, __cloc);
+	  _M_data->_M_aday7 = __nl_langinfo_l(ABDAY_7, __cloc);
+
+	  // Month names, starting with "C"'s January.
+	  _M_data->_M_month01 = __nl_langinfo_l(MON_1, __cloc);
+	  _M_data->_M_month02 = __nl_langinfo_l(MON_2, __cloc);
+	  _M_data->_M_month03 = __nl_langinfo_l(MON_3, __cloc);
+	  _M_data->_M_month04 = __nl_langinfo_l(MON_4, __cloc);
+	  _M_data->_M_month05 = __nl_langinfo_l(MON_5, __cloc);
+	  _M_data->_M_month06 = __nl_langinfo_l(MON_6, __cloc);
+	  _M_data->_M_month07 = __nl_langinfo_l(MON_7, __cloc);
+	  _M_data->_M_month08 = __nl_langinfo_l(MON_8, __cloc);
+	  _M_data->_M_month09 = __nl_langinfo_l(MON_9, __cloc);
+	  _M_data->_M_month10 = __nl_langinfo_l(MON_10, __cloc);
+	  _M_data->_M_month11 = __nl_langinfo_l(MON_11, __cloc);
+	  _M_data->_M_month12 = __nl_langinfo_l(MON_12, __cloc);
+
+	  // Abbreviated month names, starting with "C"'s Jan.
+	  _M_data->_M_amonth01 = __nl_langinfo_l(ABMON_1, __cloc);
+	  _M_data->_M_amonth02 = __nl_langinfo_l(ABMON_2, __cloc);
+	  _M_data->_M_amonth03 = __nl_langinfo_l(ABMON_3, __cloc);
+	  _M_data->_M_amonth04 = __nl_langinfo_l(ABMON_4, __cloc);
+	  _M_data->_M_amonth05 = __nl_langinfo_l(ABMON_5, __cloc);
+	  _M_data->_M_amonth06 = __nl_langinfo_l(ABMON_6, __cloc);
+	  _M_data->_M_amonth07 = __nl_langinfo_l(ABMON_7, __cloc);
+	  _M_data->_M_amonth08 = __nl_langinfo_l(ABMON_8, __cloc);
+	  _M_data->_M_amonth09 = __nl_langinfo_l(ABMON_9, __cloc);
+	  _M_data->_M_amonth10 = __nl_langinfo_l(ABMON_10, __cloc);
+	  _M_data->_M_amonth11 = __nl_langinfo_l(ABMON_11, __cloc);
+	  _M_data->_M_amonth12 = __nl_langinfo_l(ABMON_12, __cloc);
+	}
+    }
+
+#ifdef _GLIBCXX_USE_WCHAR_T
+  template<>
+    void
+    __timepunct<wchar_t>::
+    _M_put(wchar_t* __s, size_t __maxlen, const wchar_t* __format,
+	   const tm* __tm) const
+    {
+#ifdef __UCLIBC_HAS_XLOCALE__
+      __wcsftime_l(__s, __maxlen, __format, __tm, _M_c_locale_timepunct);
+      const size_t __len = __wcsftime_l(__s, __maxlen, __format, __tm,
+					_M_c_locale_timepunct);
+#else
+      char* __old = strdup(setlocale(LC_ALL, NULL));
+      setlocale(LC_ALL, _M_name_timepunct);
+      const size_t __len = wcsftime(__s, __maxlen, __format, __tm);
+      setlocale(LC_ALL, __old);
+      free(__old);
+#endif
+      // Make sure __s is null terminated.
+      if (__len == 0)
+	__s[0] = L'\0';
+    }
+
+  template<>
+    void
+    __timepunct<wchar_t>::_M_initialize_timepunct(__c_locale __cloc)
+    {
+      if (!_M_data)
+	_M_data = new __timepunct_cache<wchar_t>;
+
+#warning wide time stuff
+//       if (!__cloc)
+	{
+	  // "C" locale
+	  _M_c_locale_timepunct = _S_get_c_locale();
+
+	  _M_data->_M_date_format = L"%m/%d/%y";
+	  _M_data->_M_date_era_format = L"%m/%d/%y";
+	  _M_data->_M_time_format = L"%H:%M:%S";
+	  _M_data->_M_time_era_format = L"%H:%M:%S";
+	  _M_data->_M_date_time_format = L"";
+	  _M_data->_M_date_time_era_format = L"";
+	  _M_data->_M_am = L"AM";
+	  _M_data->_M_pm = L"PM";
+	  _M_data->_M_am_pm_format = L"";
+
+	  // Day names, starting with "C"'s Sunday.
+	  _M_data->_M_day1 = L"Sunday";
+	  _M_data->_M_day2 = L"Monday";
+	  _M_data->_M_day3 = L"Tuesday";
+	  _M_data->_M_day4 = L"Wednesday";
+	  _M_data->_M_day5 = L"Thursday";
+	  _M_data->_M_day6 = L"Friday";
+	  _M_data->_M_day7 = L"Saturday";
+
+	  // Abbreviated day names, starting with "C"'s Sun.
+	  _M_data->_M_aday1 = L"Sun";
+	  _M_data->_M_aday2 = L"Mon";
+	  _M_data->_M_aday3 = L"Tue";
+	  _M_data->_M_aday4 = L"Wed";
+	  _M_data->_M_aday5 = L"Thu";
+	  _M_data->_M_aday6 = L"Fri";
+	  _M_data->_M_aday7 = L"Sat";
+
+	  // Month names, starting with "C"'s January.
+	  _M_data->_M_month01 = L"January";
+	  _M_data->_M_month02 = L"February";
+	  _M_data->_M_month03 = L"March";
+	  _M_data->_M_month04 = L"April";
+	  _M_data->_M_month05 = L"May";
+	  _M_data->_M_month06 = L"June";
+	  _M_data->_M_month07 = L"July";
+	  _M_data->_M_month08 = L"August";
+	  _M_data->_M_month09 = L"September";
+	  _M_data->_M_month10 = L"October";
+	  _M_data->_M_month11 = L"November";
+	  _M_data->_M_month12 = L"December";
+
+	  // Abbreviated month names, starting with "C"'s Jan.
+	  _M_data->_M_amonth01 = L"Jan";
+	  _M_data->_M_amonth02 = L"Feb";
+	  _M_data->_M_amonth03 = L"Mar";
+	  _M_data->_M_amonth04 = L"Apr";
+	  _M_data->_M_amonth05 = L"May";
+	  _M_data->_M_amonth06 = L"Jun";
+	  _M_data->_M_amonth07 = L"Jul";
+	  _M_data->_M_amonth08 = L"Aug";
+	  _M_data->_M_amonth09 = L"Sep";
+	  _M_data->_M_amonth10 = L"Oct";
+	  _M_data->_M_amonth11 = L"Nov";
+	  _M_data->_M_amonth12 = L"Dec";
+	}
+#if 0
+      else
+	{
+	  _M_c_locale_timepunct = _S_clone_c_locale(__cloc);
+
+	  union { char *__s; wchar_t *__w; } __u;
+
+	  __u.__s = __nl_langinfo_l(_NL_WD_FMT, __cloc);
+	  _M_data->_M_date_format = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WERA_D_FMT, __cloc);
+	  _M_data->_M_date_era_format = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WT_FMT, __cloc);
+	  _M_data->_M_time_format = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WERA_T_FMT, __cloc);
+	  _M_data->_M_time_era_format = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WD_T_FMT, __cloc);
+	  _M_data->_M_date_time_format = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WERA_D_T_FMT, __cloc);
+	  _M_data->_M_date_time_era_format = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WAM_STR, __cloc);
+	  _M_data->_M_am = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WPM_STR, __cloc);
+	  _M_data->_M_pm = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WT_FMT_AMPM, __cloc);
+	  _M_data->_M_am_pm_format = __u.__w;
+
+	  // Day names, starting with "C"'s Sunday.
+	  __u.__s = __nl_langinfo_l(_NL_WDAY_1, __cloc);
+	  _M_data->_M_day1 = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WDAY_2, __cloc);
+	  _M_data->_M_day2 = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WDAY_3, __cloc);
+	  _M_data->_M_day3 = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WDAY_4, __cloc);
+	  _M_data->_M_day4 = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WDAY_5, __cloc);
+	  _M_data->_M_day5 = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WDAY_6, __cloc);
+	  _M_data->_M_day6 = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WDAY_7, __cloc);
+	  _M_data->_M_day7 = __u.__w;
+
+	  // Abbreviated day names, starting with "C"'s Sun.
+	  __u.__s = __nl_langinfo_l(_NL_WABDAY_1, __cloc);
+	  _M_data->_M_aday1 = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WABDAY_2, __cloc);
+	  _M_data->_M_aday2 = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WABDAY_3, __cloc);
+	  _M_data->_M_aday3 = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WABDAY_4, __cloc);
+	  _M_data->_M_aday4 = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WABDAY_5, __cloc);
+	  _M_data->_M_aday5 = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WABDAY_6, __cloc);
+	  _M_data->_M_aday6 = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WABDAY_7, __cloc);
+	  _M_data->_M_aday7 = __u.__w;
+
+	  // Month names, starting with "C"'s January.
+	  __u.__s = __nl_langinfo_l(_NL_WMON_1, __cloc);
+	  _M_data->_M_month01 = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WMON_2, __cloc);
+	  _M_data->_M_month02 = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WMON_3, __cloc);
+	  _M_data->_M_month03 = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WMON_4, __cloc);
+	  _M_data->_M_month04 = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WMON_5, __cloc);
+	  _M_data->_M_month05 = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WMON_6, __cloc);
+	  _M_data->_M_month06 = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WMON_7, __cloc);
+	  _M_data->_M_month07 = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WMON_8, __cloc);
+	  _M_data->_M_month08 = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WMON_9, __cloc);
+	  _M_data->_M_month09 = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WMON_10, __cloc);
+	  _M_data->_M_month10 = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WMON_11, __cloc);
+	  _M_data->_M_month11 = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WMON_12, __cloc);
+	  _M_data->_M_month12 = __u.__w;
+
+	  // Abbreviated month names, starting with "C"'s Jan.
+	  __u.__s = __nl_langinfo_l(_NL_WABMON_1, __cloc);
+	  _M_data->_M_amonth01 = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WABMON_2, __cloc);
+	  _M_data->_M_amonth02 = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WABMON_3, __cloc);
+	  _M_data->_M_amonth03 = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WABMON_4, __cloc);
+	  _M_data->_M_amonth04 = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WABMON_5, __cloc);
+	  _M_data->_M_amonth05 = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WABMON_6, __cloc);
+	  _M_data->_M_amonth06 = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WABMON_7, __cloc);
+	  _M_data->_M_amonth07 = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WABMON_8, __cloc);
+	  _M_data->_M_amonth08 = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WABMON_9, __cloc);
+	  _M_data->_M_amonth09 = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WABMON_10, __cloc);
+	  _M_data->_M_amonth10 = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WABMON_11, __cloc);
+	  _M_data->_M_amonth11 = __u.__w;
+	  __u.__s = __nl_langinfo_l(_NL_WABMON_12, __cloc);
+	  _M_data->_M_amonth12 = __u.__w;
+	}
+#endif // 0
+    }
+#endif
+}
diff --git a/libstdc++-v3/config/locale/uclibc/time_members.h b/libstdc++-v3/config/locale/uclibc/time_members.h
new file mode 100644
index 0000000..ba8e858
--- /dev/null
+++ b/libstdc++-v3/config/locale/uclibc/time_members.h
@@ -0,0 +1,68 @@
+// std::time_get, std::time_put implementation, GNU version -*- C++ -*-
+
+// Copyright (C) 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 2, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING.  If not, write to the Free
+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+// USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+//
+// ISO C++ 14882: 22.2.5.1.2 - time_get functions
+// ISO C++ 14882: 22.2.5.3.2 - time_put functions
+//
+
+// Written by Benjamin Kosnik <bkoz@redhat.com>
+
+  template<typename _CharT>
+    __timepunct<_CharT>::__timepunct(size_t __refs)
+    : facet(__refs), _M_data(NULL), _M_c_locale_timepunct(NULL),
+    _M_name_timepunct(_S_get_c_name())
+    { _M_initialize_timepunct(); }
+
+  template<typename _CharT>
+    __timepunct<_CharT>::__timepunct(__cache_type* __cache, size_t __refs)
+    : facet(__refs), _M_data(__cache), _M_c_locale_timepunct(NULL),
+    _M_name_timepunct(_S_get_c_name())
+    { _M_initialize_timepunct(); }
+
+  template<typename _CharT>
+    __timepunct<_CharT>::__timepunct(__c_locale __cloc, const char* __s,
+				     size_t __refs)
+    : facet(__refs), _M_data(NULL), _M_c_locale_timepunct(NULL),
+    _M_name_timepunct(__s)
+    {
+      char* __tmp = new char[std::strlen(__s) + 1];
+      std::strcpy(__tmp, __s);
+      _M_name_timepunct = __tmp;
+      _M_initialize_timepunct(__cloc);
+    }
+
+  template<typename _CharT>
+    __timepunct<_CharT>::~__timepunct()
+    {
+      if (_M_name_timepunct != _S_get_c_name())
+	delete [] _M_name_timepunct;
+      delete _M_data;
+      _S_destroy_c_locale(_M_c_locale_timepunct);
+    }
diff --git a/libstdc++-v3/configure b/libstdc++-v3/configure
index 8cd4c76..217012e 100755
--- a/libstdc++-v3/configure
+++ b/libstdc++-v3/configure
@@ -15918,6 +15918,9 @@ fi
   # Default to "generic".
   if test $enable_clocale_flag = auto; then
     case ${target_os} in
+      *-uclibc*)
+        enable_clocale_flag=uclibc
+        ;;
       linux* | gnu* | kfreebsd*-gnu | knetbsd*-gnu)
 	enable_clocale_flag=gnu
 	;;
@@ -16196,6 +16199,78 @@ $as_echo "newlib" >&6; }
       CTIME_CC=config/locale/generic/time_members.cc
       CLOCALE_INTERNAL_H=config/locale/generic/c++locale_internal.h
       ;;
+    uclibc)
+      { $as_echo "$as_me:${as_lineno-$LINENO}: result: uclibc" >&5
+$as_echo "uclibc" >&6; }
+
+      # Declare intention to use gettext, and add support for specific
+      # languages.
+      # For some reason, ALL_LINGUAS has to be before AM-GNU-GETTEXT
+      ALL_LINGUAS="de fr"
+
+      # Don't call AM-GNU-GETTEXT here. Instead, assume glibc.
+      # Extract the first word of "msgfmt", so it can be a program name with args.
+set dummy msgfmt; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_check_msgfmt+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$check_msgfmt"; then
+  ac_cv_prog_check_msgfmt="$check_msgfmt" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_check_msgfmt="yes"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  test -z "$ac_cv_prog_check_msgfmt" && ac_cv_prog_check_msgfmt="no"
+fi
+fi
+check_msgfmt=$ac_cv_prog_check_msgfmt
+if test -n "$check_msgfmt"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $check_msgfmt" >&5
+$as_echo "$check_msgfmt" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+      if test x"$check_msgfmt" = x"yes" && test x"$enable_nls" = x"yes"; then
+        USE_NLS=yes
+      fi
+      # Export the build objects.
+      for ling in $ALL_LINGUAS; do \
+        glibcxx_MOFILES="$glibcxx_MOFILES $ling.mo"; \
+        glibcxx_POFILES="$glibcxx_POFILES $ling.po"; \
+      done
+
+
+
+      CLOCALE_H=config/locale/uclibc/c_locale.h
+      CLOCALE_CC=config/locale/uclibc/c_locale.cc
+      CCODECVT_CC=config/locale/uclibc/codecvt_members.cc
+      CCOLLATE_CC=config/locale/uclibc/collate_members.cc
+      CCTYPE_CC=config/locale/uclibc/ctype_members.cc
+      CMESSAGES_H=config/locale/uclibc/messages_members.h
+      CMESSAGES_CC=config/locale/uclibc/messages_members.cc
+      CMONEY_CC=config/locale/uclibc/monetary_members.cc
+      CNUMERIC_CC=config/locale/uclibc/numeric_members.cc
+      CTIME_H=config/locale/uclibc/time_members.h
+      CTIME_CC=config/locale/uclibc/time_members.cc
+      CLOCALE_INTERNAL_H=config/locale/uclibc/c++locale_internal.h
+      ;;
   esac
 
   # This is where the testsuite looks for locale catalogs, using the
diff --git a/libstdc++-v3/include/c_compatibility/wchar.h b/libstdc++-v3/include/c_compatibility/wchar.h
index 06b5d47..7d3f835 100644
--- a/libstdc++-v3/include/c_compatibility/wchar.h
+++ b/libstdc++-v3/include/c_compatibility/wchar.h
@@ -101,7 +101,9 @@ using std::wmemcmp;
 using std::wmemcpy;
 using std::wmemmove;
 using std::wmemset;
+#if _GLIBCXX_HAVE_WCSFTIME
 using std::wcsftime;
+#endif
 
 #if _GLIBCXX_USE_C99
 using std::wcstold;
diff --git a/libstdc++-v3/include/c_std/cwchar b/libstdc++-v3/include/c_std/cwchar
index aa1b2fa..45c4617 100644
--- a/libstdc++-v3/include/c_std/cwchar
+++ b/libstdc++-v3/include/c_std/cwchar
@@ -175,7 +175,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
   using ::wcscoll;
   using ::wcscpy;
   using ::wcscspn;
+#if _GLIBCXX_HAVE_WCSFTIME
   using ::wcsftime;
+#endif
   using ::wcslen;
   using ::wcsncat;
   using ::wcsncmp;
-- 
2.6.3

