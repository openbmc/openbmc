From 1a410ae58f28eeab32fa87626cfd5a663ba33c51 Mon Sep 17 00:00:00 2001
From: Bernhard Walle <bernhard@bwalle.de>
Date: Tue, 13 May 2014 23:40:56 +0200
Subject: [PATCH 2/2] Update x86emu from X.org

This commit updates the x86emu copy from X.org tarball
(ftp://mirror.csclub.uwaterloo.ca/x.org/current/src/xserver/xorg-server-1.12.2.tar.bz2).

This fixes a compatibility issue between v86d and SeaBIOS VGA BIOS where
the leal instruction is not decoded properly. Read the
http://thread.gmane.org/gmane.comp.emulators.qemu/271806 thread for more
details.

Upstream-Status: Backport

Signed-off-by: Bernhard Walle <bernhard@bwalle.de>
---
 libs/x86emu/LICENSE               |   17 -
 libs/x86emu/debug.c               |  509 +++---
 libs/x86emu/decode.c              | 1069 ++++++------
 libs/x86emu/fpu.c                 |  463 +++---
 libs/x86emu/ops.c                 | 2940 +++++++++++++++++++--------------
 libs/x86emu/ops2.c                | 1929 +++++++++++-----------
 libs/x86emu/prim_ops.c            | 3219 +++++++++++++++++++------------------
 libs/x86emu/sys.c                 |  583 +++----
 libs/x86emu/validate.c            |   52 +-
 libs/x86emu/x86emu.h              |   75 +-
 libs/x86emu/x86emu/debug.h        |  163 +-
 libs/x86emu/x86emu/decode.h       |   57 +-
 libs/x86emu/x86emu/fpu.h          |   23 +-
 libs/x86emu/x86emu/fpu_regs.h     |   44 +-
 libs/x86emu/x86emu/ops.h          |    6 +-
 libs/x86emu/x86emu/prim_asm.h     |  251 ++-
 libs/x86emu/x86emu/prim_ops.h     |  188 +--
 libs/x86emu/x86emu/prim_x86_gcc.h |   77 +
 libs/x86emu/x86emu/regs.h         |  101 +-
 libs/x86emu/x86emu/types.h        |   50 +-
 libs/x86emu/x86emu/x86emui.h      |   34 +-
 21 files changed, 6379 insertions(+), 5471 deletions(-)
 delete mode 100644 libs/x86emu/LICENSE
 create mode 100644 libs/x86emu/x86emu/prim_x86_gcc.h

diff --git a/libs/x86emu/LICENSE b/libs/x86emu/LICENSE
deleted file mode 100644
index a3ede4a..0000000
--- a/libs/x86emu/LICENSE
+++ /dev/null
@@ -1,17 +0,0 @@
-                         License information
-                         -------------------
-
-The x86emu library is under a BSD style license, comaptible
-with the XFree86 and X licenses used by XFree86. The
-original x86emu libraries were under the GNU General Public
-License. Due to license incompatibilities between the GPL
-and the XFree86 license, the original authors of the code
-decided to allow a license change. If you have submitted
-code to the original x86emu project, and you don't agree
-with the license change, please contact us and let you
-know. Your code will be removed to comply with your wishes.
-
-If you have any questions about this, please send email to
-x86emu@linuxlabs.com or KendallB@scitechsoft.com for
-clarification.
-
diff --git a/libs/x86emu/debug.c b/libs/x86emu/debug.c
index 6fd7f11..1a8d1d6 100644
--- a/libs/x86emu/debug.c
+++ b/libs/x86emu/debug.c
@@ -38,6 +38,8 @@
 ****************************************************************************/
 
 #include "x86emu/x86emui.h"
+#include <stdio.h>
+#include <string.h>
 #ifndef NO_SYS_HEADERS
 #include <stdarg.h>
 #include <stdlib.h>
@@ -47,46 +49,51 @@
 
 #ifdef DEBUG
 
-static void     print_encoded_bytes (u16 s, u16 o);
-static void     print_decoded_instruction (void);
-static int      parse_line (char *s, int *ps, int *n);
-  
+static void print_encoded_bytes(u16 s, u16 o);
+static void print_decoded_instruction(void);
+static int parse_line(char *s, int *ps, int *n);
+
 /* should look something like debug's output. */
-void X86EMU_trace_regs (void)
+void
+X86EMU_trace_regs(void)
 {
-	if (DEBUG_TRACE()) {
-		x86emu_dump_regs();
+    if (DEBUG_TRACE()) {
+        x86emu_dump_regs();
     }
-	if (DEBUG_DECODE() && ! DEBUG_DECODE_NOPRINT()) {
-		printk("%04x:%04x ",M.x86.saved_cs, M.x86.saved_ip);
-		print_encoded_bytes( M.x86.saved_cs, M.x86.saved_ip);
-		print_decoded_instruction();
+    if (DEBUG_DECODE() && !DEBUG_DECODE_NOPRINT()) {
+        printk("%04x:%04x ", M.x86.saved_cs, M.x86.saved_ip);
+        print_encoded_bytes(M.x86.saved_cs, M.x86.saved_ip);
+        print_decoded_instruction();
     }
 }
 
-void X86EMU_trace_xregs (void)
+void
+X86EMU_trace_xregs(void)
 {
-	if (DEBUG_TRACE()) {
-		x86emu_dump_xregs();
+    if (DEBUG_TRACE()) {
+        x86emu_dump_xregs();
     }
 }
 
-void x86emu_just_disassemble (void)
+void
+x86emu_just_disassemble(void)
 {
     /*
      * This routine called if the flag DEBUG_DISASSEMBLE is set kind
      * of a hack!
      */
-	printk("%04x:%04x ",M.x86.saved_cs, M.x86.saved_ip);
-	print_encoded_bytes( M.x86.saved_cs, M.x86.saved_ip);
-	print_decoded_instruction();
+    printk("%04x:%04x ", M.x86.saved_cs, M.x86.saved_ip);
+    print_encoded_bytes(M.x86.saved_cs, M.x86.saved_ip);
+    print_decoded_instruction();
 }
 
-static void disassemble_forward (u16 seg, u16 off, int n)
+static void
+disassemble_forward(u16 seg, u16 off, int n)
 {
-	X86EMU_sysEnv tregs;
-	int i;
-	u8 op1;
+    X86EMU_sysEnv tregs;
+    int i;
+    u8 op1;
+
     /*
      * hack, hack, hack.  What we do is use the exact machinery set up
      * for execution, except that now there is an additional state
@@ -111,17 +118,17 @@ static void disassemble_forward (u16 seg, u16 off, int n)
      * This was done for an entirely different reason, but makes a
      * nice way to get the system to help debug codes.
      */
-	tregs = M;
+    tregs = M;
     tregs.x86.R_IP = off;
     tregs.x86.R_CS = seg;
-    
+
     /* reset the decoding buffers */
     tregs.x86.enc_str_pos = 0;
     tregs.x86.enc_pos = 0;
-    
+
     /* turn on the "disassemble only, no execute" flag */
     tregs.x86.debug |= DEBUG_DISASSEMBLE_F;
- 
+
     /* DUMP NEXT n instructions to screen in straight_line fashion */
     /*
      * This looks like the regular instruction fetch stream, except
@@ -130,299 +137,359 @@ static void disassemble_forward (u16 seg, u16 off, int n)
      * the instruction.  XXX --- CHECK THAT MEM IS NOT AFFECTED!!!
      * Note the use of a copy of the register structure...
      */
-    for (i=0; i<n; i++) {
-		op1 = (*sys_rdb)(((u32)M.x86.R_CS<<4) + (M.x86.R_IP++));
-		(x86emu_optab[op1])(op1);
+    for (i = 0; i < n; i++) {
+        op1 = (*sys_rdb) (((u32) M.x86.R_CS << 4) + (M.x86.R_IP++));
+        (x86emu_optab[op1]) (op1);
     }
     /* end major hack mode. */
 }
 
-void x86emu_check_ip_access (void)
+void
+x86emu_check_ip_access(void)
 {
     /* NULL as of now */
 }
 
-void x86emu_check_sp_access (void)
+void
+x86emu_check_sp_access(void)
 {
 }
 
-void x86emu_check_mem_access (u32 dummy)
+void
+x86emu_check_mem_access(u32 dummy)
 {
-	/*  check bounds, etc */
+    /*  check bounds, etc */
 }
 
-void x86emu_check_data_access (uint dummy1, uint dummy2)
+void
+x86emu_check_data_access(uint dummy1, uint dummy2)
 {
-	/*  check bounds, etc */
+    /*  check bounds, etc */
 }
 
-void x86emu_inc_decoded_inst_len (int x)
+void
+x86emu_inc_decoded_inst_len(int x)
 {
-	M.x86.enc_pos += x;
+    M.x86.enc_pos += x;
 }
 
-void x86emu_decode_printf (char *x)
+void
+x86emu_decode_printf(const char *x)
 {
-	sprintf(M.x86.decoded_buf+M.x86.enc_str_pos,"%s",x);
-	M.x86.enc_str_pos += strlen(x);
+    sprintf(M.x86.decoded_buf + M.x86.enc_str_pos, "%s", x);
+    M.x86.enc_str_pos += strlen(x);
 }
 
-void x86emu_decode_printf2 (char *x, int y)
+void
+x86emu_decode_printf2(const char *x, int y)
 {
-	char temp[100];
-	sprintf(temp,x,y);
-	sprintf(M.x86.decoded_buf+M.x86.enc_str_pos,"%s",temp);
-	M.x86.enc_str_pos += strlen(temp);
+    char temp[100];
+
+    snprintf(temp, sizeof(temp), x, y);
+    sprintf(M.x86.decoded_buf + M.x86.enc_str_pos, "%s", temp);
+    M.x86.enc_str_pos += strlen(temp);
 }
 
-void x86emu_end_instr (void)
+void
+x86emu_end_instr(void)
 {
-	M.x86.enc_str_pos = 0;
-	M.x86.enc_pos = 0;
+    M.x86.enc_str_pos = 0;
+    M.x86.enc_pos = 0;
 }
 
-static void print_encoded_bytes (u16 s, u16 o)
+static void
+print_encoded_bytes(u16 s, u16 o)
 {
     int i;
     char buf1[64];
-	for (i=0; i< M.x86.enc_pos; i++) {
-		sprintf(buf1+2*i,"%02x", fetch_data_byte_abs(s,o+i));
+
+    for (i = 0; i < M.x86.enc_pos; i++) {
+        sprintf(buf1 + 2 * i, "%02x", fetch_data_byte_abs(s, o + i));
     }
-	printk("%-20s",buf1);
+    printk("%-20s", buf1);
 }
 
-static void print_decoded_instruction (void)
+static void
+print_decoded_instruction(void)
 {
-	printk("%s", M.x86.decoded_buf);
+    printk("%s", M.x86.decoded_buf);
 }
 
-void x86emu_print_int_vect (u16 iv)
+void
+x86emu_print_int_vect(u16 iv)
 {
-	u16 seg,off;
+    u16 seg, off;
 
-	if (iv > 256) return;
-	seg   = fetch_data_word_abs(0,iv*4);
-	off   = fetch_data_word_abs(0,iv*4+2);
-	printk("%04x:%04x ", seg, off);
+    if (iv > 256)
+        return;
+    seg = fetch_data_word_abs(0, iv * 4);
+    off = fetch_data_word_abs(0, iv * 4 + 2);
+    printk("%04x:%04x ", seg, off);
 }
 
-void X86EMU_dump_memory (u16 seg, u16 off, u32 amt)
+void
+X86EMU_dump_memory(u16 seg, u16 off, u32 amt)
 {
-	u32 start = off & 0xfffffff0;
-	u32 end  = (off+16) & 0xfffffff0;
-	u32 i;
-	u32 current;
-
-	current = start;
-	while (end <= off + amt) {
-		printk("%04x:%04x ", seg, start);
-		for (i=start; i< off; i++)
-		  printk("   ");
-		for (       ; i< end; i++)
-		  printk("%02x ", fetch_data_byte_abs(seg,i));
-		printk("\n");
-		start = end;
-		end = start + 16;
-	}
+    u32 start = off & 0xfffffff0;
+    u32 end = (off + 16) & 0xfffffff0;
+    u32 i;
+    u32 current;
+
+    current = start;
+    while (end <= off + amt) {
+        printk("%04x:%04x ", seg, start);
+        for (i = start; i < off; i++)
+            printk("   ");
+        for (; i < end; i++)
+            printk("%02x ", fetch_data_byte_abs(seg, i));
+        printk("\n");
+        start = end;
+        end = start + 16;
+    }
 }
 
-void x86emu_single_step (void)
+void
+x86emu_single_step(void)
 {
     char s[1024];
     int ps[10];
     int ntok;
     int cmd;
     int done;
-		int segment;
+    int segment;
     int offset;
     static int breakpoint;
     static int noDecode = 1;
-    
+
     char *p;
 
-		if (DEBUG_BREAK()) {
-				if (M.x86.saved_ip != breakpoint) {
-						return;
-				} else {
- 	          M.x86.debug &= ~DEBUG_DECODE_NOPRINT_F;
-						M.x86.debug |= DEBUG_TRACE_F;
-						M.x86.debug &= ~DEBUG_BREAK_F;
-						print_decoded_instruction ();
-						X86EMU_trace_regs();
-				}
-		}
-    done=0;
-	offset = M.x86.saved_ip;
+    if (DEBUG_BREAK()) {
+        if (M.x86.saved_ip != breakpoint) {
+            return;
+        }
+        else {
+            M.x86.debug &= ~DEBUG_DECODE_NOPRINT_F;
+            M.x86.debug |= DEBUG_TRACE_F;
+            M.x86.debug &= ~DEBUG_BREAK_F;
+            print_decoded_instruction();
+            X86EMU_trace_regs();
+        }
+    }
+    done = 0;
+    offset = M.x86.saved_ip;
     while (!done) {
         printk("-");
         p = fgets(s, 1023, stdin);
         cmd = parse_line(s, ps, &ntok);
-        switch(cmd) {
-          case 'u':
-			disassemble_forward(M.x86.saved_cs,(u16)offset,10);
+        switch (cmd) {
+        case 'u':
+            disassemble_forward(M.x86.saved_cs, (u16) offset, 10);
             break;
-          case 'd':  
-							if (ntok == 2) {
-									segment = M.x86.saved_cs;
-									offset = ps[1];
-									X86EMU_dump_memory(segment,(u16)offset,16);
-									offset += 16;
-							} else if (ntok == 3) {
-									segment = ps[1];
-									offset = ps[2];
-									X86EMU_dump_memory(segment,(u16)offset,16);
-									offset += 16;
-							} else {
-									segment = M.x86.saved_cs;
-									X86EMU_dump_memory(segment,(u16)offset,16);
-									offset += 16;
-							}
+        case 'd':
+            if (ntok == 2) {
+                segment = M.x86.saved_cs;
+                offset = ps[1];
+                X86EMU_dump_memory(segment, (u16) offset, 16);
+                offset += 16;
+            }
+            else if (ntok == 3) {
+                segment = ps[1];
+                offset = ps[2];
+                X86EMU_dump_memory(segment, (u16) offset, 16);
+                offset += 16;
+            }
+            else {
+                segment = M.x86.saved_cs;
+                X86EMU_dump_memory(segment, (u16) offset, 16);
+                offset += 16;
+            }
             break;
-          case 'c':
-			M.x86.debug ^= DEBUG_TRACECALL_F;
+        case 'c':
+            M.x86.debug ^= DEBUG_TRACECALL_F;
             break;
-          case 's':
-			M.x86.debug ^= DEBUG_SVC_F | DEBUG_SYS_F | DEBUG_SYSINT_F;
+        case 's':
+            M.x86.debug ^= DEBUG_SVC_F | DEBUG_SYS_F | DEBUG_SYSINT_F;
             break;
-          case 'r':
-			X86EMU_trace_regs();
+        case 'r':
+            X86EMU_trace_regs();
             break;
-          case 'x':
-			X86EMU_trace_xregs();
+        case 'x':
+            X86EMU_trace_xregs();
             break;
-          case 'g':
+        case 'g':
             if (ntok == 2) {
                 breakpoint = ps[1];
-		if (noDecode) {
-		                M.x86.debug |= DEBUG_DECODE_NOPRINT_F;
-		} else {
-		                M.x86.debug &= ~DEBUG_DECODE_NOPRINT_F;
-		}
-		M.x86.debug &= ~DEBUG_TRACE_F;
-		M.x86.debug |= DEBUG_BREAK_F;
-		done = 1;
+                if (noDecode) {
+                    M.x86.debug |= DEBUG_DECODE_NOPRINT_F;
+                }
+                else {
+                    M.x86.debug &= ~DEBUG_DECODE_NOPRINT_F;
+                }
+                M.x86.debug &= ~DEBUG_TRACE_F;
+                M.x86.debug |= DEBUG_BREAK_F;
+                done = 1;
             }
             break;
-          case 'q':
-          M.x86.debug |= DEBUG_EXIT;
-          return;
-	  case 'P':
-	      noDecode = (noDecode)?0:1;
-	      printk("Toggled decoding to %s\n",(noDecode)?"FALSE":"TRUE");
-	      break;
-          case 't':
-	  case 0:
+        case 'q':
+            M.x86.debug |= DEBUG_EXIT;
+            return;
+        case 'P':
+            noDecode = (noDecode) ? 0 : 1;
+            printk("Toggled decoding to %s\n", (noDecode) ? "FALSE" : "TRUE");
+            break;
+        case 't':
+        case 0:
             done = 1;
             break;
-        }   
+        }
     }
 }
 
-int X86EMU_trace_on(void)
+int
+X86EMU_trace_on(void)
 {
-	return M.x86.debug |= DEBUG_STEP_F | DEBUG_DECODE_F | DEBUG_TRACE_F;
+    return M.x86.debug |= DEBUG_STEP_F | DEBUG_DECODE_F | DEBUG_TRACE_F;
 }
 
-int X86EMU_trace_off(void)
+int
+X86EMU_trace_off(void)
 {
-	return M.x86.debug &= ~(DEBUG_STEP_F | DEBUG_DECODE_F | DEBUG_TRACE_F);
+    return M.x86.debug &= ~(DEBUG_STEP_F | DEBUG_DECODE_F | DEBUG_TRACE_F);
 }
 
-static int parse_line (char *s, int *ps, int *n)
+static int
+parse_line(char *s, int *ps, int *n)
 {
     int cmd;
 
     *n = 0;
-    while(*s == ' ' || *s == '\t') s++;
+    while (*s == ' ' || *s == '\t')
+        s++;
     ps[*n] = *s;
     switch (*s) {
-      case '\n':
+    case '\n':
         *n += 1;
         return 0;
-      default:
+    default:
         cmd = *s;
         *n += 1;
     }
 
-	while (1) {
-		while (*s != ' ' && *s != '\t' && *s != '\n')  s++;
-		
-		if (*s == '\n')
-			return cmd;
-		
-		while(*s == ' ' || *s == '\t') s++;
-		
-		sscanf(s,"%x",&ps[*n]);
-		*n += 1;
-	}
+    while (1) {
+        while (*s != ' ' && *s != '\t' && *s != '\n')
+            s++;
+
+        if (*s == '\n')
+            return cmd;
+
+        while (*s == ' ' || *s == '\t')
+            s++;
+
+        sscanf(s, "%x", &ps[*n]);
+        *n += 1;
+    }
 }
 
-#endif /* DEBUG */
+#endif                          /* DEBUG */
 
-void x86emu_dump_regs (void)
+void
+x86emu_dump_regs(void)
 {
-	printk("\tAX=%04x  ", M.x86.R_AX );
-	printk("BX=%04x  ", M.x86.R_BX );
-	printk("CX=%04x  ", M.x86.R_CX );
-	printk("DX=%04x  ", M.x86.R_DX );
-	printk("SP=%04x  ", M.x86.R_SP );
-	printk("BP=%04x  ", M.x86.R_BP );
-	printk("SI=%04x  ", M.x86.R_SI );
-	printk("DI=%04x\n", M.x86.R_DI );
-	printk("\tDS=%04x  ", M.x86.R_DS );
-	printk("ES=%04x  ", M.x86.R_ES );
-	printk("SS=%04x  ", M.x86.R_SS );
-	printk("CS=%04x  ", M.x86.R_CS );
-	printk("IP=%04x   ", M.x86.R_IP );
-	if (ACCESS_FLAG(F_OF))    printk("OV ");     /* CHECKED... */
-	else                        printk("NV ");
-	if (ACCESS_FLAG(F_DF))    printk("DN ");
-	else                        printk("UP ");
-	if (ACCESS_FLAG(F_IF))    printk("EI ");
-	else                        printk("DI ");
-	if (ACCESS_FLAG(F_SF))    printk("NG ");
-	else                        printk("PL ");
-	if (ACCESS_FLAG(F_ZF))    printk("ZR ");
-	else                        printk("NZ ");
-	if (ACCESS_FLAG(F_AF))    printk("AC ");
-	else                        printk("NA ");
-	if (ACCESS_FLAG(F_PF))    printk("PE ");
-	else                        printk("PO ");
-	if (ACCESS_FLAG(F_CF))    printk("CY ");
-	else                        printk("NC ");
-	printk("\n");
+    printk("\tAX=%04x  ", M.x86.R_AX);
+    printk("BX=%04x  ", M.x86.R_BX);
+    printk("CX=%04x  ", M.x86.R_CX);
+    printk("DX=%04x  ", M.x86.R_DX);
+    printk("SP=%04x  ", M.x86.R_SP);
+    printk("BP=%04x  ", M.x86.R_BP);
+    printk("SI=%04x  ", M.x86.R_SI);
+    printk("DI=%04x\n", M.x86.R_DI);
+    printk("\tDS=%04x  ", M.x86.R_DS);
+    printk("ES=%04x  ", M.x86.R_ES);
+    printk("SS=%04x  ", M.x86.R_SS);
+    printk("CS=%04x  ", M.x86.R_CS);
+    printk("IP=%04x   ", M.x86.R_IP);
+    if (ACCESS_FLAG(F_OF))
+        printk("OV ");          /* CHECKED... */
+    else
+        printk("NV ");
+    if (ACCESS_FLAG(F_DF))
+        printk("DN ");
+    else
+        printk("UP ");
+    if (ACCESS_FLAG(F_IF))
+        printk("EI ");
+    else
+        printk("DI ");
+    if (ACCESS_FLAG(F_SF))
+        printk("NG ");
+    else
+        printk("PL ");
+    if (ACCESS_FLAG(F_ZF))
+        printk("ZR ");
+    else
+        printk("NZ ");
+    if (ACCESS_FLAG(F_AF))
+        printk("AC ");
+    else
+        printk("NA ");
+    if (ACCESS_FLAG(F_PF))
+        printk("PE ");
+    else
+        printk("PO ");
+    if (ACCESS_FLAG(F_CF))
+        printk("CY ");
+    else
+        printk("NC ");
+    printk("\n");
 }
 
-void x86emu_dump_xregs (void)
+void
+x86emu_dump_xregs(void)
 {
-	printk("\tEAX=%08x  ", M.x86.R_EAX );
-	printk("EBX=%08x  ", M.x86.R_EBX );
-	printk("ECX=%08x  ", M.x86.R_ECX );
-	printk("EDX=%08x  \n", M.x86.R_EDX );
-	printk("\tESP=%08x  ", M.x86.R_ESP );
-	printk("EBP=%08x  ", M.x86.R_EBP );
-	printk("ESI=%08x  ", M.x86.R_ESI );
-	printk("EDI=%08x\n", M.x86.R_EDI );
-	printk("\tDS=%04x  ", M.x86.R_DS );
-	printk("ES=%04x  ", M.x86.R_ES );
-	printk("SS=%04x  ", M.x86.R_SS );
-	printk("CS=%04x  ", M.x86.R_CS );
-	printk("EIP=%08x\n\t", M.x86.R_EIP );
-	if (ACCESS_FLAG(F_OF))    printk("OV ");     /* CHECKED... */
-	else                        printk("NV ");
-	if (ACCESS_FLAG(F_DF))    printk("DN ");
-	else                        printk("UP ");
-	if (ACCESS_FLAG(F_IF))    printk("EI ");
-	else                        printk("DI ");
-	if (ACCESS_FLAG(F_SF))    printk("NG ");
-	else                        printk("PL ");
-	if (ACCESS_FLAG(F_ZF))    printk("ZR ");
-	else                        printk("NZ ");
-	if (ACCESS_FLAG(F_AF))    printk("AC ");
-	else                        printk("NA ");
-	if (ACCESS_FLAG(F_PF))    printk("PE ");
-	else                        printk("PO ");
-	if (ACCESS_FLAG(F_CF))    printk("CY ");
-	else                        printk("NC ");
-	printk("\n");
+    printk("\tEAX=%08x  ", M.x86.R_EAX);
+    printk("EBX=%08x  ", M.x86.R_EBX);
+    printk("ECX=%08x  ", M.x86.R_ECX);
+    printk("EDX=%08x  \n", M.x86.R_EDX);
+    printk("\tESP=%08x  ", M.x86.R_ESP);
+    printk("EBP=%08x  ", M.x86.R_EBP);
+    printk("ESI=%08x  ", M.x86.R_ESI);
+    printk("EDI=%08x\n", M.x86.R_EDI);
+    printk("\tDS=%04x  ", M.x86.R_DS);
+    printk("ES=%04x  ", M.x86.R_ES);
+    printk("SS=%04x  ", M.x86.R_SS);
+    printk("CS=%04x  ", M.x86.R_CS);
+    printk("EIP=%08x\n\t", M.x86.R_EIP);
+    if (ACCESS_FLAG(F_OF))
+        printk("OV ");          /* CHECKED... */
+    else
+        printk("NV ");
+    if (ACCESS_FLAG(F_DF))
+        printk("DN ");
+    else
+        printk("UP ");
+    if (ACCESS_FLAG(F_IF))
+        printk("EI ");
+    else
+        printk("DI ");
+    if (ACCESS_FLAG(F_SF))
+        printk("NG ");
+    else
+        printk("PL ");
+    if (ACCESS_FLAG(F_ZF))
+        printk("ZR ");
+    else
+        printk("NZ ");
+    if (ACCESS_FLAG(F_AF))
+        printk("AC ");
+    else
+        printk("NA ");
+    if (ACCESS_FLAG(F_PF))
+        printk("PE ");
+    else
+        printk("PO ");
+    if (ACCESS_FLAG(F_CF))
+        printk("CY ");
+    else
+        printk("NC ");
+    printk("\n");
 }
diff --git a/libs/x86emu/decode.c b/libs/x86emu/decode.c
index 7d9a34a..12f8fb8 100644
--- a/libs/x86emu/decode.c
+++ b/libs/x86emu/decode.c
@@ -46,25 +46,27 @@
 REMARKS:
 Handles any pending asychronous interrupts.
 ****************************************************************************/
-static void x86emu_intr_handle(void)
+static void
+x86emu_intr_handle(void)
 {
-	u8	intno;
-
-	if (M.x86.intr & INTR_SYNCH) {
-		intno = M.x86.intno;
-		if (_X86EMU_intrTab[intno]) {
-			(*_X86EMU_intrTab[intno])(intno);
-		} else {
-			push_word((u16)M.x86.R_FLG);
-			CLEAR_FLAG(F_IF);
-			CLEAR_FLAG(F_TF);
-			push_word(M.x86.R_CS);
-			M.x86.R_CS = mem_access_word(intno * 4 + 2);
-			push_word(M.x86.R_IP);
-			M.x86.R_IP = mem_access_word(intno * 4);
-			M.x86.intr = 0;
-		}
-	}
+    u8 intno;
+
+    if (M.x86.intr & INTR_SYNCH) {
+        intno = M.x86.intno;
+        if (_X86EMU_intrTab[intno]) {
+            (*_X86EMU_intrTab[intno]) (intno);
+        }
+        else {
+            push_word((u16) M.x86.R_FLG);
+            CLEAR_FLAG(F_IF);
+            CLEAR_FLAG(F_TF);
+            push_word(M.x86.R_CS);
+            M.x86.R_CS = mem_access_word(intno * 4 + 2);
+            push_word(M.x86.R_IP);
+            M.x86.R_IP = mem_access_word(intno * 4);
+            M.x86.intr = 0;
+        }
+    }
 }
 
 /****************************************************************************
@@ -75,11 +77,11 @@ REMARKS:
 Raise the specified interrupt to be handled before the execution of the
 next instruction.
 ****************************************************************************/
-void x86emu_intr_raise(
-	u8 intrnum)
+void
+x86emu_intr_raise(u8 intrnum)
 {
-	M.x86.intno = intrnum;
-	M.x86.intr |= INTR_SYNCH;
+    M.x86.intno = intrnum;
+    M.x86.intr |= INTR_SYNCH;
 }
 
 /****************************************************************************
@@ -88,39 +90,39 @@ Main execution loop for the emulator. We return from here when the system
 halts, which is normally caused by a stack fault when we return from the
 original real mode call.
 ****************************************************************************/
-void X86EMU_exec(void)
+void
+X86EMU_exec(void)
 {
-	u8 op1;
-
-	M.x86.intr = 0;
-	DB(x86emu_end_instr();)
-
-    for (;;) {
-DB(		if (CHECK_IP_FETCH())
-		  x86emu_check_ip_access();)
-		/* If debugging, save the IP and CS values. */
-		SAVE_IP_CS(M.x86.R_CS, M.x86.R_IP);
-		INC_DECODED_INST_LEN(1);
-		if (M.x86.intr) {
-			if (M.x86.intr & INTR_HALTED) {
-DB(             if (M.x86.R_SP != 0) {
-                    printk("halted\n");
-                    X86EMU_trace_regs();
-                    }
-                else {
-                    if (M.x86.debug)
-                        printk("Service completed successfully\n");
-                    })
-				return;
+    u8 op1;
+
+    M.x86.intr = 0;
+    DB(x86emu_end_instr();
+        )
+
+        for (;;) {
+        DB(if (CHECK_IP_FETCH())
+           x86emu_check_ip_access();)
+            /* If debugging, save the IP and CS values. */
+            SAVE_IP_CS(M.x86.R_CS, M.x86.R_IP);
+        INC_DECODED_INST_LEN(1);
+        if (M.x86.intr) {
+            if (M.x86.intr & INTR_HALTED) {
+                DB(if (M.x86.R_SP != 0) {
+                   printk("halted\n"); X86EMU_trace_regs();}
+                   else {
+                   if (M.x86.debug)
+                   printk("Service completed successfully\n");}
+                )
+                    return;
             }
-			if (((M.x86.intr & INTR_SYNCH) && (M.x86.intno == 0 || M.x86.intno == 2)) ||
-				!ACCESS_FLAG(F_IF)) {
-				x86emu_intr_handle();
-			}
-		}
-
-		op1 = (*sys_rdb)(((u32)M.x86.R_CS << 4) + (M.x86.R_IP++));
-		(*x86emu_optab[op1])(op1);
+            if (((M.x86.intr & INTR_SYNCH) &&
+                 (M.x86.intno == 0 || M.x86.intno == 2)) ||
+                !ACCESS_FLAG(F_IF)) {
+                x86emu_intr_handle();
+            }
+        }
+        op1 = (*sys_rdb) (((u32) M.x86.R_CS << 4) + (M.x86.R_IP++));
+        (*x86emu_optab[op1]) (op1);
         if (M.x86.debug & DEBUG_EXIT) {
             M.x86.debug &= ~DEBUG_EXIT;
             return;
@@ -132,9 +134,10 @@ DB(             if (M.x86.R_SP != 0) {
 REMARKS:
 Halts the system by setting the halted system flag.
 ****************************************************************************/
-void X86EMU_halt_sys(void)
+void
+X86EMU_halt_sys(void)
 {
-	M.x86.intr |= INTR_HALTED;
+    M.x86.intr |= INTR_HALTED;
 }
 
 /****************************************************************************
@@ -149,19 +152,17 @@ next instruction.
 
 NOTE: Do not inline this function, as (*sys_rdb) is already inline!
 ****************************************************************************/
-void fetch_decode_modrm(
-	int *mod,
-	int *regh,
-	int *regl)
+void
+fetch_decode_modrm(int *mod, int *regh, int *regl)
 {
-	int fetched;
-
-DB(	if (CHECK_IP_FETCH())
-	  x86emu_check_ip_access();)
-	fetched = (*sys_rdb)(((u32)M.x86.R_CS << 4) + (M.x86.R_IP++));
-	INC_DECODED_INST_LEN(1);
-	*mod  = (fetched >> 6) & 0x03;
-	*regh = (fetched >> 3) & 0x07;
+    int fetched;
+
+    DB(if (CHECK_IP_FETCH())
+       x86emu_check_ip_access();)
+        fetched = (*sys_rdb) (((u32) M.x86.R_CS << 4) + (M.x86.R_IP++));
+    INC_DECODED_INST_LEN(1);
+    *mod = (fetched >> 6) & 0x03;
+    *regh = (fetched >> 3) & 0x07;
     *regl = (fetched >> 0) & 0x07;
 }
 
@@ -175,15 +176,16 @@ moves the instruction pointer to the next value.
 
 NOTE: Do not inline this function, as (*sys_rdb) is already inline!
 ****************************************************************************/
-u8 fetch_byte_imm(void)
+u8
+fetch_byte_imm(void)
 {
-	u8 fetched;
+    u8 fetched;
 
-DB(	if (CHECK_IP_FETCH())
-		x86emu_check_ip_access();)
-	fetched = (*sys_rdb)(((u32)M.x86.R_CS << 4) + (M.x86.R_IP++));
-	INC_DECODED_INST_LEN(1);
-	return fetched;
+    DB(if (CHECK_IP_FETCH())
+       x86emu_check_ip_access();)
+        fetched = (*sys_rdb) (((u32) M.x86.R_CS << 4) + (M.x86.R_IP++));
+    INC_DECODED_INST_LEN(1);
+    return fetched;
 }
 
 /****************************************************************************
@@ -196,16 +198,17 @@ moves the instruction pointer to the next value.
 
 NOTE: Do not inline this function, as (*sys_rdw) is already inline!
 ****************************************************************************/
-u16 fetch_word_imm(void)
+u16
+fetch_word_imm(void)
 {
-	u16	fetched;
-
-DB(	if (CHECK_IP_FETCH())
-		x86emu_check_ip_access();)
-	fetched = (*sys_rdw)(((u32)M.x86.R_CS << 4) + (M.x86.R_IP));
-	M.x86.R_IP += 2;
-	INC_DECODED_INST_LEN(2);
-	return fetched;
+    u16 fetched;
+
+    DB(if (CHECK_IP_FETCH())
+       x86emu_check_ip_access();)
+        fetched = (*sys_rdw) (((u32) M.x86.R_CS << 4) + (M.x86.R_IP));
+    M.x86.R_IP += 2;
+    INC_DECODED_INST_LEN(2);
+    return fetched;
 }
 
 /****************************************************************************
@@ -218,16 +221,17 @@ moves the instruction pointer to the next value.
 
 NOTE: Do not inline this function, as (*sys_rdw) is already inline!
 ****************************************************************************/
-u32 fetch_long_imm(void)
+u32
+fetch_long_imm(void)
 {
-	u32 fetched;
-
-DB(	if (CHECK_IP_FETCH())
-	  x86emu_check_ip_access();)
-	fetched = (*sys_rdl)(((u32)M.x86.R_CS << 4) + (M.x86.R_IP));
-	M.x86.R_IP += 4;
-	INC_DECODED_INST_LEN(4);
-	return fetched;
+    u32 fetched;
+
+    DB(if (CHECK_IP_FETCH())
+       x86emu_check_ip_access();)
+        fetched = (*sys_rdl) (((u32) M.x86.R_CS << 4) + (M.x86.R_IP));
+    M.x86.R_IP += 4;
+    INC_DECODED_INST_LEN(4);
+    return fetched;
 }
 
 /****************************************************************************
@@ -259,38 +263,39 @@ cpu-state-varible M.x86.mode. There are several potential states:
 
 Each of the above 7 items are handled with a bit in the mode field.
 ****************************************************************************/
-_INLINE u32 get_data_segment(void)
+_INLINE u32
+get_data_segment(void)
 {
 #define	GET_SEGMENT(segment)
-	switch (M.x86.mode & SYSMODE_SEGMASK) {
-	  case 0:					/* default case: use ds register */
-	  case SYSMODE_SEGOVR_DS:
-	  case SYSMODE_SEGOVR_DS | SYSMODE_SEG_DS_SS:
-		return  M.x86.R_DS;
-	  case SYSMODE_SEG_DS_SS:	/* non-overridden, use ss register */
-		return  M.x86.R_SS;
-	  case SYSMODE_SEGOVR_CS:
-	  case SYSMODE_SEGOVR_CS | SYSMODE_SEG_DS_SS:
-		return  M.x86.R_CS;
-	  case SYSMODE_SEGOVR_ES:
-	  case SYSMODE_SEGOVR_ES | SYSMODE_SEG_DS_SS:
-		return  M.x86.R_ES;
-	  case SYSMODE_SEGOVR_FS:
-	  case SYSMODE_SEGOVR_FS | SYSMODE_SEG_DS_SS:
-		return  M.x86.R_FS;
-	  case SYSMODE_SEGOVR_GS:
-	  case SYSMODE_SEGOVR_GS | SYSMODE_SEG_DS_SS:
-		return  M.x86.R_GS;
-	  case SYSMODE_SEGOVR_SS:
-	  case SYSMODE_SEGOVR_SS | SYSMODE_SEG_DS_SS:
-		return  M.x86.R_SS;
-	  default:
+    switch (M.x86.mode & SYSMODE_SEGMASK) {
+    case 0:                    /* default case: use ds register */
+    case SYSMODE_SEGOVR_DS:
+    case SYSMODE_SEGOVR_DS | SYSMODE_SEG_DS_SS:
+        return M.x86.R_DS;
+    case SYSMODE_SEG_DS_SS:    /* non-overridden, use ss register */
+        return M.x86.R_SS;
+    case SYSMODE_SEGOVR_CS:
+    case SYSMODE_SEGOVR_CS | SYSMODE_SEG_DS_SS:
+        return M.x86.R_CS;
+    case SYSMODE_SEGOVR_ES:
+    case SYSMODE_SEGOVR_ES | SYSMODE_SEG_DS_SS:
+        return M.x86.R_ES;
+    case SYSMODE_SEGOVR_FS:
+    case SYSMODE_SEGOVR_FS | SYSMODE_SEG_DS_SS:
+        return M.x86.R_FS;
+    case SYSMODE_SEGOVR_GS:
+    case SYSMODE_SEGOVR_GS | SYSMODE_SEG_DS_SS:
+        return M.x86.R_GS;
+    case SYSMODE_SEGOVR_SS:
+    case SYSMODE_SEGOVR_SS | SYSMODE_SEG_DS_SS:
+        return M.x86.R_SS;
+    default:
 #ifdef	DEBUG
-		printk("error: should not happen:  multiple overrides.\n");
+        printk("error: should not happen:  multiple overrides.\n");
 #endif
-		HALT_SYS();
-		return 0;
-	}
+        HALT_SYS();
+        return 0;
+    }
 }
 
 /****************************************************************************
@@ -302,14 +307,14 @@ Byte value read from the absolute memory location.
 
 NOTE: Do not inline this function as (*sys_rdX) is already inline!
 ****************************************************************************/
-u8 fetch_data_byte(
-	uint offset)
+u8
+fetch_data_byte(uint offset)
 {
 #ifdef DEBUG
-	if (CHECK_DATA_ACCESS())
-		x86emu_check_data_access((u16)get_data_segment(), offset);
+    if (CHECK_DATA_ACCESS())
+        x86emu_check_data_access((u16) get_data_segment(), offset);
 #endif
-	return (*sys_rdb)((get_data_segment() << 4) + offset);
+    return (*sys_rdb) ((get_data_segment() << 4) + offset);
 }
 
 /****************************************************************************
@@ -321,14 +326,14 @@ Word value read from the absolute memory location.
 
 NOTE: Do not inline this function as (*sys_rdX) is already inline!
 ****************************************************************************/
-u16 fetch_data_word(
-	uint offset)
+u16
+fetch_data_word(uint offset)
 {
 #ifdef DEBUG
-	if (CHECK_DATA_ACCESS())
-		x86emu_check_data_access((u16)get_data_segment(), offset);
+    if (CHECK_DATA_ACCESS())
+        x86emu_check_data_access((u16) get_data_segment(), offset);
 #endif
-	return (*sys_rdw)((get_data_segment() << 4) + offset);
+    return (*sys_rdw) ((get_data_segment() << 4) + offset);
 }
 
 /****************************************************************************
@@ -340,14 +345,14 @@ Long value read from the absolute memory location.
 
 NOTE: Do not inline this function as (*sys_rdX) is already inline!
 ****************************************************************************/
-u32 fetch_data_long(
-	uint offset)
+u32
+fetch_data_long(uint offset)
 {
 #ifdef DEBUG
-	if (CHECK_DATA_ACCESS())
-		x86emu_check_data_access((u16)get_data_segment(), offset);
+    if (CHECK_DATA_ACCESS())
+        x86emu_check_data_access((u16) get_data_segment(), offset);
 #endif
-	return (*sys_rdl)((get_data_segment() << 4) + offset);
+    return (*sys_rdl) ((get_data_segment() << 4) + offset);
 }
 
 /****************************************************************************
@@ -360,15 +365,14 @@ Byte value read from the absolute memory location.
 
 NOTE: Do not inline this function as (*sys_rdX) is already inline!
 ****************************************************************************/
-u8 fetch_data_byte_abs(
-	uint segment,
-	uint offset)
+u8
+fetch_data_byte_abs(uint segment, uint offset)
 {
 #ifdef DEBUG
-	if (CHECK_DATA_ACCESS())
-		x86emu_check_data_access(segment, offset);
+    if (CHECK_DATA_ACCESS())
+        x86emu_check_data_access(segment, offset);
 #endif
-	return (*sys_rdb)(((u32)segment << 4) + offset);
+    return (*sys_rdb) (((u32) segment << 4) + offset);
 }
 
 /****************************************************************************
@@ -381,15 +385,14 @@ Word value read from the absolute memory location.
 
 NOTE: Do not inline this function as (*sys_rdX) is already inline!
 ****************************************************************************/
-u16 fetch_data_word_abs(
-	uint segment,
-	uint offset)
+u16
+fetch_data_word_abs(uint segment, uint offset)
 {
 #ifdef DEBUG
-	if (CHECK_DATA_ACCESS())
-		x86emu_check_data_access(segment, offset);
+    if (CHECK_DATA_ACCESS())
+        x86emu_check_data_access(segment, offset);
 #endif
-	return (*sys_rdw)(((u32)segment << 4) + offset);
+    return (*sys_rdw) (((u32) segment << 4) + offset);
 }
 
 /****************************************************************************
@@ -402,15 +405,14 @@ Long value read from the absolute memory location.
 
 NOTE: Do not inline this function as (*sys_rdX) is already inline!
 ****************************************************************************/
-u32 fetch_data_long_abs(
-	uint segment,
-	uint offset)
+u32
+fetch_data_long_abs(uint segment, uint offset)
 {
 #ifdef DEBUG
-	if (CHECK_DATA_ACCESS())
-		x86emu_check_data_access(segment, offset);
+    if (CHECK_DATA_ACCESS())
+        x86emu_check_data_access(segment, offset);
 #endif
-	return (*sys_rdl)(((u32)segment << 4) + offset);
+    return (*sys_rdl) (((u32) segment << 4) + offset);
 }
 
 /****************************************************************************
@@ -424,15 +426,14 @@ the current 'default' segment, which may have been overridden.
 
 NOTE: Do not inline this function as (*sys_wrX) is already inline!
 ****************************************************************************/
-void store_data_byte(
-	uint offset,
-	u8 val)
+void
+store_data_byte(uint offset, u8 val)
 {
 #ifdef DEBUG
-	if (CHECK_DATA_ACCESS())
-		x86emu_check_data_access((u16)get_data_segment(), offset);
+    if (CHECK_DATA_ACCESS())
+        x86emu_check_data_access((u16) get_data_segment(), offset);
 #endif
-	(*sys_wrb)((get_data_segment() << 4) + offset, val);
+    (*sys_wrb) ((get_data_segment() << 4) + offset, val);
 }
 
 /****************************************************************************
@@ -446,15 +447,14 @@ the current 'default' segment, which may have been overridden.
 
 NOTE: Do not inline this function as (*sys_wrX) is already inline!
 ****************************************************************************/
-void store_data_word(
-	uint offset,
-	u16 val)
+void
+store_data_word(uint offset, u16 val)
 {
 #ifdef DEBUG
-	if (CHECK_DATA_ACCESS())
-		x86emu_check_data_access((u16)get_data_segment(), offset);
+    if (CHECK_DATA_ACCESS())
+        x86emu_check_data_access((u16) get_data_segment(), offset);
 #endif
-	(*sys_wrw)((get_data_segment() << 4) + offset, val);
+    (*sys_wrw) ((get_data_segment() << 4) + offset, val);
 }
 
 /****************************************************************************
@@ -468,15 +468,14 @@ the current 'default' segment, which may have been overridden.
 
 NOTE: Do not inline this function as (*sys_wrX) is already inline!
 ****************************************************************************/
-void store_data_long(
-	uint offset,
-	u32 val)
+void
+store_data_long(uint offset, u32 val)
 {
 #ifdef DEBUG
-	if (CHECK_DATA_ACCESS())
-		x86emu_check_data_access((u16)get_data_segment(), offset);
+    if (CHECK_DATA_ACCESS())
+        x86emu_check_data_access((u16) get_data_segment(), offset);
 #endif
-	(*sys_wrl)((get_data_segment() << 4) + offset, val);
+    (*sys_wrl) ((get_data_segment() << 4) + offset, val);
 }
 
 /****************************************************************************
@@ -490,16 +489,14 @@ Writes a byte value to an absolute memory location.
 
 NOTE: Do not inline this function as (*sys_wrX) is already inline!
 ****************************************************************************/
-void store_data_byte_abs(
-	uint segment,
-	uint offset,
-	u8 val)
+void
+store_data_byte_abs(uint segment, uint offset, u8 val)
 {
 #ifdef DEBUG
-	if (CHECK_DATA_ACCESS())
-		x86emu_check_data_access(segment, offset);
+    if (CHECK_DATA_ACCESS())
+        x86emu_check_data_access(segment, offset);
 #endif
-	(*sys_wrb)(((u32)segment << 4) + offset, val);
+    (*sys_wrb) (((u32) segment << 4) + offset, val);
 }
 
 /****************************************************************************
@@ -513,16 +510,14 @@ Writes a word value to an absolute memory location.
 
 NOTE: Do not inline this function as (*sys_wrX) is already inline!
 ****************************************************************************/
-void store_data_word_abs(
-	uint segment,
-	uint offset,
-	u16 val)
+void
+store_data_word_abs(uint segment, uint offset, u16 val)
 {
 #ifdef DEBUG
-	if (CHECK_DATA_ACCESS())
-		x86emu_check_data_access(segment, offset);
+    if (CHECK_DATA_ACCESS())
+        x86emu_check_data_access(segment, offset);
 #endif
-	(*sys_wrw)(((u32)segment << 4) + offset, val);
+    (*sys_wrw) (((u32) segment << 4) + offset, val);
 }
 
 /****************************************************************************
@@ -536,16 +531,14 @@ Writes a long value to an absolute memory location.
 
 NOTE: Do not inline this function as (*sys_wrX) is already inline!
 ****************************************************************************/
-void store_data_long_abs(
-	uint segment,
-	uint offset,
-	u32 val)
+void
+store_data_long_abs(uint segment, uint offset, u32 val)
 {
 #ifdef DEBUG
-	if (CHECK_DATA_ACCESS())
-		x86emu_check_data_access(segment, offset);
+    if (CHECK_DATA_ACCESS())
+        x86emu_check_data_access(segment, offset);
 #endif
-	(*sys_wrl)(((u32)segment << 4) + offset, val);
+    (*sys_wrl) (((u32) segment << 4) + offset, val);
 }
 
 /****************************************************************************
@@ -559,37 +552,37 @@ REMARKS:
 Return a pointer to the register given by the R/RM field of the
 modrm byte, for byte operands. Also enables the decoding of instructions.
 ****************************************************************************/
-u8* decode_rm_byte_register(
-	int reg)
+u8 *
+decode_rm_byte_register(int reg)
 {
-	switch (reg) {
-      case 0:
-		DECODE_PRINTF("AL");
-		return &M.x86.R_AL;
-	  case 1:
-		DECODE_PRINTF("CL");
-		return &M.x86.R_CL;
-	  case 2:
-		DECODE_PRINTF("DL");
-		return &M.x86.R_DL;
-	  case 3:
-		DECODE_PRINTF("BL");
-		return &M.x86.R_BL;
-	  case 4:
-		DECODE_PRINTF("AH");
-		return &M.x86.R_AH;
-	  case 5:
-		DECODE_PRINTF("CH");
-		return &M.x86.R_CH;
-	  case 6:
-		DECODE_PRINTF("DH");
-		return &M.x86.R_DH;
-	  case 7:
-		DECODE_PRINTF("BH");
-		return &M.x86.R_BH;
-	}
-	HALT_SYS();
-	return NULL;                /* NOT REACHED OR REACHED ON ERROR */
+    switch (reg) {
+    case 0:
+        DECODE_PRINTF("AL");
+        return &M.x86.R_AL;
+    case 1:
+        DECODE_PRINTF("CL");
+        return &M.x86.R_CL;
+    case 2:
+        DECODE_PRINTF("DL");
+        return &M.x86.R_DL;
+    case 3:
+        DECODE_PRINTF("BL");
+        return &M.x86.R_BL;
+    case 4:
+        DECODE_PRINTF("AH");
+        return &M.x86.R_AH;
+    case 5:
+        DECODE_PRINTF("CH");
+        return &M.x86.R_CH;
+    case 6:
+        DECODE_PRINTF("DH");
+        return &M.x86.R_DH;
+    case 7:
+        DECODE_PRINTF("BH");
+        return &M.x86.R_BH;
+    }
+    HALT_SYS();
+    return NULL;                /* NOT REACHED OR REACHED ON ERROR */
 }
 
 /****************************************************************************
@@ -603,36 +596,36 @@ REMARKS:
 Return a pointer to the register given by the R/RM field of the
 modrm byte, for word operands.  Also enables the decoding of instructions.
 ****************************************************************************/
-u16* decode_rm_word_register(
-	int reg)
+u16 *
+decode_rm_word_register(int reg)
 {
-	switch (reg) {
-	  case 0:
-		DECODE_PRINTF("AX");
-		return &M.x86.R_AX;
-	  case 1:
-		DECODE_PRINTF("CX");
-		return &M.x86.R_CX;
-	  case 2:
-		DECODE_PRINTF("DX");
-		return &M.x86.R_DX;
-	  case 3:
-		DECODE_PRINTF("BX");
-		return &M.x86.R_BX;
-	  case 4:
-		DECODE_PRINTF("SP");
-		return &M.x86.R_SP;
-	  case 5:
-		DECODE_PRINTF("BP");
-		return &M.x86.R_BP;
-	  case 6:
-		DECODE_PRINTF("SI");
-		return &M.x86.R_SI;
-	  case 7:
-		DECODE_PRINTF("DI");
-		return &M.x86.R_DI;
-	}
-	HALT_SYS();
+    switch (reg) {
+    case 0:
+        DECODE_PRINTF("AX");
+        return &M.x86.R_AX;
+    case 1:
+        DECODE_PRINTF("CX");
+        return &M.x86.R_CX;
+    case 2:
+        DECODE_PRINTF("DX");
+        return &M.x86.R_DX;
+    case 3:
+        DECODE_PRINTF("BX");
+        return &M.x86.R_BX;
+    case 4:
+        DECODE_PRINTF("SP");
+        return &M.x86.R_SP;
+    case 5:
+        DECODE_PRINTF("BP");
+        return &M.x86.R_BP;
+    case 6:
+        DECODE_PRINTF("SI");
+        return &M.x86.R_SI;
+    case 7:
+        DECODE_PRINTF("DI");
+        return &M.x86.R_DI;
+    }
+    HALT_SYS();
     return NULL;                /* NOTREACHED OR REACHED ON ERROR */
 }
 
@@ -647,36 +640,36 @@ REMARKS:
 Return a pointer to the register given by the R/RM field of the
 modrm byte, for dword operands.  Also enables the decoding of instructions.
 ****************************************************************************/
-u32* decode_rm_long_register(
-	int reg)
+u32 *
+decode_rm_long_register(int reg)
 {
     switch (reg) {
-      case 0:
-		DECODE_PRINTF("EAX");
-		return &M.x86.R_EAX;
-	  case 1:
-		DECODE_PRINTF("ECX");
-		return &M.x86.R_ECX;
-	  case 2:
-		DECODE_PRINTF("EDX");
-		return &M.x86.R_EDX;
-	  case 3:
-		DECODE_PRINTF("EBX");
-		return &M.x86.R_EBX;
-	  case 4:
-		DECODE_PRINTF("ESP");
-		return &M.x86.R_ESP;
-	  case 5:
-		DECODE_PRINTF("EBP");
-		return &M.x86.R_EBP;
-	  case 6:
-		DECODE_PRINTF("ESI");
-		return &M.x86.R_ESI;
-	  case 7:
-		DECODE_PRINTF("EDI");
-		return &M.x86.R_EDI;
-	}
-	HALT_SYS();
+    case 0:
+        DECODE_PRINTF("EAX");
+        return &M.x86.R_EAX;
+    case 1:
+        DECODE_PRINTF("ECX");
+        return &M.x86.R_ECX;
+    case 2:
+        DECODE_PRINTF("EDX");
+        return &M.x86.R_EDX;
+    case 3:
+        DECODE_PRINTF("EBX");
+        return &M.x86.R_EBX;
+    case 4:
+        DECODE_PRINTF("ESP");
+        return &M.x86.R_ESP;
+    case 5:
+        DECODE_PRINTF("EBP");
+        return &M.x86.R_EBP;
+    case 6:
+        DECODE_PRINTF("ESI");
+        return &M.x86.R_ESI;
+    case 7:
+        DECODE_PRINTF("EDI");
+        return &M.x86.R_EDI;
+    }
+    HALT_SYS();
     return NULL;                /* NOTREACHED OR REACHED ON ERROR */
 }
 
@@ -692,126 +685,129 @@ Return a pointer to the register given by the R/RM field of the
 modrm byte, for word operands, modified from above for the weirdo
 special case of segreg operands.  Also enables the decoding of instructions.
 ****************************************************************************/
-u16* decode_rm_seg_register(
-	int reg)
+u16 *
+decode_rm_seg_register(int reg)
 {
-	switch (reg) {
-	  case 0:
-		DECODE_PRINTF("ES");
-		return &M.x86.R_ES;
-	  case 1:
-		DECODE_PRINTF("CS");
-		return &M.x86.R_CS;
-	  case 2:
-		DECODE_PRINTF("SS");
-		return &M.x86.R_SS;
-	  case 3:
-		DECODE_PRINTF("DS");
-		return &M.x86.R_DS;
-	  case 4:
-		DECODE_PRINTF("FS");
-		return &M.x86.R_FS;
-	  case 5:
-		DECODE_PRINTF("GS");
-		return &M.x86.R_GS;
-	  case 6:
-	  case 7:
-		DECODE_PRINTF("ILLEGAL SEGREG");
-		break;
-	}
-	HALT_SYS();
-	return NULL;                /* NOT REACHED OR REACHED ON ERROR */
+    switch (reg) {
+    case 0:
+        DECODE_PRINTF("ES");
+        return &M.x86.R_ES;
+    case 1:
+        DECODE_PRINTF("CS");
+        return &M.x86.R_CS;
+    case 2:
+        DECODE_PRINTF("SS");
+        return &M.x86.R_SS;
+    case 3:
+        DECODE_PRINTF("DS");
+        return &M.x86.R_DS;
+    case 4:
+        DECODE_PRINTF("FS");
+        return &M.x86.R_FS;
+    case 5:
+        DECODE_PRINTF("GS");
+        return &M.x86.R_GS;
+    case 6:
+    case 7:
+        DECODE_PRINTF("ILLEGAL SEGREG");
+        break;
+    }
+    HALT_SYS();
+    return NULL;                /* NOT REACHED OR REACHED ON ERROR */
 }
 
 /*
  *
  * return offset from the SIB Byte
  */
-u32 decode_sib_address(int sib, int mod)
+u32
+decode_sib_address(int sib, int mod)
 {
     u32 base = 0, i = 0, scale = 1;
 
-    switch(sib & 0x07) {
+    switch (sib & 0x07) {
     case 0:
-	DECODE_PRINTF("[EAX]");
-	base = M.x86.R_EAX;
-	break;
+        DECODE_PRINTF("[EAX]");
+        base = M.x86.R_EAX;
+        break;
     case 1:
-	DECODE_PRINTF("[ECX]");
-	base = M.x86.R_ECX;
-	break;
+        DECODE_PRINTF("[ECX]");
+        base = M.x86.R_ECX;
+        break;
     case 2:
-	DECODE_PRINTF("[EDX]");
-	base = M.x86.R_EDX;
-	break;
+        DECODE_PRINTF("[EDX]");
+        base = M.x86.R_EDX;
+        break;
     case 3:
-	DECODE_PRINTF("[EBX]");
-	base = M.x86.R_EBX;
-	break;
+        DECODE_PRINTF("[EBX]");
+        base = M.x86.R_EBX;
+        break;
     case 4:
-	DECODE_PRINTF("[ESP]");
-	base = M.x86.R_ESP;
-	M.x86.mode |= SYSMODE_SEG_DS_SS;
-	break;
+        DECODE_PRINTF("[ESP]");
+        base = M.x86.R_ESP;
+        M.x86.mode |= SYSMODE_SEG_DS_SS;
+        break;
     case 5:
-	if (mod == 0) {
-	    base = fetch_long_imm();
-	    DECODE_PRINTF2("%08x", base);
-	} else {
-	    DECODE_PRINTF("[EBP]");
-	    base = M.x86.R_ESP;
-	    M.x86.mode |= SYSMODE_SEG_DS_SS;
-	}
-	break;
+        if (mod == 0) {
+            base = fetch_long_imm();
+            DECODE_PRINTF2("%08x", base);
+        }
+        else {
+            DECODE_PRINTF("[EBP]");
+            base = M.x86.R_ESP;
+            M.x86.mode |= SYSMODE_SEG_DS_SS;
+        }
+        break;
     case 6:
-	DECODE_PRINTF("[ESI]");
-	base = M.x86.R_ESI;
-	break;
+        DECODE_PRINTF("[ESI]");
+        base = M.x86.R_ESI;
+        break;
     case 7:
-	DECODE_PRINTF("[EDI]");
-	base = M.x86.R_EDI;
-	break;
+        DECODE_PRINTF("[EDI]");
+        base = M.x86.R_EDI;
+        break;
     }
     switch ((sib >> 3) & 0x07) {
     case 0:
-	DECODE_PRINTF("[EAX");
-	i = M.x86.R_EAX;
-	break;
+        DECODE_PRINTF("[EAX");
+        i = M.x86.R_EAX;
+        break;
     case 1:
-	DECODE_PRINTF("[ECX");
-	i = M.x86.R_ECX;
-	break;
+        DECODE_PRINTF("[ECX");
+        i = M.x86.R_ECX;
+        break;
     case 2:
-	DECODE_PRINTF("[EDX");
-	i = M.x86.R_EDX;
-	break;
+        DECODE_PRINTF("[EDX");
+        i = M.x86.R_EDX;
+        break;
     case 3:
-	DECODE_PRINTF("[EBX");
-	i = M.x86.R_EBX;
-	break;
+        DECODE_PRINTF("[EBX");
+        i = M.x86.R_EBX;
+        break;
     case 4:
-	i = 0;
-	break;
+        i = 0;
+        break;
     case 5:
-	DECODE_PRINTF("[EBP");
-	i = M.x86.R_EBP;
-	break;
+        DECODE_PRINTF("[EBP");
+        i = M.x86.R_EBP;
+        break;
     case 6:
-	DECODE_PRINTF("[ESI");
-	i = M.x86.R_ESI;
-	break;
+        DECODE_PRINTF("[ESI");
+        i = M.x86.R_ESI;
+        break;
     case 7:
-	DECODE_PRINTF("[EDI");
-	i = M.x86.R_EDI;
-	break;
+        DECODE_PRINTF("[EDI");
+        i = M.x86.R_EDI;
+        break;
     }
     scale = 1 << ((sib >> 6) & 0x03);
     if (((sib >> 3) & 0x07) != 4) {
-	if (scale == 1) {
-	    DECODE_PRINTF("]");
-	} else {
-	    DECODE_PRINTF2("*%d]", scale);
-	}
+        if (scale == 1) {
+            DECODE_PRINTF("]");
+        }
+        else {
+            DECODE_PRINTF2("*%d]", scale);
+        }
     }
     return base + (i * scale);
 }
@@ -836,74 +832,75 @@ NOTE: 	The code which specifies the corresponding segment (ds vs ss)
 		if a SS access is needed, set this bit.  Otherwise, DS access
 		occurs (unless any of the segment override bits are set).
 ****************************************************************************/
-u32 decode_rm00_address(
-	int rm)
+u32
+decode_rm00_address(int rm)
 {
     u32 offset;
     int sib;
 
     if (M.x86.mode & SYSMODE_PREFIX_ADDR) {
         /* 32-bit addressing */
-	switch (rm) {
-	  case 0:
-		DECODE_PRINTF("[EAX]");
-		return M.x86.R_EAX;
-	  case 1:
-		DECODE_PRINTF("[ECX]");
-		return M.x86.R_ECX;
-	  case 2:
-		DECODE_PRINTF("[EDX]");
-		return M.x86.R_EDX;
-	  case 3:
-		DECODE_PRINTF("[EBX]");
-		return M.x86.R_EBX;
-	  case 4:
-		sib = fetch_byte_imm();
-		return decode_sib_address(sib, 0);
-	  case 5:
-		offset = fetch_long_imm();
-		DECODE_PRINTF2("[%08x]", offset);
-		return offset;
-	  case 6:
-		DECODE_PRINTF("[ESI]");
-		return M.x86.R_ESI;
-	  case 7:
-		DECODE_PRINTF("[EDI]");
-		return M.x86.R_EDI;
-	}
-	HALT_SYS();
-    } else {
+        switch (rm) {
+        case 0:
+            DECODE_PRINTF("[EAX]");
+            return M.x86.R_EAX;
+        case 1:
+            DECODE_PRINTF("[ECX]");
+            return M.x86.R_ECX;
+        case 2:
+            DECODE_PRINTF("[EDX]");
+            return M.x86.R_EDX;
+        case 3:
+            DECODE_PRINTF("[EBX]");
+            return M.x86.R_EBX;
+        case 4:
+            sib = fetch_byte_imm();
+            return decode_sib_address(sib, 0);
+        case 5:
+            offset = fetch_long_imm();
+            DECODE_PRINTF2("[%08x]", offset);
+            return offset;
+        case 6:
+            DECODE_PRINTF("[ESI]");
+            return M.x86.R_ESI;
+        case 7:
+            DECODE_PRINTF("[EDI]");
+            return M.x86.R_EDI;
+        }
+        HALT_SYS();
+    }
+    else {
         /* 16-bit addressing */
-	switch (rm) {
-	  case 0:
-		DECODE_PRINTF("[BX+SI]");
+        switch (rm) {
+        case 0:
+            DECODE_PRINTF("[BX+SI]");
             return (M.x86.R_BX + M.x86.R_SI) & 0xffff;
-	  case 1:
-		DECODE_PRINTF("[BX+DI]");
+        case 1:
+            DECODE_PRINTF("[BX+DI]");
             return (M.x86.R_BX + M.x86.R_DI) & 0xffff;
-	  case 2:
-		DECODE_PRINTF("[BP+SI]");
-		M.x86.mode |= SYSMODE_SEG_DS_SS;
+        case 2:
+            DECODE_PRINTF("[BP+SI]");
+            M.x86.mode |= SYSMODE_SEG_DS_SS;
             return (M.x86.R_BP + M.x86.R_SI) & 0xffff;
-	  case 3:
-		DECODE_PRINTF("[BP+DI]");
-		M.x86.mode |= SYSMODE_SEG_DS_SS;
+        case 3:
+            DECODE_PRINTF("[BP+DI]");
+            M.x86.mode |= SYSMODE_SEG_DS_SS;
             return (M.x86.R_BP + M.x86.R_DI) & 0xffff;
-	  case 4:
-		DECODE_PRINTF("[SI]");
-		return M.x86.R_SI;
-	  case 5:
-		DECODE_PRINTF("[DI]");
-		return M.x86.R_DI;
-	  case 6:
-		offset = fetch_word_imm();
-		DECODE_PRINTF2("[%04x]", offset);
-		return offset;
-	  case 7:
-		DECODE_PRINTF("[BX]");
-		return M.x86.R_BX;
-	}
-	HALT_SYS();
+        case 4:
+            DECODE_PRINTF("[SI]");
+            return M.x86.R_SI;
+        case 5:
+            DECODE_PRINTF("[DI]");
+            return M.x86.R_DI;
+        case 6:
+            offset = fetch_word_imm();
+            DECODE_PRINTF2("[%04x]", offset);
+            return offset;
+        case 7:
+            DECODE_PRINTF("[BX]");
+            return M.x86.R_BX;
+        }
+        HALT_SYS();
     }
     return 0;
 }
@@ -919,79 +916,80 @@ REMARKS:
 Return the offset given by mod=01 addressing.  Also enables the
 decoding of instructions.
 ****************************************************************************/
-u32 decode_rm01_address(
-	int rm)
+u32
+decode_rm01_address(int rm)
 {
     int displacement = 0;
     int sib;
 
     /* Fetch disp8 if no SIB byte */
     if (!((M.x86.mode & SYSMODE_PREFIX_ADDR) && (rm == 4)))
-	displacement = (s8)fetch_byte_imm();
+        displacement = (s8) fetch_byte_imm();
 
     if (M.x86.mode & SYSMODE_PREFIX_ADDR) {
         /* 32-bit addressing */
-	switch (rm) {
-	  case 0:
-		DECODE_PRINTF2("%d[EAX]", displacement);
-		return M.x86.R_EAX + displacement;
-	  case 1:
-		DECODE_PRINTF2("%d[ECX]", displacement);
-		return M.x86.R_ECX + displacement;
-	  case 2:
-		DECODE_PRINTF2("%d[EDX]", displacement);
-		return M.x86.R_EDX + displacement;
-	  case 3:
-		DECODE_PRINTF2("%d[EBX]", displacement);
-		return M.x86.R_EBX + displacement;
-	  case 4:
-		sib = fetch_byte_imm();
-		displacement = (s8)fetch_byte_imm();
-		DECODE_PRINTF2("%d", displacement);
-		return decode_sib_address(sib, 1) + displacement;
-	  case 5:
-		DECODE_PRINTF2("%d[EBP]", displacement);
-		return M.x86.R_EBP + displacement;
-	  case 6:
-		DECODE_PRINTF2("%d[ESI]", displacement);
-		return M.x86.R_ESI + displacement;
-	  case 7:
-		DECODE_PRINTF2("%d[EDI]", displacement);
-		return M.x86.R_EDI + displacement;
-	}
-	HALT_SYS();
-    } else {
+        switch (rm) {
+        case 0:
+            DECODE_PRINTF2("%d[EAX]", displacement);
+            return M.x86.R_EAX + displacement;
+        case 1:
+            DECODE_PRINTF2("%d[ECX]", displacement);
+            return M.x86.R_ECX + displacement;
+        case 2:
+            DECODE_PRINTF2("%d[EDX]", displacement);
+            return M.x86.R_EDX + displacement;
+        case 3:
+            DECODE_PRINTF2("%d[EBX]", displacement);
+            return M.x86.R_EBX + displacement;
+        case 4:
+            sib = fetch_byte_imm();
+            displacement = (s8) fetch_byte_imm();
+            DECODE_PRINTF2("%d", displacement);
+            return decode_sib_address(sib, 1) + displacement;
+        case 5:
+            DECODE_PRINTF2("%d[EBP]", displacement);
+            return M.x86.R_EBP + displacement;
+        case 6:
+            DECODE_PRINTF2("%d[ESI]", displacement);
+            return M.x86.R_ESI + displacement;
+        case 7:
+            DECODE_PRINTF2("%d[EDI]", displacement);
+            return M.x86.R_EDI + displacement;
+        }
+        HALT_SYS();
+    }
+    else {
         /* 16-bit addressing */
-	switch (rm) {
-	  case 0:
-		DECODE_PRINTF2("%d[BX+SI]", displacement);
+        switch (rm) {
+        case 0:
+            DECODE_PRINTF2("%d[BX+SI]", displacement);
             return (M.x86.R_BX + M.x86.R_SI + displacement) & 0xffff;
-	  case 1:
-		DECODE_PRINTF2("%d[BX+DI]", displacement);
+        case 1:
+            DECODE_PRINTF2("%d[BX+DI]", displacement);
             return (M.x86.R_BX + M.x86.R_DI + displacement) & 0xffff;
-	  case 2:
-		DECODE_PRINTF2("%d[BP+SI]", displacement);
-		M.x86.mode |= SYSMODE_SEG_DS_SS;
+        case 2:
+            DECODE_PRINTF2("%d[BP+SI]", displacement);
+            M.x86.mode |= SYSMODE_SEG_DS_SS;
             return (M.x86.R_BP + M.x86.R_SI + displacement) & 0xffff;
-	  case 3:
-		DECODE_PRINTF2("%d[BP+DI]", displacement);
-		M.x86.mode |= SYSMODE_SEG_DS_SS;
+        case 3:
+            DECODE_PRINTF2("%d[BP+DI]", displacement);
+            M.x86.mode |= SYSMODE_SEG_DS_SS;
             return (M.x86.R_BP + M.x86.R_DI + displacement) & 0xffff;
-	  case 4:
-		DECODE_PRINTF2("%d[SI]", displacement);
+        case 4:
+            DECODE_PRINTF2("%d[SI]", displacement);
             return (M.x86.R_SI + displacement) & 0xffff;
-	  case 5:
-		DECODE_PRINTF2("%d[DI]", displacement);
+        case 5:
+            DECODE_PRINTF2("%d[DI]", displacement);
             return (M.x86.R_DI + displacement) & 0xffff;
-	  case 6:
-		DECODE_PRINTF2("%d[BP]", displacement);
-		M.x86.mode |= SYSMODE_SEG_DS_SS;
+        case 6:
+            DECODE_PRINTF2("%d[BP]", displacement);
+            M.x86.mode |= SYSMODE_SEG_DS_SS;
             return (M.x86.R_BP + displacement) & 0xffff;
-	  case 7:
-		DECODE_PRINTF2("%d[BX]", displacement);
+        case 7:
+            DECODE_PRINTF2("%d[BX]", displacement);
             return (M.x86.R_BX + displacement) & 0xffff;
-	}
-	HALT_SYS();
+        }
+        HALT_SYS();
     }
     return 0;                   /* SHOULD NOT HAPPEN */
 }
@@ -1007,86 +1005,87 @@ REMARKS:
 Return the offset given by mod=10 addressing.  Also enables the
 decoding of instructions.
 ****************************************************************************/
-u32 decode_rm10_address(
-	int rm)
+u32
+decode_rm10_address(int rm)
 {
     u32 displacement = 0;
     int sib;
 
     /* Fetch disp16 if 16-bit addr mode */
     if (!(M.x86.mode & SYSMODE_PREFIX_ADDR))
-	displacement = (u16)fetch_word_imm();
+        displacement = (u16) fetch_word_imm();
     else {
-	/* Fetch disp32 if no SIB byte */
-	if (rm != 4)
-	    displacement = (u32)fetch_long_imm();
+        /* Fetch disp32 if no SIB byte */
+        if (rm != 4)
+            displacement = (u32) fetch_long_imm();
     }
 
     if (M.x86.mode & SYSMODE_PREFIX_ADDR) {
         /* 32-bit addressing */
-      switch (rm) {
-	  case 0:
-		DECODE_PRINTF2("%08x[EAX]", displacement);
-		return M.x86.R_EAX + displacement;
-	  case 1:
-		DECODE_PRINTF2("%08x[ECX]", displacement);
-		return M.x86.R_ECX + displacement;
-	  case 2:
-		DECODE_PRINTF2("%08x[EDX]", displacement);
-		M.x86.mode |= SYSMODE_SEG_DS_SS;
-		return M.x86.R_EDX + displacement;
-	  case 3:
-		DECODE_PRINTF2("%08x[EBX]", displacement);
-		return M.x86.R_EBX + displacement;
-	  case 4:
-		sib = fetch_byte_imm();
-		displacement = (u32)fetch_long_imm();
-		DECODE_PRINTF2("%08x", displacement);
-		return decode_sib_address(sib, 2) + displacement;
-		break;
-	  case 5:
-		DECODE_PRINTF2("%08x[EBP]", displacement);
-		return M.x86.R_EBP + displacement;
-	  case 6:
-		DECODE_PRINTF2("%08x[ESI]", displacement);
-		return M.x86.R_ESI + displacement;
-	  case 7:
-		DECODE_PRINTF2("%08x[EDI]", displacement);
-		return M.x86.R_EDI + displacement;
-	}
-	HALT_SYS();
-    } else {
+        switch (rm) {
+        case 0:
+            DECODE_PRINTF2("%08x[EAX]", displacement);
+            return M.x86.R_EAX + displacement;
+        case 1:
+            DECODE_PRINTF2("%08x[ECX]", displacement);
+            return M.x86.R_ECX + displacement;
+        case 2:
+            DECODE_PRINTF2("%08x[EDX]", displacement);
+            M.x86.mode |= SYSMODE_SEG_DS_SS;
+            return M.x86.R_EDX + displacement;
+        case 3:
+            DECODE_PRINTF2("%08x[EBX]", displacement);
+            return M.x86.R_EBX + displacement;
+        case 4:
+            sib = fetch_byte_imm();
+            displacement = (u32) fetch_long_imm();
+            DECODE_PRINTF2("%08x", displacement);
+            return decode_sib_address(sib, 2) + displacement;
+            break;
+        case 5:
+            DECODE_PRINTF2("%08x[EBP]", displacement);
+            return M.x86.R_EBP + displacement;
+        case 6:
+            DECODE_PRINTF2("%08x[ESI]", displacement);
+            return M.x86.R_ESI + displacement;
+        case 7:
+            DECODE_PRINTF2("%08x[EDI]", displacement);
+            return M.x86.R_EDI + displacement;
+        }
+        HALT_SYS();
+    }
+    else {
         /* 16-bit addressing */
-      switch (rm) {
-	  case 0:
+        switch (rm) {
+        case 0:
             DECODE_PRINTF2("%04x[BX+SI]", displacement);
             return (M.x86.R_BX + M.x86.R_SI + displacement) & 0xffff;
-	  case 1:
+        case 1:
             DECODE_PRINTF2("%04x[BX+DI]", displacement);
             return (M.x86.R_BX + M.x86.R_DI + displacement) & 0xffff;
-	  case 2:
-		DECODE_PRINTF2("%04x[BP+SI]", displacement);
-		M.x86.mode |= SYSMODE_SEG_DS_SS;
+        case 2:
+            DECODE_PRINTF2("%04x[BP+SI]", displacement);
+            M.x86.mode |= SYSMODE_SEG_DS_SS;
             return (M.x86.R_BP + M.x86.R_SI + displacement) & 0xffff;
-	  case 3:
-		DECODE_PRINTF2("%04x[BP+DI]", displacement);
-		M.x86.mode |= SYSMODE_SEG_DS_SS;
+        case 3:
+            DECODE_PRINTF2("%04x[BP+DI]", displacement);
+            M.x86.mode |= SYSMODE_SEG_DS_SS;
             return (M.x86.R_BP + M.x86.R_DI + displacement) & 0xffff;
-	  case 4:
+        case 4:
             DECODE_PRINTF2("%04x[SI]", displacement);
             return (M.x86.R_SI + displacement) & 0xffff;
-	  case 5:
+        case 5:
             DECODE_PRINTF2("%04x[DI]", displacement);
             return (M.x86.R_DI + displacement) & 0xffff;
-	  case 6:
-		DECODE_PRINTF2("%04x[BP]", displacement);
-		M.x86.mode |= SYSMODE_SEG_DS_SS;
+        case 6:
+            DECODE_PRINTF2("%04x[BP]", displacement);
+            M.x86.mode |= SYSMODE_SEG_DS_SS;
             return (M.x86.R_BP + displacement) & 0xffff;
-	  case 7:
+        case 7:
             DECODE_PRINTF2("%04x[BX]", displacement);
             return (M.x86.R_BX + displacement) & 0xffff;
-	}
-	HALT_SYS();
+        }
+        HALT_SYS();
     }
     return 0;
     /*NOTREACHED */
diff --git a/libs/x86emu/fpu.c b/libs/x86emu/fpu.c
index b72de1e..0dab05c 100644
--- a/libs/x86emu/fpu.c
+++ b/libs/x86emu/fpu.c
@@ -42,7 +42,8 @@
 /*----------------------------- Implementation ----------------------------*/
 
 /* opcode=0xd8 */
-void x86emuOp_esc_coprocess_d8(u8 X86EMU_UNUSED(op1))
+void
+x86emuOp_esc_coprocess_d8(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     DECODE_PRINTF("ESC D8\n");
@@ -52,7 +53,7 @@ void x86emuOp_esc_coprocess_d8(u8 X86EMU_UNUSED(op1))
 
 #ifdef DEBUG
 
-static char *x86emu_fpu_op_d9_tab[] = {
+static const char *x86emu_fpu_op_d9_tab[] = {
     "FLD\tDWORD PTR ", "ESC_D9\t", "FST\tDWORD PTR ", "FSTP\tDWORD PTR ",
     "FLDENV\t", "FLDCW\t", "FSTENV\t", "FSTCW\t",
 
@@ -63,7 +64,7 @@ static char *x86emu_fpu_op_d9_tab[] = {
     "FLDENV\t", "FLDCW\t", "FSTENV\t", "FSTCW\t",
 };
 
-static char *x86emu_fpu_op_d9_tab1[] = {
+static const char *x86emu_fpu_op_d9_tab1[] = {
     "FLD\t", "FLD\t", "FLD\t", "FLD\t",
     "FLD\t", "FLD\t", "FLD\t", "FLD\t",
 
@@ -89,10 +90,11 @@ static char *x86emu_fpu_op_d9_tab1[] = {
     "FRNDINT", "FSCALE", "ESC_D9", "ESC_D9",
 };
 
-#endif /* DEBUG */
+#endif                          /* DEBUG */
 
 /* opcode=0xd9 */
-void x86emuOp_esc_coprocess_d9(u8 X86EMU_UNUSED(op1))
+void
+x86emuOp_esc_coprocess_d9(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     uint destoffset = 0;
@@ -103,56 +105,58 @@ void x86emuOp_esc_coprocess_d9(u8 X86EMU_UNUSED(op1))
 #ifdef DEBUG
     if (mod != 3) {
         DECODE_PRINTINSTR32(x86emu_fpu_op_d9_tab, mod, rh, rl);
-    } else {
+    }
+    else {
         DECODE_PRINTF(x86emu_fpu_op_d9_tab1[(rh << 3) + rl]);
     }
 #endif
     switch (mod) {
-      case 0:
+    case 0:
         destoffset = decode_rm00_address(rl);
         DECODE_PRINTF("\n");
         break;
-      case 1:
+    case 1:
         destoffset = decode_rm01_address(rl);
         DECODE_PRINTF("\n");
         break;
-      case 2:
+    case 2:
         destoffset = decode_rm10_address(rl);
         DECODE_PRINTF("\n");
         break;
-      case 3:                   /* register to register */
-		stkelem = (u8)rl;
-		if (rh < 4) {
-				DECODE_PRINTF2("ST(%d)\n", stkelem);
-		} else {
-				DECODE_PRINTF("\n");
-		}
+    case 3:                    /* register to register */
+        stkelem = (u8) rl;
+        if (rh < 4) {
+            DECODE_PRINTF2("ST(%d)\n", stkelem);
+        }
+        else {
+            DECODE_PRINTF("\n");
+        }
         break;
     }
 #ifdef X86EMU_FPU_PRESENT
     /* execute */
     switch (mod) {
-      case 3:
+    case 3:
         switch (rh) {
-          case 0:
+        case 0:
             x86emu_fpu_R_fld(X86EMU_FPU_STKTOP, stkelem);
             break;
-          case 1:
+        case 1:
             x86emu_fpu_R_fxch(X86EMU_FPU_STKTOP, stkelem);
             break;
-          case 2:
+        case 2:
             switch (rl) {
-              case 0:
+            case 0:
                 x86emu_fpu_R_nop();
                 break;
-              default:
+            default:
                 x86emu_fpu_illegal();
                 break;
             }
-          case 3:
+        case 3:
             x86emu_fpu_R_fstp(X86EMU_FPU_STKTOP, stkelem);
             break;
-          case 4:
+        case 4:
             switch (rl) {
             case 0:
                 x86emu_fpu_R_fchs(X86EMU_FPU_STKTOP);
@@ -173,133 +177,133 @@ void x86emuOp_esc_coprocess_d9(u8 X86EMU_UNUSED(op1))
             }
             break;
 
-          case 5:
+        case 5:
             switch (rl) {
-              case 0:
+            case 0:
                 x86emu_fpu_R_fld1(X86EMU_FPU_STKTOP);
                 break;
-              case 1:
+            case 1:
                 x86emu_fpu_R_fldl2t(X86EMU_FPU_STKTOP);
                 break;
-              case 2:
+            case 2:
                 x86emu_fpu_R_fldl2e(X86EMU_FPU_STKTOP);
                 break;
-              case 3:
+            case 3:
                 x86emu_fpu_R_fldpi(X86EMU_FPU_STKTOP);
                 break;
-              case 4:
+            case 4:
                 x86emu_fpu_R_fldlg2(X86EMU_FPU_STKTOP);
                 break;
-              case 5:
+            case 5:
                 x86emu_fpu_R_fldln2(X86EMU_FPU_STKTOP);
                 break;
-              case 6:
+            case 6:
                 x86emu_fpu_R_fldz(X86EMU_FPU_STKTOP);
                 break;
-              default:
+            default:
                 /* 7 */
                 x86emu_fpu_illegal();
                 break;
             }
             break;
 
-          case 6:
+        case 6:
             switch (rl) {
-              case 0:
+            case 0:
                 x86emu_fpu_R_f2xm1(X86EMU_FPU_STKTOP);
                 break;
-              case 1:
+            case 1:
                 x86emu_fpu_R_fyl2x(X86EMU_FPU_STKTOP);
                 break;
-              case 2:
+            case 2:
                 x86emu_fpu_R_fptan(X86EMU_FPU_STKTOP);
                 break;
-              case 3:
+            case 3:
                 x86emu_fpu_R_fpatan(X86EMU_FPU_STKTOP);
                 break;
-              case 4:
+            case 4:
                 x86emu_fpu_R_fxtract(X86EMU_FPU_STKTOP);
                 break;
-              case 5:
+            case 5:
                 x86emu_fpu_illegal();
                 break;
-              case 6:
+            case 6:
                 x86emu_fpu_R_decstp();
                 break;
-              case 7:
+            case 7:
                 x86emu_fpu_R_incstp();
                 break;
             }
             break;
 
-          case 7:
+        case 7:
             switch (rl) {
-              case 0:
+            case 0:
                 x86emu_fpu_R_fprem(X86EMU_FPU_STKTOP);
                 break;
-              case 1:
+            case 1:
                 x86emu_fpu_R_fyl2xp1(X86EMU_FPU_STKTOP);
                 break;
-              case 2:
+            case 2:
                 x86emu_fpu_R_fsqrt(X86EMU_FPU_STKTOP);
                 break;
-              case 3:
+            case 3:
                 x86emu_fpu_illegal();
                 break;
-              case 4:
+            case 4:
                 x86emu_fpu_R_frndint(X86EMU_FPU_STKTOP);
                 break;
-              case 5:
+            case 5:
                 x86emu_fpu_R_fscale(X86EMU_FPU_STKTOP);
                 break;
-              case 6:
-              case 7:
-              default:
+            case 6:
+            case 7:
+            default:
                 x86emu_fpu_illegal();
                 break;
             }
             break;
 
-          default:
+        default:
             switch (rh) {
-              case 0:
+            case 0:
                 x86emu_fpu_M_fld(X86EMU_FPU_FLOAT, destoffset);
                 break;
-              case 1:
+            case 1:
                 x86emu_fpu_illegal();
                 break;
-              case 2:
+            case 2:
                 x86emu_fpu_M_fst(X86EMU_FPU_FLOAT, destoffset);
                 break;
-              case 3:
+            case 3:
                 x86emu_fpu_M_fstp(X86EMU_FPU_FLOAT, destoffset);
                 break;
-              case 4:
+            case 4:
                 x86emu_fpu_M_fldenv(X86EMU_FPU_WORD, destoffset);
                 break;
-              case 5:
+            case 5:
                 x86emu_fpu_M_fldcw(X86EMU_FPU_WORD, destoffset);
                 break;
-              case 6:
+            case 6:
                 x86emu_fpu_M_fstenv(X86EMU_FPU_WORD, destoffset);
                 break;
-              case 7:
+            case 7:
                 x86emu_fpu_M_fstcw(X86EMU_FPU_WORD, destoffset);
                 break;
             }
         }
     }
 #else
-    (void)destoffset;
-    (void)stkelem;
-#endif /* X86EMU_FPU_PRESENT */
+    (void) destoffset;
+    (void) stkelem;
+#endif                          /* X86EMU_FPU_PRESENT */
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR_NO_TRACE();
 }
 
 #ifdef DEBUG
 
-char *x86emu_fpu_op_da_tab[] = {
+static const char *x86emu_fpu_op_da_tab[] = {
     "FIADD\tDWORD PTR ", "FIMUL\tDWORD PTR ", "FICOM\tDWORD PTR ",
     "FICOMP\tDWORD PTR ",
     "FISUB\tDWORD PTR ", "FISUBR\tDWORD PTR ", "FIDIV\tDWORD PTR ",
@@ -309,7 +313,7 @@ char *x86emu_fpu_op_da_tab[] = {
     "FICOMP\tDWORD PTR ",
     "FISUB\tDWORD PTR ", "FISUBR\tDWORD PTR ", "FIDIV\tDWORD PTR ",
     "FIDIVR\tDWORD PTR ",
-    
+
     "FIADD\tDWORD PTR ", "FIMUL\tDWORD PTR ", "FICOM\tDWORD PTR ",
     "FICOMP\tDWORD PTR ",
     "FISUB\tDWORD PTR ", "FISUBR\tDWORD PTR ", "FIDIV\tDWORD PTR ",
@@ -319,10 +323,11 @@ char *x86emu_fpu_op_da_tab[] = {
     "ESC_DA     ", "ESC_DA ", "ESC_DA   ", "ESC_DA ",
 };
 
-#endif /* DEBUG */
+#endif                          /* DEBUG */
 
 /* opcode=0xda */
-void x86emuOp_esc_coprocess_da(u8 X86EMU_UNUSED(op1))
+void
+x86emuOp_esc_coprocess_da(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     uint destoffset = 0;
@@ -332,59 +337,59 @@ void x86emuOp_esc_coprocess_da(u8 X86EMU_UNUSED(op1))
     FETCH_DECODE_MODRM(mod, rh, rl);
     DECODE_PRINTINSTR32(x86emu_fpu_op_da_tab, mod, rh, rl);
     switch (mod) {
-      case 0:
+    case 0:
         destoffset = decode_rm00_address(rl);
         DECODE_PRINTF("\n");
         break;
-      case 1:
+    case 1:
         destoffset = decode_rm01_address(rl);
         DECODE_PRINTF("\n");
         break;
-      case 2:
+    case 2:
         destoffset = decode_rm10_address(rl);
         DECODE_PRINTF("\n");
         break;
-      case 3:           /* register to register */
-		stkelem = (u8)rl;
+    case 3:                    /* register to register */
+        stkelem = (u8) rl;
         DECODE_PRINTF2("\tST(%d),ST\n", stkelem);
         break;
     }
 #ifdef X86EMU_FPU_PRESENT
     switch (mod) {
-      case 3:
+    case 3:
         x86emu_fpu_illegal();
         break;
-      default:
+    default:
         switch (rh) {
-          case 0:
+        case 0:
             x86emu_fpu_M_iadd(X86EMU_FPU_SHORT, destoffset);
             break;
-          case 1:
+        case 1:
             x86emu_fpu_M_imul(X86EMU_FPU_SHORT, destoffset);
             break;
-          case 2:
+        case 2:
             x86emu_fpu_M_icom(X86EMU_FPU_SHORT, destoffset);
             break;
-          case 3:
+        case 3:
             x86emu_fpu_M_icomp(X86EMU_FPU_SHORT, destoffset);
             break;
-          case 4:
+        case 4:
             x86emu_fpu_M_isub(X86EMU_FPU_SHORT, destoffset);
             break;
-          case 5:
+        case 5:
             x86emu_fpu_M_isubr(X86EMU_FPU_SHORT, destoffset);
             break;
-          case 6:
+        case 6:
             x86emu_fpu_M_idiv(X86EMU_FPU_SHORT, destoffset);
             break;
-          case 7:
+        case 7:
             x86emu_fpu_M_idivr(X86EMU_FPU_SHORT, destoffset);
             break;
         }
     }
 #else
-    (void)destoffset;
-    (void)stkelem;
+    (void) destoffset;
+    (void) stkelem;
 #endif
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR_NO_TRACE();
@@ -392,7 +397,7 @@ void x86emuOp_esc_coprocess_da(u8 X86EMU_UNUSED(op1))
 
 #ifdef DEBUG
 
-char *x86emu_fpu_op_db_tab[] = {
+static const char *x86emu_fpu_op_db_tab[] = {
     "FILD\tDWORD PTR ", "ESC_DB\t19", "FIST\tDWORD PTR ", "FISTP\tDWORD PTR ",
     "ESC_DB\t1C", "FLD\tTBYTE PTR ", "ESC_DB\t1E", "FSTP\tTBYTE PTR ",
 
@@ -403,10 +408,11 @@ char *x86emu_fpu_op_db_tab[] = {
     "ESC_DB\t1C", "FLD\tTBYTE PTR ", "ESC_DB\t1E", "FSTP\tTBYTE PTR ",
 };
 
-#endif /* DEBUG */
+#endif                          /* DEBUG */
 
 /* opcode=0xdb */
-void x86emuOp_esc_coprocess_db(u8 X86EMU_UNUSED(op1))
+void
+x86emuOp_esc_coprocess_db(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     uint destoffset = 0;
@@ -416,104 +422,106 @@ void x86emuOp_esc_coprocess_db(u8 X86EMU_UNUSED(op1))
 #ifdef DEBUG
     if (mod != 3) {
         DECODE_PRINTINSTR32(x86emu_fpu_op_db_tab, mod, rh, rl);
-    } else if (rh == 4) {       /* === 11 10 0 nnn */
+    }
+    else if (rh == 4) {         /* === 11 10 0 nnn */
         switch (rl) {
-          case 0:
+        case 0:
             DECODE_PRINTF("FENI\n");
             break;
-          case 1:
+        case 1:
             DECODE_PRINTF("FDISI\n");
             break;
-          case 2:
+        case 2:
             DECODE_PRINTF("FCLEX\n");
             break;
-          case 3:
+        case 3:
             DECODE_PRINTF("FINIT\n");
             break;
         }
-    } else {
+    }
+    else {
         DECODE_PRINTF2("ESC_DB %0x\n", (mod << 6) + (rh << 3) + (rl));
     }
-#endif /* DEBUG */
+#endif                          /* DEBUG */
     switch (mod) {
-      case 0:
+    case 0:
         destoffset = decode_rm00_address(rl);
         break;
-      case 1:
+    case 1:
         destoffset = decode_rm01_address(rl);
         break;
-      case 2:
+    case 2:
         destoffset = decode_rm10_address(rl);
         break;
-      case 3:                   /* register to register */
+    case 3:                    /* register to register */
         break;
     }
 #ifdef X86EMU_FPU_PRESENT
     /* execute */
     switch (mod) {
-      case 3:
+    case 3:
         switch (rh) {
-          case 4:
+        case 4:
             switch (rl) {
-              case 0:
+            case 0:
                 x86emu_fpu_R_feni();
                 break;
-              case 1:
+            case 1:
                 x86emu_fpu_R_fdisi();
                 break;
-              case 2:
+            case 2:
                 x86emu_fpu_R_fclex();
                 break;
-              case 3:
+            case 3:
                 x86emu_fpu_R_finit();
                 break;
-              default:
+            default:
                 x86emu_fpu_illegal();
                 break;
             }
             break;
-          default:
+        default:
             x86emu_fpu_illegal();
             break;
         }
         break;
-      default:
+    default:
         switch (rh) {
-          case 0:
+        case 0:
             x86emu_fpu_M_fild(X86EMU_FPU_SHORT, destoffset);
             break;
-          case 1:
+        case 1:
             x86emu_fpu_illegal();
             break;
-          case 2:
+        case 2:
             x86emu_fpu_M_fist(X86EMU_FPU_SHORT, destoffset);
             break;
-          case 3:
+        case 3:
             x86emu_fpu_M_fistp(X86EMU_FPU_SHORT, destoffset);
             break;
-          case 4:
+        case 4:
             x86emu_fpu_illegal();
             break;
-          case 5:
+        case 5:
             x86emu_fpu_M_fld(X86EMU_FPU_LDBL, destoffset);
             break;
-                      case 6:
+        case 6:
             x86emu_fpu_illegal();
             break;
-          case 7:
+        case 7:
             x86emu_fpu_M_fstp(X86EMU_FPU_LDBL, destoffset);
             break;
         }
     }
 #else
-    (void)destoffset;
+    (void) destoffset;
 #endif
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR_NO_TRACE();
 }
 
 #ifdef DEBUG
-char *x86emu_fpu_op_dc_tab[] = {
+static const char *x86emu_fpu_op_dc_tab[] = {
     "FADD\tQWORD PTR ", "FMUL\tQWORD PTR ", "FCOM\tQWORD PTR ",
     "FCOMP\tQWORD PTR ",
     "FSUB\tQWORD PTR ", "FSUBR\tQWORD PTR ", "FDIV\tQWORD PTR ",
@@ -532,10 +540,11 @@ char *x86emu_fpu_op_dc_tab[] = {
     "FADD\t", "FMUL\t", "FCOM\t", "FCOMP\t",
     "FSUBR\t", "FSUB\t", "FDIVR\t", "FDIV\t",
 };
-#endif /* DEBUG */
+#endif                          /* DEBUG */
 
 /* opcode=0xdc */
-void x86emuOp_esc_coprocess_dc(u8 X86EMU_UNUSED(op1))
+void
+x86emuOp_esc_coprocess_dc(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     uint destoffset = 0;
@@ -545,85 +554,85 @@ void x86emuOp_esc_coprocess_dc(u8 X86EMU_UNUSED(op1))
     FETCH_DECODE_MODRM(mod, rh, rl);
     DECODE_PRINTINSTR32(x86emu_fpu_op_dc_tab, mod, rh, rl);
     switch (mod) {
-      case 0:
+    case 0:
         destoffset = decode_rm00_address(rl);
         DECODE_PRINTF("\n");
         break;
-      case 1:
+    case 1:
         destoffset = decode_rm01_address(rl);
         DECODE_PRINTF("\n");
         break;
-      case 2:
+    case 2:
         destoffset = decode_rm10_address(rl);
         DECODE_PRINTF("\n");
         break;
-      case 3:                   /* register to register */
-		stkelem = (u8)rl;
+    case 3:                    /* register to register */
+        stkelem = (u8) rl;
         DECODE_PRINTF2("\tST(%d),ST\n", stkelem);
         break;
     }
 #ifdef X86EMU_FPU_PRESENT
     /* execute */
     switch (mod) {
-      case 3:
+    case 3:
         switch (rh) {
-          case 0:
+        case 0:
             x86emu_fpu_R_fadd(stkelem, X86EMU_FPU_STKTOP);
             break;
-          case 1:
+        case 1:
             x86emu_fpu_R_fmul(stkelem, X86EMU_FPU_STKTOP);
             break;
-          case 2:
+        case 2:
             x86emu_fpu_R_fcom(stkelem, X86EMU_FPU_STKTOP);
             break;
-          case 3:
+        case 3:
             x86emu_fpu_R_fcomp(stkelem, X86EMU_FPU_STKTOP);
             break;
-          case 4:
+        case 4:
             x86emu_fpu_R_fsubr(stkelem, X86EMU_FPU_STKTOP);
             break;
-          case 5:
+        case 5:
             x86emu_fpu_R_fsub(stkelem, X86EMU_FPU_STKTOP);
             break;
-          case 6:
+        case 6:
             x86emu_fpu_R_fdivr(stkelem, X86EMU_FPU_STKTOP);
             break;
-          case 7:
+        case 7:
             x86emu_fpu_R_fdiv(stkelem, X86EMU_FPU_STKTOP);
             break;
         }
         break;
-      default:
+    default:
         switch (rh) {
-          case 0:
+        case 0:
             x86emu_fpu_M_fadd(X86EMU_FPU_DOUBLE, destoffset);
             break;
-          case 1:
+        case 1:
             x86emu_fpu_M_fmul(X86EMU_FPU_DOUBLE, destoffset);
             break;
-          case 2:
+        case 2:
             x86emu_fpu_M_fcom(X86EMU_FPU_DOUBLE, destoffset);
             break;
-          case 3:
+        case 3:
             x86emu_fpu_M_fcomp(X86EMU_FPU_DOUBLE, destoffset);
             break;
-          case 4:
+        case 4:
             x86emu_fpu_M_fsub(X86EMU_FPU_DOUBLE, destoffset);
             break;
-          case 5:
+        case 5:
             x86emu_fpu_M_fsubr(X86EMU_FPU_DOUBLE, destoffset);
             break;
-          case 6:
+        case 6:
             x86emu_fpu_M_fdiv(X86EMU_FPU_DOUBLE, destoffset);
             break;
-          case 7:
+        case 7:
             x86emu_fpu_M_fdivr(X86EMU_FPU_DOUBLE, destoffset);
             break;
         }
     }
 #else
-    (void)destoffset;
-    (void)stkelem;
+    (void) destoffset;
+    (void) stkelem;
 #endif
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR_NO_TRACE();
@@ -631,7 +640,7 @@ void x86emuOp_esc_coprocess_dc(u8 X86EMU_UNUSED(op1))
 
 #ifdef DEBUG
 
-static char *x86emu_fpu_op_dd_tab[] = {
+static const char *x86emu_fpu_op_dd_tab[] = {
     "FLD\tQWORD PTR ", "ESC_DD\t29,", "FST\tQWORD PTR ", "FSTP\tQWORD PTR ",
     "FRSTOR\t", "ESC_DD\t2D,", "FSAVE\t", "FSTSW\t",
 
@@ -645,10 +654,11 @@ static char *x86emu_fpu_op_dd_tab[] = {
     "ESC_DD\t2C,", "ESC_DD\t2D,", "ESC_DD\t2E,", "ESC_DD\t2F,",
 };
 
-#endif /* DEBUG */
+#endif                          /* DEBUG */
 
 /* opcode=0xdd */
-void x86emuOp_esc_coprocess_dd(u8 X86EMU_UNUSED(op1))
+void
+x86emuOp_esc_coprocess_dd(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     uint destoffset = 0;
@@ -658,75 +668,75 @@ void x86emuOp_esc_coprocess_dd(u8 X86EMU_UNUSED(op1))
     FETCH_DECODE_MODRM(mod, rh, rl);
     DECODE_PRINTINSTR32(x86emu_fpu_op_dd_tab, mod, rh, rl);
     switch (mod) {
-      case 0:
+    case 0:
         destoffset = decode_rm00_address(rl);
         DECODE_PRINTF("\n");
         break;
-      case 1:
+    case 1:
         destoffset = decode_rm01_address(rl);
         DECODE_PRINTF("\n");
         break;
-      case 2:
+    case 2:
         destoffset = decode_rm10_address(rl);
         DECODE_PRINTF("\n");
         break;
-      case 3:                   /* register to register */
-		stkelem = (u8)rl;
+    case 3:                    /* register to register */
+        stkelem = (u8) rl;
         DECODE_PRINTF2("\tST(%d),ST\n", stkelem);
         break;
     }
 #ifdef X86EMU_FPU_PRESENT
     switch (mod) {
-      case 3:
+    case 3:
         switch (rh) {
-          case 0:
+        case 0:
             x86emu_fpu_R_ffree(stkelem);
             break;
-          case 1:
+        case 1:
             x86emu_fpu_R_fxch(stkelem);
             break;
-          case 2:
+        case 2:
             x86emu_fpu_R_fst(stkelem);  /* register version */
             break;
-          case 3:
+        case 3:
             x86emu_fpu_R_fstp(stkelem); /* register version */
             break;
-          default:
+        default:
             x86emu_fpu_illegal();
             break;
         }
         break;
-      default:
+    default:
         switch (rh) {
-          case 0:
+        case 0:
             x86emu_fpu_M_fld(X86EMU_FPU_DOUBLE, destoffset);
             break;
-          case 1:
+        case 1:
             x86emu_fpu_illegal();
             break;
-          case 2:
+        case 2:
             x86emu_fpu_M_fst(X86EMU_FPU_DOUBLE, destoffset);
             break;
-          case 3:
+        case 3:
             x86emu_fpu_M_fstp(X86EMU_FPU_DOUBLE, destoffset);
             break;
-          case 4:
+        case 4:
             x86emu_fpu_M_frstor(X86EMU_FPU_WORD, destoffset);
             break;
-          case 5:
+        case 5:
             x86emu_fpu_illegal();
             break;
-          case 6:
+        case 6:
             x86emu_fpu_M_fsave(X86EMU_FPU_WORD, destoffset);
             break;
-          case 7:
+        case 7:
             x86emu_fpu_M_fstsw(X86EMU_FPU_WORD, destoffset);
             break;
         }
     }
 #else
-    (void)destoffset;
-    (void)stkelem;
+    (void) destoffset;
+    (void) stkelem;
 #endif
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR_NO_TRACE();
@@ -734,8 +744,7 @@ void x86emuOp_esc_coprocess_dd(u8 X86EMU_UNUSED(op1))
 
 #ifdef DEBUG
 
-static char *x86emu_fpu_op_de_tab[] =
-{
+static const char *x86emu_fpu_op_de_tab[] = {
     "FIADD\tWORD PTR ", "FIMUL\tWORD PTR ", "FICOM\tWORD PTR ",
     "FICOMP\tWORD PTR ",
     "FISUB\tWORD PTR ", "FISUBR\tWORD PTR ", "FIDIV\tWORD PTR ",
@@ -755,10 +764,11 @@ static char *x86emu_fpu_op_de_tab[] =
     "FSUBRP\t", "FSUBP\t", "FDIVRP\t", "FDIVP\t",
 };
 
-#endif /* DEBUG */
+#endif                          /* DEBUG */
 
 /* opcode=0xde */
-void x86emuOp_esc_coprocess_de(u8 X86EMU_UNUSED(op1))
+void
+x86emuOp_esc_coprocess_de(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     uint destoffset = 0;
@@ -768,87 +778,87 @@ void x86emuOp_esc_coprocess_de(u8 X86EMU_UNUSED(op1))
     FETCH_DECODE_MODRM(mod, rh, rl);
     DECODE_PRINTINSTR32(x86emu_fpu_op_de_tab, mod, rh, rl);
     switch (mod) {
-      case 0:
+    case 0:
         destoffset = decode_rm00_address(rl);
         DECODE_PRINTF("\n");
         break;
-      case 1:
+    case 1:
         destoffset = decode_rm01_address(rl);
         DECODE_PRINTF("\n");
         break;
-      case 2:
+    case 2:
         destoffset = decode_rm10_address(rl);
         DECODE_PRINTF("\n");
         break;
-      case 3:                   /* register to register */
-		stkelem = (u8)rl;
+    case 3:                    /* register to register */
+        stkelem = (u8) rl;
         DECODE_PRINTF2("\tST(%d),ST\n", stkelem);
         break;
     }
 #ifdef X86EMU_FPU_PRESENT
     switch (mod) {
-      case 3:
+    case 3:
         switch (rh) {
-          case 0:
+        case 0:
             x86emu_fpu_R_faddp(stkelem, X86EMU_FPU_STKTOP);
             break;
-          case 1:
+        case 1:
             x86emu_fpu_R_fmulp(stkelem, X86EMU_FPU_STKTOP);
             break;
-          case 2:
+        case 2:
             x86emu_fpu_R_fcomp(stkelem, X86EMU_FPU_STKTOP);
             break;
-          case 3:
+        case 3:
             if (stkelem == 1)
-              x86emu_fpu_R_fcompp(stkelem, X86EMU_FPU_STKTOP);
+                x86emu_fpu_R_fcompp(stkelem, X86EMU_FPU_STKTOP);
             else
-              x86emu_fpu_illegal();
+                x86emu_fpu_illegal();
             break;
-          case 4:
+        case 4:
             x86emu_fpu_R_fsubrp(stkelem, X86EMU_FPU_STKTOP);
             break;
-          case 5:
+        case 5:
             x86emu_fpu_R_fsubp(stkelem, X86EMU_FPU_STKTOP);
             break;
-          case 6:
+        case 6:
             x86emu_fpu_R_fdivrp(stkelem, X86EMU_FPU_STKTOP);
             break;
-          case 7:
+        case 7:
             x86emu_fpu_R_fdivp(stkelem, X86EMU_FPU_STKTOP);
             break;
         }
         break;
-      default:
+    default:
         switch (rh) {
-          case 0:
+        case 0:
             x86emu_fpu_M_fiadd(X86EMU_FPU_WORD, destoffset);
             break;
-          case 1:
+        case 1:
             x86emu_fpu_M_fimul(X86EMU_FPU_WORD, destoffset);
             break;
-          case 2:
+        case 2:
             x86emu_fpu_M_ficom(X86EMU_FPU_WORD, destoffset);
             break;
-          case 3:
+        case 3:
             x86emu_fpu_M_ficomp(X86EMU_FPU_WORD, destoffset);
             break;
-          case 4:
+        case 4:
             x86emu_fpu_M_fisub(X86EMU_FPU_WORD, destoffset);
             break;
-          case 5:
+        case 5:
             x86emu_fpu_M_fisubr(X86EMU_FPU_WORD, destoffset);
             break;
-          case 6:
+        case 6:
             x86emu_fpu_M_fidiv(X86EMU_FPU_WORD, destoffset);
             break;
-          case 7:
+        case 7:
             x86emu_fpu_M_fidivr(X86EMU_FPU_WORD, destoffset);
             break;
         }
     }
 #else
-    (void)destoffset;
-    (void)stkelem;
+    (void) destoffset;
+    (void) stkelem;
 #endif
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR_NO_TRACE();
@@ -856,7 +866,7 @@ void x86emuOp_esc_coprocess_de(u8 X86EMU_UNUSED(op1))
 
 #ifdef DEBUG
 
-static char *x86emu_fpu_op_df_tab[] = {
+static const char *x86emu_fpu_op_df_tab[] = {
     /* mod == 00 */
     "FILD\tWORD PTR ", "ESC_DF\t39\n", "FIST\tWORD PTR ", "FISTP\tWORD PTR ",
     "FBLD\tTBYTE PTR ", "FILD\tQWORD PTR ", "FBSTP\tTBYTE PTR ",
@@ -877,10 +887,11 @@ static char *x86emu_fpu_op_df_tab[] = {
     "ESC_DF\t3C,", "ESC_DF\t3D,", "ESC_DF\t3E,", "ESC_DF\t3F,"
 };
 
-#endif /* DEBUG */
+#endif                          /* DEBUG */
 
 /* opcode=0xdf */
-void x86emuOp_esc_coprocess_df(u8 X86EMU_UNUSED(op1))
+void
+x86emuOp_esc_coprocess_df(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     uint destoffset = 0;
@@ -890,75 +901,75 @@ void x86emuOp_esc_coprocess_df(u8 X86EMU_UNUSED(op1))
     FETCH_DECODE_MODRM(mod, rh, rl);
     DECODE_PRINTINSTR32(x86emu_fpu_op_df_tab, mod, rh, rl);
     switch (mod) {
-      case 0:
+    case 0:
         destoffset = decode_rm00_address(rl);
         DECODE_PRINTF("\n");
         break;
-      case 1:
+    case 1:
         destoffset = decode_rm01_address(rl);
         DECODE_PRINTF("\n");
         break;
-      case 2:
+    case 2:
         destoffset = decode_rm10_address(rl);
         DECODE_PRINTF("\n");
         break;
-      case 3:                   /* register to register */
-		stkelem = (u8)rl;
+    case 3:                    /* register to register */
+        stkelem = (u8) rl;
         DECODE_PRINTF2("\tST(%d)\n", stkelem);
         break;
     }
 #ifdef X86EMU_FPU_PRESENT
     switch (mod) {
-      case 3:
+    case 3:
         switch (rh) {
-          case 0:
+        case 0:
             x86emu_fpu_R_ffree(stkelem);
             break;
-          case 1:
+        case 1:
             x86emu_fpu_R_fxch(stkelem);
             break;
-          case 2:
+        case 2:
             x86emu_fpu_R_fst(stkelem);  /* register version */
             break;
-          case 3:
+        case 3:
             x86emu_fpu_R_fstp(stkelem); /* register version */
             break;
-          default:
+        default:
             x86emu_fpu_illegal();
             break;
         }
         break;
-      default:
+    default:
         switch (rh) {
-          case 0:
+        case 0:
             x86emu_fpu_M_fild(X86EMU_FPU_WORD, destoffset);
             break;
-          case 1:
+        case 1:
             x86emu_fpu_illegal();
             break;
-          case 2:
+        case 2:
             x86emu_fpu_M_fist(X86EMU_FPU_WORD, destoffset);
             break;
-          case 3:
+        case 3:
             x86emu_fpu_M_fistp(X86EMU_FPU_WORD, destoffset);
             break;
-          case 4:
+        case 4:
             x86emu_fpu_M_fbld(X86EMU_FPU_BSD, destoffset);
             break;
-          case 5:
+        case 5:
             x86emu_fpu_M_fild(X86EMU_FPU_LONG, destoffset);
             break;
-          case 6:
+        case 6:
             x86emu_fpu_M_fbstp(X86EMU_FPU_BSD, destoffset);
             break;
-          case 7:
+        case 7:
             x86emu_fpu_M_fistp(X86EMU_FPU_LONG, destoffset);
             break;
         }
     }
 #else
-    (void)destoffset;
-    (void)stkelem;
+    (void) destoffset;
+    (void) stkelem;
 #endif
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR_NO_TRACE();
diff --git a/libs/x86emu/ops.c b/libs/x86emu/ops.c
index 4f504c9..76b8358 100644
--- a/libs/x86emu/ops.c
+++ b/libs/x86emu/ops.c
@@ -81,17 +81,17 @@ op1 - Instruction op code
 REMARKS:
 Handles illegal opcodes.
 ****************************************************************************/
-static void x86emuOp_illegal_op(
-    u8 op1)
+static void
+x86emuOp_illegal_op(u8 op1)
 {
     START_OF_INSTR();
     if (M.x86.R_SP != 0) {
-    DECODE_PRINTF("ILLEGAL X86 OPCODE\n");
-    TRACE_REGS();
-    printk("%04x:%04x: %02X ILLEGAL X86 OPCODE!\n",
-        M.x86.R_CS, M.x86.R_IP-1,op1);
-    HALT_SYS();
-        }
+        DECODE_PRINTF("ILLEGAL X86 OPCODE\n");
+        TRACE_REGS();
+        DB(printk("%04x:%04x: %02X ILLEGAL X86 OPCODE!\n",
+                  M.x86.R_CS, M.x86.R_IP - 1, op1));
+        HALT_SYS();
+    }
     else {
         /* If we get here, it means the stack pointer is back to zero
          * so we are just returning from an emulator service call
@@ -100,7 +100,7 @@ static void x86emuOp_illegal_op(
          * call.
          */
         X86EMU_halt_sys();
-        }
+    }
     END_OF_INSTR();
 }
 
@@ -108,7 +108,8 @@ static void x86emuOp_illegal_op(
 REMARKS:
 Handles opcode 0x00
 ****************************************************************************/
-static void x86emuOp_add_byte_RM_R(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_add_byte_RM_R(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     uint destoffset;
@@ -149,7 +150,7 @@ static void x86emuOp_add_byte_RM_R(u8 X86EMU_UNUSED(op1))
         destval = add_byte(destval, *srcreg);
         store_data_byte(destoffset, destval);
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         destreg = DECODE_RM_BYTE_REGISTER(rl);
         DECODE_PRINTF(",");
         srcreg = DECODE_RM_BYTE_REGISTER(rh);
@@ -166,7 +167,8 @@ static void x86emuOp_add_byte_RM_R(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x01
 ****************************************************************************/
-static void x86emuOp_add_word_RM_R(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_add_word_RM_R(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     uint destoffset;
@@ -188,7 +190,8 @@ static void x86emuOp_add_word_RM_R(u8 X86EMU_UNUSED(op1))
             TRACE_AND_STEP();
             destval = add_long(destval, *srcreg);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
             u16 *srcreg;
 
@@ -215,7 +218,8 @@ static void x86emuOp_add_word_RM_R(u8 X86EMU_UNUSED(op1))
             TRACE_AND_STEP();
             destval = add_long(destval, *srcreg);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
             u16 *srcreg;
 
@@ -242,7 +246,8 @@ static void x86emuOp_add_word_RM_R(u8 X86EMU_UNUSED(op1))
             TRACE_AND_STEP();
             destval = add_long(destval, *srcreg);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
             u16 *srcreg;
 
@@ -256,9 +261,9 @@ static void x86emuOp_add_word_RM_R(u8 X86EMU_UNUSED(op1))
             store_data_word(destoffset, destval);
         }
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-            u32 *destreg,*srcreg;
+            u32 *destreg, *srcreg;
 
             destreg = DECODE_RM_LONG_REGISTER(rl);
             DECODE_PRINTF(",");
@@ -266,8 +271,9 @@ static void x86emuOp_add_word_RM_R(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = add_long(*destreg, *srcreg);
-        } else {
-            u16 *destreg,*srcreg;
+        }
+        else {
+            u16 *destreg, *srcreg;
 
             destreg = DECODE_RM_WORD_REGISTER(rl);
             DECODE_PRINTF(",");
@@ -286,7 +292,8 @@ static void x86emuOp_add_word_RM_R(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x02
 ****************************************************************************/
-static void x86emuOp_add_byte_R_RM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_add_byte_R_RM(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     u8 *destreg, *srcreg;
@@ -324,7 +331,7 @@ static void x86emuOp_add_byte_R_RM(u8 X86EMU_UNUSED(op1))
         TRACE_AND_STEP();
         *destreg = add_byte(*destreg, srcval);
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         destreg = DECODE_RM_BYTE_REGISTER(rh);
         DECODE_PRINTF(",");
         srcreg = DECODE_RM_BYTE_REGISTER(rl);
@@ -341,7 +348,8 @@ static void x86emuOp_add_byte_R_RM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x03
 ****************************************************************************/
-static void x86emuOp_add_word_R_RM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_add_word_R_RM(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     uint srcoffset;
@@ -362,7 +370,8 @@ static void x86emuOp_add_word_R_RM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = add_long(*destreg, srcval);
-        } else {
+        }
+        else {
             u16 *destreg;
             u16 srcval;
 
@@ -387,7 +396,8 @@ static void x86emuOp_add_word_R_RM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = add_long(*destreg, srcval);
-        } else {
+        }
+        else {
             u16 *destreg;
             u16 srcval;
 
@@ -412,7 +422,8 @@ static void x86emuOp_add_word_R_RM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = add_long(*destreg, srcval);
-        } else {
+        }
+        else {
             u16 *destreg;
             u16 srcval;
 
@@ -425,9 +436,9 @@ static void x86emuOp_add_word_R_RM(u8 X86EMU_UNUSED(op1))
             *destreg = add_word(*destreg, srcval);
         }
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-            u32 *destreg,*srcreg;
+            u32 *destreg, *srcreg;
 
             destreg = DECODE_RM_LONG_REGISTER(rh);
             DECODE_PRINTF(",");
@@ -435,8 +446,9 @@ static void x86emuOp_add_word_R_RM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = add_long(*destreg, *srcreg);
-        } else {
-            u16 *destreg,*srcreg;
+        }
+        else {
+            u16 *destreg, *srcreg;
 
             destreg = DECODE_RM_WORD_REGISTER(rh);
             DECODE_PRINTF(",");
@@ -455,7 +467,8 @@ static void x86emuOp_add_word_R_RM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x04
 ****************************************************************************/
-static void x86emuOp_add_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_add_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
 {
     u8 srcval;
 
@@ -473,7 +486,8 @@ static void x86emuOp_add_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x05
 ****************************************************************************/
-static void x86emuOp_add_word_AX_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_add_word_AX_IMM(u8 X86EMU_UNUSED(op1))
 {
     u32 srcval;
 
@@ -481,7 +495,8 @@ static void x86emuOp_add_word_AX_IMM(u8 X86EMU_UNUSED(op1))
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("ADD\tEAX,");
         srcval = fetch_long_imm();
-    } else {
+    }
+    else {
         DECODE_PRINTF("ADD\tAX,");
         srcval = fetch_word_imm();
     }
@@ -489,8 +504,9 @@ static void x86emuOp_add_word_AX_IMM(u8 X86EMU_UNUSED(op1))
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_EAX = add_long(M.x86.R_EAX, srcval);
-    } else {
-        M.x86.R_AX = add_word(M.x86.R_AX, (u16)srcval);
+    }
+    else {
+        M.x86.R_AX = add_word(M.x86.R_AX, (u16) srcval);
     }
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
@@ -500,7 +516,8 @@ static void x86emuOp_add_word_AX_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x06
 ****************************************************************************/
-static void x86emuOp_push_ES(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_push_ES(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     DECODE_PRINTF("PUSH\tES\n");
@@ -514,7 +531,8 @@ static void x86emuOp_push_ES(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x07
 ****************************************************************************/
-static void x86emuOp_pop_ES(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_pop_ES(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     DECODE_PRINTF("POP\tES\n");
@@ -528,7 +546,8 @@ static void x86emuOp_pop_ES(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x08
 ****************************************************************************/
-static void x86emuOp_or_byte_RM_R(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_or_byte_RM_R(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     u8 *destreg, *srcreg;
@@ -569,7 +588,7 @@ static void x86emuOp_or_byte_RM_R(u8 X86EMU_UNUSED(op1))
         destval = or_byte(destval, *srcreg);
         store_data_byte(destoffset, destval);
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         destreg = DECODE_RM_BYTE_REGISTER(rl);
         DECODE_PRINTF(",");
         srcreg = DECODE_RM_BYTE_REGISTER(rh);
@@ -586,7 +605,8 @@ static void x86emuOp_or_byte_RM_R(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x09
 ****************************************************************************/
-static void x86emuOp_or_word_RM_R(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_or_word_RM_R(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     uint destoffset;
@@ -608,7 +628,8 @@ static void x86emuOp_or_word_RM_R(u8 X86EMU_UNUSED(op1))
             TRACE_AND_STEP();
             destval = or_long(destval, *srcreg);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
             u16 *srcreg;
 
@@ -635,7 +656,8 @@ static void x86emuOp_or_word_RM_R(u8 X86EMU_UNUSED(op1))
             TRACE_AND_STEP();
             destval = or_long(destval, *srcreg);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
             u16 *srcreg;
 
@@ -662,7 +684,8 @@ static void x86emuOp_or_word_RM_R(u8 X86EMU_UNUSED(op1))
             TRACE_AND_STEP();
             destval = or_long(destval, *srcreg);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
             u16 *srcreg;
 
@@ -676,9 +699,9 @@ static void x86emuOp_or_word_RM_R(u8 X86EMU_UNUSED(op1))
             store_data_word(destoffset, destval);
         }
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-            u32 *destreg,*srcreg;
+            u32 *destreg, *srcreg;
 
             destreg = DECODE_RM_LONG_REGISTER(rl);
             DECODE_PRINTF(",");
@@ -686,8 +709,9 @@ static void x86emuOp_or_word_RM_R(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = or_long(*destreg, *srcreg);
-        } else {
-            u16 *destreg,*srcreg;
+        }
+        else {
+            u16 *destreg, *srcreg;
 
             destreg = DECODE_RM_WORD_REGISTER(rl);
             DECODE_PRINTF(",");
@@ -706,7 +730,8 @@ static void x86emuOp_or_word_RM_R(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x0a
 ****************************************************************************/
-static void x86emuOp_or_byte_R_RM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_or_byte_R_RM(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     u8 *destreg, *srcreg;
@@ -744,7 +769,7 @@ static void x86emuOp_or_byte_R_RM(u8 X86EMU_UNUSED(op1))
         TRACE_AND_STEP();
         *destreg = or_byte(*destreg, srcval);
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         destreg = DECODE_RM_BYTE_REGISTER(rh);
         DECODE_PRINTF(",");
         srcreg = DECODE_RM_BYTE_REGISTER(rl);
@@ -761,7 +786,8 @@ static void x86emuOp_or_byte_R_RM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x0b
 ****************************************************************************/
-static void x86emuOp_or_word_R_RM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_or_word_R_RM(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     uint srcoffset;
@@ -782,7 +808,8 @@ static void x86emuOp_or_word_R_RM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = or_long(*destreg, srcval);
-        } else {
+        }
+        else {
             u16 *destreg;
             u16 srcval;
 
@@ -807,7 +834,8 @@ static void x86emuOp_or_word_R_RM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = or_long(*destreg, srcval);
-        } else {
+        }
+        else {
             u16 *destreg;
             u16 srcval;
 
@@ -832,7 +860,8 @@ static void x86emuOp_or_word_R_RM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = or_long(*destreg, srcval);
-        } else {
+        }
+        else {
             u16 *destreg;
             u16 srcval;
 
@@ -845,9 +874,9 @@ static void x86emuOp_or_word_R_RM(u8 X86EMU_UNUSED(op1))
             *destreg = or_word(*destreg, srcval);
         }
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-            u32 *destreg,*srcreg;
+            u32 *destreg, *srcreg;
 
             destreg = DECODE_RM_LONG_REGISTER(rh);
             DECODE_PRINTF(",");
@@ -855,8 +884,9 @@ static void x86emuOp_or_word_R_RM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = or_long(*destreg, *srcreg);
-        } else {
-            u16 *destreg,*srcreg;
+        }
+        else {
+            u16 *destreg, *srcreg;
 
             destreg = DECODE_RM_WORD_REGISTER(rh);
             DECODE_PRINTF(",");
@@ -875,7 +905,8 @@ static void x86emuOp_or_word_R_RM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x0c
 ****************************************************************************/
-static void x86emuOp_or_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_or_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
 {
     u8 srcval;
 
@@ -893,7 +924,8 @@ static void x86emuOp_or_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x0d
 ****************************************************************************/
-static void x86emuOp_or_word_AX_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_or_word_AX_IMM(u8 X86EMU_UNUSED(op1))
 {
     u32 srcval;
 
@@ -901,7 +933,8 @@ static void x86emuOp_or_word_AX_IMM(u8 X86EMU_UNUSED(op1))
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("OR\tEAX,");
         srcval = fetch_long_imm();
-    } else {
+    }
+    else {
         DECODE_PRINTF("OR\tAX,");
         srcval = fetch_word_imm();
     }
@@ -909,8 +942,9 @@ static void x86emuOp_or_word_AX_IMM(u8 X86EMU_UNUSED(op1))
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_EAX = or_long(M.x86.R_EAX, srcval);
-    } else {
-        M.x86.R_AX = or_word(M.x86.R_AX, (u16)srcval);
+    }
+    else {
+        M.x86.R_AX = or_word(M.x86.R_AX, (u16) srcval);
     }
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
@@ -920,7 +954,8 @@ static void x86emuOp_or_word_AX_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x0e
 ****************************************************************************/
-static void x86emuOp_push_CS(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_push_CS(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     DECODE_PRINTF("PUSH\tCS\n");
@@ -934,18 +969,21 @@ static void x86emuOp_push_CS(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x0f. Escape for two-byte opcode (286 or better)
 ****************************************************************************/
-static void x86emuOp_two_byte(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_two_byte(u8 X86EMU_UNUSED(op1))
 {
-    u8 op2 = (*sys_rdb)(((u32)M.x86.R_CS << 4) + (M.x86.R_IP++));
+    u8 op2 = (*sys_rdb) (((u32) M.x86.R_CS << 4) + (M.x86.R_IP++));
+
     INC_DECODED_INST_LEN(1);
-    (*x86emu_optab2[op2])(op2);
+    (*x86emu_optab2[op2]) (op2);
 }
 
 /****************************************************************************
 REMARKS:
 Handles opcode 0x10
 ****************************************************************************/
-static void x86emuOp_adc_byte_RM_R(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_adc_byte_RM_R(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     u8 *destreg, *srcreg;
@@ -986,7 +1024,7 @@ static void x86emuOp_adc_byte_RM_R(u8 X86EMU_UNUSED(op1))
         destval = adc_byte(destval, *srcreg);
         store_data_byte(destoffset, destval);
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         destreg = DECODE_RM_BYTE_REGISTER(rl);
         DECODE_PRINTF(",");
         srcreg = DECODE_RM_BYTE_REGISTER(rh);
@@ -1003,7 +1041,8 @@ static void x86emuOp_adc_byte_RM_R(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x11
 ****************************************************************************/
-static void x86emuOp_adc_word_RM_R(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_adc_word_RM_R(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     uint destoffset;
@@ -1025,7 +1064,8 @@ static void x86emuOp_adc_word_RM_R(u8 X86EMU_UNUSED(op1))
             TRACE_AND_STEP();
             destval = adc_long(destval, *srcreg);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
             u16 *srcreg;
 
@@ -1052,7 +1092,8 @@ static void x86emuOp_adc_word_RM_R(u8 X86EMU_UNUSED(op1))
             TRACE_AND_STEP();
             destval = adc_long(destval, *srcreg);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
             u16 *srcreg;
 
@@ -1079,7 +1120,8 @@ static void x86emuOp_adc_word_RM_R(u8 X86EMU_UNUSED(op1))
             TRACE_AND_STEP();
             destval = adc_long(destval, *srcreg);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
             u16 *srcreg;
 
@@ -1093,9 +1135,9 @@ static void x86emuOp_adc_word_RM_R(u8 X86EMU_UNUSED(op1))
             store_data_word(destoffset, destval);
         }
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-            u32 *destreg,*srcreg;
+            u32 *destreg, *srcreg;
 
             destreg = DECODE_RM_LONG_REGISTER(rl);
             DECODE_PRINTF(",");
@@ -1103,8 +1145,9 @@ static void x86emuOp_adc_word_RM_R(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = adc_long(*destreg, *srcreg);
-        } else {
-            u16 *destreg,*srcreg;
+        }
+        else {
+            u16 *destreg, *srcreg;
 
             destreg = DECODE_RM_WORD_REGISTER(rl);
             DECODE_PRINTF(",");
@@ -1123,7 +1166,8 @@ static void x86emuOp_adc_word_RM_R(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x12
 ****************************************************************************/
-static void x86emuOp_adc_byte_R_RM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_adc_byte_R_RM(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     u8 *destreg, *srcreg;
@@ -1161,7 +1205,7 @@ static void x86emuOp_adc_byte_R_RM(u8 X86EMU_UNUSED(op1))
         TRACE_AND_STEP();
         *destreg = adc_byte(*destreg, srcval);
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         destreg = DECODE_RM_BYTE_REGISTER(rh);
         DECODE_PRINTF(",");
         srcreg = DECODE_RM_BYTE_REGISTER(rl);
@@ -1178,7 +1222,8 @@ static void x86emuOp_adc_byte_R_RM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x13
 ****************************************************************************/
-static void x86emuOp_adc_word_R_RM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_adc_word_R_RM(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     uint srcoffset;
@@ -1199,7 +1244,8 @@ static void x86emuOp_adc_word_R_RM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = adc_long(*destreg, srcval);
-        } else {
+        }
+        else {
             u16 *destreg;
             u16 srcval;
 
@@ -1224,7 +1270,8 @@ static void x86emuOp_adc_word_R_RM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = adc_long(*destreg, srcval);
-        } else {
+        }
+        else {
             u16 *destreg;
             u16 srcval;
 
@@ -1249,7 +1296,8 @@ static void x86emuOp_adc_word_R_RM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = adc_long(*destreg, srcval);
-        } else {
+        }
+        else {
             u16 *destreg;
             u16 srcval;
 
@@ -1262,9 +1310,9 @@ static void x86emuOp_adc_word_R_RM(u8 X86EMU_UNUSED(op1))
             *destreg = adc_word(*destreg, srcval);
         }
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-            u32 *destreg,*srcreg;
+            u32 *destreg, *srcreg;
 
             destreg = DECODE_RM_LONG_REGISTER(rh);
             DECODE_PRINTF(",");
@@ -1272,8 +1320,9 @@ static void x86emuOp_adc_word_R_RM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = adc_long(*destreg, *srcreg);
-        } else {
-            u16 *destreg,*srcreg;
+        }
+        else {
+            u16 *destreg, *srcreg;
 
             destreg = DECODE_RM_WORD_REGISTER(rh);
             DECODE_PRINTF(",");
@@ -1292,7 +1341,8 @@ static void x86emuOp_adc_word_R_RM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x14
 ****************************************************************************/
-static void x86emuOp_adc_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_adc_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
 {
     u8 srcval;
 
@@ -1310,7 +1360,8 @@ static void x86emuOp_adc_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x15
 ****************************************************************************/
-static void x86emuOp_adc_word_AX_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_adc_word_AX_IMM(u8 X86EMU_UNUSED(op1))
 {
     u32 srcval;
 
@@ -1318,7 +1369,8 @@ static void x86emuOp_adc_word_AX_IMM(u8 X86EMU_UNUSED(op1))
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("ADC\tEAX,");
         srcval = fetch_long_imm();
-    } else {
+    }
+    else {
         DECODE_PRINTF("ADC\tAX,");
         srcval = fetch_word_imm();
     }
@@ -1326,8 +1378,9 @@ static void x86emuOp_adc_word_AX_IMM(u8 X86EMU_UNUSED(op1))
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_EAX = adc_long(M.x86.R_EAX, srcval);
-    } else {
-        M.x86.R_AX = adc_word(M.x86.R_AX, (u16)srcval);
+    }
+    else {
+        M.x86.R_AX = adc_word(M.x86.R_AX, (u16) srcval);
     }
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
@@ -1337,7 +1390,8 @@ static void x86emuOp_adc_word_AX_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x16
 ****************************************************************************/
-static void x86emuOp_push_SS(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_push_SS(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     DECODE_PRINTF("PUSH\tSS\n");
@@ -1351,7 +1405,8 @@ static void x86emuOp_push_SS(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x17
 ****************************************************************************/
-static void x86emuOp_pop_SS(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_pop_SS(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     DECODE_PRINTF("POP\tSS\n");
@@ -1365,7 +1420,8 @@ static void x86emuOp_pop_SS(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x18
 ****************************************************************************/
-static void x86emuOp_sbb_byte_RM_R(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_sbb_byte_RM_R(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     u8 *destreg, *srcreg;
@@ -1406,7 +1462,7 @@ static void x86emuOp_sbb_byte_RM_R(u8 X86EMU_UNUSED(op1))
         destval = sbb_byte(destval, *srcreg);
         store_data_byte(destoffset, destval);
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         destreg = DECODE_RM_BYTE_REGISTER(rl);
         DECODE_PRINTF(",");
         srcreg = DECODE_RM_BYTE_REGISTER(rh);
@@ -1423,7 +1479,8 @@ static void x86emuOp_sbb_byte_RM_R(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x19
 ****************************************************************************/
-static void x86emuOp_sbb_word_RM_R(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_sbb_word_RM_R(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     uint destoffset;
@@ -1445,7 +1502,8 @@ static void x86emuOp_sbb_word_RM_R(u8 X86EMU_UNUSED(op1))
             TRACE_AND_STEP();
             destval = sbb_long(destval, *srcreg);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
             u16 *srcreg;
 
@@ -1472,7 +1530,8 @@ static void x86emuOp_sbb_word_RM_R(u8 X86EMU_UNUSED(op1))
             TRACE_AND_STEP();
             destval = sbb_long(destval, *srcreg);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
             u16 *srcreg;
 
@@ -1499,7 +1558,8 @@ static void x86emuOp_sbb_word_RM_R(u8 X86EMU_UNUSED(op1))
             TRACE_AND_STEP();
             destval = sbb_long(destval, *srcreg);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
             u16 *srcreg;
 
@@ -1513,9 +1573,9 @@ static void x86emuOp_sbb_word_RM_R(u8 X86EMU_UNUSED(op1))
             store_data_word(destoffset, destval);
         }
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-            u32 *destreg,*srcreg;
+            u32 *destreg, *srcreg;
 
             destreg = DECODE_RM_LONG_REGISTER(rl);
             DECODE_PRINTF(",");
@@ -1523,8 +1583,9 @@ static void x86emuOp_sbb_word_RM_R(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = sbb_long(*destreg, *srcreg);
-        } else {
-            u16 *destreg,*srcreg;
+        }
+        else {
+            u16 *destreg, *srcreg;
 
             destreg = DECODE_RM_WORD_REGISTER(rl);
             DECODE_PRINTF(",");
@@ -1543,7 +1604,8 @@ static void x86emuOp_sbb_word_RM_R(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x1a
 ****************************************************************************/
-static void x86emuOp_sbb_byte_R_RM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_sbb_byte_R_RM(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     u8 *destreg, *srcreg;
@@ -1581,7 +1643,7 @@ static void x86emuOp_sbb_byte_R_RM(u8 X86EMU_UNUSED(op1))
         TRACE_AND_STEP();
         *destreg = sbb_byte(*destreg, srcval);
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         destreg = DECODE_RM_BYTE_REGISTER(rh);
         DECODE_PRINTF(",");
         srcreg = DECODE_RM_BYTE_REGISTER(rl);
@@ -1598,7 +1660,8 @@ static void x86emuOp_sbb_byte_R_RM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x1b
 ****************************************************************************/
-static void x86emuOp_sbb_word_R_RM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_sbb_word_R_RM(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     uint srcoffset;
@@ -1619,7 +1682,8 @@ static void x86emuOp_sbb_word_R_RM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = sbb_long(*destreg, srcval);
-        } else {
+        }
+        else {
             u16 *destreg;
             u16 srcval;
 
@@ -1644,7 +1708,8 @@ static void x86emuOp_sbb_word_R_RM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = sbb_long(*destreg, srcval);
-        } else {
+        }
+        else {
             u16 *destreg;
             u16 srcval;
 
@@ -1669,7 +1734,8 @@ static void x86emuOp_sbb_word_R_RM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = sbb_long(*destreg, srcval);
-        } else {
+        }
+        else {
             u16 *destreg;
             u16 srcval;
 
@@ -1682,9 +1748,9 @@ static void x86emuOp_sbb_word_R_RM(u8 X86EMU_UNUSED(op1))
             *destreg = sbb_word(*destreg, srcval);
         }
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-            u32 *destreg,*srcreg;
+            u32 *destreg, *srcreg;
 
             destreg = DECODE_RM_LONG_REGISTER(rh);
             DECODE_PRINTF(",");
@@ -1692,8 +1758,9 @@ static void x86emuOp_sbb_word_R_RM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = sbb_long(*destreg, *srcreg);
-        } else {
-            u16 *destreg,*srcreg;
+        }
+        else {
+            u16 *destreg, *srcreg;
 
             destreg = DECODE_RM_WORD_REGISTER(rh);
             DECODE_PRINTF(",");
@@ -1712,7 +1779,8 @@ static void x86emuOp_sbb_word_R_RM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x1c
 ****************************************************************************/
-static void x86emuOp_sbb_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_sbb_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
 {
     u8 srcval;
 
@@ -1730,7 +1798,8 @@ static void x86emuOp_sbb_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x1d
 ****************************************************************************/
-static void x86emuOp_sbb_word_AX_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_sbb_word_AX_IMM(u8 X86EMU_UNUSED(op1))
 {
     u32 srcval;
 
@@ -1738,7 +1807,8 @@ static void x86emuOp_sbb_word_AX_IMM(u8 X86EMU_UNUSED(op1))
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("SBB\tEAX,");
         srcval = fetch_long_imm();
-    } else {
+    }
+    else {
         DECODE_PRINTF("SBB\tAX,");
         srcval = fetch_word_imm();
     }
@@ -1746,8 +1816,9 @@ static void x86emuOp_sbb_word_AX_IMM(u8 X86EMU_UNUSED(op1))
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_EAX = sbb_long(M.x86.R_EAX, srcval);
-    } else {
-        M.x86.R_AX = sbb_word(M.x86.R_AX, (u16)srcval);
+    }
+    else {
+        M.x86.R_AX = sbb_word(M.x86.R_AX, (u16) srcval);
     }
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
@@ -1757,7 +1828,8 @@ static void x86emuOp_sbb_word_AX_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x1e
 ****************************************************************************/
-static void x86emuOp_push_DS(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_push_DS(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     DECODE_PRINTF("PUSH\tDS\n");
@@ -1771,7 +1843,8 @@ static void x86emuOp_push_DS(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x1f
 ****************************************************************************/
-static void x86emuOp_pop_DS(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_pop_DS(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     DECODE_PRINTF("POP\tDS\n");
@@ -1785,7 +1858,8 @@ static void x86emuOp_pop_DS(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x20
 ****************************************************************************/
-static void x86emuOp_and_byte_RM_R(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_and_byte_RM_R(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     u8 *destreg, *srcreg;
@@ -1830,7 +1904,7 @@ static void x86emuOp_and_byte_RM_R(u8 X86EMU_UNUSED(op1))
         store_data_byte(destoffset, destval);
         break;
 
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         destreg = DECODE_RM_BYTE_REGISTER(rl);
         DECODE_PRINTF(",");
         srcreg = DECODE_RM_BYTE_REGISTER(rh);
@@ -1847,7 +1921,8 @@ static void x86emuOp_and_byte_RM_R(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x21
 ****************************************************************************/
-static void x86emuOp_and_word_RM_R(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_and_word_RM_R(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     uint destoffset;
@@ -1869,7 +1944,8 @@ static void x86emuOp_and_word_RM_R(u8 X86EMU_UNUSED(op1))
             TRACE_AND_STEP();
             destval = and_long(destval, *srcreg);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
             u16 *srcreg;
 
@@ -1896,7 +1972,8 @@ static void x86emuOp_and_word_RM_R(u8 X86EMU_UNUSED(op1))
             TRACE_AND_STEP();
             destval = and_long(destval, *srcreg);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
             u16 *srcreg;
 
@@ -1923,7 +2000,8 @@ static void x86emuOp_and_word_RM_R(u8 X86EMU_UNUSED(op1))
             TRACE_AND_STEP();
             destval = and_long(destval, *srcreg);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
             u16 *srcreg;
 
@@ -1937,9 +2015,9 @@ static void x86emuOp_and_word_RM_R(u8 X86EMU_UNUSED(op1))
             store_data_word(destoffset, destval);
         }
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-            u32 *destreg,*srcreg;
+            u32 *destreg, *srcreg;
 
             destreg = DECODE_RM_LONG_REGISTER(rl);
             DECODE_PRINTF(",");
@@ -1947,8 +2025,9 @@ static void x86emuOp_and_word_RM_R(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = and_long(*destreg, *srcreg);
-        } else {
-            u16 *destreg,*srcreg;
+        }
+        else {
+            u16 *destreg, *srcreg;
 
             destreg = DECODE_RM_WORD_REGISTER(rl);
             DECODE_PRINTF(",");
@@ -1967,7 +2046,8 @@ static void x86emuOp_and_word_RM_R(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x22
 ****************************************************************************/
-static void x86emuOp_and_byte_R_RM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_and_byte_R_RM(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     u8 *destreg, *srcreg;
@@ -2005,7 +2085,7 @@ static void x86emuOp_and_byte_R_RM(u8 X86EMU_UNUSED(op1))
         TRACE_AND_STEP();
         *destreg = and_byte(*destreg, srcval);
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         destreg = DECODE_RM_BYTE_REGISTER(rh);
         DECODE_PRINTF(",");
         srcreg = DECODE_RM_BYTE_REGISTER(rl);
@@ -2022,7 +2102,8 @@ static void x86emuOp_and_byte_R_RM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x23
 ****************************************************************************/
-static void x86emuOp_and_word_R_RM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_and_word_R_RM(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     uint srcoffset;
@@ -2043,7 +2124,8 @@ static void x86emuOp_and_word_R_RM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = and_long(*destreg, srcval);
-        } else {
+        }
+        else {
             u16 *destreg;
             u16 srcval;
 
@@ -2069,7 +2151,8 @@ static void x86emuOp_and_word_R_RM(u8 X86EMU_UNUSED(op1))
             TRACE_AND_STEP();
             *destreg = and_long(*destreg, srcval);
             break;
-        } else {
+        }
+        else {
             u16 *destreg;
             u16 srcval;
 
@@ -2094,7 +2177,8 @@ static void x86emuOp_and_word_R_RM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = and_long(*destreg, srcval);
-        } else {
+        }
+        else {
             u16 *destreg;
             u16 srcval;
 
@@ -2107,9 +2191,9 @@ static void x86emuOp_and_word_R_RM(u8 X86EMU_UNUSED(op1))
             *destreg = and_word(*destreg, srcval);
         }
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-            u32 *destreg,*srcreg;
+            u32 *destreg, *srcreg;
 
             destreg = DECODE_RM_LONG_REGISTER(rh);
             DECODE_PRINTF(",");
@@ -2117,8 +2201,9 @@ static void x86emuOp_and_word_R_RM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = and_long(*destreg, *srcreg);
-        } else {
-            u16 *destreg,*srcreg;
+        }
+        else {
+            u16 *destreg, *srcreg;
 
             destreg = DECODE_RM_WORD_REGISTER(rh);
             DECODE_PRINTF(",");
@@ -2137,7 +2222,8 @@ static void x86emuOp_and_word_R_RM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x24
 ****************************************************************************/
-static void x86emuOp_and_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_and_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
 {
     u8 srcval;
 
@@ -2155,7 +2241,8 @@ static void x86emuOp_and_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x25
 ****************************************************************************/
-static void x86emuOp_and_word_AX_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_and_word_AX_IMM(u8 X86EMU_UNUSED(op1))
 {
     u32 srcval;
 
@@ -2163,7 +2250,8 @@ static void x86emuOp_and_word_AX_IMM(u8 X86EMU_UNUSED(op1))
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("AND\tEAX,");
         srcval = fetch_long_imm();
-    } else {
+    }
+    else {
         DECODE_PRINTF("AND\tAX,");
         srcval = fetch_word_imm();
     }
@@ -2171,8 +2259,9 @@ static void x86emuOp_and_word_AX_IMM(u8 X86EMU_UNUSED(op1))
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_EAX = and_long(M.x86.R_EAX, srcval);
-    } else {
-        M.x86.R_AX = and_word(M.x86.R_AX, (u16)srcval);
+    }
+    else {
+        M.x86.R_AX = and_word(M.x86.R_AX, (u16) srcval);
     }
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
@@ -2182,7 +2271,8 @@ static void x86emuOp_and_word_AX_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x26
 ****************************************************************************/
-static void x86emuOp_segovr_ES(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_segovr_ES(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     DECODE_PRINTF("ES:\n");
@@ -2199,7 +2289,8 @@ static void x86emuOp_segovr_ES(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x27
 ****************************************************************************/
-static void x86emuOp_daa(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_daa(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     DECODE_PRINTF("DAA\n");
@@ -2213,7 +2304,8 @@ static void x86emuOp_daa(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x28
 ****************************************************************************/
-static void x86emuOp_sub_byte_RM_R(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_sub_byte_RM_R(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     u8 *destreg, *srcreg;
@@ -2254,7 +2346,7 @@ static void x86emuOp_sub_byte_RM_R(u8 X86EMU_UNUSED(op1))
         destval = sub_byte(destval, *srcreg);
         store_data_byte(destoffset, destval);
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         destreg = DECODE_RM_BYTE_REGISTER(rl);
         DECODE_PRINTF(",");
         srcreg = DECODE_RM_BYTE_REGISTER(rh);
@@ -2271,7 +2363,8 @@ static void x86emuOp_sub_byte_RM_R(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x29
 ****************************************************************************/
-static void x86emuOp_sub_word_RM_R(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_sub_word_RM_R(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     uint destoffset;
@@ -2293,7 +2386,8 @@ static void x86emuOp_sub_word_RM_R(u8 X86EMU_UNUSED(op1))
             TRACE_AND_STEP();
             destval = sub_long(destval, *srcreg);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
             u16 *srcreg;
 
@@ -2320,7 +2414,8 @@ static void x86emuOp_sub_word_RM_R(u8 X86EMU_UNUSED(op1))
             TRACE_AND_STEP();
             destval = sub_long(destval, *srcreg);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
             u16 *srcreg;
 
@@ -2347,7 +2442,8 @@ static void x86emuOp_sub_word_RM_R(u8 X86EMU_UNUSED(op1))
             TRACE_AND_STEP();
             destval = sub_long(destval, *srcreg);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
             u16 *srcreg;
 
@@ -2361,9 +2457,9 @@ static void x86emuOp_sub_word_RM_R(u8 X86EMU_UNUSED(op1))
             store_data_word(destoffset, destval);
         }
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-            u32 *destreg,*srcreg;
+            u32 *destreg, *srcreg;
 
             destreg = DECODE_RM_LONG_REGISTER(rl);
             DECODE_PRINTF(",");
@@ -2371,8 +2467,9 @@ static void x86emuOp_sub_word_RM_R(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = sub_long(*destreg, *srcreg);
-        } else {
-            u16 *destreg,*srcreg;
+        }
+        else {
+            u16 *destreg, *srcreg;
 
             destreg = DECODE_RM_WORD_REGISTER(rl);
             DECODE_PRINTF(",");
@@ -2391,7 +2488,8 @@ static void x86emuOp_sub_word_RM_R(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x2a
 ****************************************************************************/
-static void x86emuOp_sub_byte_R_RM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_sub_byte_R_RM(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     u8 *destreg, *srcreg;
@@ -2429,7 +2527,7 @@ static void x86emuOp_sub_byte_R_RM(u8 X86EMU_UNUSED(op1))
         TRACE_AND_STEP();
         *destreg = sub_byte(*destreg, srcval);
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         destreg = DECODE_RM_BYTE_REGISTER(rh);
         DECODE_PRINTF(",");
         srcreg = DECODE_RM_BYTE_REGISTER(rl);
@@ -2446,7 +2544,8 @@ static void x86emuOp_sub_byte_R_RM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x2b
 ****************************************************************************/
-static void x86emuOp_sub_word_R_RM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_sub_word_R_RM(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     uint srcoffset;
@@ -2467,7 +2566,8 @@ static void x86emuOp_sub_word_R_RM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = sub_long(*destreg, srcval);
-        } else {
+        }
+        else {
             u16 *destreg;
             u16 srcval;
 
@@ -2492,7 +2592,8 @@ static void x86emuOp_sub_word_R_RM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = sub_long(*destreg, srcval);
-        } else {
+        }
+        else {
             u16 *destreg;
             u16 srcval;
 
@@ -2517,7 +2618,8 @@ static void x86emuOp_sub_word_R_RM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = sub_long(*destreg, srcval);
-        } else {
+        }
+        else {
             u16 *destreg;
             u16 srcval;
 
@@ -2530,9 +2632,9 @@ static void x86emuOp_sub_word_R_RM(u8 X86EMU_UNUSED(op1))
             *destreg = sub_word(*destreg, srcval);
         }
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-            u32 *destreg,*srcreg;
+            u32 *destreg, *srcreg;
 
             destreg = DECODE_RM_LONG_REGISTER(rh);
             DECODE_PRINTF(",");
@@ -2540,8 +2642,9 @@ static void x86emuOp_sub_word_R_RM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = sub_long(*destreg, *srcreg);
-        } else {
-            u16 *destreg,*srcreg;
+        }
+        else {
+            u16 *destreg, *srcreg;
 
             destreg = DECODE_RM_WORD_REGISTER(rh);
             DECODE_PRINTF(",");
@@ -2560,7 +2663,8 @@ static void x86emuOp_sub_word_R_RM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x2c
 ****************************************************************************/
-static void x86emuOp_sub_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_sub_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
 {
     u8 srcval;
 
@@ -2578,7 +2682,8 @@ static void x86emuOp_sub_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x2d
 ****************************************************************************/
-static void x86emuOp_sub_word_AX_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_sub_word_AX_IMM(u8 X86EMU_UNUSED(op1))
 {
     u32 srcval;
 
@@ -2586,7 +2691,8 @@ static void x86emuOp_sub_word_AX_IMM(u8 X86EMU_UNUSED(op1))
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("SUB\tEAX,");
         srcval = fetch_long_imm();
-    } else {
+    }
+    else {
         DECODE_PRINTF("SUB\tAX,");
         srcval = fetch_word_imm();
     }
@@ -2594,8 +2700,9 @@ static void x86emuOp_sub_word_AX_IMM(u8 X86EMU_UNUSED(op1))
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_EAX = sub_long(M.x86.R_EAX, srcval);
-    } else {
-        M.x86.R_AX = sub_word(M.x86.R_AX, (u16)srcval);
+    }
+    else {
+        M.x86.R_AX = sub_word(M.x86.R_AX, (u16) srcval);
     }
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
@@ -2605,7 +2712,8 @@ static void x86emuOp_sub_word_AX_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x2e
 ****************************************************************************/
-static void x86emuOp_segovr_CS(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_segovr_CS(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     DECODE_PRINTF("CS:\n");
@@ -2619,7 +2727,8 @@ static void x86emuOp_segovr_CS(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x2f
 ****************************************************************************/
-static void x86emuOp_das(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_das(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     DECODE_PRINTF("DAS\n");
@@ -2633,7 +2742,8 @@ static void x86emuOp_das(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x30
 ****************************************************************************/
-static void x86emuOp_xor_byte_RM_R(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_xor_byte_RM_R(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     u8 *destreg, *srcreg;
@@ -2674,7 +2784,7 @@ static void x86emuOp_xor_byte_RM_R(u8 X86EMU_UNUSED(op1))
         destval = xor_byte(destval, *srcreg);
         store_data_byte(destoffset, destval);
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         destreg = DECODE_RM_BYTE_REGISTER(rl);
         DECODE_PRINTF(",");
         srcreg = DECODE_RM_BYTE_REGISTER(rh);
@@ -2691,7 +2801,8 @@ static void x86emuOp_xor_byte_RM_R(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x31
 ****************************************************************************/
-static void x86emuOp_xor_word_RM_R(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_xor_word_RM_R(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     uint destoffset;
@@ -2713,7 +2824,8 @@ static void x86emuOp_xor_word_RM_R(u8 X86EMU_UNUSED(op1))
             TRACE_AND_STEP();
             destval = xor_long(destval, *srcreg);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
             u16 *srcreg;
 
@@ -2740,7 +2852,8 @@ static void x86emuOp_xor_word_RM_R(u8 X86EMU_UNUSED(op1))
             TRACE_AND_STEP();
             destval = xor_long(destval, *srcreg);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
             u16 *srcreg;
 
@@ -2767,7 +2880,8 @@ static void x86emuOp_xor_word_RM_R(u8 X86EMU_UNUSED(op1))
             TRACE_AND_STEP();
             destval = xor_long(destval, *srcreg);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
             u16 *srcreg;
 
@@ -2781,9 +2895,9 @@ static void x86emuOp_xor_word_RM_R(u8 X86EMU_UNUSED(op1))
             store_data_word(destoffset, destval);
         }
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-            u32 *destreg,*srcreg;
+            u32 *destreg, *srcreg;
 
             destreg = DECODE_RM_LONG_REGISTER(rl);
             DECODE_PRINTF(",");
@@ -2791,8 +2905,9 @@ static void x86emuOp_xor_word_RM_R(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = xor_long(*destreg, *srcreg);
-        } else {
-            u16 *destreg,*srcreg;
+        }
+        else {
+            u16 *destreg, *srcreg;
 
             destreg = DECODE_RM_WORD_REGISTER(rl);
             DECODE_PRINTF(",");
@@ -2811,7 +2926,8 @@ static void x86emuOp_xor_word_RM_R(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x32
 ****************************************************************************/
-static void x86emuOp_xor_byte_R_RM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_xor_byte_R_RM(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     u8 *destreg, *srcreg;
@@ -2849,7 +2965,7 @@ static void x86emuOp_xor_byte_R_RM(u8 X86EMU_UNUSED(op1))
         TRACE_AND_STEP();
         *destreg = xor_byte(*destreg, srcval);
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         destreg = DECODE_RM_BYTE_REGISTER(rh);
         DECODE_PRINTF(",");
         srcreg = DECODE_RM_BYTE_REGISTER(rl);
@@ -2866,7 +2982,8 @@ static void x86emuOp_xor_byte_R_RM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x33
 ****************************************************************************/
-static void x86emuOp_xor_word_R_RM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_xor_word_R_RM(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     uint srcoffset;
@@ -2887,7 +3004,8 @@ static void x86emuOp_xor_word_R_RM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = xor_long(*destreg, srcval);
-        } else {
+        }
+        else {
             u16 *destreg;
             u16 srcval;
 
@@ -2912,7 +3030,8 @@ static void x86emuOp_xor_word_R_RM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = xor_long(*destreg, srcval);
-        } else {
+        }
+        else {
             u16 *destreg;
             u16 srcval;
 
@@ -2937,7 +3056,8 @@ static void x86emuOp_xor_word_R_RM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = xor_long(*destreg, srcval);
-        } else {
+        }
+        else {
             u16 *destreg;
             u16 srcval;
 
@@ -2950,9 +3070,9 @@ static void x86emuOp_xor_word_R_RM(u8 X86EMU_UNUSED(op1))
             *destreg = xor_word(*destreg, srcval);
         }
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-            u32 *destreg,*srcreg;
+            u32 *destreg, *srcreg;
 
             destreg = DECODE_RM_LONG_REGISTER(rh);
             DECODE_PRINTF(",");
@@ -2960,8 +3080,9 @@ static void x86emuOp_xor_word_R_RM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = xor_long(*destreg, *srcreg);
-        } else {
-            u16 *destreg,*srcreg;
+        }
+        else {
+            u16 *destreg, *srcreg;
 
             destreg = DECODE_RM_WORD_REGISTER(rh);
             DECODE_PRINTF(",");
@@ -2980,7 +3101,8 @@ static void x86emuOp_xor_word_R_RM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x34
 ****************************************************************************/
-static void x86emuOp_xor_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_xor_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
 {
     u8 srcval;
 
@@ -2998,7 +3120,8 @@ static void x86emuOp_xor_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x35
 ****************************************************************************/
-static void x86emuOp_xor_word_AX_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_xor_word_AX_IMM(u8 X86EMU_UNUSED(op1))
 {
     u32 srcval;
 
@@ -3006,7 +3129,8 @@ static void x86emuOp_xor_word_AX_IMM(u8 X86EMU_UNUSED(op1))
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("XOR\tEAX,");
         srcval = fetch_long_imm();
-    } else {
+    }
+    else {
         DECODE_PRINTF("XOR\tAX,");
         srcval = fetch_word_imm();
     }
@@ -3014,8 +3138,9 @@ static void x86emuOp_xor_word_AX_IMM(u8 X86EMU_UNUSED(op1))
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_EAX = xor_long(M.x86.R_EAX, srcval);
-    } else {
-        M.x86.R_AX = xor_word(M.x86.R_AX, (u16)srcval);
+    }
+    else {
+        M.x86.R_AX = xor_word(M.x86.R_AX, (u16) srcval);
     }
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
@@ -3025,7 +3150,8 @@ static void x86emuOp_xor_word_AX_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x36
 ****************************************************************************/
-static void x86emuOp_segovr_SS(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_segovr_SS(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     DECODE_PRINTF("SS:\n");
@@ -3039,7 +3165,8 @@ static void x86emuOp_segovr_SS(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x37
 ****************************************************************************/
-static void x86emuOp_aaa(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_aaa(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     DECODE_PRINTF("AAA\n");
@@ -3053,7 +3180,8 @@ static void x86emuOp_aaa(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x38
 ****************************************************************************/
-static void x86emuOp_cmp_byte_RM_R(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_cmp_byte_RM_R(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     uint destoffset;
@@ -3091,7 +3219,7 @@ static void x86emuOp_cmp_byte_RM_R(u8 X86EMU_UNUSED(op1))
         TRACE_AND_STEP();
         cmp_byte(destval, *srcreg);
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         destreg = DECODE_RM_BYTE_REGISTER(rl);
         DECODE_PRINTF(",");
         srcreg = DECODE_RM_BYTE_REGISTER(rh);
@@ -3108,7 +3236,8 @@ static void x86emuOp_cmp_byte_RM_R(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x39
 ****************************************************************************/
-static void x86emuOp_cmp_word_RM_R(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_cmp_word_RM_R(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     uint destoffset;
@@ -3129,7 +3258,8 @@ static void x86emuOp_cmp_word_RM_R(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             cmp_long(destval, *srcreg);
-        } else {
+        }
+        else {
             u16 destval;
             u16 *srcreg;
 
@@ -3154,7 +3284,8 @@ static void x86emuOp_cmp_word_RM_R(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             cmp_long(destval, *srcreg);
-        } else {
+        }
+        else {
             u16 destval;
             u16 *srcreg;
 
@@ -3179,7 +3310,8 @@ static void x86emuOp_cmp_word_RM_R(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             cmp_long(destval, *srcreg);
-        } else {
+        }
+        else {
             u16 destval;
             u16 *srcreg;
 
@@ -3192,9 +3324,9 @@ static void x86emuOp_cmp_word_RM_R(u8 X86EMU_UNUSED(op1))
             cmp_word(destval, *srcreg);
         }
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-            u32 *destreg,*srcreg;
+            u32 *destreg, *srcreg;
 
             destreg = DECODE_RM_LONG_REGISTER(rl);
             DECODE_PRINTF(",");
@@ -3202,8 +3334,9 @@ static void x86emuOp_cmp_word_RM_R(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             cmp_long(*destreg, *srcreg);
-        } else {
-            u16 *destreg,*srcreg;
+        }
+        else {
+            u16 *destreg, *srcreg;
 
             destreg = DECODE_RM_WORD_REGISTER(rl);
             DECODE_PRINTF(",");
@@ -3222,7 +3355,8 @@ static void x86emuOp_cmp_word_RM_R(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x3a
 ****************************************************************************/
-static void x86emuOp_cmp_byte_R_RM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_cmp_byte_R_RM(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     u8 *destreg, *srcreg;
@@ -3260,7 +3394,7 @@ static void x86emuOp_cmp_byte_R_RM(u8 X86EMU_UNUSED(op1))
         TRACE_AND_STEP();
         cmp_byte(*destreg, srcval);
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         destreg = DECODE_RM_BYTE_REGISTER(rh);
         DECODE_PRINTF(",");
         srcreg = DECODE_RM_BYTE_REGISTER(rl);
@@ -3277,7 +3411,8 @@ static void x86emuOp_cmp_byte_R_RM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x3b
 ****************************************************************************/
-static void x86emuOp_cmp_word_R_RM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_cmp_word_R_RM(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     uint srcoffset;
@@ -3298,7 +3433,8 @@ static void x86emuOp_cmp_word_R_RM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             cmp_long(*destreg, srcval);
-        } else {
+        }
+        else {
             u16 *destreg;
             u16 srcval;
 
@@ -3323,7 +3459,8 @@ static void x86emuOp_cmp_word_R_RM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             cmp_long(*destreg, srcval);
-        } else {
+        }
+        else {
             u16 *destreg;
             u16 srcval;
 
@@ -3348,7 +3485,8 @@ static void x86emuOp_cmp_word_R_RM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             cmp_long(*destreg, srcval);
-        } else {
+        }
+        else {
             u16 *destreg;
             u16 srcval;
 
@@ -3361,9 +3499,9 @@ static void x86emuOp_cmp_word_R_RM(u8 X86EMU_UNUSED(op1))
             cmp_word(*destreg, srcval);
         }
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-            u32 *destreg,*srcreg;
+            u32 *destreg, *srcreg;
 
             destreg = DECODE_RM_LONG_REGISTER(rh);
             DECODE_PRINTF(",");
@@ -3371,8 +3509,9 @@ static void x86emuOp_cmp_word_R_RM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             cmp_long(*destreg, *srcreg);
-        } else {
-            u16 *destreg,*srcreg;
+        }
+        else {
+            u16 *destreg, *srcreg;
 
             destreg = DECODE_RM_WORD_REGISTER(rh);
             DECODE_PRINTF(",");
@@ -3391,7 +3530,8 @@ static void x86emuOp_cmp_word_R_RM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x3c
 ****************************************************************************/
-static void x86emuOp_cmp_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_cmp_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
 {
     u8 srcval;
 
@@ -3409,7 +3549,8 @@ static void x86emuOp_cmp_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x3d
 ****************************************************************************/
-static void x86emuOp_cmp_word_AX_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_cmp_word_AX_IMM(u8 X86EMU_UNUSED(op1))
 {
     u32 srcval;
 
@@ -3417,7 +3558,8 @@ static void x86emuOp_cmp_word_AX_IMM(u8 X86EMU_UNUSED(op1))
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("CMP\tEAX,");
         srcval = fetch_long_imm();
-    } else {
+    }
+    else {
         DECODE_PRINTF("CMP\tAX,");
         srcval = fetch_word_imm();
     }
@@ -3425,8 +3567,9 @@ static void x86emuOp_cmp_word_AX_IMM(u8 X86EMU_UNUSED(op1))
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         cmp_long(M.x86.R_EAX, srcval);
-    } else {
-        cmp_word(M.x86.R_AX, (u16)srcval);
+    }
+    else {
+        cmp_word(M.x86.R_AX, (u16) srcval);
     }
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
@@ -3436,7 +3579,8 @@ static void x86emuOp_cmp_word_AX_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x3e
 ****************************************************************************/
-static void x86emuOp_segovr_DS(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_segovr_DS(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     DECODE_PRINTF("DS:\n");
@@ -3450,7 +3594,8 @@ static void x86emuOp_segovr_DS(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x3f
 ****************************************************************************/
-static void x86emuOp_aas(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_aas(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     DECODE_PRINTF("AAS\n");
@@ -3464,18 +3609,21 @@ static void x86emuOp_aas(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x40
 ****************************************************************************/
-static void x86emuOp_inc_AX(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_inc_AX(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("INC\tEAX\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("INC\tAX\n");
     }
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_EAX = inc_long(M.x86.R_EAX);
-    } else {
+    }
+    else {
         M.x86.R_AX = inc_word(M.x86.R_AX);
     }
     DECODE_CLEAR_SEGOVR();
@@ -3486,18 +3634,21 @@ static void x86emuOp_inc_AX(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x41
 ****************************************************************************/
-static void x86emuOp_inc_CX(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_inc_CX(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("INC\tECX\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("INC\tCX\n");
     }
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_ECX = inc_long(M.x86.R_ECX);
-    } else {
+    }
+    else {
         M.x86.R_CX = inc_word(M.x86.R_CX);
     }
     DECODE_CLEAR_SEGOVR();
@@ -3508,18 +3659,21 @@ static void x86emuOp_inc_CX(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x42
 ****************************************************************************/
-static void x86emuOp_inc_DX(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_inc_DX(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("INC\tEDX\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("INC\tDX\n");
     }
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_EDX = inc_long(M.x86.R_EDX);
-    } else {
+    }
+    else {
         M.x86.R_DX = inc_word(M.x86.R_DX);
     }
     DECODE_CLEAR_SEGOVR();
@@ -3530,18 +3684,21 @@ static void x86emuOp_inc_DX(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x43
 ****************************************************************************/
-static void x86emuOp_inc_BX(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_inc_BX(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("INC\tEBX\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("INC\tBX\n");
     }
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_EBX = inc_long(M.x86.R_EBX);
-    } else {
+    }
+    else {
         M.x86.R_BX = inc_word(M.x86.R_BX);
     }
     DECODE_CLEAR_SEGOVR();
@@ -3552,18 +3709,21 @@ static void x86emuOp_inc_BX(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x44
 ****************************************************************************/
-static void x86emuOp_inc_SP(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_inc_SP(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("INC\tESP\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("INC\tSP\n");
     }
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_ESP = inc_long(M.x86.R_ESP);
-    } else {
+    }
+    else {
         M.x86.R_SP = inc_word(M.x86.R_SP);
     }
     DECODE_CLEAR_SEGOVR();
@@ -3574,18 +3734,21 @@ static void x86emuOp_inc_SP(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x45
 ****************************************************************************/
-static void x86emuOp_inc_BP(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_inc_BP(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("INC\tEBP\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("INC\tBP\n");
     }
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_EBP = inc_long(M.x86.R_EBP);
-    } else {
+    }
+    else {
         M.x86.R_BP = inc_word(M.x86.R_BP);
     }
     DECODE_CLEAR_SEGOVR();
@@ -3596,18 +3759,21 @@ static void x86emuOp_inc_BP(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x46
 ****************************************************************************/
-static void x86emuOp_inc_SI(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_inc_SI(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("INC\tESI\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("INC\tSI\n");
     }
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_ESI = inc_long(M.x86.R_ESI);
-    } else {
+    }
+    else {
         M.x86.R_SI = inc_word(M.x86.R_SI);
     }
     DECODE_CLEAR_SEGOVR();
@@ -3618,18 +3784,21 @@ static void x86emuOp_inc_SI(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x47
 ****************************************************************************/
-static void x86emuOp_inc_DI(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_inc_DI(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("INC\tEDI\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("INC\tDI\n");
     }
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_EDI = inc_long(M.x86.R_EDI);
-    } else {
+    }
+    else {
         M.x86.R_DI = inc_word(M.x86.R_DI);
     }
     DECODE_CLEAR_SEGOVR();
@@ -3640,18 +3809,21 @@ static void x86emuOp_inc_DI(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x48
 ****************************************************************************/
-static void x86emuOp_dec_AX(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_dec_AX(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("DEC\tEAX\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("DEC\tAX\n");
     }
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_EAX = dec_long(M.x86.R_EAX);
-    } else {
+    }
+    else {
         M.x86.R_AX = dec_word(M.x86.R_AX);
     }
     DECODE_CLEAR_SEGOVR();
@@ -3662,18 +3834,21 @@ static void x86emuOp_dec_AX(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x49
 ****************************************************************************/
-static void x86emuOp_dec_CX(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_dec_CX(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("DEC\tECX\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("DEC\tCX\n");
     }
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_ECX = dec_long(M.x86.R_ECX);
-    } else {
+    }
+    else {
         M.x86.R_CX = dec_word(M.x86.R_CX);
     }
     DECODE_CLEAR_SEGOVR();
@@ -3684,18 +3859,21 @@ static void x86emuOp_dec_CX(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x4a
 ****************************************************************************/
-static void x86emuOp_dec_DX(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_dec_DX(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("DEC\tEDX\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("DEC\tDX\n");
     }
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_EDX = dec_long(M.x86.R_EDX);
-    } else {
+    }
+    else {
         M.x86.R_DX = dec_word(M.x86.R_DX);
     }
     DECODE_CLEAR_SEGOVR();
@@ -3706,18 +3884,21 @@ static void x86emuOp_dec_DX(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x4b
 ****************************************************************************/
-static void x86emuOp_dec_BX(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_dec_BX(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("DEC\tEBX\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("DEC\tBX\n");
     }
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_EBX = dec_long(M.x86.R_EBX);
-    } else {
+    }
+    else {
         M.x86.R_BX = dec_word(M.x86.R_BX);
     }
     DECODE_CLEAR_SEGOVR();
@@ -3728,18 +3909,21 @@ static void x86emuOp_dec_BX(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x4c
 ****************************************************************************/
-static void x86emuOp_dec_SP(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_dec_SP(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("DEC\tESP\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("DEC\tSP\n");
     }
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_ESP = dec_long(M.x86.R_ESP);
-    } else {
+    }
+    else {
         M.x86.R_SP = dec_word(M.x86.R_SP);
     }
     DECODE_CLEAR_SEGOVR();
@@ -3750,18 +3934,21 @@ static void x86emuOp_dec_SP(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x4d
 ****************************************************************************/
-static void x86emuOp_dec_BP(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_dec_BP(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("DEC\tEBP\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("DEC\tBP\n");
     }
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_EBP = dec_long(M.x86.R_EBP);
-    } else {
+    }
+    else {
         M.x86.R_BP = dec_word(M.x86.R_BP);
     }
     DECODE_CLEAR_SEGOVR();
@@ -3772,18 +3959,21 @@ static void x86emuOp_dec_BP(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x4e
 ****************************************************************************/
-static void x86emuOp_dec_SI(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_dec_SI(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("DEC\tESI\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("DEC\tSI\n");
     }
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_ESI = dec_long(M.x86.R_ESI);
-    } else {
+    }
+    else {
         M.x86.R_SI = dec_word(M.x86.R_SI);
     }
     DECODE_CLEAR_SEGOVR();
@@ -3794,18 +3984,21 @@ static void x86emuOp_dec_SI(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x4f
 ****************************************************************************/
-static void x86emuOp_dec_DI(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_dec_DI(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("DEC\tEDI\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("DEC\tDI\n");
     }
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_EDI = dec_long(M.x86.R_EDI);
-    } else {
+    }
+    else {
         M.x86.R_DI = dec_word(M.x86.R_DI);
     }
     DECODE_CLEAR_SEGOVR();
@@ -3816,18 +4009,21 @@ static void x86emuOp_dec_DI(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x50
 ****************************************************************************/
-static void x86emuOp_push_AX(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_push_AX(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("PUSH\tEAX\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("PUSH\tAX\n");
     }
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         push_long(M.x86.R_EAX);
-    } else {
+    }
+    else {
         push_word(M.x86.R_AX);
     }
     DECODE_CLEAR_SEGOVR();
@@ -3838,18 +4034,21 @@ static void x86emuOp_push_AX(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x51
 ****************************************************************************/
-static void x86emuOp_push_CX(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_push_CX(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("PUSH\tECX\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("PUSH\tCX\n");
     }
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         push_long(M.x86.R_ECX);
-    } else {
+    }
+    else {
         push_word(M.x86.R_CX);
     }
     DECODE_CLEAR_SEGOVR();
@@ -3860,18 +4059,21 @@ static void x86emuOp_push_CX(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x52
 ****************************************************************************/
-static void x86emuOp_push_DX(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_push_DX(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("PUSH\tEDX\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("PUSH\tDX\n");
     }
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         push_long(M.x86.R_EDX);
-    } else {
+    }
+    else {
         push_word(M.x86.R_DX);
     }
     DECODE_CLEAR_SEGOVR();
@@ -3882,18 +4084,21 @@ static void x86emuOp_push_DX(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x53
 ****************************************************************************/
-static void x86emuOp_push_BX(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_push_BX(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("PUSH\tEBX\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("PUSH\tBX\n");
     }
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         push_long(M.x86.R_EBX);
-    } else {
+    }
+    else {
         push_word(M.x86.R_BX);
     }
     DECODE_CLEAR_SEGOVR();
@@ -3904,23 +4109,26 @@ static void x86emuOp_push_BX(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x54
 ****************************************************************************/
-static void x86emuOp_push_SP(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_push_SP(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("PUSH\tESP\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("PUSH\tSP\n");
     }
     TRACE_AND_STEP();
-	/* Always push (E)SP, since we are emulating an i386 and above
-	 * processor. This is necessary as some BIOS'es use this to check
-	 * what type of processor is in the system.
-	 */
-	if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-		push_long(M.x86.R_ESP);
-	} else {
-		push_word((u16)(M.x86.R_SP));
+    /* Always push (E)SP, since we are emulating an i386 and above
+     * processor. This is necessary as some BIOS'es use this to check
+     * what type of processor is in the system.
+     */
+    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
+        push_long(M.x86.R_ESP);
+    }
+    else {
+        push_word((u16) (M.x86.R_SP));
     }
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
@@ -3930,18 +4138,21 @@ static void x86emuOp_push_SP(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x55
 ****************************************************************************/
-static void x86emuOp_push_BP(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_push_BP(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("PUSH\tEBP\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("PUSH\tBP\n");
     }
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         push_long(M.x86.R_EBP);
-    } else {
+    }
+    else {
         push_word(M.x86.R_BP);
     }
     DECODE_CLEAR_SEGOVR();
@@ -3952,18 +4163,21 @@ static void x86emuOp_push_BP(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x56
 ****************************************************************************/
-static void x86emuOp_push_SI(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_push_SI(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("PUSH\tESI\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("PUSH\tSI\n");
     }
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         push_long(M.x86.R_ESI);
-    } else {
+    }
+    else {
         push_word(M.x86.R_SI);
     }
     DECODE_CLEAR_SEGOVR();
@@ -3974,18 +4188,21 @@ static void x86emuOp_push_SI(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x57
 ****************************************************************************/
-static void x86emuOp_push_DI(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_push_DI(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("PUSH\tEDI\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("PUSH\tDI\n");
     }
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         push_long(M.x86.R_EDI);
-    } else {
+    }
+    else {
         push_word(M.x86.R_DI);
     }
     DECODE_CLEAR_SEGOVR();
@@ -3996,18 +4213,21 @@ static void x86emuOp_push_DI(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x58
 ****************************************************************************/
-static void x86emuOp_pop_AX(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_pop_AX(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("POP\tEAX\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("POP\tAX\n");
     }
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_EAX = pop_long();
-    } else {
+    }
+    else {
         M.x86.R_AX = pop_word();
     }
     DECODE_CLEAR_SEGOVR();
@@ -4018,18 +4238,21 @@ static void x86emuOp_pop_AX(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x59
 ****************************************************************************/
-static void x86emuOp_pop_CX(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_pop_CX(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("POP\tECX\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("POP\tCX\n");
     }
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_ECX = pop_long();
-    } else {
+    }
+    else {
         M.x86.R_CX = pop_word();
     }
     DECODE_CLEAR_SEGOVR();
@@ -4040,18 +4263,21 @@ static void x86emuOp_pop_CX(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x5a
 ****************************************************************************/
-static void x86emuOp_pop_DX(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_pop_DX(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("POP\tEDX\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("POP\tDX\n");
     }
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_EDX = pop_long();
-    } else {
+    }
+    else {
         M.x86.R_DX = pop_word();
     }
     DECODE_CLEAR_SEGOVR();
@@ -4062,18 +4288,21 @@ static void x86emuOp_pop_DX(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x5b
 ****************************************************************************/
-static void x86emuOp_pop_BX(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_pop_BX(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("POP\tEBX\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("POP\tBX\n");
     }
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_EBX = pop_long();
-    } else {
+    }
+    else {
         M.x86.R_BX = pop_word();
     }
     DECODE_CLEAR_SEGOVR();
@@ -4084,18 +4313,21 @@ static void x86emuOp_pop_BX(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x5c
 ****************************************************************************/
-static void x86emuOp_pop_SP(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_pop_SP(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("POP\tESP\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("POP\tSP\n");
     }
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_ESP = pop_long();
-    } else {
+    }
+    else {
         M.x86.R_SP = pop_word();
     }
     DECODE_CLEAR_SEGOVR();
@@ -4106,18 +4338,21 @@ static void x86emuOp_pop_SP(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x5d
 ****************************************************************************/
-static void x86emuOp_pop_BP(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_pop_BP(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("POP\tEBP\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("POP\tBP\n");
     }
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_EBP = pop_long();
-    } else {
+    }
+    else {
         M.x86.R_BP = pop_word();
     }
     DECODE_CLEAR_SEGOVR();
@@ -4128,18 +4363,21 @@ static void x86emuOp_pop_BP(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x5e
 ****************************************************************************/
-static void x86emuOp_pop_SI(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_pop_SI(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("POP\tESI\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("POP\tSI\n");
     }
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_ESI = pop_long();
-    } else {
+    }
+    else {
         M.x86.R_SI = pop_word();
     }
     DECODE_CLEAR_SEGOVR();
@@ -4150,18 +4388,21 @@ static void x86emuOp_pop_SI(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x5f
 ****************************************************************************/
-static void x86emuOp_pop_DI(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_pop_DI(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("POP\tEDI\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("POP\tDI\n");
     }
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_EDI = pop_long();
-    } else {
+    }
+    else {
         M.x86.R_DI = pop_word();
     }
     DECODE_CLEAR_SEGOVR();
@@ -4172,12 +4413,14 @@ static void x86emuOp_pop_DI(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x60
 ****************************************************************************/
-static void x86emuOp_push_all(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_push_all(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("PUSHAD\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("PUSHA\n");
     }
     TRACE_AND_STEP();
@@ -4192,7 +4435,8 @@ static void x86emuOp_push_all(u8 X86EMU_UNUSED(op1))
         push_long(M.x86.R_EBP);
         push_long(M.x86.R_ESI);
         push_long(M.x86.R_EDI);
-    } else {
+    }
+    else {
         u16 old_sp = M.x86.R_SP;
 
         push_word(M.x86.R_AX);
@@ -4212,12 +4456,14 @@ static void x86emuOp_push_all(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x61
 ****************************************************************************/
-static void x86emuOp_pop_all(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_pop_all(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("POPAD\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("POPA\n");
     }
     TRACE_AND_STEP();
@@ -4225,16 +4471,17 @@ static void x86emuOp_pop_all(u8 X86EMU_UNUSED(op1))
         M.x86.R_EDI = pop_long();
         M.x86.R_ESI = pop_long();
         M.x86.R_EBP = pop_long();
-        M.x86.R_ESP += 4;              /* skip ESP */
+        M.x86.R_ESP += 4;       /* skip ESP */
         M.x86.R_EBX = pop_long();
         M.x86.R_EDX = pop_long();
         M.x86.R_ECX = pop_long();
         M.x86.R_EAX = pop_long();
-    } else {
+    }
+    else {
         M.x86.R_DI = pop_word();
         M.x86.R_SI = pop_word();
         M.x86.R_BP = pop_word();
-        M.x86.R_SP += 2;               /* skip SP */
+        M.x86.R_SP += 2;        /* skip SP */
         M.x86.R_BX = pop_word();
         M.x86.R_DX = pop_word();
         M.x86.R_CX = pop_word();
@@ -4251,7 +4498,8 @@ static void x86emuOp_pop_all(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x64
 ****************************************************************************/
-static void x86emuOp_segovr_FS(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_segovr_FS(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     DECODE_PRINTF("FS:\n");
@@ -4268,7 +4516,8 @@ static void x86emuOp_segovr_FS(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x65
 ****************************************************************************/
-static void x86emuOp_segovr_GS(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_segovr_GS(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     DECODE_PRINTF("GS:\n");
@@ -4285,7 +4534,8 @@ static void x86emuOp_segovr_GS(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x66 - prefix for 32-bit register
 ****************************************************************************/
-static void x86emuOp_prefix_data(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_prefix_data(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     DECODE_PRINTF("DATA:\n");
@@ -4299,7 +4549,8 @@ static void x86emuOp_prefix_data(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x67 - prefix for 32-bit address
 ****************************************************************************/
-static void x86emuOp_prefix_addr(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_prefix_addr(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     DECODE_PRINTF("ADDR:\n");
@@ -4313,22 +4564,25 @@ static void x86emuOp_prefix_addr(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x68
 ****************************************************************************/
-static void x86emuOp_push_word_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_push_word_IMM(u8 X86EMU_UNUSED(op1))
 {
     u32 imm;
 
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         imm = fetch_long_imm();
-    } else {
+    }
+    else {
         imm = fetch_word_imm();
     }
     DECODE_PRINTF2("PUSH\t%x\n", imm);
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         push_long(imm);
-    } else {
-        push_word((u16)imm);
+    }
+    else {
+        push_word((u16) imm);
     }
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
@@ -4338,7 +4592,8 @@ static void x86emuOp_push_word_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x69
 ****************************************************************************/
-static void x86emuOp_imul_word_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_imul_word_IMM(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     uint srcoffset;
@@ -4351,7 +4606,7 @@ static void x86emuOp_imul_word_IMM(u8 X86EMU_UNUSED(op1))
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
             u32 *destreg;
             u32 srcval;
-            u32 res_lo,res_hi;
+            u32 res_lo, res_hi;
             s32 imm;
 
             destreg = DECODE_RM_LONG_REGISTER(rh);
@@ -4359,18 +4614,20 @@ static void x86emuOp_imul_word_IMM(u8 X86EMU_UNUSED(op1))
             srcoffset = decode_rm00_address(rl);
             srcval = fetch_data_long(srcoffset);
             imm = fetch_long_imm();
-            DECODE_PRINTF2(",%d\n", (s32)imm);
+            DECODE_PRINTF2(",%d\n", (s32) imm);
             TRACE_AND_STEP();
-            imul_long_direct(&res_lo,&res_hi,(s32)srcval,(s32)imm);
+            imul_long_direct(&res_lo, &res_hi, (s32) srcval, (s32) imm);
             if (res_hi != 0) {
                 SET_FLAG(F_CF);
                 SET_FLAG(F_OF);
-            } else {
+            }
+            else {
                 CLEAR_FLAG(F_CF);
                 CLEAR_FLAG(F_OF);
             }
-            *destreg = (u32)res_lo;
-        } else {
+            *destreg = (u32) res_lo;
+        }
+        else {
             u16 *destreg;
             u16 srcval;
             u32 res;
@@ -4381,24 +4638,26 @@ static void x86emuOp_imul_word_IMM(u8 X86EMU_UNUSED(op1))
             srcoffset = decode_rm00_address(rl);
             srcval = fetch_data_word(srcoffset);
             imm = fetch_word_imm();
-            DECODE_PRINTF2(",%d\n", (s32)imm);
+            DECODE_PRINTF2(",%d\n", (s32) imm);
             TRACE_AND_STEP();
-            res = (s16)srcval * (s16)imm;
+            res = (s16) srcval *(s16) imm;
+
             if (res > 0xFFFF) {
                 SET_FLAG(F_CF);
                 SET_FLAG(F_OF);
-            } else {
+            }
+            else {
                 CLEAR_FLAG(F_CF);
                 CLEAR_FLAG(F_OF);
             }
-            *destreg = (u16)res;
+            *destreg = (u16) res;
         }
         break;
     case 1:
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
             u32 *destreg;
             u32 srcval;
-            u32 res_lo,res_hi;
+            u32 res_lo, res_hi;
             s32 imm;
 
             destreg = DECODE_RM_LONG_REGISTER(rh);
@@ -4406,18 +4665,20 @@ static void x86emuOp_imul_word_IMM(u8 X86EMU_UNUSED(op1))
             srcoffset = decode_rm01_address(rl);
             srcval = fetch_data_long(srcoffset);
             imm = fetch_long_imm();
-            DECODE_PRINTF2(",%d\n", (s32)imm);
+            DECODE_PRINTF2(",%d\n", (s32) imm);
             TRACE_AND_STEP();
-            imul_long_direct(&res_lo,&res_hi,(s32)srcval,(s32)imm);
+            imul_long_direct(&res_lo, &res_hi, (s32) srcval, (s32) imm);
             if (res_hi != 0) {
                 SET_FLAG(F_CF);
                 SET_FLAG(F_OF);
-            } else {
+            }
+            else {
                 CLEAR_FLAG(F_CF);
                 CLEAR_FLAG(F_OF);
             }
-            *destreg = (u32)res_lo;
-        } else {
+            *destreg = (u32) res_lo;
+        }
+        else {
             u16 *destreg;
             u16 srcval;
             u32 res;
@@ -4428,24 +4689,26 @@ static void x86emuOp_imul_word_IMM(u8 X86EMU_UNUSED(op1))
             srcoffset = decode_rm01_address(rl);
             srcval = fetch_data_word(srcoffset);
             imm = fetch_word_imm();
-            DECODE_PRINTF2(",%d\n", (s32)imm);
+            DECODE_PRINTF2(",%d\n", (s32) imm);
             TRACE_AND_STEP();
-            res = (s16)srcval * (s16)imm;
+            res = (s16) srcval *(s16) imm;
+
             if (res > 0xFFFF) {
                 SET_FLAG(F_CF);
                 SET_FLAG(F_OF);
-            } else {
+            }
+            else {
                 CLEAR_FLAG(F_CF);
                 CLEAR_FLAG(F_OF);
             }
-            *destreg = (u16)res;
+            *destreg = (u16) res;
         }
         break;
     case 2:
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
             u32 *destreg;
             u32 srcval;
-            u32 res_lo,res_hi;
+            u32 res_lo, res_hi;
             s32 imm;
 
             destreg = DECODE_RM_LONG_REGISTER(rh);
@@ -4453,18 +4716,20 @@ static void x86emuOp_imul_word_IMM(u8 X86EMU_UNUSED(op1))
             srcoffset = decode_rm10_address(rl);
             srcval = fetch_data_long(srcoffset);
             imm = fetch_long_imm();
-            DECODE_PRINTF2(",%d\n", (s32)imm);
+            DECODE_PRINTF2(",%d\n", (s32) imm);
             TRACE_AND_STEP();
-            imul_long_direct(&res_lo,&res_hi,(s32)srcval,(s32)imm);
+            imul_long_direct(&res_lo, &res_hi, (s32) srcval, (s32) imm);
             if (res_hi != 0) {
                 SET_FLAG(F_CF);
                 SET_FLAG(F_OF);
-            } else {
+            }
+            else {
                 CLEAR_FLAG(F_CF);
                 CLEAR_FLAG(F_OF);
             }
-            *destreg = (u32)res_lo;
-        } else {
+            *destreg = (u32) res_lo;
+        }
+        else {
             u16 *destreg;
             u16 srcval;
             u32 res;
@@ -4475,42 +4740,46 @@ static void x86emuOp_imul_word_IMM(u8 X86EMU_UNUSED(op1))
             srcoffset = decode_rm10_address(rl);
             srcval = fetch_data_word(srcoffset);
             imm = fetch_word_imm();
-            DECODE_PRINTF2(",%d\n", (s32)imm);
+            DECODE_PRINTF2(",%d\n", (s32) imm);
             TRACE_AND_STEP();
-            res = (s16)srcval * (s16)imm;
+            res = (s16) srcval *(s16) imm;
+
             if (res > 0xFFFF) {
                 SET_FLAG(F_CF);
                 SET_FLAG(F_OF);
-            } else {
+            }
+            else {
                 CLEAR_FLAG(F_CF);
                 CLEAR_FLAG(F_OF);
             }
-            *destreg = (u16)res;
+            *destreg = (u16) res;
         }
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-            u32 *destreg,*srcreg;
-            u32 res_lo,res_hi;
+            u32 *destreg, *srcreg;
+            u32 res_lo, res_hi;
             s32 imm;
 
             destreg = DECODE_RM_LONG_REGISTER(rh);
             DECODE_PRINTF(",");
             srcreg = DECODE_RM_LONG_REGISTER(rl);
             imm = fetch_long_imm();
-            DECODE_PRINTF2(",%d\n", (s32)imm);
+            DECODE_PRINTF2(",%d\n", (s32) imm);
             TRACE_AND_STEP();
-            imul_long_direct(&res_lo,&res_hi,(s32)*srcreg,(s32)imm);
+            imul_long_direct(&res_lo, &res_hi, (s32) * srcreg, (s32) imm);
             if (res_hi != 0) {
                 SET_FLAG(F_CF);
                 SET_FLAG(F_OF);
-            } else {
+            }
+            else {
                 CLEAR_FLAG(F_CF);
                 CLEAR_FLAG(F_OF);
             }
-            *destreg = (u32)res_lo;
-        } else {
-            u16 *destreg,*srcreg;
+            *destreg = (u32) res_lo;
+        }
+        else {
+            u16 *destreg, *srcreg;
             u32 res;
             s16 imm;
 
@@ -4518,16 +4787,17 @@ static void x86emuOp_imul_word_IMM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF(",");
             srcreg = DECODE_RM_WORD_REGISTER(rl);
             imm = fetch_word_imm();
-            DECODE_PRINTF2(",%d\n", (s32)imm);
-            res = (s16)*srcreg * (s16)imm;
+            DECODE_PRINTF2(",%d\n", (s32) imm);
+            res = (s16) * srcreg * (s16) imm;
             if (res > 0xFFFF) {
                 SET_FLAG(F_CF);
                 SET_FLAG(F_OF);
-            } else {
+            }
+            else {
                 CLEAR_FLAG(F_CF);
                 CLEAR_FLAG(F_OF);
             }
-            *destreg = (u16)res;
+            *destreg = (u16) res;
         }
         break;
     }
@@ -4539,18 +4809,20 @@ static void x86emuOp_imul_word_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x6a
 ****************************************************************************/
-static void x86emuOp_push_byte_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_push_byte_IMM(u8 X86EMU_UNUSED(op1))
 {
     s16 imm;
 
     START_OF_INSTR();
-    imm = (s8)fetch_byte_imm();
+    imm = (s8) fetch_byte_imm();
     DECODE_PRINTF2("PUSH\t%d\n", imm);
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-	push_long((s32)imm);
-    } else {
-	push_word(imm);
+        push_long((s32) imm);
+    }
+    else {
+        push_word(imm);
     }
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
@@ -4560,11 +4832,12 @@ static void x86emuOp_push_byte_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x6b
 ****************************************************************************/
-static void x86emuOp_imul_byte_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_imul_byte_IMM(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     uint srcoffset;
-    s8  imm;
+    s8 imm;
 
     START_OF_INSTR();
     DECODE_PRINTF("IMUL\t");
@@ -4574,25 +4847,27 @@ static void x86emuOp_imul_byte_IMM(u8 X86EMU_UNUSED(op1))
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
             u32 *destreg;
             u32 srcval;
-            u32 res_lo,res_hi;
+            u32 res_lo, res_hi;
 
             destreg = DECODE_RM_LONG_REGISTER(rh);
             DECODE_PRINTF(",");
             srcoffset = decode_rm00_address(rl);
             srcval = fetch_data_long(srcoffset);
             imm = fetch_byte_imm();
-            DECODE_PRINTF2(",%d\n", (s32)imm);
+            DECODE_PRINTF2(",%d\n", (s32) imm);
             TRACE_AND_STEP();
-            imul_long_direct(&res_lo,&res_hi,(s32)srcval,(s32)imm);
+            imul_long_direct(&res_lo, &res_hi, (s32) srcval, (s32) imm);
             if (res_hi != 0) {
                 SET_FLAG(F_CF);
                 SET_FLAG(F_OF);
-            } else {
+            }
+            else {
                 CLEAR_FLAG(F_CF);
                 CLEAR_FLAG(F_OF);
             }
-            *destreg = (u32)res_lo;
-        } else {
+            *destreg = (u32) res_lo;
+        }
+        else {
             u16 *destreg;
             u16 srcval;
             u32 res;
@@ -4602,42 +4877,46 @@ static void x86emuOp_imul_byte_IMM(u8 X86EMU_UNUSED(op1))
             srcoffset = decode_rm00_address(rl);
             srcval = fetch_data_word(srcoffset);
             imm = fetch_byte_imm();
-            DECODE_PRINTF2(",%d\n", (s32)imm);
+            DECODE_PRINTF2(",%d\n", (s32) imm);
             TRACE_AND_STEP();
-            res = (s16)srcval * (s16)imm;
+            res = (s16) srcval *(s16) imm;
+
             if (res > 0xFFFF) {
                 SET_FLAG(F_CF);
                 SET_FLAG(F_OF);
-            } else {
+            }
+            else {
                 CLEAR_FLAG(F_CF);
                 CLEAR_FLAG(F_OF);
             }
-            *destreg = (u16)res;
+            *destreg = (u16) res;
         }
         break;
     case 1:
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
             u32 *destreg;
             u32 srcval;
-            u32 res_lo,res_hi;
+            u32 res_lo, res_hi;
 
             destreg = DECODE_RM_LONG_REGISTER(rh);
             DECODE_PRINTF(",");
             srcoffset = decode_rm01_address(rl);
             srcval = fetch_data_long(srcoffset);
             imm = fetch_byte_imm();
-            DECODE_PRINTF2(",%d\n", (s32)imm);
+            DECODE_PRINTF2(",%d\n", (s32) imm);
             TRACE_AND_STEP();
-            imul_long_direct(&res_lo,&res_hi,(s32)srcval,(s32)imm);
+            imul_long_direct(&res_lo, &res_hi, (s32) srcval, (s32) imm);
             if (res_hi != 0) {
                 SET_FLAG(F_CF);
                 SET_FLAG(F_OF);
-            } else {
+            }
+            else {
                 CLEAR_FLAG(F_CF);
                 CLEAR_FLAG(F_OF);
             }
-            *destreg = (u32)res_lo;
-        } else {
+            *destreg = (u32) res_lo;
+        }
+        else {
             u16 *destreg;
             u16 srcval;
             u32 res;
@@ -4647,42 +4926,46 @@ static void x86emuOp_imul_byte_IMM(u8 X86EMU_UNUSED(op1))
             srcoffset = decode_rm01_address(rl);
             srcval = fetch_data_word(srcoffset);
             imm = fetch_byte_imm();
-            DECODE_PRINTF2(",%d\n", (s32)imm);
+            DECODE_PRINTF2(",%d\n", (s32) imm);
             TRACE_AND_STEP();
-            res = (s16)srcval * (s16)imm;
+            res = (s16) srcval *(s16) imm;
+
             if (res > 0xFFFF) {
                 SET_FLAG(F_CF);
                 SET_FLAG(F_OF);
-            } else {
+            }
+            else {
                 CLEAR_FLAG(F_CF);
                 CLEAR_FLAG(F_OF);
             }
-            *destreg = (u16)res;
+            *destreg = (u16) res;
         }
         break;
     case 2:
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
             u32 *destreg;
             u32 srcval;
-            u32 res_lo,res_hi;
+            u32 res_lo, res_hi;
 
             destreg = DECODE_RM_LONG_REGISTER(rh);
             DECODE_PRINTF(",");
             srcoffset = decode_rm10_address(rl);
             srcval = fetch_data_long(srcoffset);
             imm = fetch_byte_imm();
-            DECODE_PRINTF2(",%d\n", (s32)imm);
+            DECODE_PRINTF2(",%d\n", (s32) imm);
             TRACE_AND_STEP();
-            imul_long_direct(&res_lo,&res_hi,(s32)srcval,(s32)imm);
+            imul_long_direct(&res_lo, &res_hi, (s32) srcval, (s32) imm);
             if (res_hi != 0) {
                 SET_FLAG(F_CF);
                 SET_FLAG(F_OF);
-            } else {
+            }
+            else {
                 CLEAR_FLAG(F_CF);
                 CLEAR_FLAG(F_OF);
             }
-            *destreg = (u32)res_lo;
-        } else {
+            *destreg = (u32) res_lo;
+        }
+        else {
             u16 *destreg;
             u16 srcval;
             u32 res;
@@ -4692,57 +4975,62 @@ static void x86emuOp_imul_byte_IMM(u8 X86EMU_UNUSED(op1))
             srcoffset = decode_rm10_address(rl);
             srcval = fetch_data_word(srcoffset);
             imm = fetch_byte_imm();
-            DECODE_PRINTF2(",%d\n", (s32)imm);
+            DECODE_PRINTF2(",%d\n", (s32) imm);
             TRACE_AND_STEP();
-            res = (s16)srcval * (s16)imm;
+            res = (s16) srcval *(s16) imm;
+
             if (res > 0xFFFF) {
                 SET_FLAG(F_CF);
                 SET_FLAG(F_OF);
-            } else {
+            }
+            else {
                 CLEAR_FLAG(F_CF);
                 CLEAR_FLAG(F_OF);
             }
-            *destreg = (u16)res;
+            *destreg = (u16) res;
         }
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-            u32 *destreg,*srcreg;
-            u32 res_lo,res_hi;
+            u32 *destreg, *srcreg;
+            u32 res_lo, res_hi;
 
             destreg = DECODE_RM_LONG_REGISTER(rh);
             DECODE_PRINTF(",");
             srcreg = DECODE_RM_LONG_REGISTER(rl);
             imm = fetch_byte_imm();
-            DECODE_PRINTF2(",%d\n", (s32)imm);
+            DECODE_PRINTF2(",%d\n", (s32) imm);
             TRACE_AND_STEP();
-            imul_long_direct(&res_lo,&res_hi,(s32)*srcreg,(s32)imm);
+            imul_long_direct(&res_lo, &res_hi, (s32) * srcreg, (s32) imm);
             if (res_hi != 0) {
                 SET_FLAG(F_CF);
                 SET_FLAG(F_OF);
-            } else {
+            }
+            else {
                 CLEAR_FLAG(F_CF);
                 CLEAR_FLAG(F_OF);
             }
-            *destreg = (u32)res_lo;
-        } else {
-            u16 *destreg,*srcreg;
+            *destreg = (u32) res_lo;
+        }
+        else {
+            u16 *destreg, *srcreg;
             u32 res;
 
             destreg = DECODE_RM_WORD_REGISTER(rh);
             DECODE_PRINTF(",");
             srcreg = DECODE_RM_WORD_REGISTER(rl);
             imm = fetch_byte_imm();
-            DECODE_PRINTF2(",%d\n", (s32)imm);
-            res = (s16)*srcreg * (s16)imm;
+            DECODE_PRINTF2(",%d\n", (s32) imm);
+            res = (s16) * srcreg * (s16) imm;
             if (res > 0xFFFF) {
                 SET_FLAG(F_CF);
                 SET_FLAG(F_OF);
-            } else {
+            }
+            else {
                 CLEAR_FLAG(F_CF);
                 CLEAR_FLAG(F_OF);
             }
-            *destreg = (u16)res;
+            *destreg = (u16) res;
         }
         break;
     }
@@ -4754,7 +5042,8 @@ static void x86emuOp_imul_byte_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x6c
 ****************************************************************************/
-static void x86emuOp_ins_byte(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_ins_byte(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     DECODE_PRINTF("INSB\n");
@@ -4768,13 +5057,15 @@ static void x86emuOp_ins_byte(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x6d
 ****************************************************************************/
-static void x86emuOp_ins_word(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_ins_word(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("INSD\n");
         ins(4);
-    } else {
+    }
+    else {
         DECODE_PRINTF("INSW\n");
         ins(2);
     }
@@ -4787,7 +5078,8 @@ static void x86emuOp_ins_word(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x6e
 ****************************************************************************/
-static void x86emuOp_outs_byte(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_outs_byte(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     DECODE_PRINTF("OUTSB\n");
@@ -4801,13 +5093,15 @@ static void x86emuOp_outs_byte(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x6f
 ****************************************************************************/
-static void x86emuOp_outs_word(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_outs_word(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("OUTSD\n");
         outs(4);
-    } else {
+    }
+    else {
         DECODE_PRINTF("OUTSW\n");
         outs(2);
     }
@@ -4820,7 +5114,8 @@ static void x86emuOp_outs_word(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x70
 ****************************************************************************/
-static void x86emuOp_jump_near_O(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_jump_near_O(u8 X86EMU_UNUSED(op1))
 {
     s8 offset;
     u16 target;
@@ -4828,8 +5123,8 @@ static void x86emuOp_jump_near_O(u8 X86EMU_UNUSED(op1))
     /* jump to byte offset if overflow flag is set */
     START_OF_INSTR();
     DECODE_PRINTF("JO\t");
-    offset = (s8)fetch_byte_imm();
-    target = (u16)(M.x86.R_IP + (s16)offset);
+    offset = (s8) fetch_byte_imm();
+    target = (u16) (M.x86.R_IP + (s16) offset);
     DECODE_PRINTF2("%x\n", target);
     TRACE_AND_STEP();
     if (ACCESS_FLAG(F_OF))
@@ -4842,7 +5137,8 @@ static void x86emuOp_jump_near_O(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x71
 ****************************************************************************/
-static void x86emuOp_jump_near_NO(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_jump_near_NO(u8 X86EMU_UNUSED(op1))
 {
     s8 offset;
     u16 target;
@@ -4850,8 +5146,8 @@ static void x86emuOp_jump_near_NO(u8 X86EMU_UNUSED(op1))
     /* jump to byte offset if overflow is not set */
     START_OF_INSTR();
     DECODE_PRINTF("JNO\t");
-    offset = (s8)fetch_byte_imm();
-    target = (u16)(M.x86.R_IP + (s16)offset);
+    offset = (s8) fetch_byte_imm();
+    target = (u16) (M.x86.R_IP + (s16) offset);
     DECODE_PRINTF2("%x\n", target);
     TRACE_AND_STEP();
     if (!ACCESS_FLAG(F_OF))
@@ -4864,7 +5160,8 @@ static void x86emuOp_jump_near_NO(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x72
 ****************************************************************************/
-static void x86emuOp_jump_near_B(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_jump_near_B(u8 X86EMU_UNUSED(op1))
 {
     s8 offset;
     u16 target;
@@ -4872,8 +5169,8 @@ static void x86emuOp_jump_near_B(u8 X86EMU_UNUSED(op1))
     /* jump to byte offset if carry flag is set. */
     START_OF_INSTR();
     DECODE_PRINTF("JB\t");
-    offset = (s8)fetch_byte_imm();
-    target = (u16)(M.x86.R_IP + (s16)offset);
+    offset = (s8) fetch_byte_imm();
+    target = (u16) (M.x86.R_IP + (s16) offset);
     DECODE_PRINTF2("%x\n", target);
     TRACE_AND_STEP();
     if (ACCESS_FLAG(F_CF))
@@ -4886,7 +5183,8 @@ static void x86emuOp_jump_near_B(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x73
 ****************************************************************************/
-static void x86emuOp_jump_near_NB(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_jump_near_NB(u8 X86EMU_UNUSED(op1))
 {
     s8 offset;
     u16 target;
@@ -4894,8 +5192,8 @@ static void x86emuOp_jump_near_NB(u8 X86EMU_UNUSED(op1))
     /* jump to byte offset if carry flag is clear. */
     START_OF_INSTR();
     DECODE_PRINTF("JNB\t");
-    offset = (s8)fetch_byte_imm();
-    target = (u16)(M.x86.R_IP + (s16)offset);
+    offset = (s8) fetch_byte_imm();
+    target = (u16) (M.x86.R_IP + (s16) offset);
     DECODE_PRINTF2("%x\n", target);
     TRACE_AND_STEP();
     if (!ACCESS_FLAG(F_CF))
@@ -4908,7 +5206,8 @@ static void x86emuOp_jump_near_NB(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x74
 ****************************************************************************/
-static void x86emuOp_jump_near_Z(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_jump_near_Z(u8 X86EMU_UNUSED(op1))
 {
     s8 offset;
     u16 target;
@@ -4916,8 +5215,8 @@ static void x86emuOp_jump_near_Z(u8 X86EMU_UNUSED(op1))
     /* jump to byte offset if zero flag is set. */
     START_OF_INSTR();
     DECODE_PRINTF("JZ\t");
-    offset = (s8)fetch_byte_imm();
-    target = (u16)(M.x86.R_IP + (s16)offset);
+    offset = (s8) fetch_byte_imm();
+    target = (u16) (M.x86.R_IP + (s16) offset);
     DECODE_PRINTF2("%x\n", target);
     TRACE_AND_STEP();
     if (ACCESS_FLAG(F_ZF))
@@ -4930,7 +5229,8 @@ static void x86emuOp_jump_near_Z(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x75
 ****************************************************************************/
-static void x86emuOp_jump_near_NZ(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_jump_near_NZ(u8 X86EMU_UNUSED(op1))
 {
     s8 offset;
     u16 target;
@@ -4938,8 +5238,8 @@ static void x86emuOp_jump_near_NZ(u8 X86EMU_UNUSED(op1))
     /* jump to byte offset if zero flag is clear. */
     START_OF_INSTR();
     DECODE_PRINTF("JNZ\t");
-    offset = (s8)fetch_byte_imm();
-    target = (u16)(M.x86.R_IP + (s16)offset);
+    offset = (s8) fetch_byte_imm();
+    target = (u16) (M.x86.R_IP + (s16) offset);
     DECODE_PRINTF2("%x\n", target);
     TRACE_AND_STEP();
     if (!ACCESS_FLAG(F_ZF))
@@ -4952,7 +5252,8 @@ static void x86emuOp_jump_near_NZ(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x76
 ****************************************************************************/
-static void x86emuOp_jump_near_BE(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_jump_near_BE(u8 X86EMU_UNUSED(op1))
 {
     s8 offset;
     u16 target;
@@ -4961,8 +5262,8 @@ static void x86emuOp_jump_near_BE(u8 X86EMU_UNUSED(op1))
        flag is set. */
     START_OF_INSTR();
     DECODE_PRINTF("JBE\t");
-    offset = (s8)fetch_byte_imm();
-    target = (u16)(M.x86.R_IP + (s16)offset);
+    offset = (s8) fetch_byte_imm();
+    target = (u16) (M.x86.R_IP + (s16) offset);
     DECODE_PRINTF2("%x\n", target);
     TRACE_AND_STEP();
     if (ACCESS_FLAG(F_CF) || ACCESS_FLAG(F_ZF))
@@ -4975,7 +5276,8 @@ static void x86emuOp_jump_near_BE(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x77
 ****************************************************************************/
-static void x86emuOp_jump_near_NBE(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_jump_near_NBE(u8 X86EMU_UNUSED(op1))
 {
     s8 offset;
     u16 target;
@@ -4984,8 +5286,8 @@ static void x86emuOp_jump_near_NBE(u8 X86EMU_UNUSED(op1))
        flag is clear */
     START_OF_INSTR();
     DECODE_PRINTF("JNBE\t");
-    offset = (s8)fetch_byte_imm();
-    target = (u16)(M.x86.R_IP + (s16)offset);
+    offset = (s8) fetch_byte_imm();
+    target = (u16) (M.x86.R_IP + (s16) offset);
     DECODE_PRINTF2("%x\n", target);
     TRACE_AND_STEP();
     if (!(ACCESS_FLAG(F_CF) || ACCESS_FLAG(F_ZF)))
@@ -4998,7 +5300,8 @@ static void x86emuOp_jump_near_NBE(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x78
 ****************************************************************************/
-static void x86emuOp_jump_near_S(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_jump_near_S(u8 X86EMU_UNUSED(op1))
 {
     s8 offset;
     u16 target;
@@ -5006,8 +5309,8 @@ static void x86emuOp_jump_near_S(u8 X86EMU_UNUSED(op1))
     /* jump to byte offset if sign flag is set */
     START_OF_INSTR();
     DECODE_PRINTF("JS\t");
-    offset = (s8)fetch_byte_imm();
-    target = (u16)(M.x86.R_IP + (s16)offset);
+    offset = (s8) fetch_byte_imm();
+    target = (u16) (M.x86.R_IP + (s16) offset);
     DECODE_PRINTF2("%x\n", target);
     TRACE_AND_STEP();
     if (ACCESS_FLAG(F_SF))
@@ -5020,7 +5323,8 @@ static void x86emuOp_jump_near_S(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x79
 ****************************************************************************/
-static void x86emuOp_jump_near_NS(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_jump_near_NS(u8 X86EMU_UNUSED(op1))
 {
     s8 offset;
     u16 target;
@@ -5028,8 +5332,8 @@ static void x86emuOp_jump_near_NS(u8 X86EMU_UNUSED(op1))
     /* jump to byte offset if sign flag is clear */
     START_OF_INSTR();
     DECODE_PRINTF("JNS\t");
-    offset = (s8)fetch_byte_imm();
-    target = (u16)(M.x86.R_IP + (s16)offset);
+    offset = (s8) fetch_byte_imm();
+    target = (u16) (M.x86.R_IP + (s16) offset);
     DECODE_PRINTF2("%x\n", target);
     TRACE_AND_STEP();
     if (!ACCESS_FLAG(F_SF))
@@ -5042,7 +5346,8 @@ static void x86emuOp_jump_near_NS(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x7a
 ****************************************************************************/
-static void x86emuOp_jump_near_P(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_jump_near_P(u8 X86EMU_UNUSED(op1))
 {
     s8 offset;
     u16 target;
@@ -5050,8 +5355,8 @@ static void x86emuOp_jump_near_P(u8 X86EMU_UNUSED(op1))
     /* jump to byte offset if parity flag is set (even parity) */
     START_OF_INSTR();
     DECODE_PRINTF("JP\t");
-    offset = (s8)fetch_byte_imm();
-    target = (u16)(M.x86.R_IP + (s16)offset);
+    offset = (s8) fetch_byte_imm();
+    target = (u16) (M.x86.R_IP + (s16) offset);
     DECODE_PRINTF2("%x\n", target);
     TRACE_AND_STEP();
     if (ACCESS_FLAG(F_PF))
@@ -5064,7 +5369,8 @@ static void x86emuOp_jump_near_P(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x7b
 ****************************************************************************/
-static void x86emuOp_jump_near_NP(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_jump_near_NP(u8 X86EMU_UNUSED(op1))
 {
     s8 offset;
     u16 target;
@@ -5072,8 +5378,8 @@ static void x86emuOp_jump_near_NP(u8 X86EMU_UNUSED(op1))
     /* jump to byte offset if parity flag is clear (odd parity) */
     START_OF_INSTR();
     DECODE_PRINTF("JNP\t");
-    offset = (s8)fetch_byte_imm();
-    target = (u16)(M.x86.R_IP + (s16)offset);
+    offset = (s8) fetch_byte_imm();
+    target = (u16) (M.x86.R_IP + (s16) offset);
     DECODE_PRINTF2("%x\n", target);
     TRACE_AND_STEP();
     if (!ACCESS_FLAG(F_PF))
@@ -5086,7 +5392,8 @@ static void x86emuOp_jump_near_NP(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x7c
 ****************************************************************************/
-static void x86emuOp_jump_near_L(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_jump_near_L(u8 X86EMU_UNUSED(op1))
 {
     s8 offset;
     u16 target;
@@ -5095,8 +5402,8 @@ static void x86emuOp_jump_near_L(u8 X86EMU_UNUSED(op1))
     /* jump to byte offset if sign flag not equal to overflow flag. */
     START_OF_INSTR();
     DECODE_PRINTF("JL\t");
-    offset = (s8)fetch_byte_imm();
-    target = (u16)(M.x86.R_IP + (s16)offset);
+    offset = (s8) fetch_byte_imm();
+    target = (u16) (M.x86.R_IP + (s16) offset);
     DECODE_PRINTF2("%x\n", target);
     TRACE_AND_STEP();
     sf = ACCESS_FLAG(F_SF) != 0;
@@ -5111,7 +5418,8 @@ static void x86emuOp_jump_near_L(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x7d
 ****************************************************************************/
-static void x86emuOp_jump_near_NL(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_jump_near_NL(u8 X86EMU_UNUSED(op1))
 {
     s8 offset;
     u16 target;
@@ -5120,8 +5428,8 @@ static void x86emuOp_jump_near_NL(u8 X86EMU_UNUSED(op1))
     /* jump to byte offset if sign flag not equal to overflow flag. */
     START_OF_INSTR();
     DECODE_PRINTF("JNL\t");
-    offset = (s8)fetch_byte_imm();
-    target = (u16)(M.x86.R_IP + (s16)offset);
+    offset = (s8) fetch_byte_imm();
+    target = (u16) (M.x86.R_IP + (s16) offset);
     DECODE_PRINTF2("%x\n", target);
     TRACE_AND_STEP();
     sf = ACCESS_FLAG(F_SF) != 0;
@@ -5137,7 +5445,8 @@ static void x86emuOp_jump_near_NL(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x7e
 ****************************************************************************/
-static void x86emuOp_jump_near_LE(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_jump_near_LE(u8 X86EMU_UNUSED(op1))
 {
     s8 offset;
     u16 target;
@@ -5147,8 +5456,8 @@ static void x86emuOp_jump_near_LE(u8 X86EMU_UNUSED(op1))
        or the zero flag is set */
     START_OF_INSTR();
     DECODE_PRINTF("JLE\t");
-    offset = (s8)fetch_byte_imm();
-    target = (u16)(M.x86.R_IP + (s16)offset);
+    offset = (s8) fetch_byte_imm();
+    target = (u16) (M.x86.R_IP + (s16) offset);
     DECODE_PRINTF2("%x\n", target);
     TRACE_AND_STEP();
     sf = ACCESS_FLAG(F_SF) != 0;
@@ -5163,7 +5472,8 @@ static void x86emuOp_jump_near_LE(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x7f
 ****************************************************************************/
-static void x86emuOp_jump_near_NLE(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_jump_near_NLE(u8 X86EMU_UNUSED(op1))
 {
     s8 offset;
     u16 target;
@@ -5173,8 +5483,8 @@ static void x86emuOp_jump_near_NLE(u8 X86EMU_UNUSED(op1))
        and the zero flag is clear */
     START_OF_INSTR();
     DECODE_PRINTF("JNLE\t");
-    offset = (s8)fetch_byte_imm();
-    target = (u16)(M.x86.R_IP + (s16)offset);
+    offset = (s8) fetch_byte_imm();
+    target = (u16) (M.x86.R_IP + (s16) offset);
     DECODE_PRINTF2("%x\n", target);
     TRACE_AND_STEP();
     sf = ACCESS_FLAG(F_SF) != 0;
@@ -5185,23 +5495,23 @@ static void x86emuOp_jump_near_NLE(u8 X86EMU_UNUSED(op1))
     END_OF_INSTR();
 }
 
-static u8 (*opc80_byte_operation[])(u8 d, u8 s) =
-{
-    add_byte,           /* 00 */
-    or_byte,            /* 01 */
-    adc_byte,           /* 02 */
-    sbb_byte,           /* 03 */
-    and_byte,           /* 04 */
-    sub_byte,           /* 05 */
-    xor_byte,           /* 06 */
-    cmp_byte,           /* 07 */
+static u8(*opc80_byte_operation[]) (u8 d, u8 s) = {
+    add_byte,                   /* 00 */
+        or_byte,                /* 01 */
+        adc_byte,               /* 02 */
+        sbb_byte,               /* 03 */
+        and_byte,               /* 04 */
+        sub_byte,               /* 05 */
+        xor_byte,               /* 06 */
+        cmp_byte,               /* 07 */
 };
 
 /****************************************************************************
 REMARKS:
 Handles opcode 0x80
 ****************************************************************************/
-static void x86emuOp_opc80_byte_RM_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_opc80_byte_RM_IMM(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     u8 *destreg;
@@ -5290,7 +5600,7 @@ static void x86emuOp_opc80_byte_RM_IMM(u8 X86EMU_UNUSED(op1))
         if (rh != 7)
             store_data_byte(destoffset, destval);
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         destreg = DECODE_RM_BYTE_REGISTER(rl);
         DECODE_PRINTF(",");
         imm = fetch_byte_imm();
@@ -5305,35 +5615,34 @@ static void x86emuOp_opc80_byte_RM_IMM(u8 X86EMU_UNUSED(op1))
     END_OF_INSTR();
 }
 
-static u16 (*opc81_word_operation[])(u16 d, u16 s) =
-{
-    add_word,           /*00 */
-    or_word,            /*01 */
-    adc_word,           /*02 */
-    sbb_word,           /*03 */
-    and_word,           /*04 */
-    sub_word,           /*05 */
-    xor_word,           /*06 */
-    cmp_word,           /*07 */
+static u16(*opc81_word_operation[]) (u16 d, u16 s) = {
+    add_word,                   /*00 */
+        or_word,                /*01 */
+        adc_word,               /*02 */
+        sbb_word,               /*03 */
+        and_word,               /*04 */
+        sub_word,               /*05 */
+        xor_word,               /*06 */
+        cmp_word,               /*07 */
 };
 
-static u32 (*opc81_long_operation[])(u32 d, u32 s) =
-{
-    add_long,           /*00 */
-    or_long,            /*01 */
-    adc_long,           /*02 */
-    sbb_long,           /*03 */
-    and_long,           /*04 */
-    sub_long,           /*05 */
-    xor_long,           /*06 */
-    cmp_long,           /*07 */
+static u32(*opc81_long_operation[]) (u32 d, u32 s) = {
+    add_long,                   /*00 */
+        or_long,                /*01 */
+        adc_long,               /*02 */
+        sbb_long,               /*03 */
+        and_long,               /*04 */
+        sub_long,               /*05 */
+        xor_long,               /*06 */
+        cmp_long,               /*07 */
 };
 
 /****************************************************************************
 REMARKS:
 Handles opcode 0x81
 ****************************************************************************/
-static void x86emuOp_opc81_word_RM_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_opc81_word_RM_IMM(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     uint destoffset;
@@ -5387,7 +5696,7 @@ static void x86emuOp_opc81_word_RM_IMM(u8 X86EMU_UNUSED(op1))
     switch (mod) {
     case 0:
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-            u32 destval,imm;
+            u32 destval, imm;
 
             DECODE_PRINTF("DWORD PTR ");
             destoffset = decode_rm00_address(rl);
@@ -5399,8 +5708,9 @@ static void x86emuOp_opc81_word_RM_IMM(u8 X86EMU_UNUSED(op1))
             destval = (*opc81_long_operation[rh]) (destval, imm);
             if (rh != 7)
                 store_data_long(destoffset, destval);
-        } else {
-            u16 destval,imm;
+        }
+        else {
+            u16 destval, imm;
 
             DECODE_PRINTF("WORD PTR ");
             destoffset = decode_rm00_address(rl);
@@ -5416,7 +5726,7 @@ static void x86emuOp_opc81_word_RM_IMM(u8 X86EMU_UNUSED(op1))
         break;
     case 1:
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-            u32 destval,imm;
+            u32 destval, imm;
 
             DECODE_PRINTF("DWORD PTR ");
             destoffset = decode_rm01_address(rl);
@@ -5428,8 +5738,9 @@ static void x86emuOp_opc81_word_RM_IMM(u8 X86EMU_UNUSED(op1))
             destval = (*opc81_long_operation[rh]) (destval, imm);
             if (rh != 7)
                 store_data_long(destoffset, destval);
-        } else {
-            u16 destval,imm;
+        }
+        else {
+            u16 destval, imm;
 
             DECODE_PRINTF("WORD PTR ");
             destoffset = decode_rm01_address(rl);
@@ -5445,7 +5756,7 @@ static void x86emuOp_opc81_word_RM_IMM(u8 X86EMU_UNUSED(op1))
         break;
     case 2:
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-            u32 destval,imm;
+            u32 destval, imm;
 
             DECODE_PRINTF("DWORD PTR ");
             destoffset = decode_rm10_address(rl);
@@ -5457,8 +5768,9 @@ static void x86emuOp_opc81_word_RM_IMM(u8 X86EMU_UNUSED(op1))
             destval = (*opc81_long_operation[rh]) (destval, imm);
             if (rh != 7)
                 store_data_long(destoffset, destval);
-        } else {
-            u16 destval,imm;
+        }
+        else {
+            u16 destval, imm;
 
             DECODE_PRINTF("WORD PTR ");
             destoffset = decode_rm10_address(rl);
@@ -5472,10 +5784,10 @@ static void x86emuOp_opc81_word_RM_IMM(u8 X86EMU_UNUSED(op1))
                 store_data_word(destoffset, destval);
         }
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
             u32 *destreg;
-            u32 destval,imm;
+            u32 destval, imm;
 
             destreg = DECODE_RM_LONG_REGISTER(rl);
             DECODE_PRINTF(",");
@@ -5485,9 +5797,10 @@ static void x86emuOp_opc81_word_RM_IMM(u8 X86EMU_UNUSED(op1))
             destval = (*opc81_long_operation[rh]) (*destreg, imm);
             if (rh != 7)
                 *destreg = destval;
-        } else {
+        }
+        else {
             u16 *destreg;
-            u16 destval,imm;
+            u16 destval, imm;
 
             destreg = DECODE_RM_WORD_REGISTER(rl);
             DECODE_PRINTF(",");
@@ -5504,23 +5817,23 @@ static void x86emuOp_opc81_word_RM_IMM(u8 X86EMU_UNUSED(op1))
     END_OF_INSTR();
 }
 
-static u8 (*opc82_byte_operation[])(u8 s, u8 d) =
-{
-    add_byte,           /*00 */
-    or_byte,            /*01 *//*YYY UNUSED ???? */
-    adc_byte,           /*02 */
-    sbb_byte,           /*03 */
-    and_byte,           /*04 *//*YYY UNUSED ???? */
-    sub_byte,           /*05 */
-    xor_byte,           /*06 *//*YYY UNUSED ???? */
-    cmp_byte,           /*07 */
+static u8(*opc82_byte_operation[]) (u8 s, u8 d) = {
+    add_byte,                   /*00 */
+        or_byte,                /*01 *//*YYY UNUSED ???? */
+        adc_byte,               /*02 */
+        sbb_byte,               /*03 */
+        and_byte,               /*04 *//*YYY UNUSED ???? */
+        sub_byte,               /*05 */
+        xor_byte,               /*06 *//*YYY UNUSED ???? */
+        cmp_byte,               /*07 */
 };
 
 /****************************************************************************
 REMARKS:
 Handles opcode 0x82
 ****************************************************************************/
-static void x86emuOp_opc82_byte_RM_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_opc82_byte_RM_IMM(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     u8 *destreg;
@@ -5606,7 +5919,7 @@ static void x86emuOp_opc82_byte_RM_IMM(u8 X86EMU_UNUSED(op1))
         if (rh != 7)
             store_data_byte(destoffset, destval);
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         destreg = DECODE_RM_BYTE_REGISTER(rl);
         imm = fetch_byte_imm();
         DECODE_PRINTF2(",%x\n", imm);
@@ -5620,35 +5933,34 @@ static void x86emuOp_opc82_byte_RM_IMM(u8 X86EMU_UNUSED(op1))
     END_OF_INSTR();
 }
 
-static u16 (*opc83_word_operation[])(u16 s, u16 d) =
-{
-    add_word,           /*00 */
-    or_word,            /*01 *//*YYY UNUSED ???? */
-    adc_word,           /*02 */
-    sbb_word,           /*03 */
-    and_word,           /*04 *//*YYY UNUSED ???? */
-    sub_word,           /*05 */
-    xor_word,           /*06 *//*YYY UNUSED ???? */
-    cmp_word,           /*07 */
+static u16(*opc83_word_operation[]) (u16 s, u16 d) = {
+    add_word,                   /*00 */
+        or_word,                /*01 *//*YYY UNUSED ???? */
+        adc_word,               /*02 */
+        sbb_word,               /*03 */
+        and_word,               /*04 *//*YYY UNUSED ???? */
+        sub_word,               /*05 */
+        xor_word,               /*06 *//*YYY UNUSED ???? */
+        cmp_word,               /*07 */
 };
 
-static u32 (*opc83_long_operation[])(u32 s, u32 d) =
-{
-    add_long,           /*00 */
-    or_long,            /*01 *//*YYY UNUSED ???? */
-    adc_long,           /*02 */
-    sbb_long,           /*03 */
-    and_long,           /*04 *//*YYY UNUSED ???? */
-    sub_long,           /*05 */
-    xor_long,           /*06 *//*YYY UNUSED ???? */
-    cmp_long,           /*07 */
+static u32(*opc83_long_operation[]) (u32 s, u32 d) = {
+    add_long,                   /*00 */
+        or_long,                /*01 *//*YYY UNUSED ???? */
+        adc_long,               /*02 */
+        sbb_long,               /*03 */
+        and_long,               /*04 *//*YYY UNUSED ???? */
+        sub_long,               /*05 */
+        xor_long,               /*06 *//*YYY UNUSED ???? */
+        cmp_long,               /*07 */
 };
 
 /****************************************************************************
 REMARKS:
 Handles opcode 0x83
 ****************************************************************************/
-static void x86emuOp_opc83_word_RM_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_opc83_word_RM_IMM(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     uint destoffset;
@@ -5667,7 +5979,7 @@ static void x86emuOp_opc83_word_RM_IMM(u8 X86EMU_UNUSED(op1))
            general, so that it is important to leave the strings
            in the same format, even though the result is that the 
            above test is done twice. */
-       switch (rh) {
+        switch (rh) {
         case 0:
             DECODE_PRINTF("ADD\t");
             break;
@@ -5700,7 +6012,7 @@ static void x86emuOp_opc83_word_RM_IMM(u8 X86EMU_UNUSED(op1))
     switch (mod) {
     case 0:
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-            u32 destval,imm;
+            u32 destval, imm;
 
             DECODE_PRINTF("DWORD PTR ");
             destoffset = decode_rm00_address(rl);
@@ -5711,8 +6023,9 @@ static void x86emuOp_opc83_word_RM_IMM(u8 X86EMU_UNUSED(op1))
             destval = (*opc83_long_operation[rh]) (destval, imm);
             if (rh != 7)
                 store_data_long(destoffset, destval);
-        } else {
-            u16 destval,imm;
+        }
+        else {
+            u16 destval, imm;
 
             DECODE_PRINTF("WORD PTR ");
             destoffset = decode_rm00_address(rl);
@@ -5727,7 +6040,7 @@ static void x86emuOp_opc83_word_RM_IMM(u8 X86EMU_UNUSED(op1))
         break;
     case 1:
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-            u32 destval,imm;
+            u32 destval, imm;
 
             DECODE_PRINTF("DWORD PTR ");
             destoffset = decode_rm01_address(rl);
@@ -5738,8 +6051,9 @@ static void x86emuOp_opc83_word_RM_IMM(u8 X86EMU_UNUSED(op1))
             destval = (*opc83_long_operation[rh]) (destval, imm);
             if (rh != 7)
                 store_data_long(destoffset, destval);
-        } else {
-            u16 destval,imm;
+        }
+        else {
+            u16 destval, imm;
 
             DECODE_PRINTF("WORD PTR ");
             destoffset = decode_rm01_address(rl);
@@ -5754,7 +6068,7 @@ static void x86emuOp_opc83_word_RM_IMM(u8 X86EMU_UNUSED(op1))
         break;
     case 2:
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-            u32 destval,imm;
+            u32 destval, imm;
 
             DECODE_PRINTF("DWORD PTR ");
             destoffset = decode_rm10_address(rl);
@@ -5765,8 +6079,9 @@ static void x86emuOp_opc83_word_RM_IMM(u8 X86EMU_UNUSED(op1))
             destval = (*opc83_long_operation[rh]) (destval, imm);
             if (rh != 7)
                 store_data_long(destoffset, destval);
-        } else {
-            u16 destval,imm;
+        }
+        else {
+            u16 destval, imm;
 
             DECODE_PRINTF("WORD PTR ");
             destoffset = decode_rm10_address(rl);
@@ -5779,10 +6094,10 @@ static void x86emuOp_opc83_word_RM_IMM(u8 X86EMU_UNUSED(op1))
                 store_data_word(destoffset, destval);
         }
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
             u32 *destreg;
-            u32 destval,imm;
+            u32 destval, imm;
 
             destreg = DECODE_RM_LONG_REGISTER(rl);
             imm = (s8) fetch_byte_imm();
@@ -5791,9 +6106,10 @@ static void x86emuOp_opc83_word_RM_IMM(u8 X86EMU_UNUSED(op1))
             destval = (*opc83_long_operation[rh]) (*destreg, imm);
             if (rh != 7)
                 *destreg = destval;
-        } else {
+        }
+        else {
             u16 *destreg;
-            u16 destval,imm;
+            u16 destval, imm;
 
             destreg = DECODE_RM_WORD_REGISTER(rl);
             imm = (s8) fetch_byte_imm();
@@ -5813,7 +6129,8 @@ static void x86emuOp_opc83_word_RM_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x84
 ****************************************************************************/
-static void x86emuOp_test_byte_RM_R(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_test_byte_RM_R(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     u8 *destreg, *srcreg;
@@ -5851,7 +6168,7 @@ static void x86emuOp_test_byte_RM_R(u8 X86EMU_UNUSED(op1))
         TRACE_AND_STEP();
         test_byte(destval, *srcreg);
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         destreg = DECODE_RM_BYTE_REGISTER(rl);
         DECODE_PRINTF(",");
         srcreg = DECODE_RM_BYTE_REGISTER(rh);
@@ -5868,7 +6185,8 @@ static void x86emuOp_test_byte_RM_R(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x85
 ****************************************************************************/
-static void x86emuOp_test_word_RM_R(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_test_word_RM_R(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     uint destoffset;
@@ -5889,7 +6207,8 @@ static void x86emuOp_test_word_RM_R(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             test_long(destval, *srcreg);
-        } else {
+        }
+        else {
             u16 destval;
             u16 *srcreg;
 
@@ -5914,7 +6233,8 @@ static void x86emuOp_test_word_RM_R(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             test_long(destval, *srcreg);
-        } else {
+        }
+        else {
             u16 destval;
             u16 *srcreg;
 
@@ -5939,7 +6259,8 @@ static void x86emuOp_test_word_RM_R(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             test_long(destval, *srcreg);
-        } else {
+        }
+        else {
             u16 destval;
             u16 *srcreg;
 
@@ -5952,9 +6273,9 @@ static void x86emuOp_test_word_RM_R(u8 X86EMU_UNUSED(op1))
             test_word(destval, *srcreg);
         }
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-            u32 *destreg,*srcreg;
+            u32 *destreg, *srcreg;
 
             destreg = DECODE_RM_LONG_REGISTER(rl);
             DECODE_PRINTF(",");
@@ -5962,8 +6283,9 @@ static void x86emuOp_test_word_RM_R(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             test_long(*destreg, *srcreg);
-        } else {
-            u16 *destreg,*srcreg;
+        }
+        else {
+            u16 *destreg, *srcreg;
 
             destreg = DECODE_RM_WORD_REGISTER(rl);
             DECODE_PRINTF(",");
@@ -5982,7 +6304,8 @@ static void x86emuOp_test_word_RM_R(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x86
 ****************************************************************************/
-static void x86emuOp_xchg_byte_RM_R(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_xchg_byte_RM_R(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     u8 *destreg, *srcreg;
@@ -6030,7 +6353,7 @@ static void x86emuOp_xchg_byte_RM_R(u8 X86EMU_UNUSED(op1))
         destval = tmp;
         store_data_byte(destoffset, destval);
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         destreg = DECODE_RM_BYTE_REGISTER(rl);
         DECODE_PRINTF(",");
         srcreg = DECODE_RM_BYTE_REGISTER(rh);
@@ -6049,7 +6372,8 @@ static void x86emuOp_xchg_byte_RM_R(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x87
 ****************************************************************************/
-static void x86emuOp_xchg_word_RM_R(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_xchg_word_RM_R(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     uint destoffset;
@@ -6061,7 +6385,7 @@ static void x86emuOp_xchg_word_RM_R(u8 X86EMU_UNUSED(op1))
     case 0:
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
             u32 *srcreg;
-            u32 destval,tmp;
+            u32 destval, tmp;
 
             destoffset = decode_rm00_address(rl);
             DECODE_PRINTF(",");
@@ -6073,9 +6397,10 @@ static void x86emuOp_xchg_word_RM_R(u8 X86EMU_UNUSED(op1))
             *srcreg = destval;
             destval = tmp;
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 *srcreg;
-            u16 destval,tmp;
+            u16 destval, tmp;
 
             destoffset = decode_rm00_address(rl);
             DECODE_PRINTF(",");
@@ -6092,7 +6417,7 @@ static void x86emuOp_xchg_word_RM_R(u8 X86EMU_UNUSED(op1))
     case 1:
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
             u32 *srcreg;
-            u32 destval,tmp;
+            u32 destval, tmp;
 
             destoffset = decode_rm01_address(rl);
             DECODE_PRINTF(",");
@@ -6104,9 +6429,10 @@ static void x86emuOp_xchg_word_RM_R(u8 X86EMU_UNUSED(op1))
             *srcreg = destval;
             destval = tmp;
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 *srcreg;
-            u16 destval,tmp;
+            u16 destval, tmp;
 
             destoffset = decode_rm01_address(rl);
             DECODE_PRINTF(",");
@@ -6123,7 +6449,7 @@ static void x86emuOp_xchg_word_RM_R(u8 X86EMU_UNUSED(op1))
     case 2:
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
             u32 *srcreg;
-            u32 destval,tmp;
+            u32 destval, tmp;
 
             destoffset = decode_rm10_address(rl);
             DECODE_PRINTF(",");
@@ -6135,9 +6461,10 @@ static void x86emuOp_xchg_word_RM_R(u8 X86EMU_UNUSED(op1))
             *srcreg = destval;
             destval = tmp;
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 *srcreg;
-            u16 destval,tmp;
+            u16 destval, tmp;
 
             destoffset = decode_rm10_address(rl);
             DECODE_PRINTF(",");
@@ -6151,9 +6478,9 @@ static void x86emuOp_xchg_word_RM_R(u8 X86EMU_UNUSED(op1))
             store_data_word(destoffset, destval);
         }
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-            u32 *destreg,*srcreg;
+            u32 *destreg, *srcreg;
             u32 tmp;
 
             destreg = DECODE_RM_LONG_REGISTER(rl);
@@ -6164,8 +6491,9 @@ static void x86emuOp_xchg_word_RM_R(u8 X86EMU_UNUSED(op1))
             tmp = *srcreg;
             *srcreg = *destreg;
             *destreg = tmp;
-        } else {
-            u16 *destreg,*srcreg;
+        }
+        else {
+            u16 *destreg, *srcreg;
             u16 tmp;
 
             destreg = DECODE_RM_WORD_REGISTER(rl);
@@ -6187,7 +6515,8 @@ static void x86emuOp_xchg_word_RM_R(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x88
 ****************************************************************************/
-static void x86emuOp_mov_byte_RM_R(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_mov_byte_RM_R(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     u8 *destreg, *srcreg;
@@ -6221,7 +6550,7 @@ static void x86emuOp_mov_byte_RM_R(u8 X86EMU_UNUSED(op1))
         TRACE_AND_STEP();
         store_data_byte(destoffset, *srcreg);
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         destreg = DECODE_RM_BYTE_REGISTER(rl);
         DECODE_PRINTF(",");
         srcreg = DECODE_RM_BYTE_REGISTER(rh);
@@ -6238,7 +6567,8 @@ static void x86emuOp_mov_byte_RM_R(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x89
 ****************************************************************************/
-static void x86emuOp_mov_word_RM_R(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_mov_word_RM_R(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     u32 destoffset;
@@ -6257,7 +6587,8 @@ static void x86emuOp_mov_word_RM_R(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             store_data_long(destoffset, *srcreg);
-        } else {
+        }
+        else {
             u16 *srcreg;
 
             destoffset = decode_rm00_address(rl);
@@ -6278,7 +6609,8 @@ static void x86emuOp_mov_word_RM_R(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             store_data_long(destoffset, *srcreg);
-        } else {
+        }
+        else {
             u16 *srcreg;
 
             destoffset = decode_rm01_address(rl);
@@ -6299,7 +6631,8 @@ static void x86emuOp_mov_word_RM_R(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             store_data_long(destoffset, *srcreg);
-        } else {
+        }
+        else {
             u16 *srcreg;
 
             destoffset = decode_rm10_address(rl);
@@ -6310,9 +6643,9 @@ static void x86emuOp_mov_word_RM_R(u8 X86EMU_UNUSED(op1))
             store_data_word(destoffset, *srcreg);
         }
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-            u32 *destreg,*srcreg;
+            u32 *destreg, *srcreg;
 
             destreg = DECODE_RM_LONG_REGISTER(rl);
             DECODE_PRINTF(",");
@@ -6320,8 +6653,9 @@ static void x86emuOp_mov_word_RM_R(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = *srcreg;
-        } else {
-            u16 *destreg,*srcreg;
+        }
+        else {
+            u16 *destreg, *srcreg;
 
             destreg = DECODE_RM_WORD_REGISTER(rl);
             DECODE_PRINTF(",");
@@ -6340,7 +6674,8 @@ static void x86emuOp_mov_word_RM_R(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x8a
 ****************************************************************************/
-static void x86emuOp_mov_byte_R_RM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_mov_byte_R_RM(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     u8 *destreg, *srcreg;
@@ -6378,7 +6713,7 @@ static void x86emuOp_mov_byte_R_RM(u8 X86EMU_UNUSED(op1))
         TRACE_AND_STEP();
         *destreg = srcval;
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         destreg = DECODE_RM_BYTE_REGISTER(rh);
         DECODE_PRINTF(",");
         srcreg = DECODE_RM_BYTE_REGISTER(rl);
@@ -6395,7 +6730,8 @@ static void x86emuOp_mov_byte_R_RM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x8b
 ****************************************************************************/
-static void x86emuOp_mov_word_R_RM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_mov_word_R_RM(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     uint srcoffset;
@@ -6416,7 +6752,8 @@ static void x86emuOp_mov_word_R_RM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = srcval;
-        } else {
+        }
+        else {
             u16 *destreg;
             u16 srcval;
 
@@ -6441,7 +6778,8 @@ static void x86emuOp_mov_word_R_RM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = srcval;
-        } else {
+        }
+        else {
             u16 *destreg;
             u16 srcval;
 
@@ -6466,7 +6804,8 @@ static void x86emuOp_mov_word_R_RM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = srcval;
-        } else {
+        }
+        else {
             u16 *destreg;
             u16 srcval;
 
@@ -6479,7 +6818,7 @@ static void x86emuOp_mov_word_R_RM(u8 X86EMU_UNUSED(op1))
             *destreg = srcval;
         }
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
             u32 *destreg, *srcreg;
 
@@ -6489,7 +6828,8 @@ static void x86emuOp_mov_word_R_RM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = *srcreg;
-        } else {
+        }
+        else {
             u16 *destreg, *srcreg;
 
             destreg = DECODE_RM_WORD_REGISTER(rh);
@@ -6509,7 +6849,8 @@ static void x86emuOp_mov_word_R_RM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x8c
 ****************************************************************************/
-static void x86emuOp_mov_word_RM_SR(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_mov_word_RM_SR(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     u16 *destreg, *srcreg;
@@ -6547,7 +6888,7 @@ static void x86emuOp_mov_word_RM_SR(u8 X86EMU_UNUSED(op1))
         destval = *srcreg;
         store_data_word(destoffset, destval);
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         destreg = DECODE_RM_WORD_REGISTER(rl);
         DECODE_PRINTF(",");
         srcreg = decode_rm_seg_register(rh);
@@ -6564,47 +6905,77 @@ static void x86emuOp_mov_word_RM_SR(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x8d
 ****************************************************************************/
-static void x86emuOp_lea_word_R_M(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_lea_word_R_M(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
-    u16 *srcreg;
     uint destoffset;
 
-/*
- * TODO: Need to handle address size prefix!
- *
- * lea  eax,[eax+ebx*2] ??
- */
-    
     START_OF_INSTR();
     DECODE_PRINTF("LEA\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
     switch (mod) {
     case 0:
-        srcreg = DECODE_RM_WORD_REGISTER(rh);
-        DECODE_PRINTF(",");
-        destoffset = decode_rm00_address(rl);
-        DECODE_PRINTF("\n");
-        TRACE_AND_STEP();
-        *srcreg = (u16)destoffset;
+        if (M.x86.mode & SYSMODE_PREFIX_ADDR) {
+            u32 *srcreg = DECODE_RM_LONG_REGISTER(rh);
+
+            DECODE_PRINTF(",");
+            destoffset = decode_rm00_address(rl);
+            DECODE_PRINTF("\n");
+            TRACE_AND_STEP();
+            *srcreg = (u32) destoffset;
+        }
+        else {
+            u16 *srcreg = DECODE_RM_WORD_REGISTER(rh);
+
+            DECODE_PRINTF(",");
+            destoffset = decode_rm00_address(rl);
+            DECODE_PRINTF("\n");
+            TRACE_AND_STEP();
+            *srcreg = (u16) destoffset;
+        }
         break;
     case 1:
-        srcreg = DECODE_RM_WORD_REGISTER(rh);
-        DECODE_PRINTF(",");
-        destoffset = decode_rm01_address(rl);
-        DECODE_PRINTF("\n");
-        TRACE_AND_STEP();
-        *srcreg = (u16)destoffset;
+        if (M.x86.mode & SYSMODE_PREFIX_ADDR) {
+            u32 *srcreg = DECODE_RM_LONG_REGISTER(rh);
+
+            DECODE_PRINTF(",");
+            destoffset = decode_rm01_address(rl);
+            DECODE_PRINTF("\n");
+            TRACE_AND_STEP();
+            *srcreg = (u32) destoffset;
+        }
+        else {
+            u16 *srcreg = DECODE_RM_WORD_REGISTER(rh);
+
+            DECODE_PRINTF(",");
+            destoffset = decode_rm01_address(rl);
+            DECODE_PRINTF("\n");
+            TRACE_AND_STEP();
+            *srcreg = (u16) destoffset;
+        }
         break;
     case 2:
-        srcreg = DECODE_RM_WORD_REGISTER(rh);
-        DECODE_PRINTF(",");
-        destoffset = decode_rm10_address(rl);
-        DECODE_PRINTF("\n");
-        TRACE_AND_STEP();
-        *srcreg = (u16)destoffset;
+        if (M.x86.mode & SYSMODE_PREFIX_ADDR) {
+            u32 *srcreg = DECODE_RM_LONG_REGISTER(rh);
+
+            DECODE_PRINTF(",");
+            destoffset = decode_rm10_address(rl);
+            DECODE_PRINTF("\n");
+            TRACE_AND_STEP();
+            *srcreg = (u32) destoffset;
+        }
+        else {
+            u16 *srcreg = DECODE_RM_WORD_REGISTER(rh);
+
+            DECODE_PRINTF(",");
+            destoffset = decode_rm10_address(rl);
+            DECODE_PRINTF("\n");
+            TRACE_AND_STEP();
+            *srcreg = (u16) destoffset;
+        }
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         /* undefined.  Do nothing. */
         break;
     }
@@ -6616,7 +6987,8 @@ static void x86emuOp_lea_word_R_M(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x8e
 ****************************************************************************/
-static void x86emuOp_mov_word_SR_RM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_mov_word_SR_RM(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     u16 *destreg, *srcreg;
@@ -6654,7 +7026,7 @@ static void x86emuOp_mov_word_SR_RM(u8 X86EMU_UNUSED(op1))
         TRACE_AND_STEP();
         *destreg = srcval;
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         destreg = decode_rm_seg_register(rh);
         DECODE_PRINTF(",");
         srcreg = DECODE_RM_WORD_REGISTER(rl);
@@ -6677,7 +7049,8 @@ static void x86emuOp_mov_word_SR_RM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x8f
 ****************************************************************************/
-static void x86emuOp_pop_RM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_pop_RM(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     uint destoffset;
@@ -6699,7 +7072,8 @@ static void x86emuOp_pop_RM(u8 X86EMU_UNUSED(op1))
             TRACE_AND_STEP();
             destval = pop_long();
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
 
             destoffset = decode_rm00_address(rl);
@@ -6718,7 +7092,8 @@ static void x86emuOp_pop_RM(u8 X86EMU_UNUSED(op1))
             TRACE_AND_STEP();
             destval = pop_long();
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
 
             destoffset = decode_rm01_address(rl);
@@ -6737,7 +7112,8 @@ static void x86emuOp_pop_RM(u8 X86EMU_UNUSED(op1))
             TRACE_AND_STEP();
             destval = pop_long();
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
 
             destoffset = decode_rm10_address(rl);
@@ -6747,7 +7123,7 @@ static void x86emuOp_pop_RM(u8 X86EMU_UNUSED(op1))
             store_data_word(destoffset, destval);
         }
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
             u32 *destreg;
 
@@ -6755,7 +7131,8 @@ static void x86emuOp_pop_RM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = pop_long();
-        } else {
+        }
+        else {
             u16 *destreg;
 
             destreg = DECODE_RM_WORD_REGISTER(rl);
@@ -6773,7 +7150,8 @@ static void x86emuOp_pop_RM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x90
 ****************************************************************************/
-static void x86emuOp_nop(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_nop(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     DECODE_PRINTF("NOP\n");
@@ -6786,14 +7164,16 @@ static void x86emuOp_nop(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x91
 ****************************************************************************/
-static void x86emuOp_xchg_word_AX_CX(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_xchg_word_AX_CX(u8 X86EMU_UNUSED(op1))
 {
     u32 tmp;
 
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("XCHG\tEAX,ECX\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("XCHG\tAX,CX\n");
     }
     TRACE_AND_STEP();
@@ -6801,10 +7181,11 @@ static void x86emuOp_xchg_word_AX_CX(u8 X86EMU_UNUSED(op1))
         tmp = M.x86.R_EAX;
         M.x86.R_EAX = M.x86.R_ECX;
         M.x86.R_ECX = tmp;
-    } else {
+    }
+    else {
         tmp = M.x86.R_AX;
         M.x86.R_AX = M.x86.R_CX;
-        M.x86.R_CX = (u16)tmp;
+        M.x86.R_CX = (u16) tmp;
     }
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
@@ -6814,14 +7195,16 @@ static void x86emuOp_xchg_word_AX_CX(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x92
 ****************************************************************************/
-static void x86emuOp_xchg_word_AX_DX(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_xchg_word_AX_DX(u8 X86EMU_UNUSED(op1))
 {
     u32 tmp;
 
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("XCHG\tEAX,EDX\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("XCHG\tAX,DX\n");
     }
     TRACE_AND_STEP();
@@ -6829,10 +7212,11 @@ static void x86emuOp_xchg_word_AX_DX(u8 X86EMU_UNUSED(op1))
         tmp = M.x86.R_EAX;
         M.x86.R_EAX = M.x86.R_EDX;
         M.x86.R_EDX = tmp;
-    } else {
+    }
+    else {
         tmp = M.x86.R_AX;
         M.x86.R_AX = M.x86.R_DX;
-        M.x86.R_DX = (u16)tmp;
+        M.x86.R_DX = (u16) tmp;
     }
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
@@ -6842,14 +7226,16 @@ static void x86emuOp_xchg_word_AX_DX(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x93
 ****************************************************************************/
-static void x86emuOp_xchg_word_AX_BX(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_xchg_word_AX_BX(u8 X86EMU_UNUSED(op1))
 {
     u32 tmp;
 
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("XCHG\tEAX,EBX\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("XCHG\tAX,BX\n");
     }
     TRACE_AND_STEP();
@@ -6857,10 +7243,11 @@ static void x86emuOp_xchg_word_AX_BX(u8 X86EMU_UNUSED(op1))
         tmp = M.x86.R_EAX;
         M.x86.R_EAX = M.x86.R_EBX;
         M.x86.R_EBX = tmp;
-    } else {
+    }
+    else {
         tmp = M.x86.R_AX;
         M.x86.R_AX = M.x86.R_BX;
-        M.x86.R_BX = (u16)tmp;
+        M.x86.R_BX = (u16) tmp;
     }
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
@@ -6870,14 +7257,16 @@ static void x86emuOp_xchg_word_AX_BX(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x94
 ****************************************************************************/
-static void x86emuOp_xchg_word_AX_SP(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_xchg_word_AX_SP(u8 X86EMU_UNUSED(op1))
 {
     u32 tmp;
 
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("XCHG\tEAX,ESP\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("XCHG\tAX,SP\n");
     }
     TRACE_AND_STEP();
@@ -6885,10 +7274,11 @@ static void x86emuOp_xchg_word_AX_SP(u8 X86EMU_UNUSED(op1))
         tmp = M.x86.R_EAX;
         M.x86.R_EAX = M.x86.R_ESP;
         M.x86.R_ESP = tmp;
-    } else {
+    }
+    else {
         tmp = M.x86.R_AX;
         M.x86.R_AX = M.x86.R_SP;
-        M.x86.R_SP = (u16)tmp;
+        M.x86.R_SP = (u16) tmp;
     }
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
@@ -6898,14 +7288,16 @@ static void x86emuOp_xchg_word_AX_SP(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x95
 ****************************************************************************/
-static void x86emuOp_xchg_word_AX_BP(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_xchg_word_AX_BP(u8 X86EMU_UNUSED(op1))
 {
     u32 tmp;
 
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("XCHG\tEAX,EBP\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("XCHG\tAX,BP\n");
     }
     TRACE_AND_STEP();
@@ -6913,10 +7305,11 @@ static void x86emuOp_xchg_word_AX_BP(u8 X86EMU_UNUSED(op1))
         tmp = M.x86.R_EAX;
         M.x86.R_EAX = M.x86.R_EBP;
         M.x86.R_EBP = tmp;
-    } else {
+    }
+    else {
         tmp = M.x86.R_AX;
         M.x86.R_AX = M.x86.R_BP;
-        M.x86.R_BP = (u16)tmp;
+        M.x86.R_BP = (u16) tmp;
     }
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
@@ -6926,14 +7319,16 @@ static void x86emuOp_xchg_word_AX_BP(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x96
 ****************************************************************************/
-static void x86emuOp_xchg_word_AX_SI(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_xchg_word_AX_SI(u8 X86EMU_UNUSED(op1))
 {
     u32 tmp;
 
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("XCHG\tEAX,ESI\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("XCHG\tAX,SI\n");
     }
     TRACE_AND_STEP();
@@ -6941,10 +7336,11 @@ static void x86emuOp_xchg_word_AX_SI(u8 X86EMU_UNUSED(op1))
         tmp = M.x86.R_EAX;
         M.x86.R_EAX = M.x86.R_ESI;
         M.x86.R_ESI = tmp;
-    } else {
+    }
+    else {
         tmp = M.x86.R_AX;
         M.x86.R_AX = M.x86.R_SI;
-        M.x86.R_SI = (u16)tmp;
+        M.x86.R_SI = (u16) tmp;
     }
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
@@ -6954,14 +7350,16 @@ static void x86emuOp_xchg_word_AX_SI(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x97
 ****************************************************************************/
-static void x86emuOp_xchg_word_AX_DI(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_xchg_word_AX_DI(u8 X86EMU_UNUSED(op1))
 {
     u32 tmp;
 
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("XCHG\tEAX,EDI\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("XCHG\tAX,DI\n");
     }
     TRACE_AND_STEP();
@@ -6969,10 +7367,11 @@ static void x86emuOp_xchg_word_AX_DI(u8 X86EMU_UNUSED(op1))
         tmp = M.x86.R_EAX;
         M.x86.R_EAX = M.x86.R_EDI;
         M.x86.R_EDI = tmp;
-    } else {
+    }
+    else {
         tmp = M.x86.R_AX;
         M.x86.R_AX = M.x86.R_DI;
-        M.x86.R_DI = (u16)tmp;
+        M.x86.R_DI = (u16) tmp;
     }
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
@@ -6982,25 +7381,30 @@ static void x86emuOp_xchg_word_AX_DI(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x98
 ****************************************************************************/
-static void x86emuOp_cbw(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_cbw(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("CWDE\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("CBW\n");
     }
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         if (M.x86.R_AX & 0x8000) {
             M.x86.R_EAX |= 0xffff0000;
-        } else {
+        }
+        else {
             M.x86.R_EAX &= 0x0000ffff;
         }
-    } else {
+    }
+    else {
         if (M.x86.R_AL & 0x80) {
             M.x86.R_AH = 0xff;
-        } else {
+        }
+        else {
             M.x86.R_AH = 0x0;
         }
     }
@@ -7012,12 +7416,14 @@ static void x86emuOp_cbw(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x99
 ****************************************************************************/
-static void x86emuOp_cwd(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_cwd(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("CDQ\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("CWD\n");
     }
     DECODE_PRINTF("CWD\n");
@@ -7025,13 +7431,16 @@ static void x86emuOp_cwd(u8 X86EMU_UNUSED(op1))
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         if (M.x86.R_EAX & 0x80000000) {
             M.x86.R_EDX = 0xffffffff;
-        } else {
+        }
+        else {
             M.x86.R_EDX = 0x0;
         }
-    } else {
+    }
+    else {
         if (M.x86.R_AX & 0x8000) {
             M.x86.R_DX = 0xffff;
-        } else {
+        }
+        else {
             M.x86.R_DX = 0x0;
         }
     }
@@ -7043,17 +7452,24 @@ static void x86emuOp_cwd(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x9a
 ****************************************************************************/
-static void x86emuOp_call_far_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_call_far_IMM(u8 X86EMU_UNUSED(op1))
 {
-    u16 farseg, faroff;
+    u32 farseg, faroff;
 
     START_OF_INSTR();
-	DECODE_PRINTF("CALL\t");
-	faroff = fetch_word_imm();
-	farseg = fetch_word_imm();
-	DECODE_PRINTF2("%04x:", farseg);
-	DECODE_PRINTF2("%04x\n", faroff);
-	CALL_TRACE(M.x86.saved_cs, M.x86.saved_ip, farseg, faroff, "FAR ");
+    DECODE_PRINTF("CALL\t");
+    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
+        faroff = fetch_long_imm();
+        farseg = fetch_word_imm();
+    }
+    else {
+        faroff = fetch_word_imm();
+        farseg = fetch_word_imm();
+    }
+    DECODE_PRINTF2("%04x:", farseg);
+    DECODE_PRINTF2("%04x\n", faroff);
+    CALL_TRACE(M.x86.saved_cs, M.x86.saved_ip, farseg, faroff, "FAR ");
 
     /* XXX
      * 
@@ -7064,8 +7480,13 @@ static void x86emuOp_call_far_IMM(u8 X86EMU_UNUSED(op1))
     TRACE_AND_STEP();
     push_word(M.x86.R_CS);
     M.x86.R_CS = farseg;
-    push_word(M.x86.R_IP);
-    M.x86.R_IP = faroff;
+    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
+        push_long(M.x86.R_EIP);
+    }
+    else {
+        push_word(M.x86.R_IP);
+    }
+    M.x86.R_EIP = faroff & 0xffff;
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
 }
@@ -7074,7 +7495,8 @@ static void x86emuOp_call_far_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x9b
 ****************************************************************************/
-static void x86emuOp_wait(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_wait(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     DECODE_PRINTF("WAIT");
@@ -7088,14 +7510,16 @@ static void x86emuOp_wait(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x9c
 ****************************************************************************/
-static void x86emuOp_pushf_word(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_pushf_word(u8 X86EMU_UNUSED(op1))
 {
     u32 flags;
 
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("PUSHFD\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("PUSHF\n");
     }
     TRACE_AND_STEP();
@@ -7104,8 +7528,9 @@ static void x86emuOp_pushf_word(u8 X86EMU_UNUSED(op1))
     flags = (M.x86.R_EFLG & F_MSK) | F_ALWAYS_ON;
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         push_long(flags);
-    } else {
-        push_word((u16)flags);
+    }
+    else {
+        push_word((u16) flags);
     }
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
@@ -7115,18 +7540,21 @@ static void x86emuOp_pushf_word(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x9d
 ****************************************************************************/
-static void x86emuOp_popf_word(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_popf_word(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("POPFD\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("POPF\n");
     }
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_EFLG = pop_long();
-    } else {
+    }
+    else {
         M.x86.R_FLG = pop_word();
     }
     DECODE_CLEAR_SEGOVR();
@@ -7137,7 +7565,8 @@ static void x86emuOp_popf_word(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x9e
 ****************************************************************************/
-static void x86emuOp_sahf(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_sahf(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     DECODE_PRINTF("SAHF\n");
@@ -7154,12 +7583,13 @@ static void x86emuOp_sahf(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0x9f
 ****************************************************************************/
-static void x86emuOp_lahf(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_lahf(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     DECODE_PRINTF("LAHF\n");
     TRACE_AND_STEP();
-	M.x86.R_AH = (u8)(M.x86.R_FLG & 0xff);
+    M.x86.R_AH = (u8) (M.x86.R_FLG & 0xff);
     /*undocumented TC++ behavior??? Nope.  It's documented, but
        you have too look real hard to notice it. */
     M.x86.R_AH |= 0x2;
@@ -7171,7 +7601,8 @@ static void x86emuOp_lahf(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xa0
 ****************************************************************************/
-static void x86emuOp_mov_AL_M_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_mov_AL_M_IMM(u8 X86EMU_UNUSED(op1))
 {
     u16 offset;
 
@@ -7189,7 +7620,8 @@ static void x86emuOp_mov_AL_M_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xa1
 ****************************************************************************/
-static void x86emuOp_mov_AX_M_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_mov_AX_M_IMM(u8 X86EMU_UNUSED(op1))
 {
     u16 offset;
 
@@ -7197,13 +7629,15 @@ static void x86emuOp_mov_AX_M_IMM(u8 X86EMU_UNUSED(op1))
     offset = fetch_word_imm();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF2("MOV\tEAX,[%04x]\n", offset);
-    } else {
+    }
+    else {
         DECODE_PRINTF2("MOV\tAX,[%04x]\n", offset);
     }
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_EAX = fetch_data_long(offset);
-    } else {
+    }
+    else {
         M.x86.R_AX = fetch_data_word(offset);
     }
     DECODE_CLEAR_SEGOVR();
@@ -7214,7 +7648,8 @@ static void x86emuOp_mov_AX_M_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xa2
 ****************************************************************************/
-static void x86emuOp_mov_M_AL_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_mov_M_AL_IMM(u8 X86EMU_UNUSED(op1))
 {
     u16 offset;
 
@@ -7232,7 +7667,8 @@ static void x86emuOp_mov_M_AL_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xa3
 ****************************************************************************/
-static void x86emuOp_mov_M_AX_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_mov_M_AX_IMM(u8 X86EMU_UNUSED(op1))
 {
     u16 offset;
 
@@ -7240,13 +7676,15 @@ static void x86emuOp_mov_M_AX_IMM(u8 X86EMU_UNUSED(op1))
     offset = fetch_word_imm();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF2("MOV\t[%04x],EAX\n", offset);
-    } else {
+    }
+    else {
         DECODE_PRINTF2("MOV\t[%04x],AX\n", offset);
     }
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         store_data_long(offset, M.x86.R_EAX);
-    } else {
+    }
+    else {
         store_data_word(offset, M.x86.R_AX);
     }
     DECODE_CLEAR_SEGOVR();
@@ -7257,15 +7695,16 @@ static void x86emuOp_mov_M_AX_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xa4
 ****************************************************************************/
-static void x86emuOp_movs_byte(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_movs_byte(u8 X86EMU_UNUSED(op1))
 {
-    u8  val;
+    u8 val;
     u32 count;
     int inc;
 
     START_OF_INSTR();
     DECODE_PRINTF("MOVS\tBYTE\n");
-    if (ACCESS_FLAG(F_DF))   /* down */
+    if (ACCESS_FLAG(F_DF))      /* down */
         inc = -1;
     else
         inc = 1;
@@ -7292,7 +7731,8 @@ static void x86emuOp_movs_byte(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xa5
 ****************************************************************************/
-static void x86emuOp_movs_word(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_movs_word(u8 X86EMU_UNUSED(op1))
 {
     u32 val;
     int inc;
@@ -7301,13 +7741,14 @@ static void x86emuOp_movs_word(u8 X86EMU_UNUSED(op1))
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("MOVS\tDWORD\n");
-        if (ACCESS_FLAG(F_DF))      /* down */
+        if (ACCESS_FLAG(F_DF))  /* down */
             inc = -4;
         else
             inc = 4;
-    } else {
+    }
+    else {
         DECODE_PRINTF("MOVS\tWORD\n");
-        if (ACCESS_FLAG(F_DF))      /* down */
+        if (ACCESS_FLAG(F_DF))  /* down */
             inc = -2;
         else
             inc = 2;
@@ -7325,9 +7766,10 @@ static void x86emuOp_movs_word(u8 X86EMU_UNUSED(op1))
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
             val = fetch_data_long(M.x86.R_SI);
             store_data_long_abs(M.x86.R_ES, M.x86.R_DI, val);
-        } else {
+        }
+        else {
             val = fetch_data_word(M.x86.R_SI);
-            store_data_word_abs(M.x86.R_ES, M.x86.R_DI, (u16)val);
+            store_data_word_abs(M.x86.R_ES, M.x86.R_DI, (u16) val);
         }
         M.x86.R_SI += inc;
         M.x86.R_DI += inc;
@@ -7340,7 +7782,8 @@ static void x86emuOp_movs_word(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xa6
 ****************************************************************************/
-static void x86emuOp_cmps_byte(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_cmps_byte(u8 X86EMU_UNUSED(op1))
 {
     s8 val1, val2;
     int inc;
@@ -7348,7 +7791,7 @@ static void x86emuOp_cmps_byte(u8 X86EMU_UNUSED(op1))
     START_OF_INSTR();
     DECODE_PRINTF("CMPS\tBYTE\n");
     TRACE_AND_STEP();
-    if (ACCESS_FLAG(F_DF))   /* down */
+    if (ACCESS_FLAG(F_DF))      /* down */
         inc = -1;
     else
         inc = 1;
@@ -7359,7 +7802,7 @@ static void x86emuOp_cmps_byte(u8 X86EMU_UNUSED(op1))
         while (M.x86.R_CX != 0) {
             val1 = fetch_data_byte(M.x86.R_SI);
             val2 = fetch_data_byte_abs(M.x86.R_ES, M.x86.R_DI);
-                     cmp_byte(val1, val2);
+            cmp_byte(val1, val2);
             M.x86.R_CX -= 1;
             M.x86.R_SI += inc;
             M.x86.R_DI += inc;
@@ -7367,7 +7810,8 @@ static void x86emuOp_cmps_byte(u8 X86EMU_UNUSED(op1))
                 break;
         }
         M.x86.mode &= ~SYSMODE_PREFIX_REPE;
-    } else if (M.x86.mode & SYSMODE_PREFIX_REPNE) {
+    }
+    else if (M.x86.mode & SYSMODE_PREFIX_REPNE) {
         /* REPNE  */
         /* move them until CX is ZERO. */
         while (M.x86.R_CX != 0) {
@@ -7381,7 +7825,8 @@ static void x86emuOp_cmps_byte(u8 X86EMU_UNUSED(op1))
                 break;          /* zero flag set means equal */
         }
         M.x86.mode &= ~SYSMODE_PREFIX_REPNE;
-    } else {
+    }
+    else {
         val1 = fetch_data_byte(M.x86.R_SI);
         val2 = fetch_data_byte_abs(M.x86.R_ES, M.x86.R_DI);
         cmp_byte(val1, val2);
@@ -7396,21 +7841,23 @@ static void x86emuOp_cmps_byte(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xa7
 ****************************************************************************/
-static void x86emuOp_cmps_word(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_cmps_word(u8 X86EMU_UNUSED(op1))
 {
-    u32 val1,val2;
+    u32 val1, val2;
     int inc;
 
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("CMPS\tDWORD\n");
-        if (ACCESS_FLAG(F_DF))   /* down */
+        if (ACCESS_FLAG(F_DF))  /* down */
             inc = -4;
         else
             inc = 4;
-    } else {
+    }
+    else {
         DECODE_PRINTF("CMPS\tWORD\n");
-        if (ACCESS_FLAG(F_DF))   /* down */
+        if (ACCESS_FLAG(F_DF))  /* down */
             inc = -2;
         else
             inc = 2;
@@ -7424,10 +7871,11 @@ static void x86emuOp_cmps_word(u8 X86EMU_UNUSED(op1))
                 val1 = fetch_data_long(M.x86.R_SI);
                 val2 = fetch_data_long_abs(M.x86.R_ES, M.x86.R_DI);
                 cmp_long(val1, val2);
-            } else {
+            }
+            else {
                 val1 = fetch_data_word(M.x86.R_SI);
                 val2 = fetch_data_word_abs(M.x86.R_ES, M.x86.R_DI);
-                cmp_word((u16)val1, (u16)val2);
+                cmp_word((u16) val1, (u16) val2);
             }
             M.x86.R_CX -= 1;
             M.x86.R_SI += inc;
@@ -7436,7 +7884,8 @@ static void x86emuOp_cmps_word(u8 X86EMU_UNUSED(op1))
                 break;
         }
         M.x86.mode &= ~SYSMODE_PREFIX_REPE;
-    } else if (M.x86.mode & SYSMODE_PREFIX_REPNE) {
+    }
+    else if (M.x86.mode & SYSMODE_PREFIX_REPNE) {
         /* REPNE  */
         /* move them until CX is ZERO. */
         while (M.x86.R_CX != 0) {
@@ -7444,10 +7893,11 @@ static void x86emuOp_cmps_word(u8 X86EMU_UNUSED(op1))
                 val1 = fetch_data_long(M.x86.R_SI);
                 val2 = fetch_data_long_abs(M.x86.R_ES, M.x86.R_DI);
                 cmp_long(val1, val2);
-            } else {
+            }
+            else {
                 val1 = fetch_data_word(M.x86.R_SI);
                 val2 = fetch_data_word_abs(M.x86.R_ES, M.x86.R_DI);
-                cmp_word((u16)val1, (u16)val2);
+                cmp_word((u16) val1, (u16) val2);
             }
             M.x86.R_CX -= 1;
             M.x86.R_SI += inc;
@@ -7456,15 +7906,17 @@ static void x86emuOp_cmps_word(u8 X86EMU_UNUSED(op1))
                 break;          /* zero flag set means equal */
         }
         M.x86.mode &= ~SYSMODE_PREFIX_REPNE;
-    } else {
+    }
+    else {
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
             val1 = fetch_data_long(M.x86.R_SI);
             val2 = fetch_data_long_abs(M.x86.R_ES, M.x86.R_DI);
             cmp_long(val1, val2);
-        } else {
+        }
+        else {
             val1 = fetch_data_word(M.x86.R_SI);
             val2 = fetch_data_word_abs(M.x86.R_ES, M.x86.R_DI);
-            cmp_word((u16)val1, (u16)val2);
+            cmp_word((u16) val1, (u16) val2);
         }
         M.x86.R_SI += inc;
         M.x86.R_DI += inc;
@@ -7477,7 +7929,8 @@ static void x86emuOp_cmps_word(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xa8
 ****************************************************************************/
-static void x86emuOp_test_AL_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_test_AL_IMM(u8 X86EMU_UNUSED(op1))
 {
     int imm;
 
@@ -7486,7 +7939,7 @@ static void x86emuOp_test_AL_IMM(u8 X86EMU_UNUSED(op1))
     imm = fetch_byte_imm();
     DECODE_PRINTF2("%04x\n", imm);
     TRACE_AND_STEP();
-	test_byte(M.x86.R_AL, (u8)imm);
+    test_byte(M.x86.R_AL, (u8) imm);
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
 }
@@ -7495,7 +7948,8 @@ static void x86emuOp_test_AL_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xa9
 ****************************************************************************/
-static void x86emuOp_test_AX_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_test_AX_IMM(u8 X86EMU_UNUSED(op1))
 {
     u32 srcval;
 
@@ -7503,7 +7957,8 @@ static void x86emuOp_test_AX_IMM(u8 X86EMU_UNUSED(op1))
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("TEST\tEAX,");
         srcval = fetch_long_imm();
-    } else {
+    }
+    else {
         DECODE_PRINTF("TEST\tAX,");
         srcval = fetch_word_imm();
     }
@@ -7511,8 +7966,9 @@ static void x86emuOp_test_AX_IMM(u8 X86EMU_UNUSED(op1))
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         test_long(M.x86.R_EAX, srcval);
-    } else {
-        test_word(M.x86.R_AX, (u16)srcval);
+    }
+    else {
+        test_word(M.x86.R_AX, (u16) srcval);
     }
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
@@ -7522,13 +7978,14 @@ static void x86emuOp_test_AX_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xaa
 ****************************************************************************/
-static void x86emuOp_stos_byte(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_stos_byte(u8 X86EMU_UNUSED(op1))
 {
     int inc;
 
     START_OF_INSTR();
     DECODE_PRINTF("STOS\tBYTE\n");
-    if (ACCESS_FLAG(F_DF))   /* down */
+    if (ACCESS_FLAG(F_DF))      /* down */
         inc = -1;
     else
         inc = 1;
@@ -7542,7 +7999,8 @@ static void x86emuOp_stos_byte(u8 X86EMU_UNUSED(op1))
             M.x86.R_DI += inc;
         }
         M.x86.mode &= ~(SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE);
-    } else {
+    }
+    else {
         store_data_byte_abs(M.x86.R_ES, M.x86.R_DI, M.x86.R_AL);
         M.x86.R_DI += inc;
     }
@@ -7554,7 +8012,8 @@ static void x86emuOp_stos_byte(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xab
 ****************************************************************************/
-static void x86emuOp_stos_word(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_stos_word(u8 X86EMU_UNUSED(op1))
 {
     int inc;
     u32 count;
@@ -7562,13 +8021,14 @@ static void x86emuOp_stos_word(u8 X86EMU_UNUSED(op1))
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("STOS\tDWORD\n");
-        if (ACCESS_FLAG(F_DF))   /* down */
+        if (ACCESS_FLAG(F_DF))  /* down */
             inc = -4;
         else
             inc = 4;
-    } else {
+    }
+    else {
         DECODE_PRINTF("STOS\tWORD\n");
-        if (ACCESS_FLAG(F_DF))   /* down */
+        if (ACCESS_FLAG(F_DF))  /* down */
             inc = -2;
         else
             inc = 2;
@@ -7585,7 +8045,8 @@ static void x86emuOp_stos_word(u8 X86EMU_UNUSED(op1))
     while (count--) {
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
             store_data_long_abs(M.x86.R_ES, M.x86.R_DI, M.x86.R_EAX);
-        } else {
+        }
+        else {
             store_data_word_abs(M.x86.R_ES, M.x86.R_DI, M.x86.R_AX);
         }
         M.x86.R_DI += inc;
@@ -7598,14 +8059,15 @@ static void x86emuOp_stos_word(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xac
 ****************************************************************************/
-static void x86emuOp_lods_byte(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_lods_byte(u8 X86EMU_UNUSED(op1))
 {
     int inc;
 
     START_OF_INSTR();
     DECODE_PRINTF("LODS\tBYTE\n");
     TRACE_AND_STEP();
-    if (ACCESS_FLAG(F_DF))   /* down */
+    if (ACCESS_FLAG(F_DF))      /* down */
         inc = -1;
     else
         inc = 1;
@@ -7618,7 +8080,8 @@ static void x86emuOp_lods_byte(u8 X86EMU_UNUSED(op1))
             M.x86.R_SI += inc;
         }
         M.x86.mode &= ~(SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE);
-    } else {
+    }
+    else {
         M.x86.R_AL = fetch_data_byte(M.x86.R_SI);
         M.x86.R_SI += inc;
     }
@@ -7630,7 +8093,8 @@ static void x86emuOp_lods_byte(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xad
 ****************************************************************************/
-static void x86emuOp_lods_word(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_lods_word(u8 X86EMU_UNUSED(op1))
 {
     int inc;
     u32 count;
@@ -7638,13 +8102,14 @@ static void x86emuOp_lods_word(u8 X86EMU_UNUSED(op1))
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("LODS\tDWORD\n");
-        if (ACCESS_FLAG(F_DF))   /* down */
+        if (ACCESS_FLAG(F_DF))  /* down */
             inc = -4;
         else
             inc = 4;
-    } else {
+    }
+    else {
         DECODE_PRINTF("LODS\tWORD\n");
-        if (ACCESS_FLAG(F_DF))   /* down */
+        if (ACCESS_FLAG(F_DF))  /* down */
             inc = -2;
         else
             inc = 2;
@@ -7661,7 +8126,8 @@ static void x86emuOp_lods_word(u8 X86EMU_UNUSED(op1))
     while (count--) {
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
             M.x86.R_EAX = fetch_data_long(M.x86.R_SI);
-        } else {
+        }
+        else {
             M.x86.R_AX = fetch_data_word(M.x86.R_SI);
         }
         M.x86.R_SI += inc;
@@ -7674,7 +8140,8 @@ static void x86emuOp_lods_word(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xae
 ****************************************************************************/
-static void x86emuOp_scas_byte(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_scas_byte(u8 X86EMU_UNUSED(op1))
 {
     s8 val2;
     int inc;
@@ -7682,7 +8149,7 @@ static void x86emuOp_scas_byte(u8 X86EMU_UNUSED(op1))
     START_OF_INSTR();
     DECODE_PRINTF("SCAS\tBYTE\n");
     TRACE_AND_STEP();
-    if (ACCESS_FLAG(F_DF))   /* down */
+    if (ACCESS_FLAG(F_DF))      /* down */
         inc = -1;
     else
         inc = 1;
@@ -7698,7 +8165,8 @@ static void x86emuOp_scas_byte(u8 X86EMU_UNUSED(op1))
                 break;
         }
         M.x86.mode &= ~SYSMODE_PREFIX_REPE;
-    } else if (M.x86.mode & SYSMODE_PREFIX_REPNE) {
+    }
+    else if (M.x86.mode & SYSMODE_PREFIX_REPNE) {
         /* REPNE  */
         /* move them until CX is ZERO. */
         while (M.x86.R_CX != 0) {
@@ -7710,7 +8178,8 @@ static void x86emuOp_scas_byte(u8 X86EMU_UNUSED(op1))
                 break;          /* zero flag set means equal */
         }
         M.x86.mode &= ~SYSMODE_PREFIX_REPNE;
-    } else {
+    }
+    else {
         val2 = fetch_data_byte_abs(M.x86.R_ES, M.x86.R_DI);
         cmp_byte(M.x86.R_AL, val2);
         M.x86.R_DI += inc;
@@ -7723,7 +8192,8 @@ static void x86emuOp_scas_byte(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xaf
 ****************************************************************************/
-static void x86emuOp_scas_word(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_scas_word(u8 X86EMU_UNUSED(op1))
 {
     int inc;
     u32 val;
@@ -7731,13 +8201,14 @@ static void x86emuOp_scas_word(u8 X86EMU_UNUSED(op1))
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("SCAS\tDWORD\n");
-        if (ACCESS_FLAG(F_DF))   /* down */
+        if (ACCESS_FLAG(F_DF))  /* down */
             inc = -4;
         else
             inc = 4;
-    } else {
+    }
+    else {
         DECODE_PRINTF("SCAS\tWORD\n");
-        if (ACCESS_FLAG(F_DF))   /* down */
+        if (ACCESS_FLAG(F_DF))  /* down */
             inc = -2;
         else
             inc = 2;
@@ -7750,9 +8221,10 @@ static void x86emuOp_scas_word(u8 X86EMU_UNUSED(op1))
             if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                 val = fetch_data_long_abs(M.x86.R_ES, M.x86.R_DI);
                 cmp_long(M.x86.R_EAX, val);
-            } else {
+            }
+            else {
                 val = fetch_data_word_abs(M.x86.R_ES, M.x86.R_DI);
-                cmp_word(M.x86.R_AX, (u16)val);
+                cmp_word(M.x86.R_AX, (u16) val);
             }
             M.x86.R_CX -= 1;
             M.x86.R_DI += inc;
@@ -7760,16 +8232,18 @@ static void x86emuOp_scas_word(u8 X86EMU_UNUSED(op1))
                 break;
         }
         M.x86.mode &= ~SYSMODE_PREFIX_REPE;
-    } else if (M.x86.mode & SYSMODE_PREFIX_REPNE) {
+    }
+    else if (M.x86.mode & SYSMODE_PREFIX_REPNE) {
         /* REPNE  */
         /* move them until CX is ZERO. */
         while (M.x86.R_CX != 0) {
             if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                 val = fetch_data_long_abs(M.x86.R_ES, M.x86.R_DI);
                 cmp_long(M.x86.R_EAX, val);
-            } else {
+            }
+            else {
                 val = fetch_data_word_abs(M.x86.R_ES, M.x86.R_DI);
-                cmp_word(M.x86.R_AX, (u16)val);
+                cmp_word(M.x86.R_AX, (u16) val);
             }
             M.x86.R_CX -= 1;
             M.x86.R_DI += inc;
@@ -7777,13 +8251,15 @@ static void x86emuOp_scas_word(u8 X86EMU_UNUSED(op1))
                 break;          /* zero flag set means equal */
         }
         M.x86.mode &= ~SYSMODE_PREFIX_REPNE;
-    } else {
+    }
+    else {
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
             val = fetch_data_long_abs(M.x86.R_ES, M.x86.R_DI);
             cmp_long(M.x86.R_EAX, val);
-        } else {
+        }
+        else {
             val = fetch_data_word_abs(M.x86.R_ES, M.x86.R_DI);
-            cmp_word(M.x86.R_AX, (u16)val);
+            cmp_word(M.x86.R_AX, (u16) val);
         }
         M.x86.R_DI += inc;
     }
@@ -7795,7 +8271,8 @@ static void x86emuOp_scas_word(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xb0
 ****************************************************************************/
-static void x86emuOp_mov_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_mov_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
 {
     u8 imm;
 
@@ -7813,7 +8290,8 @@ static void x86emuOp_mov_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xb1
 ****************************************************************************/
-static void x86emuOp_mov_byte_CL_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_mov_byte_CL_IMM(u8 X86EMU_UNUSED(op1))
 {
     u8 imm;
 
@@ -7831,7 +8309,8 @@ static void x86emuOp_mov_byte_CL_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xb2
 ****************************************************************************/
-static void x86emuOp_mov_byte_DL_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_mov_byte_DL_IMM(u8 X86EMU_UNUSED(op1))
 {
     u8 imm;
 
@@ -7849,7 +8328,8 @@ static void x86emuOp_mov_byte_DL_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xb3
 ****************************************************************************/
-static void x86emuOp_mov_byte_BL_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_mov_byte_BL_IMM(u8 X86EMU_UNUSED(op1))
 {
     u8 imm;
 
@@ -7867,7 +8347,8 @@ static void x86emuOp_mov_byte_BL_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xb4
 ****************************************************************************/
-static void x86emuOp_mov_byte_AH_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_mov_byte_AH_IMM(u8 X86EMU_UNUSED(op1))
 {
     u8 imm;
 
@@ -7885,7 +8366,8 @@ static void x86emuOp_mov_byte_AH_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xb5
 ****************************************************************************/
-static void x86emuOp_mov_byte_CH_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_mov_byte_CH_IMM(u8 X86EMU_UNUSED(op1))
 {
     u8 imm;
 
@@ -7903,7 +8385,8 @@ static void x86emuOp_mov_byte_CH_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xb6
 ****************************************************************************/
-static void x86emuOp_mov_byte_DH_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_mov_byte_DH_IMM(u8 X86EMU_UNUSED(op1))
 {
     u8 imm;
 
@@ -7921,7 +8404,8 @@ static void x86emuOp_mov_byte_DH_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xb7
 ****************************************************************************/
-static void x86emuOp_mov_byte_BH_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_mov_byte_BH_IMM(u8 X86EMU_UNUSED(op1))
 {
     u8 imm;
 
@@ -7939,7 +8423,8 @@ static void x86emuOp_mov_byte_BH_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xb8
 ****************************************************************************/
-static void x86emuOp_mov_word_AX_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_mov_word_AX_IMM(u8 X86EMU_UNUSED(op1))
 {
     u32 srcval;
 
@@ -7947,7 +8432,8 @@ static void x86emuOp_mov_word_AX_IMM(u8 X86EMU_UNUSED(op1))
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("MOV\tEAX,");
         srcval = fetch_long_imm();
-    } else {
+    }
+    else {
         DECODE_PRINTF("MOV\tAX,");
         srcval = fetch_word_imm();
     }
@@ -7955,8 +8441,9 @@ static void x86emuOp_mov_word_AX_IMM(u8 X86EMU_UNUSED(op1))
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_EAX = srcval;
-    } else {
-        M.x86.R_AX = (u16)srcval;
+    }
+    else {
+        M.x86.R_AX = (u16) srcval;
     }
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
@@ -7966,7 +8453,8 @@ static void x86emuOp_mov_word_AX_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xb9
 ****************************************************************************/
-static void x86emuOp_mov_word_CX_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_mov_word_CX_IMM(u8 X86EMU_UNUSED(op1))
 {
     u32 srcval;
 
@@ -7974,7 +8462,8 @@ static void x86emuOp_mov_word_CX_IMM(u8 X86EMU_UNUSED(op1))
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("MOV\tECX,");
         srcval = fetch_long_imm();
-    } else {
+    }
+    else {
         DECODE_PRINTF("MOV\tCX,");
         srcval = fetch_word_imm();
     }
@@ -7982,8 +8471,9 @@ static void x86emuOp_mov_word_CX_IMM(u8 X86EMU_UNUSED(op1))
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_ECX = srcval;
-    } else {
-        M.x86.R_CX = (u16)srcval;
+    }
+    else {
+        M.x86.R_CX = (u16) srcval;
     }
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
@@ -7993,7 +8483,8 @@ static void x86emuOp_mov_word_CX_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xba
 ****************************************************************************/
-static void x86emuOp_mov_word_DX_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_mov_word_DX_IMM(u8 X86EMU_UNUSED(op1))
 {
     u32 srcval;
 
@@ -8001,7 +8492,8 @@ static void x86emuOp_mov_word_DX_IMM(u8 X86EMU_UNUSED(op1))
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("MOV\tEDX,");
         srcval = fetch_long_imm();
-    } else {
+    }
+    else {
         DECODE_PRINTF("MOV\tDX,");
         srcval = fetch_word_imm();
     }
@@ -8009,8 +8501,9 @@ static void x86emuOp_mov_word_DX_IMM(u8 X86EMU_UNUSED(op1))
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_EDX = srcval;
-    } else {
-        M.x86.R_DX = (u16)srcval;
+    }
+    else {
+        M.x86.R_DX = (u16) srcval;
     }
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
@@ -8020,7 +8513,8 @@ static void x86emuOp_mov_word_DX_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xbb
 ****************************************************************************/
-static void x86emuOp_mov_word_BX_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_mov_word_BX_IMM(u8 X86EMU_UNUSED(op1))
 {
     u32 srcval;
 
@@ -8028,7 +8522,8 @@ static void x86emuOp_mov_word_BX_IMM(u8 X86EMU_UNUSED(op1))
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("MOV\tEBX,");
         srcval = fetch_long_imm();
-    } else {
+    }
+    else {
         DECODE_PRINTF("MOV\tBX,");
         srcval = fetch_word_imm();
     }
@@ -8036,8 +8531,9 @@ static void x86emuOp_mov_word_BX_IMM(u8 X86EMU_UNUSED(op1))
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_EBX = srcval;
-    } else {
-        M.x86.R_BX = (u16)srcval;
+    }
+    else {
+        M.x86.R_BX = (u16) srcval;
     }
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
@@ -8047,7 +8543,8 @@ static void x86emuOp_mov_word_BX_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xbc
 ****************************************************************************/
-static void x86emuOp_mov_word_SP_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_mov_word_SP_IMM(u8 X86EMU_UNUSED(op1))
 {
     u32 srcval;
 
@@ -8055,7 +8552,8 @@ static void x86emuOp_mov_word_SP_IMM(u8 X86EMU_UNUSED(op1))
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("MOV\tESP,");
         srcval = fetch_long_imm();
-    } else {
+    }
+    else {
         DECODE_PRINTF("MOV\tSP,");
         srcval = fetch_word_imm();
     }
@@ -8063,8 +8561,9 @@ static void x86emuOp_mov_word_SP_IMM(u8 X86EMU_UNUSED(op1))
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_ESP = srcval;
-    } else {
-        M.x86.R_SP = (u16)srcval;
+    }
+    else {
+        M.x86.R_SP = (u16) srcval;
     }
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
@@ -8074,7 +8573,8 @@ static void x86emuOp_mov_word_SP_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xbd
 ****************************************************************************/
-static void x86emuOp_mov_word_BP_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_mov_word_BP_IMM(u8 X86EMU_UNUSED(op1))
 {
     u32 srcval;
 
@@ -8082,7 +8582,8 @@ static void x86emuOp_mov_word_BP_IMM(u8 X86EMU_UNUSED(op1))
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("MOV\tEBP,");
         srcval = fetch_long_imm();
-    } else {
+    }
+    else {
         DECODE_PRINTF("MOV\tBP,");
         srcval = fetch_word_imm();
     }
@@ -8090,8 +8591,9 @@ static void x86emuOp_mov_word_BP_IMM(u8 X86EMU_UNUSED(op1))
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_EBP = srcval;
-    } else {
-        M.x86.R_BP = (u16)srcval;
+    }
+    else {
+        M.x86.R_BP = (u16) srcval;
     }
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
@@ -8101,7 +8603,8 @@ static void x86emuOp_mov_word_BP_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xbe
 ****************************************************************************/
-static void x86emuOp_mov_word_SI_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_mov_word_SI_IMM(u8 X86EMU_UNUSED(op1))
 {
     u32 srcval;
 
@@ -8109,7 +8612,8 @@ static void x86emuOp_mov_word_SI_IMM(u8 X86EMU_UNUSED(op1))
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("MOV\tESI,");
         srcval = fetch_long_imm();
-    } else {
+    }
+    else {
         DECODE_PRINTF("MOV\tSI,");
         srcval = fetch_word_imm();
     }
@@ -8117,8 +8621,9 @@ static void x86emuOp_mov_word_SI_IMM(u8 X86EMU_UNUSED(op1))
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_ESI = srcval;
-    } else {
-        M.x86.R_SI = (u16)srcval;
+    }
+    else {
+        M.x86.R_SI = (u16) srcval;
     }
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
@@ -8128,7 +8633,8 @@ static void x86emuOp_mov_word_SI_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xbf
 ****************************************************************************/
-static void x86emuOp_mov_word_DI_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_mov_word_DI_IMM(u8 X86EMU_UNUSED(op1))
 {
     u32 srcval;
 
@@ -8136,7 +8642,8 @@ static void x86emuOp_mov_word_DI_IMM(u8 X86EMU_UNUSED(op1))
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("MOV\tEDI,");
         srcval = fetch_long_imm();
-    } else {
+    }
+    else {
         DECODE_PRINTF("MOV\tDI,");
         srcval = fetch_word_imm();
     }
@@ -8144,31 +8651,25 @@ static void x86emuOp_mov_word_DI_IMM(u8 X86EMU_UNUSED(op1))
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         M.x86.R_EDI = srcval;
-    } else {
-        M.x86.R_DI = (u16)srcval;
+    }
+    else {
+        M.x86.R_DI = (u16) srcval;
     }
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
 }
 
 /* used by opcodes c0, d0, and d2. */
-static u8(*opcD0_byte_operation[])(u8 d, u8 s) =
-{
-    rol_byte,
-    ror_byte,
-    rcl_byte,
-    rcr_byte,
-    shl_byte,
-    shr_byte,
-    shl_byte,           /* sal_byte === shl_byte  by definition */
-    sar_byte,
-};
+static u8(*opcD0_byte_operation[]) (u8 d, u8 s) = {
+    rol_byte, ror_byte, rcl_byte, rcr_byte, shl_byte, shr_byte, shl_byte,       /* sal_byte === shl_byte  by definition */
+sar_byte,};
 
 /****************************************************************************
 REMARKS:
 Handles opcode 0xc0
 ****************************************************************************/
-static void x86emuOp_opcC0_byte_RM_MEM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_opcC0_byte_RM_MEM(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     u8 *destreg;
@@ -8251,7 +8752,7 @@ static void x86emuOp_opcC0_byte_RM_MEM(u8 X86EMU_UNUSED(op1))
         destval = (*opcD0_byte_operation[rh]) (destval, amt);
         store_data_byte(destoffset, destval);
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         destreg = DECODE_RM_BYTE_REGISTER(rl);
         amt = fetch_byte_imm();
         DECODE_PRINTF2(",%x\n", amt);
@@ -8265,36 +8766,21 @@ static void x86emuOp_opcC0_byte_RM_MEM(u8 X86EMU_UNUSED(op1))
 }
 
 /* used by opcodes c1, d1, and d3. */
-static u16(*opcD1_word_operation[])(u16 s, u8 d) =
-{
-    rol_word,
-    ror_word,
-    rcl_word,
-    rcr_word,
-    shl_word,
-    shr_word,
-    shl_word,           /* sal_byte === shl_byte  by definition */
-    sar_word,
-};
+static u16(*opcD1_word_operation[]) (u16 s, u8 d) = {
+    rol_word, ror_word, rcl_word, rcr_word, shl_word, shr_word, shl_word,       /* sal_byte === shl_byte  by definition */
+sar_word,};
 
 /* used by opcodes c1, d1, and d3. */
-static u32 (*opcD1_long_operation[])(u32 s, u8 d) =
-{
-    rol_long,
-    ror_long,
-    rcl_long,
-    rcr_long,
-    shl_long,
-    shr_long,
-    shl_long,           /* sal_byte === shl_byte  by definition */
-    sar_long,
-};
+static u32(*opcD1_long_operation[]) (u32 s, u8 d) = {
+    rol_long, ror_long, rcl_long, rcr_long, shl_long, shr_long, shl_long,       /* sal_byte === shl_byte  by definition */
+sar_long,};
 
 /****************************************************************************
 REMARKS:
 Handles opcode 0xc1
 ****************************************************************************/
-static void x86emuOp_opcC1_word_RM_MEM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_opcC1_word_RM_MEM(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     uint destoffset;
@@ -8357,7 +8843,8 @@ static void x86emuOp_opcC1_word_RM_MEM(u8 X86EMU_UNUSED(op1))
             TRACE_AND_STEP();
             destval = (*opcD1_long_operation[rh]) (destval, amt);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
 
             DECODE_PRINTF("WORD PTR ");
@@ -8382,7 +8869,8 @@ static void x86emuOp_opcC1_word_RM_MEM(u8 X86EMU_UNUSED(op1))
             TRACE_AND_STEP();
             destval = (*opcD1_long_operation[rh]) (destval, amt);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
 
             DECODE_PRINTF("WORD PTR ");
@@ -8407,7 +8895,8 @@ static void x86emuOp_opcC1_word_RM_MEM(u8 X86EMU_UNUSED(op1))
             TRACE_AND_STEP();
             destval = (*opcD1_long_operation[rh]) (destval, amt);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
 
             DECODE_PRINTF("WORD PTR ");
@@ -8420,7 +8909,7 @@ static void x86emuOp_opcC1_word_RM_MEM(u8 X86EMU_UNUSED(op1))
             store_data_word(destoffset, destval);
         }
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
             u32 *destreg;
 
@@ -8429,7 +8918,8 @@ static void x86emuOp_opcC1_word_RM_MEM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF2(",%x\n", amt);
             TRACE_AND_STEP();
             *destreg = (*opcD1_long_operation[rh]) (*destreg, amt);
-        } else {
+        }
+        else {
             u16 *destreg;
 
             destreg = DECODE_RM_WORD_REGISTER(rl);
@@ -8448,7 +8938,8 @@ static void x86emuOp_opcC1_word_RM_MEM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xc2
 ****************************************************************************/
-static void x86emuOp_ret_near_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_ret_near_IMM(u8 X86EMU_UNUSED(op1))
 {
     u16 imm;
 
@@ -8456,8 +8947,8 @@ static void x86emuOp_ret_near_IMM(u8 X86EMU_UNUSED(op1))
     DECODE_PRINTF("RET\t");
     imm = fetch_word_imm();
     DECODE_PRINTF2("%x\n", imm);
-	RETURN_TRACE("RET",M.x86.saved_cs,M.x86.saved_ip);
-	TRACE_AND_STEP();
+    RETURN_TRACE("RET", M.x86.saved_cs, M.x86.saved_ip);
+    TRACE_AND_STEP();
     M.x86.R_IP = pop_word();
     M.x86.R_SP += imm;
     DECODE_CLEAR_SEGOVR();
@@ -8468,12 +8959,13 @@ static void x86emuOp_ret_near_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xc3
 ****************************************************************************/
-static void x86emuOp_ret_near(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_ret_near(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     DECODE_PRINTF("RET\n");
-	RETURN_TRACE("RET",M.x86.saved_cs,M.x86.saved_ip);
-	TRACE_AND_STEP();
+    RETURN_TRACE("RET", M.x86.saved_cs, M.x86.saved_ip);
+    TRACE_AND_STEP();
     M.x86.R_IP = pop_word();
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
@@ -8483,7 +8975,8 @@ static void x86emuOp_ret_near(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xc4
 ****************************************************************************/
-static void x86emuOp_les_R_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_les_R_IMM(u8 X86EMU_UNUSED(op1))
 {
     int mod, rh, rl;
     u16 *dstreg;
@@ -8520,7 +9013,7 @@ static void x86emuOp_les_R_IMM(u8 X86EMU_UNUSED(op1))
         *dstreg = fetch_data_word(srcoffset);
         M.x86.R_ES = fetch_data_word(srcoffset + 2);
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         /* UNDEFINED! */
         TRACE_AND_STEP();
     }
@@ -8532,7 +9025,8 @@ static void x86emuOp_les_R_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xc5
 ****************************************************************************/
-static void x86emuOp_lds_R_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_lds_R_IMM(u8 X86EMU_UNUSED(op1))
 {
     int mod, rh, rl;
     u16 *dstreg;
@@ -8569,7 +9063,7 @@ static void x86emuOp_lds_R_IMM(u8 X86EMU_UNUSED(op1))
         *dstreg = fetch_data_word(srcoffset);
         M.x86.R_DS = fetch_data_word(srcoffset + 2);
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         /* UNDEFINED! */
         TRACE_AND_STEP();
     }
@@ -8581,7 +9075,8 @@ static void x86emuOp_lds_R_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xc6
 ****************************************************************************/
-static void x86emuOp_mov_byte_RM_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_mov_byte_RM_IMM(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     u8 *destreg;
@@ -8620,7 +9115,7 @@ static void x86emuOp_mov_byte_RM_IMM(u8 X86EMU_UNUSED(op1))
         TRACE_AND_STEP();
         store_data_byte(destoffset, imm);
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         destreg = DECODE_RM_BYTE_REGISTER(rl);
         imm = fetch_byte_imm();
         DECODE_PRINTF2(",%2x\n", imm);
@@ -8636,7 +9131,8 @@ static void x86emuOp_mov_byte_RM_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xc7
 ****************************************************************************/
-static void x86emuOp_mov_word_RM_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_mov_word_RM_IMM(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     uint destoffset;
@@ -8659,7 +9155,8 @@ static void x86emuOp_mov_word_RM_IMM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF2(",%x\n", imm);
             TRACE_AND_STEP();
             store_data_long(destoffset, imm);
-        } else {
+        }
+        else {
             u16 imm;
 
             DECODE_PRINTF("WORD PTR ");
@@ -8680,7 +9177,8 @@ static void x86emuOp_mov_word_RM_IMM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF2(",%x\n", imm);
             TRACE_AND_STEP();
             store_data_long(destoffset, imm);
-        } else {
+        }
+        else {
             u16 imm;
 
             DECODE_PRINTF("WORD PTR ");
@@ -8701,7 +9199,8 @@ static void x86emuOp_mov_word_RM_IMM(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF2(",%x\n", imm);
             TRACE_AND_STEP();
             store_data_long(destoffset, imm);
-        } else {
+        }
+        else {
             u16 imm;
 
             DECODE_PRINTF("WORD PTR ");
@@ -8712,19 +9211,20 @@ static void x86emuOp_mov_word_RM_IMM(u8 X86EMU_UNUSED(op1))
             store_data_word(destoffset, imm);
         }
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-			u32 *destreg;
-			u32 imm;
+            u32 *destreg;
+            u32 imm;
 
             destreg = DECODE_RM_LONG_REGISTER(rl);
             imm = fetch_long_imm();
             DECODE_PRINTF2(",%x\n", imm);
             TRACE_AND_STEP();
             *destreg = imm;
-        } else {
-			u16 *destreg;
-			u16 imm;
+        }
+        else {
+            u16 *destreg;
+            u16 imm;
 
             destreg = DECODE_RM_WORD_REGISTER(rl);
             imm = fetch_word_imm();
@@ -8742,10 +9242,11 @@ static void x86emuOp_mov_word_RM_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xc8
 ****************************************************************************/
-static void x86emuOp_enter(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_enter(u8 X86EMU_UNUSED(op1))
 {
-    u16 local,frame_pointer;
-    u8  nesting;
+    u16 local, frame_pointer;
+    u8 nesting;
     int i;
 
     START_OF_INSTR();
@@ -8760,11 +9261,11 @@ static void x86emuOp_enter(u8 X86EMU_UNUSED(op1))
         for (i = 1; i < nesting; i++) {
             M.x86.R_BP -= 2;
             push_word(fetch_data_word_abs(M.x86.R_SS, M.x86.R_BP));
-            }
-        push_word(frame_pointer);
         }
+        push_word(frame_pointer);
+    }
     M.x86.R_BP = frame_pointer;
-    M.x86.R_SP = (u16)(M.x86.R_SP - local);
+    M.x86.R_SP = (u16) (M.x86.R_SP - local);
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
 }
@@ -8773,7 +9274,8 @@ static void x86emuOp_enter(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xc9
 ****************************************************************************/
-static void x86emuOp_leave(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_leave(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     DECODE_PRINTF("LEAVE\n");
@@ -8788,7 +9290,8 @@ static void x86emuOp_leave(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xca
 ****************************************************************************/
-static void x86emuOp_ret_far_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_ret_far_IMM(u8 X86EMU_UNUSED(op1))
 {
     u16 imm;
 
@@ -8796,8 +9299,8 @@ static void x86emuOp_ret_far_IMM(u8 X86EMU_UNUSED(op1))
     DECODE_PRINTF("RETF\t");
     imm = fetch_word_imm();
     DECODE_PRINTF2("%x\n", imm);
-	RETURN_TRACE("RETF",M.x86.saved_cs,M.x86.saved_ip);
-	TRACE_AND_STEP();
+    RETURN_TRACE("RETF", M.x86.saved_cs, M.x86.saved_ip);
+    TRACE_AND_STEP();
     M.x86.R_IP = pop_word();
     M.x86.R_CS = pop_word();
     M.x86.R_SP += imm;
@@ -8809,12 +9312,13 @@ static void x86emuOp_ret_far_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xcb
 ****************************************************************************/
-static void x86emuOp_ret_far(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_ret_far(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     DECODE_PRINTF("RETF\n");
-	RETURN_TRACE("RETF",M.x86.saved_cs,M.x86.saved_ip);
-	TRACE_AND_STEP();
+    RETURN_TRACE("RETF", M.x86.saved_cs, M.x86.saved_ip);
+    TRACE_AND_STEP();
     M.x86.R_IP = pop_word();
     M.x86.R_CS = pop_word();
     DECODE_CLEAR_SEGOVR();
@@ -8825,15 +9329,17 @@ static void x86emuOp_ret_far(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xcc
 ****************************************************************************/
-static void x86emuOp_int3(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_int3(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     DECODE_PRINTF("INT 3\n");
     TRACE_AND_STEP();
     if (_X86EMU_intrTab[3]) {
-	(*_X86EMU_intrTab[3])(3);
-    } else {
-        push_word((u16)M.x86.R_FLG);
+        (*_X86EMU_intrTab[3]) (3);
+    }
+    else {
+        push_word((u16) M.x86.R_FLG);
         CLEAR_FLAG(F_IF);
         CLEAR_FLAG(F_TF);
         push_word(M.x86.R_CS);
@@ -8849,7 +9355,8 @@ static void x86emuOp_int3(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xcd
 ****************************************************************************/
-static void x86emuOp_int_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_int_IMM(u8 X86EMU_UNUSED(op1))
 {
     u8 intnum;
 
@@ -8859,9 +9366,10 @@ static void x86emuOp_int_IMM(u8 X86EMU_UNUSED(op1))
     DECODE_PRINTF2("%x\n", intnum);
     TRACE_AND_STEP();
     if (_X86EMU_intrTab[intnum]) {
-	(*_X86EMU_intrTab[intnum])(intnum);
-    } else {
-        push_word((u16)M.x86.R_FLG);
+        (*_X86EMU_intrTab[intnum]) (intnum);
+    }
+    else {
+        push_word((u16) M.x86.R_FLG);
         CLEAR_FLAG(F_IF);
         CLEAR_FLAG(F_TF);
         push_word(M.x86.R_CS);
@@ -8877,16 +9385,18 @@ static void x86emuOp_int_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xce
 ****************************************************************************/
-static void x86emuOp_into(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_into(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     DECODE_PRINTF("INTO\n");
     TRACE_AND_STEP();
     if (ACCESS_FLAG(F_OF)) {
-	if (_X86EMU_intrTab[4]) {
-	    (*_X86EMU_intrTab[4])(4);
-        } else {
-            push_word((u16)M.x86.R_FLG);
+        if (_X86EMU_intrTab[4]) {
+            (*_X86EMU_intrTab[4]) (4);
+        }
+        else {
+            push_word((u16) M.x86.R_FLG);
             CLEAR_FLAG(F_IF);
             CLEAR_FLAG(F_TF);
             push_word(M.x86.R_CS);
@@ -8903,7 +9413,8 @@ static void x86emuOp_into(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xcf
 ****************************************************************************/
-static void x86emuOp_iret(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_iret(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     DECODE_PRINTF("IRET\n");
@@ -8921,7 +9432,8 @@ static void x86emuOp_iret(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xd0
 ****************************************************************************/
-static void x86emuOp_opcD0_byte_RM_1(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_opcD0_byte_RM_1(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     u8 *destreg;
@@ -8999,7 +9511,7 @@ static void x86emuOp_opcD0_byte_RM_1(u8 X86EMU_UNUSED(op1))
         destval = (*opcD0_byte_operation[rh]) (destval, 1);
         store_data_byte(destoffset, destval);
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         destreg = DECODE_RM_BYTE_REGISTER(rl);
         DECODE_PRINTF(",1\n");
         TRACE_AND_STEP();
@@ -9015,7 +9527,8 @@ static void x86emuOp_opcD0_byte_RM_1(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xd1
 ****************************************************************************/
-static void x86emuOp_opcD1_word_RM_1(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_opcD1_word_RM_1(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     uint destoffset;
@@ -9075,7 +9588,8 @@ static void x86emuOp_opcD1_word_RM_1(u8 X86EMU_UNUSED(op1))
             TRACE_AND_STEP();
             destval = (*opcD1_long_operation[rh]) (destval, 1);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
 
             DECODE_PRINTF("WORD PTR ");
@@ -9098,7 +9612,8 @@ static void x86emuOp_opcD1_word_RM_1(u8 X86EMU_UNUSED(op1))
             TRACE_AND_STEP();
             destval = (*opcD1_long_operation[rh]) (destval, 1);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
 
             DECODE_PRINTF("WORD PTR ");
@@ -9121,7 +9636,8 @@ static void x86emuOp_opcD1_word_RM_1(u8 X86EMU_UNUSED(op1))
             TRACE_AND_STEP();
             destval = (*opcD1_long_operation[rh]) (destval, 1);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
 
             DECODE_PRINTF("BYTE PTR ");
@@ -9133,19 +9649,20 @@ static void x86emuOp_opcD1_word_RM_1(u8 X86EMU_UNUSED(op1))
             store_data_word(destoffset, destval);
         }
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-			u32 destval;
-			u32 *destreg;
+            u32 destval;
+            u32 *destreg;
 
             destreg = DECODE_RM_LONG_REGISTER(rl);
             DECODE_PRINTF(",1\n");
             TRACE_AND_STEP();
             destval = (*opcD1_long_operation[rh]) (*destreg, 1);
             *destreg = destval;
-        } else {
-			u16 destval;
-			u16 *destreg;
+        }
+        else {
+            u16 destval;
+            u16 *destreg;
 
             destreg = DECODE_RM_WORD_REGISTER(rl);
             DECODE_PRINTF(",1\n");
@@ -9163,7 +9680,8 @@ static void x86emuOp_opcD1_word_RM_1(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xd2
 ****************************************************************************/
-static void x86emuOp_opcD2_byte_RM_CL(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_opcD2_byte_RM_CL(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     u8 *destreg;
@@ -9243,7 +9761,7 @@ static void x86emuOp_opcD2_byte_RM_CL(u8 X86EMU_UNUSED(op1))
         destval = (*opcD0_byte_operation[rh]) (destval, amt);
         store_data_byte(destoffset, destval);
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         destreg = DECODE_RM_BYTE_REGISTER(rl);
         DECODE_PRINTF(",CL\n");
         TRACE_AND_STEP();
@@ -9259,7 +9777,8 @@ static void x86emuOp_opcD2_byte_RM_CL(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xd3
 ****************************************************************************/
-static void x86emuOp_opcD3_word_RM_CL(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_opcD3_word_RM_CL(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     uint destoffset;
@@ -9321,7 +9840,8 @@ static void x86emuOp_opcD3_word_RM_CL(u8 X86EMU_UNUSED(op1))
             TRACE_AND_STEP();
             destval = (*opcD1_long_operation[rh]) (destval, amt);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
 
             DECODE_PRINTF("WORD PTR ");
@@ -9344,7 +9864,8 @@ static void x86emuOp_opcD3_word_RM_CL(u8 X86EMU_UNUSED(op1))
             TRACE_AND_STEP();
             destval = (*opcD1_long_operation[rh]) (destval, amt);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
 
             DECODE_PRINTF("WORD PTR ");
@@ -9367,7 +9888,8 @@ static void x86emuOp_opcD3_word_RM_CL(u8 X86EMU_UNUSED(op1))
             TRACE_AND_STEP();
             destval = (*opcD1_long_operation[rh]) (destval, amt);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
 
             DECODE_PRINTF("WORD PTR ");
@@ -9379,7 +9901,7 @@ static void x86emuOp_opcD3_word_RM_CL(u8 X86EMU_UNUSED(op1))
             store_data_word(destoffset, destval);
         }
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
             u32 *destreg;
 
@@ -9387,7 +9909,8 @@ static void x86emuOp_opcD3_word_RM_CL(u8 X86EMU_UNUSED(op1))
             DECODE_PRINTF(",CL\n");
             TRACE_AND_STEP();
             *destreg = (*opcD1_long_operation[rh]) (*destreg, amt);
-        } else {
+        }
+        else {
             u16 *destreg;
 
             destreg = DECODE_RM_WORD_REGISTER(rl);
@@ -9405,16 +9928,17 @@ static void x86emuOp_opcD3_word_RM_CL(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xd4
 ****************************************************************************/
-static void x86emuOp_aam(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_aam(u8 X86EMU_UNUSED(op1))
 {
     u8 a;
 
     START_OF_INSTR();
     DECODE_PRINTF("AAM\n");
-    a = fetch_byte_imm();      /* this is a stupid encoding. */
+    a = fetch_byte_imm();       /* this is a stupid encoding. */
     if (a != 10) {
-	/* fix: add base decoding
-	   aam_word(u8 val, int base a) */
+        /* fix: add base decoding
+           aam_word(u8 val, int base a) */
         DECODE_PRINTF("ERROR DECODING AAM\n");
         TRACE_REGS();
         HALT_SYS();
@@ -9430,7 +9954,8 @@ static void x86emuOp_aam(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xd5
 ****************************************************************************/
-static void x86emuOp_aad(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_aad(u8 X86EMU_UNUSED(op1))
 {
     u8 a;
 
@@ -9438,8 +9963,8 @@ static void x86emuOp_aad(u8 X86EMU_UNUSED(op1))
     DECODE_PRINTF("AAD\n");
     a = fetch_byte_imm();
     if (a != 10) {
-	/* fix: add base decoding
-	   aad_word(u16 val, int base a) */
+        /* fix: add base decoding
+           aad_word(u16 val, int base a) */
         DECODE_PRINTF("ERROR DECODING AAM\n");
         TRACE_REGS();
         HALT_SYS();
@@ -9456,14 +9981,15 @@ static void x86emuOp_aad(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xd7
 ****************************************************************************/
-static void x86emuOp_xlat(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_xlat(u8 X86EMU_UNUSED(op1))
 {
     u16 addr;
 
     START_OF_INSTR();
     DECODE_PRINTF("XLAT\n");
     TRACE_AND_STEP();
-	addr = (u16)(M.x86.R_BX + (u8)M.x86.R_AL);
+    addr = (u16) (M.x86.R_BX + (u8) M.x86.R_AL);
     M.x86.R_AL = fetch_data_byte(addr);
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
@@ -9475,7 +10001,8 @@ static void x86emuOp_xlat(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xe0
 ****************************************************************************/
-static void x86emuOp_loopne(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_loopne(u8 X86EMU_UNUSED(op1))
 {
     s16 ip;
 
@@ -9486,7 +10013,7 @@ static void x86emuOp_loopne(u8 X86EMU_UNUSED(op1))
     DECODE_PRINTF2("%04x\n", ip);
     TRACE_AND_STEP();
     M.x86.R_CX -= 1;
-    if (M.x86.R_CX != 0 && !ACCESS_FLAG(F_ZF))      /* CX != 0 and !ZF */
+    if (M.x86.R_CX != 0 && !ACCESS_FLAG(F_ZF))  /* CX != 0 and !ZF */
         M.x86.R_IP = ip;
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
@@ -9496,7 +10023,8 @@ static void x86emuOp_loopne(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xe1
 ****************************************************************************/
-static void x86emuOp_loope(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_loope(u8 X86EMU_UNUSED(op1))
 {
     s16 ip;
 
@@ -9507,7 +10035,7 @@ static void x86emuOp_loope(u8 X86EMU_UNUSED(op1))
     DECODE_PRINTF2("%04x\n", ip);
     TRACE_AND_STEP();
     M.x86.R_CX -= 1;
-    if (M.x86.R_CX != 0 && ACCESS_FLAG(F_ZF))       /* CX != 0 and ZF */
+    if (M.x86.R_CX != 0 && ACCESS_FLAG(F_ZF))   /* CX != 0 and ZF */
         M.x86.R_IP = ip;
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
@@ -9517,7 +10045,8 @@ static void x86emuOp_loope(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xe2
 ****************************************************************************/
-static void x86emuOp_loop(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_loop(u8 X86EMU_UNUSED(op1))
 {
     s16 ip;
 
@@ -9538,16 +10067,17 @@ static void x86emuOp_loop(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xe3
 ****************************************************************************/
-static void x86emuOp_jcxz(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_jcxz(u8 X86EMU_UNUSED(op1))
 {
     u16 target;
-    s8  offset;
+    s8 offset;
 
     /* jump to byte offset if overflow flag is set */
     START_OF_INSTR();
     DECODE_PRINTF("JCXZ\t");
-    offset = (s8)fetch_byte_imm();
-    target = (u16)(M.x86.R_IP + offset);
+    offset = (s8) fetch_byte_imm();
+    target = (u16) (M.x86.R_IP + offset);
     DECODE_PRINTF2("%x\n", target);
     TRACE_AND_STEP();
     if (M.x86.R_CX == 0)
@@ -9560,16 +10090,17 @@ static void x86emuOp_jcxz(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xe4
 ****************************************************************************/
-static void x86emuOp_in_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_in_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
 {
     u8 port;
 
     START_OF_INSTR();
     DECODE_PRINTF("IN\t");
-	port = (u8) fetch_byte_imm();
+    port = (u8) fetch_byte_imm();
     DECODE_PRINTF2("%x,AL\n", port);
     TRACE_AND_STEP();
-    M.x86.R_AL = (*sys_inb)(port);
+    M.x86.R_AL = (*sys_inb) (port);
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
 }
@@ -9578,23 +10109,26 @@ static void x86emuOp_in_byte_AL_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xe5
 ****************************************************************************/
-static void x86emuOp_in_word_AX_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_in_word_AX_IMM(u8 X86EMU_UNUSED(op1))
 {
     u8 port;
 
     START_OF_INSTR();
     DECODE_PRINTF("IN\t");
-	port = (u8) fetch_byte_imm();
+    port = (u8) fetch_byte_imm();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF2("EAX,%x\n", port);
-    } else {
+    }
+    else {
         DECODE_PRINTF2("AX,%x\n", port);
     }
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-        M.x86.R_EAX = (*sys_inl)(port);
-    } else {
-        M.x86.R_AX = (*sys_inw)(port);
+        M.x86.R_EAX = (*sys_inl) (port);
+    }
+    else {
+        M.x86.R_AX = (*sys_inw) (port);
     }
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
@@ -9604,16 +10138,17 @@ static void x86emuOp_in_word_AX_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xe6
 ****************************************************************************/
-static void x86emuOp_out_byte_IMM_AL(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_out_byte_IMM_AL(u8 X86EMU_UNUSED(op1))
 {
     u8 port;
 
     START_OF_INSTR();
     DECODE_PRINTF("OUT\t");
-	port = (u8) fetch_byte_imm();
+    port = (u8) fetch_byte_imm();
     DECODE_PRINTF2("%x,AL\n", port);
     TRACE_AND_STEP();
-    (*sys_outb)(port, M.x86.R_AL);
+    (*sys_outb) (port, M.x86.R_AL);
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
 }
@@ -9622,23 +10157,26 @@ static void x86emuOp_out_byte_IMM_AL(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xe7
 ****************************************************************************/
-static void x86emuOp_out_word_IMM_AX(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_out_word_IMM_AX(u8 X86EMU_UNUSED(op1))
 {
     u8 port;
 
     START_OF_INSTR();
     DECODE_PRINTF("OUT\t");
-	port = (u8) fetch_byte_imm();
+    port = (u8) fetch_byte_imm();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF2("%x,EAX\n", port);
-    } else {
+    }
+    else {
         DECODE_PRINTF2("%x,AX\n", port);
     }
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-        (*sys_outl)(port, M.x86.R_EAX);
-    } else {
-        (*sys_outw)(port, M.x86.R_AX);
+        (*sys_outl) (port, M.x86.R_EAX);
+    }
+    else {
+        (*sys_outw) (port, M.x86.R_AX);
     }
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
@@ -9648,19 +10186,35 @@ static void x86emuOp_out_word_IMM_AX(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xe8
 ****************************************************************************/
-static void x86emuOp_call_near_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_call_near_IMM(u8 X86EMU_UNUSED(op1))
 {
-    s16 ip;
+    s16 ip16;
+    s32 ip32;
 
     START_OF_INSTR();
-	DECODE_PRINTF("CALL\t");
-	ip = (s16) fetch_word_imm();
-	ip += (s16) M.x86.R_IP;    /* CHECK SIGN */
-	DECODE_PRINTF2("%04x\n", (u16)ip);
-	CALL_TRACE(M.x86.saved_cs, M.x86.saved_ip, M.x86.R_CS, ip, "");
+    DECODE_PRINTF("CALL\t");
+    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
+        ip32 = (s32) fetch_long_imm();
+        ip32 += (s16) M.x86.R_IP;       /* CHECK SIGN */
+        DECODE_PRINTF2("%04x\n", (u16) ip32);
+        CALL_TRACE(M.x86.saved_cs, M.x86.saved_ip, M.x86.R_CS, ip32, "");
+    }
+    else {
+        ip16 = (s16) fetch_word_imm();
+        ip16 += (s16) M.x86.R_IP;       /* CHECK SIGN */
+        DECODE_PRINTF2("%04x\n", (u16) ip16);
+        CALL_TRACE(M.x86.saved_cs, M.x86.saved_ip, M.x86.R_CS, ip16, "");
+    }
     TRACE_AND_STEP();
-    push_word(M.x86.R_IP);
-    M.x86.R_IP = ip;
+    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
+        push_long(M.x86.R_EIP);
+        M.x86.R_EIP = ip32 & 0xffff;
+    }
+    else {
+        push_word(M.x86.R_IP);
+        M.x86.R_EIP = ip16;
+    }
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
 }
@@ -9669,17 +10223,27 @@ static void x86emuOp_call_near_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xe9
 ****************************************************************************/
-static void x86emuOp_jump_near_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_jump_near_IMM(u8 X86EMU_UNUSED(op1))
 {
-    int ip;
+    u32 ip;
 
     START_OF_INSTR();
     DECODE_PRINTF("JMP\t");
-    ip = (s16)fetch_word_imm();
-    ip += (s16)M.x86.R_IP;
-    DECODE_PRINTF2("%04x\n", (u16)ip);
-    TRACE_AND_STEP();
-    M.x86.R_IP = (u16)ip;
+    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
+        ip = (u32) fetch_long_imm();
+        ip += (u32) M.x86.R_EIP;
+        DECODE_PRINTF2("%08x\n", (u32) ip);
+        TRACE_AND_STEP();
+        M.x86.R_EIP = (u32) ip;
+    }
+    else {
+        ip = (s16) fetch_word_imm();
+        ip += (s16) M.x86.R_IP;
+        DECODE_PRINTF2("%04x\n", (u16) ip);
+        TRACE_AND_STEP();
+        M.x86.R_IP = (u16) ip;
+    }
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
 }
@@ -9688,18 +10252,25 @@ static void x86emuOp_jump_near_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xea
 ****************************************************************************/
-static void x86emuOp_jump_far_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_jump_far_IMM(u8 X86EMU_UNUSED(op1))
 {
-    u16 cs, ip;
+    u16 cs;
+    u32 ip;
 
     START_OF_INSTR();
     DECODE_PRINTF("JMP\tFAR ");
-    ip = fetch_word_imm();
+    if (M.x86.mode & SYSMODE_PREFIX_DATA) {
+        ip = fetch_long_imm();
+    }
+    else {
+        ip = fetch_word_imm();
+    }
     cs = fetch_word_imm();
     DECODE_PRINTF2("%04x:", cs);
     DECODE_PRINTF2("%04x\n", ip);
     TRACE_AND_STEP();
-    M.x86.R_IP = ip;
+    M.x86.R_EIP = ip & 0xffff;
     M.x86.R_CS = cs;
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
@@ -9709,15 +10280,16 @@ static void x86emuOp_jump_far_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xeb
 ****************************************************************************/
-static void x86emuOp_jump_byte_IMM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_jump_byte_IMM(u8 X86EMU_UNUSED(op1))
 {
     u16 target;
     s8 offset;
 
     START_OF_INSTR();
     DECODE_PRINTF("JMP\t");
-    offset = (s8)fetch_byte_imm();
-    target = (u16)(M.x86.R_IP + offset);
+    offset = (s8) fetch_byte_imm();
+    target = (u16) (M.x86.R_IP + offset);
     DECODE_PRINTF2("%x\n", target);
     TRACE_AND_STEP();
     M.x86.R_IP = target;
@@ -9729,12 +10301,13 @@ static void x86emuOp_jump_byte_IMM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xec
 ****************************************************************************/
-static void x86emuOp_in_byte_AL_DX(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_in_byte_AL_DX(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     DECODE_PRINTF("IN\tAL,DX\n");
     TRACE_AND_STEP();
-    M.x86.R_AL = (*sys_inb)(M.x86.R_DX);
+    M.x86.R_AL = (*sys_inb) (M.x86.R_DX);
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
 }
@@ -9743,19 +10316,22 @@ static void x86emuOp_in_byte_AL_DX(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xed
 ****************************************************************************/
-static void x86emuOp_in_word_AX_DX(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_in_word_AX_DX(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("IN\tEAX,DX\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("IN\tAX,DX\n");
     }
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-        M.x86.R_EAX = (*sys_inl)(M.x86.R_DX);
-    } else {
-        M.x86.R_AX = (*sys_inw)(M.x86.R_DX);
+        M.x86.R_EAX = (*sys_inl) (M.x86.R_DX);
+    }
+    else {
+        M.x86.R_AX = (*sys_inw) (M.x86.R_DX);
     }
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
@@ -9765,12 +10341,13 @@ static void x86emuOp_in_word_AX_DX(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xee
 ****************************************************************************/
-static void x86emuOp_out_byte_DX_AL(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_out_byte_DX_AL(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     DECODE_PRINTF("OUT\tDX,AL\n");
     TRACE_AND_STEP();
-    (*sys_outb)(M.x86.R_DX, M.x86.R_AL);
+    (*sys_outb) (M.x86.R_DX, M.x86.R_AL);
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
 }
@@ -9779,19 +10356,22 @@ static void x86emuOp_out_byte_DX_AL(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xef
 ****************************************************************************/
-static void x86emuOp_out_word_DX_AX(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_out_word_DX_AX(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
         DECODE_PRINTF("OUT\tDX,EAX\n");
-    } else {
+    }
+    else {
         DECODE_PRINTF("OUT\tDX,AX\n");
     }
     TRACE_AND_STEP();
     if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-        (*sys_outl)(M.x86.R_DX, M.x86.R_EAX);
-    } else {
-        (*sys_outw)(M.x86.R_DX, M.x86.R_AX);
+        (*sys_outl) (M.x86.R_DX, M.x86.R_EAX);
+    }
+    else {
+        (*sys_outw) (M.x86.R_DX, M.x86.R_AX);
     }
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
@@ -9801,7 +10381,8 @@ static void x86emuOp_out_word_DX_AX(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xf0
 ****************************************************************************/
-static void x86emuOp_lock(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_lock(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     DECODE_PRINTF("LOCK:\n");
@@ -9816,7 +10397,8 @@ static void x86emuOp_lock(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xf2
 ****************************************************************************/
-static void x86emuOp_repne(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_repne(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     DECODE_PRINTF("REPNE\n");
@@ -9830,7 +10412,8 @@ static void x86emuOp_repne(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xf3
 ****************************************************************************/
-static void x86emuOp_repe(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_repe(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     DECODE_PRINTF("REPE\n");
@@ -9844,7 +10427,8 @@ static void x86emuOp_repe(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xf4
 ****************************************************************************/
-static void x86emuOp_halt(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_halt(u8 X86EMU_UNUSED(op1))
 {
     START_OF_INSTR();
     DECODE_PRINTF("HALT\n");
@@ -9858,7 +10442,8 @@ static void x86emuOp_halt(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xf5
 ****************************************************************************/
-static void x86emuOp_cmc(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_cmc(u8 X86EMU_UNUSED(op1))
 {
     /* complement the carry flag. */
     START_OF_INSTR();
@@ -9873,7 +10458,8 @@ static void x86emuOp_cmc(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xf6
 ****************************************************************************/
-static void x86emuOp_opcF6_byte_RM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_opcF6_byte_RM(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     u8 *destreg;
@@ -9885,9 +10471,9 @@ static void x86emuOp_opcF6_byte_RM(u8 X86EMU_UNUSED(op1))
     START_OF_INSTR();
     FETCH_DECODE_MODRM(mod, rh, rl);
     switch (mod) {
-    case 0:                     /* mod=00 */
+    case 0:                    /* mod=00 */
         switch (rh) {
-        case 0:         /* test byte imm */
+        case 0:                /* test byte imm */
             DECODE_PRINTF("TEST\tBYTE PTR ");
             destoffset = decode_rm00_address(rl);
             DECODE_PRINTF(",");
@@ -9953,9 +10539,9 @@ static void x86emuOp_opcF6_byte_RM(u8 X86EMU_UNUSED(op1))
             break;
         }
         break;                  /* end mod==00 */
-    case 1:                     /* mod=01 */
+    case 1:                    /* mod=01 */
         switch (rh) {
-        case 0:         /* test byte imm */
+        case 0:                /* test byte imm */
             DECODE_PRINTF("TEST\tBYTE PTR ");
             destoffset = decode_rm01_address(rl);
             DECODE_PRINTF(",");
@@ -10021,9 +10607,9 @@ static void x86emuOp_opcF6_byte_RM(u8 X86EMU_UNUSED(op1))
             break;
         }
         break;                  /* end mod==01 */
-    case 2:                     /* mod=10 */
+    case 2:                    /* mod=10 */
         switch (rh) {
-        case 0:         /* test byte imm */
+        case 0:                /* test byte imm */
             DECODE_PRINTF("TEST\tBYTE PTR ");
             destoffset = decode_rm10_address(rl);
             DECODE_PRINTF(",");
@@ -10089,9 +10675,9 @@ static void x86emuOp_opcF6_byte_RM(u8 X86EMU_UNUSED(op1))
             break;
         }
         break;                  /* end mod==10 */
-    case 3:                     /* mod=11 */
+    case 3:                    /* mod=11 */
         switch (rh) {
-        case 0:         /* test byte imm */
+        case 0:                /* test byte imm */
             DECODE_PRINTF("TEST\t");
             destreg = DECODE_RM_BYTE_REGISTER(rl);
             DECODE_PRINTF(",");
@@ -10123,7 +10709,7 @@ static void x86emuOp_opcF6_byte_RM(u8 X86EMU_UNUSED(op1))
             destreg = DECODE_RM_BYTE_REGISTER(rl);
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
-            mul_byte(*destreg);      /*!!!  */
+            mul_byte(*destreg); /*!!!  */
             break;
         case 5:
             DECODE_PRINTF("IMUL\t");
@@ -10157,7 +10743,8 @@ static void x86emuOp_opcF6_byte_RM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xf7
 ****************************************************************************/
-static void x86emuOp_opcF7_word_RM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_opcF7_word_RM(u8 X86EMU_UNUSED(op1))
 {
     int mod, rl, rh;
     uint destoffset;
@@ -10167,11 +10754,11 @@ static void x86emuOp_opcF7_word_RM(u8 X86EMU_UNUSED(op1))
     START_OF_INSTR();
     FETCH_DECODE_MODRM(mod, rh, rl);
     switch (mod) {
-    case 0:                     /* mod=00 */
+    case 0:                    /* mod=00 */
         switch (rh) {
-        case 0:         /* test word imm */
+        case 0:                /* test word imm */
             if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-                u32 destval,srcval;
+                u32 destval, srcval;
 
                 DECODE_PRINTF("TEST\tDWORD PTR ");
                 destoffset = decode_rm00_address(rl);
@@ -10181,8 +10768,9 @@ static void x86emuOp_opcF7_word_RM(u8 X86EMU_UNUSED(op1))
                 destval = fetch_data_long(destoffset);
                 TRACE_AND_STEP();
                 test_long(destval, srcval);
-            } else {
-                u16 destval,srcval;
+            }
+            else {
+                u16 destval, srcval;
 
                 DECODE_PRINTF("TEST\tWORD PTR ");
                 destoffset = decode_rm00_address(rl);
@@ -10209,7 +10797,8 @@ static void x86emuOp_opcF7_word_RM(u8 X86EMU_UNUSED(op1))
                 TRACE_AND_STEP();
                 destval = not_long(destval);
                 store_data_long(destoffset, destval);
-            } else {
+            }
+            else {
                 u16 destval;
 
                 DECODE_PRINTF("NOT\tWORD PTR ");
@@ -10232,7 +10821,8 @@ static void x86emuOp_opcF7_word_RM(u8 X86EMU_UNUSED(op1))
                 TRACE_AND_STEP();
                 destval = neg_long(destval);
                 store_data_long(destoffset, destval);
-            } else {
+            }
+            else {
                 u16 destval;
 
                 DECODE_PRINTF("NEG\tWORD PTR ");
@@ -10254,7 +10844,8 @@ static void x86emuOp_opcF7_word_RM(u8 X86EMU_UNUSED(op1))
                 destval = fetch_data_long(destoffset);
                 TRACE_AND_STEP();
                 mul_long(destval);
-            } else {
+            }
+            else {
                 u16 destval;
 
                 DECODE_PRINTF("MUL\tWORD PTR ");
@@ -10275,7 +10866,8 @@ static void x86emuOp_opcF7_word_RM(u8 X86EMU_UNUSED(op1))
                 destval = fetch_data_long(destoffset);
                 TRACE_AND_STEP();
                 imul_long(destval);
-            } else {
+            }
+            else {
                 u16 destval;
 
                 DECODE_PRINTF("IMUL\tWORD PTR ");
@@ -10296,7 +10888,8 @@ static void x86emuOp_opcF7_word_RM(u8 X86EMU_UNUSED(op1))
                 destval = fetch_data_long(destoffset);
                 TRACE_AND_STEP();
                 div_long(destval);
-            } else {
+            }
+            else {
                 u16 destval;
 
                 DECODE_PRINTF("DIV\tWORD PTR ");
@@ -10317,7 +10910,8 @@ static void x86emuOp_opcF7_word_RM(u8 X86EMU_UNUSED(op1))
                 destval = fetch_data_long(destoffset);
                 TRACE_AND_STEP();
                 idiv_long(destval);
-            } else {
+            }
+            else {
                 u16 destval;
 
                 DECODE_PRINTF("IDIV\tWORD PTR ");
@@ -10330,11 +10924,11 @@ static void x86emuOp_opcF7_word_RM(u8 X86EMU_UNUSED(op1))
             break;
         }
         break;                  /* end mod==00 */
-    case 1:                     /* mod=01 */
+    case 1:                    /* mod=01 */
         switch (rh) {
-        case 0:         /* test word imm */
+        case 0:                /* test word imm */
             if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-                u32 destval,srcval;
+                u32 destval, srcval;
 
                 DECODE_PRINTF("TEST\tDWORD PTR ");
                 destoffset = decode_rm01_address(rl);
@@ -10344,8 +10938,9 @@ static void x86emuOp_opcF7_word_RM(u8 X86EMU_UNUSED(op1))
                 destval = fetch_data_long(destoffset);
                 TRACE_AND_STEP();
                 test_long(destval, srcval);
-            } else {
-                u16 destval,srcval;
+            }
+            else {
+                u16 destval, srcval;
 
                 DECODE_PRINTF("TEST\tWORD PTR ");
                 destoffset = decode_rm01_address(rl);
@@ -10372,7 +10967,8 @@ static void x86emuOp_opcF7_word_RM(u8 X86EMU_UNUSED(op1))
                 TRACE_AND_STEP();
                 destval = not_long(destval);
                 store_data_long(destoffset, destval);
-            } else {
+            }
+            else {
                 u16 destval;
 
                 DECODE_PRINTF("NOT\tWORD PTR ");
@@ -10395,7 +10991,8 @@ static void x86emuOp_opcF7_word_RM(u8 X86EMU_UNUSED(op1))
                 TRACE_AND_STEP();
                 destval = neg_long(destval);
                 store_data_long(destoffset, destval);
-            } else {
+            }
+            else {
                 u16 destval;
 
                 DECODE_PRINTF("NEG\tWORD PTR ");
@@ -10417,7 +11014,8 @@ static void x86emuOp_opcF7_word_RM(u8 X86EMU_UNUSED(op1))
                 destval = fetch_data_long(destoffset);
                 TRACE_AND_STEP();
                 mul_long(destval);
-            } else {
+            }
+            else {
                 u16 destval;
 
                 DECODE_PRINTF("MUL\tWORD PTR ");
@@ -10438,7 +11036,8 @@ static void x86emuOp_opcF7_word_RM(u8 X86EMU_UNUSED(op1))
                 destval = fetch_data_long(destoffset);
                 TRACE_AND_STEP();
                 imul_long(destval);
-            } else {
+            }
+            else {
                 u16 destval;
 
                 DECODE_PRINTF("IMUL\tWORD PTR ");
@@ -10459,7 +11058,8 @@ static void x86emuOp_opcF7_word_RM(u8 X86EMU_UNUSED(op1))
                 destval = fetch_data_long(destoffset);
                 TRACE_AND_STEP();
                 div_long(destval);
-            } else {
+            }
+            else {
                 u16 destval;
 
                 DECODE_PRINTF("DIV\tWORD PTR ");
@@ -10480,7 +11080,8 @@ static void x86emuOp_opcF7_word_RM(u8 X86EMU_UNUSED(op1))
                 destval = fetch_data_long(destoffset);
                 TRACE_AND_STEP();
                 idiv_long(destval);
-            } else {
+            }
+            else {
                 u16 destval;
 
                 DECODE_PRINTF("IDIV\tWORD PTR ");
@@ -10493,11 +11094,11 @@ static void x86emuOp_opcF7_word_RM(u8 X86EMU_UNUSED(op1))
             break;
         }
         break;                  /* end mod==01 */
-    case 2:                     /* mod=10 */
+    case 2:                    /* mod=10 */
         switch (rh) {
-        case 0:         /* test word imm */
+        case 0:                /* test word imm */
             if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-                u32 destval,srcval;
+                u32 destval, srcval;
 
                 DECODE_PRINTF("TEST\tDWORD PTR ");
                 destoffset = decode_rm10_address(rl);
@@ -10507,8 +11108,9 @@ static void x86emuOp_opcF7_word_RM(u8 X86EMU_UNUSED(op1))
                 destval = fetch_data_long(destoffset);
                 TRACE_AND_STEP();
                 test_long(destval, srcval);
-            } else {
-                u16 destval,srcval;
+            }
+            else {
+                u16 destval, srcval;
 
                 DECODE_PRINTF("TEST\tWORD PTR ");
                 destoffset = decode_rm10_address(rl);
@@ -10535,7 +11137,8 @@ static void x86emuOp_opcF7_word_RM(u8 X86EMU_UNUSED(op1))
                 TRACE_AND_STEP();
                 destval = not_long(destval);
                 store_data_long(destoffset, destval);
-            } else {
+            }
+            else {
                 u16 destval;
 
                 DECODE_PRINTF("NOT\tWORD PTR ");
@@ -10558,7 +11161,8 @@ static void x86emuOp_opcF7_word_RM(u8 X86EMU_UNUSED(op1))
                 TRACE_AND_STEP();
                 destval = neg_long(destval);
                 store_data_long(destoffset, destval);
-            } else {
+            }
+            else {
                 u16 destval;
 
                 DECODE_PRINTF("NEG\tWORD PTR ");
@@ -10580,7 +11184,8 @@ static void x86emuOp_opcF7_word_RM(u8 X86EMU_UNUSED(op1))
                 destval = fetch_data_long(destoffset);
                 TRACE_AND_STEP();
                 mul_long(destval);
-            } else {
+            }
+            else {
                 u16 destval;
 
                 DECODE_PRINTF("MUL\tWORD PTR ");
@@ -10601,7 +11206,8 @@ static void x86emuOp_opcF7_word_RM(u8 X86EMU_UNUSED(op1))
                 destval = fetch_data_long(destoffset);
                 TRACE_AND_STEP();
                 imul_long(destval);
-            } else {
+            }
+            else {
                 u16 destval;
 
                 DECODE_PRINTF("IMUL\tWORD PTR ");
@@ -10622,7 +11228,8 @@ static void x86emuOp_opcF7_word_RM(u8 X86EMU_UNUSED(op1))
                 destval = fetch_data_long(destoffset);
                 TRACE_AND_STEP();
                 div_long(destval);
-            } else {
+            }
+            else {
                 u16 destval;
 
                 DECODE_PRINTF("DIV\tWORD PTR ");
@@ -10643,7 +11250,8 @@ static void x86emuOp_opcF7_word_RM(u8 X86EMU_UNUSED(op1))
                 destval = fetch_data_long(destoffset);
                 TRACE_AND_STEP();
                 idiv_long(destval);
-            } else {
+            }
+            else {
                 u16 destval;
 
                 DECODE_PRINTF("IDIV\tWORD PTR ");
@@ -10656,9 +11264,9 @@ static void x86emuOp_opcF7_word_RM(u8 X86EMU_UNUSED(op1))
             break;
         }
         break;                  /* end mod==10 */
-    case 3:                     /* mod=11 */
+    case 3:                    /* mod=11 */
         switch (rh) {
-        case 0:         /* test word imm */
+        case 0:                /* test word imm */
             if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                 u32 *destreg;
                 u32 srcval;
@@ -10670,7 +11278,8 @@ static void x86emuOp_opcF7_word_RM(u8 X86EMU_UNUSED(op1))
                 DECODE_PRINTF2("%x\n", srcval);
                 TRACE_AND_STEP();
                 test_long(*destreg, srcval);
-            } else {
+            }
+            else {
                 u16 *destreg;
                 u16 srcval;
 
@@ -10696,7 +11305,8 @@ static void x86emuOp_opcF7_word_RM(u8 X86EMU_UNUSED(op1))
                 DECODE_PRINTF("\n");
                 TRACE_AND_STEP();
                 *destreg = not_long(*destreg);
-            } else {
+            }
+            else {
                 u16 *destreg;
 
                 DECODE_PRINTF("NOT\t");
@@ -10715,7 +11325,8 @@ static void x86emuOp_opcF7_word_RM(u8 X86EMU_UNUSED(op1))
                 DECODE_PRINTF("\n");
                 TRACE_AND_STEP();
                 *destreg = neg_long(*destreg);
-            } else {
+            }
+            else {
                 u16 *destreg;
 
                 DECODE_PRINTF("NEG\t");
@@ -10733,15 +11344,16 @@ static void x86emuOp_opcF7_word_RM(u8 X86EMU_UNUSED(op1))
                 destreg = DECODE_RM_LONG_REGISTER(rl);
                 DECODE_PRINTF("\n");
                 TRACE_AND_STEP();
-                mul_long(*destreg);      /*!!!  */
-            } else {
+                mul_long(*destreg);     /*!!!  */
+            }
+            else {
                 u16 *destreg;
 
                 DECODE_PRINTF("MUL\t");
                 destreg = DECODE_RM_WORD_REGISTER(rl);
                 DECODE_PRINTF("\n");
                 TRACE_AND_STEP();
-                mul_word(*destreg);      /*!!!  */
+                mul_word(*destreg);     /*!!!  */
             }
             break;
         case 5:
@@ -10753,7 +11365,8 @@ static void x86emuOp_opcF7_word_RM(u8 X86EMU_UNUSED(op1))
                 DECODE_PRINTF("\n");
                 TRACE_AND_STEP();
                 imul_long(*destreg);
-            } else {
+            }
+            else {
                 u16 *destreg;
 
                 DECODE_PRINTF("IMUL\t");
@@ -10772,7 +11385,8 @@ static void x86emuOp_opcF7_word_RM(u8 X86EMU_UNUSED(op1))
                 DECODE_PRINTF("\n");
                 TRACE_AND_STEP();
                 div_long(*destreg);
-            } else {
+            }
+            else {
                 u16 *destreg;
 
                 DECODE_PRINTF("DIV\t");
@@ -10791,7 +11405,8 @@ static void x86emuOp_opcF7_word_RM(u8 X86EMU_UNUSED(op1))
                 DECODE_PRINTF("\n");
                 TRACE_AND_STEP();
                 idiv_long(*destreg);
-            } else {
+            }
+            else {
                 u16 *destreg;
 
                 DECODE_PRINTF("IDIV\t");
@@ -10812,7 +11427,8 @@ static void x86emuOp_opcF7_word_RM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xf8
 ****************************************************************************/
-static void x86emuOp_clc(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_clc(u8 X86EMU_UNUSED(op1))
 {
     /* clear the carry flag. */
     START_OF_INSTR();
@@ -10827,7 +11443,8 @@ static void x86emuOp_clc(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xf9
 ****************************************************************************/
-static void x86emuOp_stc(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_stc(u8 X86EMU_UNUSED(op1))
 {
     /* set the carry flag. */
     START_OF_INSTR();
@@ -10842,7 +11459,8 @@ static void x86emuOp_stc(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xfa
 ****************************************************************************/
-static void x86emuOp_cli(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_cli(u8 X86EMU_UNUSED(op1))
 {
     /* clear interrupts. */
     START_OF_INSTR();
@@ -10857,7 +11475,8 @@ static void x86emuOp_cli(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xfb
 ****************************************************************************/
-static void x86emuOp_sti(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_sti(u8 X86EMU_UNUSED(op1))
 {
     /* enable  interrupts. */
     START_OF_INSTR();
@@ -10872,7 +11491,8 @@ static void x86emuOp_sti(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xfc
 ****************************************************************************/
-static void x86emuOp_cld(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_cld(u8 X86EMU_UNUSED(op1))
 {
     /* clear interrupts. */
     START_OF_INSTR();
@@ -10887,7 +11507,8 @@ static void x86emuOp_cld(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xfd
 ****************************************************************************/
-static void x86emuOp_std(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_std(u8 X86EMU_UNUSED(op1))
 {
     /* clear interrupts. */
     START_OF_INSTR();
@@ -10902,7 +11523,8 @@ static void x86emuOp_std(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xfe
 ****************************************************************************/
-static void x86emuOp_opcFE_byte_RM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_opcFE_byte_RM(u8 X86EMU_UNUSED(op1))
 {
     int mod, rh, rl;
     u8 destval;
@@ -10944,13 +11566,13 @@ static void x86emuOp_opcFE_byte_RM(u8 X86EMU_UNUSED(op1))
         destoffset = decode_rm00_address(rl);
         DECODE_PRINTF("\n");
         switch (rh) {
-        case 0:         /* inc word ptr ... */
+        case 0:                /* inc word ptr ... */
             destval = fetch_data_byte(destoffset);
             TRACE_AND_STEP();
             destval = inc_byte(destval);
             store_data_byte(destoffset, destval);
             break;
-        case 1:         /* dec word ptr ... */
+        case 1:                /* dec word ptr ... */
             destval = fetch_data_byte(destoffset);
             TRACE_AND_STEP();
             destval = dec_byte(destval);
@@ -11019,12 +11641,13 @@ static void x86emuOp_opcFE_byte_RM(u8 X86EMU_UNUSED(op1))
 REMARKS:
 Handles opcode 0xff
 ****************************************************************************/
-static void x86emuOp_opcFF_word_RM(u8 X86EMU_UNUSED(op1))
+static void
+x86emuOp_opcFF_word_RM(u8 X86EMU_UNUSED(op1))
 {
     int mod, rh, rl;
     uint destoffset = 0;
-	u16 *destreg;
-	u16 destval,destval2;
+    u16 *destreg;
+    u16 destval, destval2;
 
     /* Yet another special case instruction. */
     START_OF_INSTR();
@@ -11040,14 +11663,16 @@ static void x86emuOp_opcFF_word_RM(u8 X86EMU_UNUSED(op1))
         case 0:
             if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                 DECODE_PRINTF("INC\tDWORD PTR ");
-            } else {
+            }
+            else {
                 DECODE_PRINTF("INC\tWORD PTR ");
             }
             break;
         case 1:
             if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                 DECODE_PRINTF("DEC\tDWORD PTR ");
-            } else {
+            }
+            else {
                 DECODE_PRINTF("DEC\tWORD PTR ");
             }
             break;
@@ -11078,7 +11703,7 @@ static void x86emuOp_opcFF_word_RM(u8 X86EMU_UNUSED(op1))
         destoffset = decode_rm00_address(rl);
         DECODE_PRINTF("\n");
         switch (rh) {
-        case 0:         /* inc word ptr ... */
+        case 0:                /* inc word ptr ... */
             if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                 u32 destval;
 
@@ -11086,7 +11711,8 @@ static void x86emuOp_opcFF_word_RM(u8 X86EMU_UNUSED(op1))
                 TRACE_AND_STEP();
                 destval = inc_long(destval);
                 store_data_long(destoffset, destval);
-            } else {
+            }
+            else {
                 u16 destval;
 
                 destval = fetch_data_word(destoffset);
@@ -11095,7 +11721,7 @@ static void x86emuOp_opcFF_word_RM(u8 X86EMU_UNUSED(op1))
                 store_data_word(destoffset, destval);
             }
             break;
-        case 1:         /* dec word ptr ... */
+        case 1:                /* dec word ptr ... */
             if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                 u32 destval;
 
@@ -11103,7 +11729,8 @@ static void x86emuOp_opcFF_word_RM(u8 X86EMU_UNUSED(op1))
                 TRACE_AND_STEP();
                 destval = dec_long(destval);
                 store_data_long(destoffset, destval);
-            } else {
+            }
+            else {
                 u16 destval;
 
                 destval = fetch_data_word(destoffset);
@@ -11112,13 +11739,13 @@ static void x86emuOp_opcFF_word_RM(u8 X86EMU_UNUSED(op1))
                 store_data_word(destoffset, destval);
             }
             break;
-        case 2:         /* call word ptr ... */
+        case 2:                /* call word ptr ... */
             destval = fetch_data_word(destoffset);
             TRACE_AND_STEP();
             push_word(M.x86.R_IP);
             M.x86.R_IP = destval;
             break;
-        case 3:         /* call far ptr ... */
+        case 3:                /* call far ptr ... */
             destval = fetch_data_word(destoffset);
             destval2 = fetch_data_word(destoffset + 2);
             TRACE_AND_STEP();
@@ -11127,26 +11754,27 @@ static void x86emuOp_opcFF_word_RM(u8 X86EMU_UNUSED(op1))
             push_word(M.x86.R_IP);
             M.x86.R_IP = destval;
             break;
-        case 4:         /* jmp word ptr ... */
+        case 4:                /* jmp word ptr ... */
             destval = fetch_data_word(destoffset);
             TRACE_AND_STEP();
             M.x86.R_IP = destval;
             break;
-        case 5:         /* jmp far ptr ... */
+        case 5:                /* jmp far ptr ... */
             destval = fetch_data_word(destoffset);
             destval2 = fetch_data_word(destoffset + 2);
             TRACE_AND_STEP();
             M.x86.R_IP = destval;
             M.x86.R_CS = destval2;
             break;
-        case 6:         /*  push word ptr ... */
+        case 6:                /*  push word ptr ... */
             if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                 u32 destval;
 
                 destval = fetch_data_long(destoffset);
                 TRACE_AND_STEP();
                 push_long(destval);
-            } else {
+            }
+            else {
                 u16 destval;
 
                 destval = fetch_data_word(destoffset);
@@ -11168,7 +11796,8 @@ static void x86emuOp_opcFF_word_RM(u8 X86EMU_UNUSED(op1))
                 TRACE_AND_STEP();
                 destval = inc_long(destval);
                 store_data_long(destoffset, destval);
-            } else {
+            }
+            else {
                 u16 destval;
 
                 destval = fetch_data_word(destoffset);
@@ -11185,7 +11814,8 @@ static void x86emuOp_opcFF_word_RM(u8 X86EMU_UNUSED(op1))
                 TRACE_AND_STEP();
                 destval = dec_long(destval);
                 store_data_long(destoffset, destval);
-            } else {
+            }
+            else {
                 u16 destval;
 
                 destval = fetch_data_word(destoffset);
@@ -11194,13 +11824,13 @@ static void x86emuOp_opcFF_word_RM(u8 X86EMU_UNUSED(op1))
                 store_data_word(destoffset, destval);
             }
             break;
-        case 2:         /* call word ptr ... */
+        case 2:                /* call word ptr ... */
             destval = fetch_data_word(destoffset);
             TRACE_AND_STEP();
             push_word(M.x86.R_IP);
             M.x86.R_IP = destval;
             break;
-        case 3:         /* call far ptr ... */
+        case 3:                /* call far ptr ... */
             destval = fetch_data_word(destoffset);
             destval2 = fetch_data_word(destoffset + 2);
             TRACE_AND_STEP();
@@ -11209,26 +11839,27 @@ static void x86emuOp_opcFF_word_RM(u8 X86EMU_UNUSED(op1))
             push_word(M.x86.R_IP);
             M.x86.R_IP = destval;
             break;
-        case 4:         /* jmp word ptr ... */
+        case 4:                /* jmp word ptr ... */
             destval = fetch_data_word(destoffset);
             TRACE_AND_STEP();
             M.x86.R_IP = destval;
             break;
-        case 5:         /* jmp far ptr ... */
+        case 5:                /* jmp far ptr ... */
             destval = fetch_data_word(destoffset);
             destval2 = fetch_data_word(destoffset + 2);
             TRACE_AND_STEP();
             M.x86.R_IP = destval;
             M.x86.R_CS = destval2;
             break;
-        case 6:         /*  push word ptr ... */
+        case 6:                /*  push word ptr ... */
             if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                 u32 destval;
 
                 destval = fetch_data_long(destoffset);
                 TRACE_AND_STEP();
                 push_long(destval);
-            } else {
+            }
+            else {
                 u16 destval;
 
                 destval = fetch_data_word(destoffset);
@@ -11250,7 +11881,8 @@ static void x86emuOp_opcFF_word_RM(u8 X86EMU_UNUSED(op1))
                 TRACE_AND_STEP();
                 destval = inc_long(destval);
                 store_data_long(destoffset, destval);
-            } else {
+            }
+            else {
                 u16 destval;
 
                 destval = fetch_data_word(destoffset);
@@ -11267,7 +11899,8 @@ static void x86emuOp_opcFF_word_RM(u8 X86EMU_UNUSED(op1))
                 TRACE_AND_STEP();
                 destval = dec_long(destval);
                 store_data_long(destoffset, destval);
-            } else {
+            }
+            else {
                 u16 destval;
 
                 destval = fetch_data_word(destoffset);
@@ -11276,13 +11909,13 @@ static void x86emuOp_opcFF_word_RM(u8 X86EMU_UNUSED(op1))
                 store_data_word(destoffset, destval);
             }
             break;
-        case 2:         /* call word ptr ... */
+        case 2:                /* call word ptr ... */
             destval = fetch_data_word(destoffset);
             TRACE_AND_STEP();
             push_word(M.x86.R_IP);
             M.x86.R_IP = destval;
             break;
-        case 3:         /* call far ptr ... */
+        case 3:                /* call far ptr ... */
             destval = fetch_data_word(destoffset);
             destval2 = fetch_data_word(destoffset + 2);
             TRACE_AND_STEP();
@@ -11291,26 +11924,27 @@ static void x86emuOp_opcFF_word_RM(u8 X86EMU_UNUSED(op1))
             push_word(M.x86.R_IP);
             M.x86.R_IP = destval;
             break;
-        case 4:         /* jmp word ptr ... */
+        case 4:                /* jmp word ptr ... */
             destval = fetch_data_word(destoffset);
             TRACE_AND_STEP();
             M.x86.R_IP = destval;
             break;
-        case 5:         /* jmp far ptr ... */
+        case 5:                /* jmp far ptr ... */
             destval = fetch_data_word(destoffset);
             destval2 = fetch_data_word(destoffset + 2);
             TRACE_AND_STEP();
             M.x86.R_IP = destval;
             M.x86.R_CS = destval2;
             break;
-        case 6:         /*  push word ptr ... */
+        case 6:                /*  push word ptr ... */
             if (M.x86.mode & SYSMODE_PREFIX_DATA) {
                 u32 destval;
 
                 destval = fetch_data_long(destoffset);
                 TRACE_AND_STEP();
                 push_long(destval);
-            } else {
+            }
+            else {
                 u16 destval;
 
                 destval = fetch_data_word(destoffset);
@@ -11330,7 +11964,8 @@ static void x86emuOp_opcFF_word_RM(u8 X86EMU_UNUSED(op1))
                 DECODE_PRINTF("\n");
                 TRACE_AND_STEP();
                 *destreg = inc_long(*destreg);
-            } else {
+            }
+            else {
                 u16 *destreg;
 
                 destreg = DECODE_RM_WORD_REGISTER(rl);
@@ -11347,7 +11982,8 @@ static void x86emuOp_opcFF_word_RM(u8 X86EMU_UNUSED(op1))
                 DECODE_PRINTF("\n");
                 TRACE_AND_STEP();
                 *destreg = dec_long(*destreg);
-            } else {
+            }
+            else {
                 u16 *destreg;
 
                 destreg = DECODE_RM_WORD_REGISTER(rl);
@@ -11356,26 +11992,26 @@ static void x86emuOp_opcFF_word_RM(u8 X86EMU_UNUSED(op1))
                 *destreg = dec_word(*destreg);
             }
             break;
-        case 2:         /* call word ptr ... */
+        case 2:                /* call word ptr ... */
             destreg = DECODE_RM_WORD_REGISTER(rl);
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             push_word(M.x86.R_IP);
             M.x86.R_IP = *destreg;
             break;
-        case 3:         /* jmp far ptr ... */
+        case 3:                /* jmp far ptr ... */
             DECODE_PRINTF("OPERATION UNDEFINED 0XFF \n");
             TRACE_AND_STEP();
             HALT_SYS();
             break;
 
-        case 4:         /* jmp  ... */
+        case 4:                /* jmp  ... */
             destreg = DECODE_RM_WORD_REGISTER(rl);
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             M.x86.R_IP = (u16) (*destreg);
             break;
-        case 5:         /* jmp far ptr ... */
+        case 5:                /* jmp far ptr ... */
             DECODE_PRINTF("OPERATION UNDEFINED 0XFF \n");
             TRACE_AND_STEP();
             HALT_SYS();
@@ -11388,7 +12024,8 @@ static void x86emuOp_opcFF_word_RM(u8 X86EMU_UNUSED(op1))
                 DECODE_PRINTF("\n");
                 TRACE_AND_STEP();
                 push_long(*destreg);
-            } else {
+            }
+            else {
                 u16 *destreg;
 
                 destreg = DECODE_RM_WORD_REGISTER(rl);
@@ -11407,8 +12044,7 @@ static void x86emuOp_opcFF_word_RM(u8 X86EMU_UNUSED(op1))
 /***************************************************************************
  * Single byte operation code table:
  **************************************************************************/
-void (*x86emu_optab[256])(u8) =
-{
+void (*x86emu_optab[256]) (u8) = {
 /*  0x00 */ x86emuOp_add_byte_RM_R,
 /*  0x01 */ x86emuOp_add_word_RM_R,
 /*  0x02 */ x86emuOp_add_byte_R_RM,
@@ -11417,7 +12053,6 @@ void (*x86emu_optab[256])(u8) =
 /*  0x05 */ x86emuOp_add_word_AX_IMM,
 /*  0x06 */ x86emuOp_push_ES,
 /*  0x07 */ x86emuOp_pop_ES,
-
 /*  0x08 */ x86emuOp_or_byte_RM_R,
 /*  0x09 */ x86emuOp_or_word_RM_R,
 /*  0x0a */ x86emuOp_or_byte_R_RM,
@@ -11426,7 +12061,6 @@ void (*x86emu_optab[256])(u8) =
 /*  0x0d */ x86emuOp_or_word_AX_IMM,
 /*  0x0e */ x86emuOp_push_CS,
 /*  0x0f */ x86emuOp_two_byte,
-
 /*  0x10 */ x86emuOp_adc_byte_RM_R,
 /*  0x11 */ x86emuOp_adc_word_RM_R,
 /*  0x12 */ x86emuOp_adc_byte_R_RM,
@@ -11435,7 +12069,6 @@ void (*x86emu_optab[256])(u8) =
 /*  0x15 */ x86emuOp_adc_word_AX_IMM,
 /*  0x16 */ x86emuOp_push_SS,
 /*  0x17 */ x86emuOp_pop_SS,
-
 /*  0x18 */ x86emuOp_sbb_byte_RM_R,
 /*  0x19 */ x86emuOp_sbb_word_RM_R,
 /*  0x1a */ x86emuOp_sbb_byte_R_RM,
@@ -11444,7 +12077,6 @@ void (*x86emu_optab[256])(u8) =
 /*  0x1d */ x86emuOp_sbb_word_AX_IMM,
 /*  0x1e */ x86emuOp_push_DS,
 /*  0x1f */ x86emuOp_pop_DS,
-
 /*  0x20 */ x86emuOp_and_byte_RM_R,
 /*  0x21 */ x86emuOp_and_word_RM_R,
 /*  0x22 */ x86emuOp_and_byte_R_RM,
@@ -11453,7 +12085,6 @@ void (*x86emu_optab[256])(u8) =
 /*  0x25 */ x86emuOp_and_word_AX_IMM,
 /*  0x26 */ x86emuOp_segovr_ES,
 /*  0x27 */ x86emuOp_daa,
-
 /*  0x28 */ x86emuOp_sub_byte_RM_R,
 /*  0x29 */ x86emuOp_sub_word_RM_R,
 /*  0x2a */ x86emuOp_sub_byte_R_RM,
@@ -11462,7 +12093,6 @@ void (*x86emu_optab[256])(u8) =
 /*  0x2d */ x86emuOp_sub_word_AX_IMM,
 /*  0x2e */ x86emuOp_segovr_CS,
 /*  0x2f */ x86emuOp_das,
-
 /*  0x30 */ x86emuOp_xor_byte_RM_R,
 /*  0x31 */ x86emuOp_xor_word_RM_R,
 /*  0x32 */ x86emuOp_xor_byte_R_RM,
@@ -11471,7 +12101,6 @@ void (*x86emu_optab[256])(u8) =
 /*  0x35 */ x86emuOp_xor_word_AX_IMM,
 /*  0x36 */ x86emuOp_segovr_SS,
 /*  0x37 */ x86emuOp_aaa,
-
 /*  0x38 */ x86emuOp_cmp_byte_RM_R,
 /*  0x39 */ x86emuOp_cmp_word_RM_R,
 /*  0x3a */ x86emuOp_cmp_byte_R_RM,
@@ -11480,7 +12109,6 @@ void (*x86emu_optab[256])(u8) =
 /*  0x3d */ x86emuOp_cmp_word_AX_IMM,
 /*  0x3e */ x86emuOp_segovr_DS,
 /*  0x3f */ x86emuOp_aas,
-
 /*  0x40 */ x86emuOp_inc_AX,
 /*  0x41 */ x86emuOp_inc_CX,
 /*  0x42 */ x86emuOp_inc_DX,
@@ -11489,7 +12117,6 @@ void (*x86emu_optab[256])(u8) =
 /*  0x45 */ x86emuOp_inc_BP,
 /*  0x46 */ x86emuOp_inc_SI,
 /*  0x47 */ x86emuOp_inc_DI,
-
 /*  0x48 */ x86emuOp_dec_AX,
 /*  0x49 */ x86emuOp_dec_CX,
 /*  0x4a */ x86emuOp_dec_DX,
@@ -11498,7 +12125,6 @@ void (*x86emu_optab[256])(u8) =
 /*  0x4d */ x86emuOp_dec_BP,
 /*  0x4e */ x86emuOp_dec_SI,
 /*  0x4f */ x86emuOp_dec_DI,
-
 /*  0x50 */ x86emuOp_push_AX,
 /*  0x51 */ x86emuOp_push_CX,
 /*  0x52 */ x86emuOp_push_DX,
@@ -11507,7 +12133,6 @@ void (*x86emu_optab[256])(u8) =
 /*  0x55 */ x86emuOp_push_BP,
 /*  0x56 */ x86emuOp_push_SI,
 /*  0x57 */ x86emuOp_push_DI,
-
 /*  0x58 */ x86emuOp_pop_AX,
 /*  0x59 */ x86emuOp_pop_CX,
 /*  0x5a */ x86emuOp_pop_DX,
@@ -11516,16 +12141,16 @@ void (*x86emu_optab[256])(u8) =
 /*  0x5d */ x86emuOp_pop_BP,
 /*  0x5e */ x86emuOp_pop_SI,
 /*  0x5f */ x86emuOp_pop_DI,
-
 /*  0x60 */ x86emuOp_push_all,
 /*  0x61 */ x86emuOp_pop_all,
-/*  0x62 */ x86emuOp_illegal_op,   /* bound */
-/*  0x63 */ x86emuOp_illegal_op,   /* arpl */
+                                                /*  0x62 */ x86emuOp_illegal_op,
+                                                /* bound */
+                                                /*  0x63 */ x86emuOp_illegal_op,
+                                                /* arpl */
 /*  0x64 */ x86emuOp_segovr_FS,
 /*  0x65 */ x86emuOp_segovr_GS,
 /*  0x66 */ x86emuOp_prefix_data,
 /*  0x67 */ x86emuOp_prefix_addr,
-
 /*  0x68 */ x86emuOp_push_word_IMM,
 /*  0x69 */ x86emuOp_imul_word_IMM,
 /*  0x6a */ x86emuOp_push_byte_IMM,
@@ -11534,7 +12159,6 @@ void (*x86emu_optab[256])(u8) =
 /*  0x6d */ x86emuOp_ins_word,
 /*  0x6e */ x86emuOp_outs_byte,
 /*  0x6f */ x86emuOp_outs_word,
-
 /*  0x70 */ x86emuOp_jump_near_O,
 /*  0x71 */ x86emuOp_jump_near_NO,
 /*  0x72 */ x86emuOp_jump_near_B,
@@ -11543,7 +12167,6 @@ void (*x86emu_optab[256])(u8) =
 /*  0x75 */ x86emuOp_jump_near_NZ,
 /*  0x76 */ x86emuOp_jump_near_BE,
 /*  0x77 */ x86emuOp_jump_near_NBE,
-
 /*  0x78 */ x86emuOp_jump_near_S,
 /*  0x79 */ x86emuOp_jump_near_NS,
 /*  0x7a */ x86emuOp_jump_near_P,
@@ -11552,7 +12175,6 @@ void (*x86emu_optab[256])(u8) =
 /*  0x7d */ x86emuOp_jump_near_NL,
 /*  0x7e */ x86emuOp_jump_near_LE,
 /*  0x7f */ x86emuOp_jump_near_NLE,
-
 /*  0x80 */ x86emuOp_opc80_byte_RM_IMM,
 /*  0x81 */ x86emuOp_opc81_word_RM_IMM,
 /*  0x82 */ x86emuOp_opc82_byte_RM_IMM,
@@ -11561,7 +12183,6 @@ void (*x86emu_optab[256])(u8) =
 /*  0x85 */ x86emuOp_test_word_RM_R,
 /*  0x86 */ x86emuOp_xchg_byte_RM_R,
 /*  0x87 */ x86emuOp_xchg_word_RM_R,
-
 /*  0x88 */ x86emuOp_mov_byte_RM_R,
 /*  0x89 */ x86emuOp_mov_word_RM_R,
 /*  0x8a */ x86emuOp_mov_byte_R_RM,
@@ -11570,7 +12191,6 @@ void (*x86emu_optab[256])(u8) =
 /*  0x8d */ x86emuOp_lea_word_R_M,
 /*  0x8e */ x86emuOp_mov_word_SR_RM,
 /*  0x8f */ x86emuOp_pop_RM,
-
 /*  0x90 */ x86emuOp_nop,
 /*  0x91 */ x86emuOp_xchg_word_AX_CX,
 /*  0x92 */ x86emuOp_xchg_word_AX_DX,
@@ -11579,7 +12199,6 @@ void (*x86emu_optab[256])(u8) =
 /*  0x95 */ x86emuOp_xchg_word_AX_BP,
 /*  0x96 */ x86emuOp_xchg_word_AX_SI,
 /*  0x97 */ x86emuOp_xchg_word_AX_DI,
-
 /*  0x98 */ x86emuOp_cbw,
 /*  0x99 */ x86emuOp_cwd,
 /*  0x9a */ x86emuOp_call_far_IMM,
@@ -11588,7 +12207,6 @@ void (*x86emu_optab[256])(u8) =
 /*  0x9d */ x86emuOp_popf_word,
 /*  0x9e */ x86emuOp_sahf,
 /*  0x9f */ x86emuOp_lahf,
-
 /*  0xa0 */ x86emuOp_mov_AL_M_IMM,
 /*  0xa1 */ x86emuOp_mov_AX_M_IMM,
 /*  0xa2 */ x86emuOp_mov_M_AL_IMM,
@@ -11605,8 +12223,6 @@ void (*x86emu_optab[256])(u8) =
 /*  0xad */ x86emuOp_lods_word,
 /*  0xac */ x86emuOp_scas_byte,
 /*  0xad */ x86emuOp_scas_word,
-
-
 /*  0xb0 */ x86emuOp_mov_byte_AL_IMM,
 /*  0xb1 */ x86emuOp_mov_byte_CL_IMM,
 /*  0xb2 */ x86emuOp_mov_byte_DL_IMM,
@@ -11615,7 +12231,6 @@ void (*x86emu_optab[256])(u8) =
 /*  0xb5 */ x86emuOp_mov_byte_CH_IMM,
 /*  0xb6 */ x86emuOp_mov_byte_DH_IMM,
 /*  0xb7 */ x86emuOp_mov_byte_BH_IMM,
-
 /*  0xb8 */ x86emuOp_mov_word_AX_IMM,
 /*  0xb9 */ x86emuOp_mov_word_CX_IMM,
 /*  0xba */ x86emuOp_mov_word_DX_IMM,
@@ -11624,7 +12239,6 @@ void (*x86emu_optab[256])(u8) =
 /*  0xbd */ x86emuOp_mov_word_BP_IMM,
 /*  0xbe */ x86emuOp_mov_word_SI_IMM,
 /*  0xbf */ x86emuOp_mov_word_DI_IMM,
-
 /*  0xc0 */ x86emuOp_opcC0_byte_RM_MEM,
 /*  0xc1 */ x86emuOp_opcC1_word_RM_MEM,
 /*  0xc2 */ x86emuOp_ret_near_IMM,
@@ -11641,14 +12255,14 @@ void (*x86emu_optab[256])(u8) =
 /*  0xcd */ x86emuOp_int_IMM,
 /*  0xce */ x86emuOp_into,
 /*  0xcf */ x86emuOp_iret,
-
 /*  0xd0 */ x86emuOp_opcD0_byte_RM_1,
 /*  0xd1 */ x86emuOp_opcD1_word_RM_1,
 /*  0xd2 */ x86emuOp_opcD2_byte_RM_CL,
 /*  0xd3 */ x86emuOp_opcD3_word_RM_CL,
 /*  0xd4 */ x86emuOp_aam,
 /*  0xd5 */ x86emuOp_aad,
-/*  0xd6 */ x86emuOp_illegal_op,   /* Undocumented SETALC instruction */
+                                                /*  0xd6 */ x86emuOp_illegal_op,
+                                                /* Undocumented SETALC instruction */
 /*  0xd7 */ x86emuOp_xlat,
 /*  0xd8 */ x86emuOp_esc_coprocess_d8,
 /*  0xd9 */ x86emuOp_esc_coprocess_d9,
@@ -11658,7 +12272,6 @@ void (*x86emu_optab[256])(u8) =
 /*  0xdd */ x86emuOp_esc_coprocess_dd,
 /*  0xde */ x86emuOp_esc_coprocess_de,
 /*  0xdf */ x86emuOp_esc_coprocess_df,
-
 /*  0xe0 */ x86emuOp_loopne,
 /*  0xe1 */ x86emuOp_loope,
 /*  0xe2 */ x86emuOp_loop,
@@ -11667,7 +12280,6 @@ void (*x86emu_optab[256])(u8) =
 /*  0xe5 */ x86emuOp_in_word_AX_IMM,
 /*  0xe6 */ x86emuOp_out_byte_IMM_AL,
 /*  0xe7 */ x86emuOp_out_word_IMM_AX,
-
 /*  0xe8 */ x86emuOp_call_near_IMM,
 /*  0xe9 */ x86emuOp_jump_near_IMM,
 /*  0xea */ x86emuOp_jump_far_IMM,
@@ -11676,7 +12288,6 @@ void (*x86emu_optab[256])(u8) =
 /*  0xed */ x86emuOp_in_word_AX_DX,
 /*  0xee */ x86emuOp_out_byte_DX_AL,
 /*  0xef */ x86emuOp_out_word_DX_AX,
-
 /*  0xf0 */ x86emuOp_lock,
 /*  0xf1 */ x86emuOp_illegal_op,
 /*  0xf2 */ x86emuOp_repne,
@@ -11685,7 +12296,6 @@ void (*x86emu_optab[256])(u8) =
 /*  0xf5 */ x86emuOp_cmc,
 /*  0xf6 */ x86emuOp_opcF6_byte_RM,
 /*  0xf7 */ x86emuOp_opcF7_word_RM,
-
 /*  0xf8 */ x86emuOp_clc,
 /*  0xf9 */ x86emuOp_stc,
 /*  0xfa */ x86emuOp_cli,
diff --git a/libs/x86emu/ops2.c b/libs/x86emu/ops2.c
index 06b7f56..5ed2bf6 100644
--- a/libs/x86emu/ops2.c
+++ b/libs/x86emu/ops2.c
@@ -55,16 +55,14 @@ op1 - Instruction op code
 REMARKS:
 Handles illegal opcodes.
 ****************************************************************************/
-static void x86emuOp2_illegal_op(
-	u8 op2)
+static void
+x86emuOp2_illegal_op(u8 op2)
 {
-	int mod, rl, rh;
-	START_OF_INSTR();
-	FETCH_DECODE_MODRM(mod, rh, rl);
-	DECODE_PRINTF("ILLEGAL EXTENDED X86 OPCODE\n");
-	TRACE_REGS();
-	printk("%04x:%04x: %02X /%d ILLEGAL EXTENDED X86 OPCODE! (mod=%d rl=%d)\n",
-		M.x86.R_CS, M.x86.R_IP-2,op2, rh, mod, rl);
+    START_OF_INSTR();
+    DECODE_PRINTF("ILLEGAL EXTENDED X86 OPCODE\n");
+    TRACE_REGS();
+    printk("%04x:%04x: %02X ILLEGAL EXTENDED X86 OPCODE!\n",
+           M.x86.R_CS, M.x86.R_IP - 2, op2);
     HALT_SYS();
     END_OF_INSTR();
 }
@@ -73,55 +71,10 @@ static void x86emuOp2_illegal_op(
 
 /****************************************************************************
 REMARKS:
-Handles opcode 0x0f,0x01
-****************************************************************************/
-static void x86emuOp2_group_g(u8 X86EMU_UNUSED(op2))
-{
-	int mod, rl, rh;
-	u16 *destreg;
-	uint destoffset;
-
-	START_OF_INSTR();
-	FETCH_DECODE_MODRM(mod, rh, rl);
-	switch (rh) {
-		case 4: // SMSW (Store Machine Status Word)
-			// Decode the mod byte to find the addressing
-			// Always returns 0x10 (initial value as per intel manual volume 3, figure 8-1
-			switch (mod) {
-				case 0:
-					destoffset = decode_rm00_address(rl);
-					store_data_word(destoffset, 0x10);
-					break;
-				case 1:
-					destoffset = decode_rm01_address(rl);
-					store_data_word(destoffset, 0x10);
-					break;
-				case 2:
-					destoffset = decode_rm10_address(rl);
-					store_data_word(destoffset, 0x10);
-					break;
-				case 3:
-					destreg = DECODE_RM_WORD_REGISTER(rl);
-					*destreg = 0x10;
-					break;
-			}
-			break;
-		default:
-			DECODE_PRINTF("ILLEGAL EXTENDED X86 OPCODE IN 0F 01\n");
-			TRACE_REGS();
-			printk("%04x:%04x: 0F %02X /%d ILLEGAL EXTENDED X86 OPCODE! (mod=%d rl=%d)\n",
-				M.x86.R_CS, M.x86.R_IP-2,op2, rh, mod, rl);
-			HALT_SYS();
-			break;
-	}
-	END_OF_INSTR();
-}
-
-/****************************************************************************
-REMARKS:
 Handles opcode 0x0f,0x31
 ****************************************************************************/
-static void x86emuOp2_rdtsc(u8 X86EMU_UNUSED(op2))
+static void
+x86emuOp2_rdtsc(u8 X86EMU_UNUSED(op2))
 {
 #ifdef __HAS_LONG_LONG__
     static u64 counter = 0;
@@ -155,90 +108,91 @@ static void x86emuOp2_rdtsc(u8 X86EMU_UNUSED(op2))
 REMARKS:
 Handles opcode 0x0f,0x80-0x8F
 ****************************************************************************/
-static void x86emuOp2_long_jump(u8 op2)
+static void
+x86emuOp2_long_jump(u8 op2)
 {
     s32 target;
-    char *name = 0;
+    const char *name = NULL;
     int cond = 0;
 
     /* conditional jump to word offset. */
     START_OF_INSTR();
     switch (op2) {
-      case 0x80:
+    case 0x80:
         name = "JO\t";
-        cond =  ACCESS_FLAG(F_OF);
+        cond = ACCESS_FLAG(F_OF);
         break;
-      case 0x81:
+    case 0x81:
         name = "JNO\t";
         cond = !ACCESS_FLAG(F_OF);
         break;
-      case 0x82:
+    case 0x82:
         name = "JB\t";
         cond = ACCESS_FLAG(F_CF);
         break;
-      case 0x83:
+    case 0x83:
         name = "JNB\t";
         cond = !ACCESS_FLAG(F_CF);
         break;
-      case 0x84:
+    case 0x84:
         name = "JZ\t";
         cond = ACCESS_FLAG(F_ZF);
         break;
-      case 0x85:
+    case 0x85:
         name = "JNZ\t";
         cond = !ACCESS_FLAG(F_ZF);
         break;
-      case 0x86:
+    case 0x86:
         name = "JBE\t";
         cond = ACCESS_FLAG(F_CF) || ACCESS_FLAG(F_ZF);
         break;
-      case 0x87:
+    case 0x87:
         name = "JNBE\t";
         cond = !(ACCESS_FLAG(F_CF) || ACCESS_FLAG(F_ZF));
         break;
-      case 0x88:
+    case 0x88:
         name = "JS\t";
         cond = ACCESS_FLAG(F_SF);
         break;
-      case 0x89:
+    case 0x89:
         name = "JNS\t";
         cond = !ACCESS_FLAG(F_SF);
         break;
-      case 0x8a:
+    case 0x8a:
         name = "JP\t";
         cond = ACCESS_FLAG(F_PF);
         break;
-      case 0x8b:
+    case 0x8b:
         name = "JNP\t";
         cond = !ACCESS_FLAG(F_PF);
         break;
-      case 0x8c:
+    case 0x8c:
         name = "JL\t";
         cond = xorl(ACCESS_FLAG(F_SF), ACCESS_FLAG(F_OF));
         break;
-      case 0x8d:
+    case 0x8d:
         name = "JNL\t";
         cond = !(xorl(ACCESS_FLAG(F_SF), ACCESS_FLAG(F_OF)));
         break;
-      case 0x8e:
+    case 0x8e:
         name = "JLE\t";
         cond = (xorl(ACCESS_FLAG(F_SF), ACCESS_FLAG(F_OF)) ||
                 ACCESS_FLAG(F_ZF));
         break;
-      case 0x8f:
+    case 0x8f:
         name = "JNLE\t";
         cond = !(xorl(ACCESS_FLAG(F_SF), ACCESS_FLAG(F_OF)) ||
                  ACCESS_FLAG(F_ZF));
         break;
     }
     DECODE_PRINTF(name);
-    (void)name;
+    (void) name;
     target = (s16) fetch_word_imm();
     target += (s16) M.x86.R_IP;
     DECODE_PRINTF2("%04x\n", target);
     TRACE_AND_STEP();
     if (cond)
-        M.x86.R_IP = (u16)target;
+        M.x86.R_IP = (u16) target;
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
 }
@@ -247,85 +201,86 @@ static void x86emuOp2_long_jump(u8 op2)
 REMARKS:
 Handles opcode 0x0f,0x90-0x9F
 ****************************************************************************/
-static void x86emuOp2_set_byte(u8 op2)
+static void
+x86emuOp2_set_byte(u8 op2)
 {
     int mod, rl, rh;
     uint destoffset;
-    u8  *destreg;
-    char *name = 0;
+    u8 *destreg;
+    const char *name = NULL;
     int cond = 0;
 
     START_OF_INSTR();
     switch (op2) {
-      case 0x90:
+    case 0x90:
         name = "SETO\t";
-        cond =  ACCESS_FLAG(F_OF);
+        cond = ACCESS_FLAG(F_OF);
         break;
-      case 0x91:
+    case 0x91:
         name = "SETNO\t";
         cond = !ACCESS_FLAG(F_OF);
         break;
-      case 0x92:
+    case 0x92:
         name = "SETB\t";
         cond = ACCESS_FLAG(F_CF);
         break;
-      case 0x93:
+    case 0x93:
         name = "SETNB\t";
         cond = !ACCESS_FLAG(F_CF);
         break;
-      case 0x94:
+    case 0x94:
         name = "SETZ\t";
         cond = ACCESS_FLAG(F_ZF);
         break;
-      case 0x95:
+    case 0x95:
         name = "SETNZ\t";
         cond = !ACCESS_FLAG(F_ZF);
         break;
-      case 0x96:
+    case 0x96:
         name = "SETBE\t";
         cond = ACCESS_FLAG(F_CF) || ACCESS_FLAG(F_ZF);
         break;
-      case 0x97:
+    case 0x97:
         name = "SETNBE\t";
         cond = !(ACCESS_FLAG(F_CF) || ACCESS_FLAG(F_ZF));
         break;
-      case 0x98:
+    case 0x98:
         name = "SETS\t";
         cond = ACCESS_FLAG(F_SF);
         break;
-      case 0x99:
+    case 0x99:
         name = "SETNS\t";
         cond = !ACCESS_FLAG(F_SF);
         break;
-      case 0x9a:
+    case 0x9a:
         name = "SETP\t";
         cond = ACCESS_FLAG(F_PF);
         break;
-      case 0x9b:
+    case 0x9b:
         name = "SETNP\t";
         cond = !ACCESS_FLAG(F_PF);
         break;
-      case 0x9c:
+    case 0x9c:
         name = "SETL\t";
         cond = xorl(ACCESS_FLAG(F_SF), ACCESS_FLAG(F_OF));
         break;
-      case 0x9d:
+    case 0x9d:
         name = "SETNL\t";
         cond = xorl(ACCESS_FLAG(F_SF), ACCESS_FLAG(F_OF));
         break;
-      case 0x9e:
+    case 0x9e:
         name = "SETLE\t";
         cond = (xorl(ACCESS_FLAG(F_SF), ACCESS_FLAG(F_OF)) ||
                 ACCESS_FLAG(F_ZF));
         break;
-      case 0x9f:
+    case 0x9f:
         name = "SETNLE\t";
         cond = !(xorl(ACCESS_FLAG(F_SF), ACCESS_FLAG(F_OF)) ||
                  ACCESS_FLAG(F_ZF));
         break;
     }
     DECODE_PRINTF(name);
-    (void)name;
+    (void) name;
     FETCH_DECODE_MODRM(mod, rh, rl);
     switch (mod) {
     case 0:
@@ -343,7 +298,7 @@ static void x86emuOp2_set_byte(u8 op2)
         TRACE_AND_STEP();
         store_data_byte(destoffset, cond ? 0x01 : 0x00);
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         destreg = DECODE_RM_BYTE_REGISTER(rl);
         TRACE_AND_STEP();
         *destreg = cond ? 0x01 : 0x00;
@@ -357,7 +312,8 @@ static void x86emuOp2_set_byte(u8 op2)
 REMARKS:
 Handles opcode 0x0f,0xa0
 ****************************************************************************/
-static void x86emuOp2_push_FS(u8 X86EMU_UNUSED(op2))
+static void
+x86emuOp2_push_FS(u8 X86EMU_UNUSED(op2))
 {
     START_OF_INSTR();
     DECODE_PRINTF("PUSH\tFS\n");
@@ -371,7 +327,8 @@ static void x86emuOp2_push_FS(u8 X86EMU_UNUSED(op2))
 REMARKS:
 Handles opcode 0x0f,0xa1
 ****************************************************************************/
-static void x86emuOp2_pop_FS(u8 X86EMU_UNUSED(op2))
+static void
+x86emuOp2_pop_FS(u8 X86EMU_UNUSED(op2))
 {
     START_OF_INSTR();
     DECODE_PRINTF("POP\tFS\n");
@@ -385,7 +342,8 @@ static void x86emuOp2_pop_FS(u8 X86EMU_UNUSED(op2))
 REMARKS: CPUID takes EAX/ECX as inputs, writes EAX/EBX/ECX/EDX as output
 Handles opcode 0x0f,0xa2
 ****************************************************************************/
-static void x86emuOp2_cpuid(u8 X86EMU_UNUSED(op2))
+static void
+x86emuOp2_cpuid(u8 X86EMU_UNUSED(op2))
 {
     START_OF_INSTR();
     DECODE_PRINTF("CPUID\n");
@@ -399,11 +357,12 @@ static void x86emuOp2_cpuid(u8 X86EMU_UNUSED(op2))
 REMARKS:
 Handles opcode 0x0f,0xa3
 ****************************************************************************/
-static void x86emuOp2_bt_R(u8 X86EMU_UNUSED(op2))
+static void
+x86emuOp2_bt_R(u8 X86EMU_UNUSED(op2))
 {
     int mod, rl, rh;
     uint srcoffset;
-    int bit,disp;
+    int bit, disp;
 
     START_OF_INSTR();
     DECODE_PRINTF("BT\t");
@@ -419,10 +378,11 @@ static void x86emuOp2_bt_R(u8 X86EMU_UNUSED(op2))
             shiftreg = DECODE_RM_LONG_REGISTER(rh);
             TRACE_AND_STEP();
             bit = *shiftreg & 0x1F;
-            disp = (s16)*shiftreg >> 5;
-            srcval = fetch_data_long(srcoffset+disp);
-            CONDITIONAL_SET_FLAG(srcval & (0x1 << bit),F_CF);
-        } else {
+            disp = (s16) * shiftreg >> 5;
+            srcval = fetch_data_long(srcoffset + disp);
+            CONDITIONAL_SET_FLAG(srcval & (0x1 << bit), F_CF);
+        }
+        else {
             u16 srcval;
             u16 *shiftreg;
 
@@ -431,9 +391,9 @@ static void x86emuOp2_bt_R(u8 X86EMU_UNUSED(op2))
             shiftreg = DECODE_RM_WORD_REGISTER(rh);
             TRACE_AND_STEP();
             bit = *shiftreg & 0xF;
-            disp = (s16)*shiftreg >> 4;
-            srcval = fetch_data_word(srcoffset+disp);
-            CONDITIONAL_SET_FLAG(srcval & (0x1 << bit),F_CF);
+            disp = (s16) * shiftreg >> 4;
+            srcval = fetch_data_word(srcoffset + disp);
+            CONDITIONAL_SET_FLAG(srcval & (0x1 << bit), F_CF);
         }
         break;
     case 1:
@@ -446,10 +406,11 @@ static void x86emuOp2_bt_R(u8 X86EMU_UNUSED(op2))
             shiftreg = DECODE_RM_LONG_REGISTER(rh);
             TRACE_AND_STEP();
             bit = *shiftreg & 0x1F;
-            disp = (s16)*shiftreg >> 5;
-            srcval = fetch_data_long(srcoffset+disp);
-            CONDITIONAL_SET_FLAG(srcval & (0x1 << bit),F_CF);
-        } else {
+            disp = (s16) * shiftreg >> 5;
+            srcval = fetch_data_long(srcoffset + disp);
+            CONDITIONAL_SET_FLAG(srcval & (0x1 << bit), F_CF);
+        }
+        else {
             u16 srcval;
             u16 *shiftreg;
 
@@ -458,9 +419,9 @@ static void x86emuOp2_bt_R(u8 X86EMU_UNUSED(op2))
             shiftreg = DECODE_RM_WORD_REGISTER(rh);
             TRACE_AND_STEP();
             bit = *shiftreg & 0xF;
-            disp = (s16)*shiftreg >> 4;
-            srcval = fetch_data_word(srcoffset+disp);
-            CONDITIONAL_SET_FLAG(srcval & (0x1 << bit),F_CF);
+            disp = (s16) * shiftreg >> 4;
+            srcval = fetch_data_word(srcoffset + disp);
+            CONDITIONAL_SET_FLAG(srcval & (0x1 << bit), F_CF);
         }
         break;
     case 2:
@@ -473,10 +434,11 @@ static void x86emuOp2_bt_R(u8 X86EMU_UNUSED(op2))
             shiftreg = DECODE_RM_LONG_REGISTER(rh);
             TRACE_AND_STEP();
             bit = *shiftreg & 0x1F;
-            disp = (s16)*shiftreg >> 5;
-            srcval = fetch_data_long(srcoffset+disp);
-            CONDITIONAL_SET_FLAG(srcval & (0x1 << bit),F_CF);
-        } else {
+            disp = (s16) * shiftreg >> 5;
+            srcval = fetch_data_long(srcoffset + disp);
+            CONDITIONAL_SET_FLAG(srcval & (0x1 << bit), F_CF);
+        }
+        else {
             u16 srcval;
             u16 *shiftreg;
 
@@ -485,30 +447,31 @@ static void x86emuOp2_bt_R(u8 X86EMU_UNUSED(op2))
             shiftreg = DECODE_RM_WORD_REGISTER(rh);
             TRACE_AND_STEP();
             bit = *shiftreg & 0xF;
-            disp = (s16)*shiftreg >> 4;
-            srcval = fetch_data_word(srcoffset+disp);
-            CONDITIONAL_SET_FLAG(srcval & (0x1 << bit),F_CF);
+            disp = (s16) * shiftreg >> 4;
+            srcval = fetch_data_word(srcoffset + disp);
+            CONDITIONAL_SET_FLAG(srcval & (0x1 << bit), F_CF);
         }
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-            u32 *srcreg,*shiftreg;
+            u32 *srcreg, *shiftreg;
 
             srcreg = DECODE_RM_LONG_REGISTER(rl);
             DECODE_PRINTF(",");
             shiftreg = DECODE_RM_LONG_REGISTER(rh);
             TRACE_AND_STEP();
             bit = *shiftreg & 0x1F;
-            CONDITIONAL_SET_FLAG(*srcreg & (0x1 << bit),F_CF);
-        } else {
-            u16 *srcreg,*shiftreg;
+            CONDITIONAL_SET_FLAG(*srcreg & (0x1 << bit), F_CF);
+        }
+        else {
+            u16 *srcreg, *shiftreg;
 
             srcreg = DECODE_RM_WORD_REGISTER(rl);
             DECODE_PRINTF(",");
             shiftreg = DECODE_RM_WORD_REGISTER(rh);
             TRACE_AND_STEP();
             bit = *shiftreg & 0xF;
-            CONDITIONAL_SET_FLAG(*srcreg & (0x1 << bit),F_CF);
+            CONDITIONAL_SET_FLAG(*srcreg & (0x1 << bit), F_CF);
         }
         break;
     }
@@ -520,11 +483,12 @@ static void x86emuOp2_bt_R(u8 X86EMU_UNUSED(op2))
 REMARKS:
 Handles opcode 0x0f,0xa4
 ****************************************************************************/
-static void x86emuOp2_shld_IMM(u8 X86EMU_UNUSED(op2))
+static void
+x86emuOp2_shld_IMM(u8 X86EMU_UNUSED(op2))
 {
     int mod, rl, rh;
     uint destoffset;
-	u8 shift;
+    u8 shift;
 
     START_OF_INSTR();
     DECODE_PRINTF("SHLD\t");
@@ -543,9 +507,10 @@ static void x86emuOp2_shld_IMM(u8 X86EMU_UNUSED(op2))
             DECODE_PRINTF2("%d\n", shift);
             TRACE_AND_STEP();
             destval = fetch_data_long(destoffset);
-            destval = shld_long(destval,*shiftreg,shift);
+            destval = shld_long(destval, *shiftreg, shift);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
             u16 *shiftreg;
 
@@ -557,7 +522,7 @@ static void x86emuOp2_shld_IMM(u8 X86EMU_UNUSED(op2))
             DECODE_PRINTF2("%d\n", shift);
             TRACE_AND_STEP();
             destval = fetch_data_word(destoffset);
-            destval = shld_word(destval,*shiftreg,shift);
+            destval = shld_word(destval, *shiftreg, shift);
             store_data_word(destoffset, destval);
         }
         break;
@@ -574,9 +539,10 @@ static void x86emuOp2_shld_IMM(u8 X86EMU_UNUSED(op2))
             DECODE_PRINTF2("%d\n", shift);
             TRACE_AND_STEP();
             destval = fetch_data_long(destoffset);
-            destval = shld_long(destval,*shiftreg,shift);
+            destval = shld_long(destval, *shiftreg, shift);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
             u16 *shiftreg;
 
@@ -588,7 +554,7 @@ static void x86emuOp2_shld_IMM(u8 X86EMU_UNUSED(op2))
             DECODE_PRINTF2("%d\n", shift);
             TRACE_AND_STEP();
             destval = fetch_data_word(destoffset);
-            destval = shld_word(destval,*shiftreg,shift);
+            destval = shld_word(destval, *shiftreg, shift);
             store_data_word(destoffset, destval);
         }
         break;
@@ -605,9 +571,10 @@ static void x86emuOp2_shld_IMM(u8 X86EMU_UNUSED(op2))
             DECODE_PRINTF2("%d\n", shift);
             TRACE_AND_STEP();
             destval = fetch_data_long(destoffset);
-            destval = shld_long(destval,*shiftreg,shift);
+            destval = shld_long(destval, *shiftreg, shift);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
             u16 *shiftreg;
 
@@ -619,13 +586,13 @@ static void x86emuOp2_shld_IMM(u8 X86EMU_UNUSED(op2))
             DECODE_PRINTF2("%d\n", shift);
             TRACE_AND_STEP();
             destval = fetch_data_word(destoffset);
-            destval = shld_word(destval,*shiftreg,shift);
+            destval = shld_word(destval, *shiftreg, shift);
             store_data_word(destoffset, destval);
         }
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-            u32 *destreg,*shiftreg;
+            u32 *destreg, *shiftreg;
 
             destreg = DECODE_RM_LONG_REGISTER(rl);
             DECODE_PRINTF(",");
@@ -634,9 +601,10 @@ static void x86emuOp2_shld_IMM(u8 X86EMU_UNUSED(op2))
             shift = fetch_byte_imm();
             DECODE_PRINTF2("%d\n", shift);
             TRACE_AND_STEP();
-            *destreg = shld_long(*destreg,*shiftreg,shift);
-        } else {
-            u16 *destreg,*shiftreg;
+            *destreg = shld_long(*destreg, *shiftreg, shift);
+        }
+        else {
+            u16 *destreg, *shiftreg;
 
             destreg = DECODE_RM_WORD_REGISTER(rl);
             DECODE_PRINTF(",");
@@ -645,7 +613,7 @@ static void x86emuOp2_shld_IMM(u8 X86EMU_UNUSED(op2))
             shift = fetch_byte_imm();
             DECODE_PRINTF2("%d\n", shift);
             TRACE_AND_STEP();
-            *destreg = shld_word(*destreg,*shiftreg,shift);
+            *destreg = shld_word(*destreg, *shiftreg, shift);
         }
         break;
     }
@@ -657,7 +625,8 @@ static void x86emuOp2_shld_IMM(u8 X86EMU_UNUSED(op2))
 REMARKS:
 Handles opcode 0x0f,0xa5
 ****************************************************************************/
-static void x86emuOp2_shld_CL(u8 X86EMU_UNUSED(op2))
+static void
+x86emuOp2_shld_CL(u8 X86EMU_UNUSED(op2))
 {
     int mod, rl, rh;
     uint destoffset;
@@ -677,9 +646,10 @@ static void x86emuOp2_shld_CL(u8 X86EMU_UNUSED(op2))
             DECODE_PRINTF(",CL\n");
             TRACE_AND_STEP();
             destval = fetch_data_long(destoffset);
-            destval = shld_long(destval,*shiftreg,M.x86.R_CL);
+            destval = shld_long(destval, *shiftreg, M.x86.R_CL);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
             u16 *shiftreg;
 
@@ -689,7 +659,7 @@ static void x86emuOp2_shld_CL(u8 X86EMU_UNUSED(op2))
             DECODE_PRINTF(",CL\n");
             TRACE_AND_STEP();
             destval = fetch_data_word(destoffset);
-            destval = shld_word(destval,*shiftreg,M.x86.R_CL);
+            destval = shld_word(destval, *shiftreg, M.x86.R_CL);
             store_data_word(destoffset, destval);
         }
         break;
@@ -704,9 +674,10 @@ static void x86emuOp2_shld_CL(u8 X86EMU_UNUSED(op2))
             DECODE_PRINTF(",CL\n");
             TRACE_AND_STEP();
             destval = fetch_data_long(destoffset);
-            destval = shld_long(destval,*shiftreg,M.x86.R_CL);
+            destval = shld_long(destval, *shiftreg, M.x86.R_CL);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
             u16 *shiftreg;
 
@@ -716,7 +687,7 @@ static void x86emuOp2_shld_CL(u8 X86EMU_UNUSED(op2))
             DECODE_PRINTF(",CL\n");
             TRACE_AND_STEP();
             destval = fetch_data_word(destoffset);
-            destval = shld_word(destval,*shiftreg,M.x86.R_CL);
+            destval = shld_word(destval, *shiftreg, M.x86.R_CL);
             store_data_word(destoffset, destval);
         }
         break;
@@ -731,9 +702,10 @@ static void x86emuOp2_shld_CL(u8 X86EMU_UNUSED(op2))
             DECODE_PRINTF(",CL\n");
             TRACE_AND_STEP();
             destval = fetch_data_long(destoffset);
-            destval = shld_long(destval,*shiftreg,M.x86.R_CL);
+            destval = shld_long(destval, *shiftreg, M.x86.R_CL);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
             u16 *shiftreg;
 
@@ -743,29 +715,30 @@ static void x86emuOp2_shld_CL(u8 X86EMU_UNUSED(op2))
             DECODE_PRINTF(",CL\n");
             TRACE_AND_STEP();
             destval = fetch_data_word(destoffset);
-            destval = shld_word(destval,*shiftreg,M.x86.R_CL);
+            destval = shld_word(destval, *shiftreg, M.x86.R_CL);
             store_data_word(destoffset, destval);
         }
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-            u32 *destreg,*shiftreg;
+            u32 *destreg, *shiftreg;
 
             destreg = DECODE_RM_LONG_REGISTER(rl);
             DECODE_PRINTF(",");
             shiftreg = DECODE_RM_LONG_REGISTER(rh);
             DECODE_PRINTF(",CL\n");
             TRACE_AND_STEP();
-            *destreg = shld_long(*destreg,*shiftreg,M.x86.R_CL);
-        } else {
-            u16 *destreg,*shiftreg;
+            *destreg = shld_long(*destreg, *shiftreg, M.x86.R_CL);
+        }
+        else {
+            u16 *destreg, *shiftreg;
 
             destreg = DECODE_RM_WORD_REGISTER(rl);
             DECODE_PRINTF(",");
             shiftreg = DECODE_RM_WORD_REGISTER(rh);
             DECODE_PRINTF(",CL\n");
             TRACE_AND_STEP();
-            *destreg = shld_word(*destreg,*shiftreg,M.x86.R_CL);
+            *destreg = shld_word(*destreg, *shiftreg, M.x86.R_CL);
         }
         break;
     }
@@ -777,7 +750,8 @@ static void x86emuOp2_shld_CL(u8 X86EMU_UNUSED(op2))
 REMARKS:
 Handles opcode 0x0f,0xa8
 ****************************************************************************/
-static void x86emuOp2_push_GS(u8 X86EMU_UNUSED(op2))
+static void
+x86emuOp2_push_GS(u8 X86EMU_UNUSED(op2))
 {
     START_OF_INSTR();
     DECODE_PRINTF("PUSH\tGS\n");
@@ -791,7 +765,8 @@ static void x86emuOp2_push_GS(u8 X86EMU_UNUSED(op2))
 REMARKS:
 Handles opcode 0x0f,0xa9
 ****************************************************************************/
-static void x86emuOp2_pop_GS(u8 X86EMU_UNUSED(op2))
+static void
+x86emuOp2_pop_GS(u8 X86EMU_UNUSED(op2))
 {
     START_OF_INSTR();
     DECODE_PRINTF("POP\tGS\n");
@@ -805,11 +780,12 @@ static void x86emuOp2_pop_GS(u8 X86EMU_UNUSED(op2))
 REMARKS:
 Handles opcode 0x0f,0xab
 ****************************************************************************/
-static void x86emuOp2_bts_R(u8 X86EMU_UNUSED(op2))
+static void
+x86emuOp2_bts_R(u8 X86EMU_UNUSED(op2))
 {
     int mod, rl, rh;
     uint srcoffset;
-    int bit,disp;
+    int bit, disp;
 
     START_OF_INSTR();
     DECODE_PRINTF("BTS\t");
@@ -817,7 +793,7 @@ static void x86emuOp2_bts_R(u8 X86EMU_UNUSED(op2))
     switch (mod) {
     case 0:
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-            u32 srcval,mask;
+            u32 srcval, mask;
             u32 *shiftreg;
 
             srcoffset = decode_rm00_address(rl);
@@ -825,13 +801,14 @@ static void x86emuOp2_bts_R(u8 X86EMU_UNUSED(op2))
             shiftreg = DECODE_RM_LONG_REGISTER(rh);
             TRACE_AND_STEP();
             bit = *shiftreg & 0x1F;
-            disp = (s16)*shiftreg >> 5;
-            srcval = fetch_data_long(srcoffset+disp);
+            disp = (s16) * shiftreg >> 5;
+            srcval = fetch_data_long(srcoffset + disp);
             mask = (0x1 << bit);
-            CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
-            store_data_long(srcoffset+disp, srcval | mask);
-        } else {
-            u16 srcval,mask;
+            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
+            store_data_long(srcoffset + disp, srcval | mask);
+        }
+        else {
+            u16 srcval, mask;
             u16 *shiftreg;
 
             srcoffset = decode_rm00_address(rl);
@@ -839,16 +816,16 @@ static void x86emuOp2_bts_R(u8 X86EMU_UNUSED(op2))
             shiftreg = DECODE_RM_WORD_REGISTER(rh);
             TRACE_AND_STEP();
             bit = *shiftreg & 0xF;
-            disp = (s16)*shiftreg >> 4;
-            srcval = fetch_data_word(srcoffset+disp);
-			mask = (u16)(0x1 << bit);
-            CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
-            store_data_word(srcoffset+disp, srcval | mask);
+            disp = (s16) * shiftreg >> 4;
+            srcval = fetch_data_word(srcoffset + disp);
+            mask = (u16) (0x1 << bit);
+            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
+            store_data_word(srcoffset + disp, srcval | mask);
         }
         break;
     case 1:
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-            u32 srcval,mask;
+            u32 srcval, mask;
             u32 *shiftreg;
 
             srcoffset = decode_rm01_address(rl);
@@ -856,13 +833,14 @@ static void x86emuOp2_bts_R(u8 X86EMU_UNUSED(op2))
             shiftreg = DECODE_RM_LONG_REGISTER(rh);
             TRACE_AND_STEP();
             bit = *shiftreg & 0x1F;
-            disp = (s16)*shiftreg >> 5;
-            srcval = fetch_data_long(srcoffset+disp);
+            disp = (s16) * shiftreg >> 5;
+            srcval = fetch_data_long(srcoffset + disp);
             mask = (0x1 << bit);
-            CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
-            store_data_long(srcoffset+disp, srcval | mask);
-        } else {
-            u16 srcval,mask;
+            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
+            store_data_long(srcoffset + disp, srcval | mask);
+        }
+        else {
+            u16 srcval, mask;
             u16 *shiftreg;
 
             srcoffset = decode_rm01_address(rl);
@@ -870,16 +848,16 @@ static void x86emuOp2_bts_R(u8 X86EMU_UNUSED(op2))
             shiftreg = DECODE_RM_WORD_REGISTER(rh);
             TRACE_AND_STEP();
             bit = *shiftreg & 0xF;
-            disp = (s16)*shiftreg >> 4;
-            srcval = fetch_data_word(srcoffset+disp);
-			mask = (u16)(0x1 << bit);
-            CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
-            store_data_word(srcoffset+disp, srcval | mask);
+            disp = (s16) * shiftreg >> 4;
+            srcval = fetch_data_word(srcoffset + disp);
+            mask = (u16) (0x1 << bit);
+            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
+            store_data_word(srcoffset + disp, srcval | mask);
         }
         break;
     case 2:
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-            u32 srcval,mask;
+            u32 srcval, mask;
             u32 *shiftreg;
 
             srcoffset = decode_rm10_address(rl);
@@ -887,51 +865,53 @@ static void x86emuOp2_bts_R(u8 X86EMU_UNUSED(op2))
             shiftreg = DECODE_RM_LONG_REGISTER(rh);
             TRACE_AND_STEP();
             bit = *shiftreg & 0x1F;
-            disp = (s16)*shiftreg >> 5;
-            srcval = fetch_data_long(srcoffset+disp);
+            disp = (s16) * shiftreg >> 5;
+            srcval = fetch_data_long(srcoffset + disp);
             mask = (0x1 << bit);
-            CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
-            store_data_long(srcoffset+disp, srcval | mask);
-        } else {
-            u16 srcval,mask;
+            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
+            store_data_long(srcoffset + disp, srcval | mask);
+        }
+        else {
+            u16 srcval, mask;
             u16 *shiftreg;
 
-			srcoffset = decode_rm10_address(rl);
-			DECODE_PRINTF(",");
-			shiftreg = DECODE_RM_WORD_REGISTER(rh);
-			TRACE_AND_STEP();
-			bit = *shiftreg & 0xF;
-			disp = (s16)*shiftreg >> 4;
-			srcval = fetch_data_word(srcoffset+disp);
-			mask = (u16)(0x1 << bit);
-			CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
-			store_data_word(srcoffset+disp, srcval | mask);
-		}
-		break;
-	case 3:                     /* register to register */
-		if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-			u32 *srcreg,*shiftreg;
-			u32 mask;
-
-			srcreg = DECODE_RM_LONG_REGISTER(rl);
-			DECODE_PRINTF(",");
-			shiftreg = DECODE_RM_LONG_REGISTER(rh);
-			TRACE_AND_STEP();
-			bit = *shiftreg & 0x1F;
-			mask = (0x1 << bit);
-			CONDITIONAL_SET_FLAG(*srcreg & mask,F_CF);
-			*srcreg |= mask;
-		} else {
-			u16 *srcreg,*shiftreg;
-			u16 mask;
-
-			srcreg = DECODE_RM_WORD_REGISTER(rl);
-			DECODE_PRINTF(",");
-			shiftreg = DECODE_RM_WORD_REGISTER(rh);
-			TRACE_AND_STEP();
-			bit = *shiftreg & 0xF;
-			mask = (u16)(0x1 << bit);
-            CONDITIONAL_SET_FLAG(*srcreg & mask,F_CF);
+            srcoffset = decode_rm10_address(rl);
+            DECODE_PRINTF(",");
+            shiftreg = DECODE_RM_WORD_REGISTER(rh);
+            TRACE_AND_STEP();
+            bit = *shiftreg & 0xF;
+            disp = (s16) * shiftreg >> 4;
+            srcval = fetch_data_word(srcoffset + disp);
+            mask = (u16) (0x1 << bit);
+            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
+            store_data_word(srcoffset + disp, srcval | mask);
+        }
+        break;
+    case 3:                    /* register to register */
+        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
+            u32 *srcreg, *shiftreg;
+            u32 mask;
+
+            srcreg = DECODE_RM_LONG_REGISTER(rl);
+            DECODE_PRINTF(",");
+            shiftreg = DECODE_RM_LONG_REGISTER(rh);
+            TRACE_AND_STEP();
+            bit = *shiftreg & 0x1F;
+            mask = (0x1 << bit);
+            CONDITIONAL_SET_FLAG(*srcreg & mask, F_CF);
+            *srcreg |= mask;
+        }
+        else {
+            u16 *srcreg, *shiftreg;
+            u16 mask;
+
+            srcreg = DECODE_RM_WORD_REGISTER(rl);
+            DECODE_PRINTF(",");
+            shiftreg = DECODE_RM_WORD_REGISTER(rh);
+            TRACE_AND_STEP();
+            bit = *shiftreg & 0xF;
+            mask = (u16) (0x1 << bit);
+            CONDITIONAL_SET_FLAG(*srcreg & mask, F_CF);
             *srcreg |= mask;
         }
         break;
@@ -944,11 +924,12 @@ static void x86emuOp2_bts_R(u8 X86EMU_UNUSED(op2))
 REMARKS:
 Handles opcode 0x0f,0xac
 ****************************************************************************/
-static void x86emuOp2_shrd_IMM(u8 X86EMU_UNUSED(op2))
+static void
+x86emuOp2_shrd_IMM(u8 X86EMU_UNUSED(op2))
 {
     int mod, rl, rh;
     uint destoffset;
-	u8 shift;
+    u8 shift;
 
     START_OF_INSTR();
     DECODE_PRINTF("SHLD\t");
@@ -967,9 +948,10 @@ static void x86emuOp2_shrd_IMM(u8 X86EMU_UNUSED(op2))
             DECODE_PRINTF2("%d\n", shift);
             TRACE_AND_STEP();
             destval = fetch_data_long(destoffset);
-            destval = shrd_long(destval,*shiftreg,shift);
+            destval = shrd_long(destval, *shiftreg, shift);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
             u16 *shiftreg;
 
@@ -981,7 +963,7 @@ static void x86emuOp2_shrd_IMM(u8 X86EMU_UNUSED(op2))
             DECODE_PRINTF2("%d\n", shift);
             TRACE_AND_STEP();
             destval = fetch_data_word(destoffset);
-            destval = shrd_word(destval,*shiftreg,shift);
+            destval = shrd_word(destval, *shiftreg, shift);
             store_data_word(destoffset, destval);
         }
         break;
@@ -998,9 +980,10 @@ static void x86emuOp2_shrd_IMM(u8 X86EMU_UNUSED(op2))
             DECODE_PRINTF2("%d\n", shift);
             TRACE_AND_STEP();
             destval = fetch_data_long(destoffset);
-            destval = shrd_long(destval,*shiftreg,shift);
+            destval = shrd_long(destval, *shiftreg, shift);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
             u16 *shiftreg;
 
@@ -1012,7 +995,7 @@ static void x86emuOp2_shrd_IMM(u8 X86EMU_UNUSED(op2))
             DECODE_PRINTF2("%d\n", shift);
             TRACE_AND_STEP();
             destval = fetch_data_word(destoffset);
-            destval = shrd_word(destval,*shiftreg,shift);
+            destval = shrd_word(destval, *shiftreg, shift);
             store_data_word(destoffset, destval);
         }
         break;
@@ -1029,9 +1012,10 @@ static void x86emuOp2_shrd_IMM(u8 X86EMU_UNUSED(op2))
             DECODE_PRINTF2("%d\n", shift);
             TRACE_AND_STEP();
             destval = fetch_data_long(destoffset);
-            destval = shrd_long(destval,*shiftreg,shift);
+            destval = shrd_long(destval, *shiftreg, shift);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
             u16 *shiftreg;
 
@@ -1043,13 +1027,13 @@ static void x86emuOp2_shrd_IMM(u8 X86EMU_UNUSED(op2))
             DECODE_PRINTF2("%d\n", shift);
             TRACE_AND_STEP();
             destval = fetch_data_word(destoffset);
-            destval = shrd_word(destval,*shiftreg,shift);
+            destval = shrd_word(destval, *shiftreg, shift);
             store_data_word(destoffset, destval);
         }
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-            u32 *destreg,*shiftreg;
+            u32 *destreg, *shiftreg;
 
             destreg = DECODE_RM_LONG_REGISTER(rl);
             DECODE_PRINTF(",");
@@ -1058,9 +1042,10 @@ static void x86emuOp2_shrd_IMM(u8 X86EMU_UNUSED(op2))
             shift = fetch_byte_imm();
             DECODE_PRINTF2("%d\n", shift);
             TRACE_AND_STEP();
-            *destreg = shrd_long(*destreg,*shiftreg,shift);
-        } else {
-            u16 *destreg,*shiftreg;
+            *destreg = shrd_long(*destreg, *shiftreg, shift);
+        }
+        else {
+            u16 *destreg, *shiftreg;
 
             destreg = DECODE_RM_WORD_REGISTER(rl);
             DECODE_PRINTF(",");
@@ -1069,7 +1054,7 @@ static void x86emuOp2_shrd_IMM(u8 X86EMU_UNUSED(op2))
             shift = fetch_byte_imm();
             DECODE_PRINTF2("%d\n", shift);
             TRACE_AND_STEP();
-            *destreg = shrd_word(*destreg,*shiftreg,shift);
+            *destreg = shrd_word(*destreg, *shiftreg, shift);
         }
         break;
     }
@@ -1081,7 +1066,8 @@ static void x86emuOp2_shrd_IMM(u8 X86EMU_UNUSED(op2))
 REMARKS:
 Handles opcode 0x0f,0xad
 ****************************************************************************/
-static void x86emuOp2_shrd_CL(u8 X86EMU_UNUSED(op2))
+static void
+x86emuOp2_shrd_CL(u8 X86EMU_UNUSED(op2))
 {
     int mod, rl, rh;
     uint destoffset;
@@ -1101,9 +1087,10 @@ static void x86emuOp2_shrd_CL(u8 X86EMU_UNUSED(op2))
             DECODE_PRINTF(",CL\n");
             TRACE_AND_STEP();
             destval = fetch_data_long(destoffset);
-            destval = shrd_long(destval,*shiftreg,M.x86.R_CL);
+            destval = shrd_long(destval, *shiftreg, M.x86.R_CL);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
             u16 *shiftreg;
 
@@ -1113,7 +1100,7 @@ static void x86emuOp2_shrd_CL(u8 X86EMU_UNUSED(op2))
             DECODE_PRINTF(",CL\n");
             TRACE_AND_STEP();
             destval = fetch_data_word(destoffset);
-            destval = shrd_word(destval,*shiftreg,M.x86.R_CL);
+            destval = shrd_word(destval, *shiftreg, M.x86.R_CL);
             store_data_word(destoffset, destval);
         }
         break;
@@ -1128,9 +1115,10 @@ static void x86emuOp2_shrd_CL(u8 X86EMU_UNUSED(op2))
             DECODE_PRINTF(",CL\n");
             TRACE_AND_STEP();
             destval = fetch_data_long(destoffset);
-            destval = shrd_long(destval,*shiftreg,M.x86.R_CL);
+            destval = shrd_long(destval, *shiftreg, M.x86.R_CL);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
             u16 *shiftreg;
 
@@ -1140,7 +1128,7 @@ static void x86emuOp2_shrd_CL(u8 X86EMU_UNUSED(op2))
             DECODE_PRINTF(",CL\n");
             TRACE_AND_STEP();
             destval = fetch_data_word(destoffset);
-            destval = shrd_word(destval,*shiftreg,M.x86.R_CL);
+            destval = shrd_word(destval, *shiftreg, M.x86.R_CL);
             store_data_word(destoffset, destval);
         }
         break;
@@ -1155,9 +1143,10 @@ static void x86emuOp2_shrd_CL(u8 X86EMU_UNUSED(op2))
             DECODE_PRINTF(",CL\n");
             TRACE_AND_STEP();
             destval = fetch_data_long(destoffset);
-            destval = shrd_long(destval,*shiftreg,M.x86.R_CL);
+            destval = shrd_long(destval, *shiftreg, M.x86.R_CL);
             store_data_long(destoffset, destval);
-        } else {
+        }
+        else {
             u16 destval;
             u16 *shiftreg;
 
@@ -1167,29 +1156,30 @@ static void x86emuOp2_shrd_CL(u8 X86EMU_UNUSED(op2))
             DECODE_PRINTF(",CL\n");
             TRACE_AND_STEP();
             destval = fetch_data_word(destoffset);
-            destval = shrd_word(destval,*shiftreg,M.x86.R_CL);
+            destval = shrd_word(destval, *shiftreg, M.x86.R_CL);
             store_data_word(destoffset, destval);
         }
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-            u32 *destreg,*shiftreg;
+            u32 *destreg, *shiftreg;
 
             destreg = DECODE_RM_LONG_REGISTER(rl);
             DECODE_PRINTF(",");
             shiftreg = DECODE_RM_LONG_REGISTER(rh);
             DECODE_PRINTF(",CL\n");
             TRACE_AND_STEP();
-            *destreg = shrd_long(*destreg,*shiftreg,M.x86.R_CL);
-        } else {
-            u16 *destreg,*shiftreg;
+            *destreg = shrd_long(*destreg, *shiftreg, M.x86.R_CL);
+        }
+        else {
+            u16 *destreg, *shiftreg;
 
             destreg = DECODE_RM_WORD_REGISTER(rl);
             DECODE_PRINTF(",");
             shiftreg = DECODE_RM_WORD_REGISTER(rh);
             DECODE_PRINTF(",CL\n");
             TRACE_AND_STEP();
-            *destreg = shrd_word(*destreg,*shiftreg,M.x86.R_CL);
+            *destreg = shrd_word(*destreg, *shiftreg, M.x86.R_CL);
         }
         break;
     }
@@ -1201,7 +1191,8 @@ static void x86emuOp2_shrd_CL(u8 X86EMU_UNUSED(op2))
 REMARKS:
 Handles opcode 0x0f,0xaf
 ****************************************************************************/
-static void x86emuOp2_imul_R_RM(u8 X86EMU_UNUSED(op2))
+static void
+x86emuOp2_imul_R_RM(u8 X86EMU_UNUSED(op2))
 {
     int mod, rl, rh;
     uint srcoffset;
@@ -1214,23 +1205,25 @@ static void x86emuOp2_imul_R_RM(u8 X86EMU_UNUSED(op2))
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
             u32 *destreg;
             u32 srcval;
-            u32 res_lo,res_hi;
+            u32 res_lo, res_hi;
 
             destreg = DECODE_RM_LONG_REGISTER(rh);
             DECODE_PRINTF(",");
             srcoffset = decode_rm00_address(rl);
             srcval = fetch_data_long(srcoffset);
             TRACE_AND_STEP();
-            imul_long_direct(&res_lo,&res_hi,(s32)*destreg,(s32)srcval);
+            imul_long_direct(&res_lo, &res_hi, (s32) * destreg, (s32) srcval);
             if (res_hi != 0) {
                 SET_FLAG(F_CF);
                 SET_FLAG(F_OF);
-            } else {
+            }
+            else {
                 CLEAR_FLAG(F_CF);
                 CLEAR_FLAG(F_OF);
             }
-            *destreg = (u32)res_lo;
-        } else {
+            *destreg = (u32) res_lo;
+        }
+        else {
             u16 *destreg;
             u16 srcval;
             u32 res;
@@ -1240,38 +1233,41 @@ static void x86emuOp2_imul_R_RM(u8 X86EMU_UNUSED(op2))
             srcoffset = decode_rm00_address(rl);
             srcval = fetch_data_word(srcoffset);
             TRACE_AND_STEP();
-            res = (s16)*destreg * (s16)srcval;
+            res = (s16) * destreg * (s16) srcval;
             if (res > 0xFFFF) {
                 SET_FLAG(F_CF);
                 SET_FLAG(F_OF);
-            } else {
+            }
+            else {
                 CLEAR_FLAG(F_CF);
                 CLEAR_FLAG(F_OF);
             }
-            *destreg = (u16)res;
+            *destreg = (u16) res;
         }
         break;
     case 1:
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
             u32 *destreg;
             u32 srcval;
-            u32 res_lo,res_hi;
+            u32 res_lo, res_hi;
 
             destreg = DECODE_RM_LONG_REGISTER(rh);
             DECODE_PRINTF(",");
             srcoffset = decode_rm01_address(rl);
             srcval = fetch_data_long(srcoffset);
             TRACE_AND_STEP();
-            imul_long_direct(&res_lo,&res_hi,(s32)*destreg,(s32)srcval);
+            imul_long_direct(&res_lo, &res_hi, (s32) * destreg, (s32) srcval);
             if (res_hi != 0) {
                 SET_FLAG(F_CF);
                 SET_FLAG(F_OF);
-            } else {
+            }
+            else {
                 CLEAR_FLAG(F_CF);
                 CLEAR_FLAG(F_OF);
             }
-            *destreg = (u32)res_lo;
-        } else {
+            *destreg = (u32) res_lo;
+        }
+        else {
             u16 *destreg;
             u16 srcval;
             u32 res;
@@ -1281,38 +1277,41 @@ static void x86emuOp2_imul_R_RM(u8 X86EMU_UNUSED(op2))
             srcoffset = decode_rm01_address(rl);
             srcval = fetch_data_word(srcoffset);
             TRACE_AND_STEP();
-            res = (s16)*destreg * (s16)srcval;
+            res = (s16) * destreg * (s16) srcval;
             if (res > 0xFFFF) {
                 SET_FLAG(F_CF);
                 SET_FLAG(F_OF);
-            } else {
+            }
+            else {
                 CLEAR_FLAG(F_CF);
                 CLEAR_FLAG(F_OF);
             }
-            *destreg = (u16)res;
+            *destreg = (u16) res;
         }
         break;
     case 2:
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
             u32 *destreg;
             u32 srcval;
-            u32 res_lo,res_hi;
+            u32 res_lo, res_hi;
 
             destreg = DECODE_RM_LONG_REGISTER(rh);
             DECODE_PRINTF(",");
             srcoffset = decode_rm10_address(rl);
             srcval = fetch_data_long(srcoffset);
             TRACE_AND_STEP();
-            imul_long_direct(&res_lo,&res_hi,(s32)*destreg,(s32)srcval);
+            imul_long_direct(&res_lo, &res_hi, (s32) * destreg, (s32) srcval);
             if (res_hi != 0) {
                 SET_FLAG(F_CF);
                 SET_FLAG(F_OF);
-            } else {
+            }
+            else {
                 CLEAR_FLAG(F_CF);
                 CLEAR_FLAG(F_OF);
             }
-            *destreg = (u32)res_lo;
-        } else {
+            *destreg = (u32) res_lo;
+        }
+        else {
             u16 *destreg;
             u16 srcval;
             u32 res;
@@ -1322,51 +1321,55 @@ static void x86emuOp2_imul_R_RM(u8 X86EMU_UNUSED(op2))
             srcoffset = decode_rm10_address(rl);
             srcval = fetch_data_word(srcoffset);
             TRACE_AND_STEP();
-            res = (s16)*destreg * (s16)srcval;
+            res = (s16) * destreg * (s16) srcval;
             if (res > 0xFFFF) {
                 SET_FLAG(F_CF);
                 SET_FLAG(F_OF);
-            } else {
+            }
+            else {
                 CLEAR_FLAG(F_CF);
                 CLEAR_FLAG(F_OF);
             }
-            *destreg = (u16)res;
+            *destreg = (u16) res;
         }
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-            u32 *destreg,*srcreg;
-            u32 res_lo,res_hi;
+            u32 *destreg, *srcreg;
+            u32 res_lo, res_hi;
 
             destreg = DECODE_RM_LONG_REGISTER(rh);
             DECODE_PRINTF(",");
             srcreg = DECODE_RM_LONG_REGISTER(rl);
             TRACE_AND_STEP();
-            imul_long_direct(&res_lo,&res_hi,(s32)*destreg,(s32)*srcreg);
+            imul_long_direct(&res_lo, &res_hi, (s32) * destreg, (s32) * srcreg);
             if (res_hi != 0) {
                 SET_FLAG(F_CF);
                 SET_FLAG(F_OF);
-            } else {
+            }
+            else {
                 CLEAR_FLAG(F_CF);
                 CLEAR_FLAG(F_OF);
             }
-            *destreg = (u32)res_lo;
-        } else {
-            u16 *destreg,*srcreg;
+            *destreg = (u32) res_lo;
+        }
+        else {
+            u16 *destreg, *srcreg;
             u32 res;
 
             destreg = DECODE_RM_WORD_REGISTER(rh);
             DECODE_PRINTF(",");
             srcreg = DECODE_RM_WORD_REGISTER(rl);
-            res = (s16)*destreg * (s16)*srcreg;
+            res = (s16) * destreg * (s16) * srcreg;
             if (res > 0xFFFF) {
                 SET_FLAG(F_CF);
                 SET_FLAG(F_OF);
-            } else {
+            }
+            else {
                 CLEAR_FLAG(F_CF);
                 CLEAR_FLAG(F_OF);
             }
-            *destreg = (u16)res;
+            *destreg = (u16) res;
         }
         break;
     }
@@ -1378,9 +1381,10 @@ static void x86emuOp2_imul_R_RM(u8 X86EMU_UNUSED(op2))
 REMARKS:
 Handles opcode 0x0f,0xb2
 ****************************************************************************/
-static void x86emuOp2_lss_R_IMM(u8 X86EMU_UNUSED(op2))
+static void
+x86emuOp2_lss_R_IMM(u8 X86EMU_UNUSED(op2))
 {
-	int mod, rh, rl;
+    int mod, rh, rl;
     u16 *dstreg;
     uint srcoffset;
 
@@ -1415,7 +1419,7 @@ static void x86emuOp2_lss_R_IMM(u8 X86EMU_UNUSED(op2))
         *dstreg = fetch_data_word(srcoffset);
         M.x86.R_SS = fetch_data_word(srcoffset + 2);
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         /* UNDEFINED! */
         TRACE_AND_STEP();
     }
@@ -1427,148 +1431,154 @@ static void x86emuOp2_lss_R_IMM(u8 X86EMU_UNUSED(op2))
 REMARKS:
 Handles opcode 0x0f,0xb3
 ****************************************************************************/
-static void x86emuOp2_btr_R(u8 X86EMU_UNUSED(op2))
+static void
+x86emuOp2_btr_R(u8 X86EMU_UNUSED(op2))
 {
-	int mod, rl, rh;
-	uint srcoffset;
-	int bit,disp;
-
-	START_OF_INSTR();
-	DECODE_PRINTF("BTR\t");
-	FETCH_DECODE_MODRM(mod, rh, rl);
-	switch (mod) {
-	case 0:
-		if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-			u32 srcval,mask;
-			u32 *shiftreg;
-
-			srcoffset = decode_rm00_address(rl);
-			DECODE_PRINTF(",");
-			shiftreg = DECODE_RM_LONG_REGISTER(rh);
-			TRACE_AND_STEP();
-			bit = *shiftreg & 0x1F;
-			disp = (s16)*shiftreg >> 5;
-			srcval = fetch_data_long(srcoffset+disp);
-			mask = (0x1 << bit);
-			CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
-			store_data_long(srcoffset+disp, srcval & ~mask);
-		} else {
-			u16 srcval,mask;
-			u16 *shiftreg;
-
-			srcoffset = decode_rm00_address(rl);
-			DECODE_PRINTF(",");
-			shiftreg = DECODE_RM_WORD_REGISTER(rh);
-			TRACE_AND_STEP();
-			bit = *shiftreg & 0xF;
-			disp = (s16)*shiftreg >> 4;
-			srcval = fetch_data_word(srcoffset+disp);
-			mask = (u16)(0x1 << bit);
-			CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
-			store_data_word(srcoffset+disp, (u16)(srcval & ~mask));
-		}
-		break;
-	case 1:
-		if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-			u32 srcval,mask;
-			u32 *shiftreg;
-
-			srcoffset = decode_rm01_address(rl);
-			DECODE_PRINTF(",");
-			shiftreg = DECODE_RM_LONG_REGISTER(rh);
-			TRACE_AND_STEP();
-			bit = *shiftreg & 0x1F;
-			disp = (s16)*shiftreg >> 5;
-			srcval = fetch_data_long(srcoffset+disp);
-			mask = (0x1 << bit);
-			CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
-			store_data_long(srcoffset+disp, srcval & ~mask);
-		} else {
-			u16 srcval,mask;
-			u16 *shiftreg;
-
-			srcoffset = decode_rm01_address(rl);
-			DECODE_PRINTF(",");
-			shiftreg = DECODE_RM_WORD_REGISTER(rh);
-			TRACE_AND_STEP();
-			bit = *shiftreg & 0xF;
-			disp = (s16)*shiftreg >> 4;
-			srcval = fetch_data_word(srcoffset+disp);
-			mask = (u16)(0x1 << bit);
-			CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
-			store_data_word(srcoffset+disp, (u16)(srcval & ~mask));
-		}
-		break;
-	case 2:
-		if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-			u32 srcval,mask;
-			u32 *shiftreg;
-
-			srcoffset = decode_rm10_address(rl);
-			DECODE_PRINTF(",");
-			shiftreg = DECODE_RM_LONG_REGISTER(rh);
-			TRACE_AND_STEP();
-			bit = *shiftreg & 0x1F;
-			disp = (s16)*shiftreg >> 5;
-			srcval = fetch_data_long(srcoffset+disp);
-			mask = (0x1 << bit);
-			CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
-			store_data_long(srcoffset+disp, srcval & ~mask);
-		} else {
-			u16 srcval,mask;
-			u16 *shiftreg;
-
-			srcoffset = decode_rm10_address(rl);
-			DECODE_PRINTF(",");
-			shiftreg = DECODE_RM_WORD_REGISTER(rh);
-			TRACE_AND_STEP();
-			bit = *shiftreg & 0xF;
-			disp = (s16)*shiftreg >> 4;
-			srcval = fetch_data_word(srcoffset+disp);
-			mask = (u16)(0x1 << bit);
-			CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
-			store_data_word(srcoffset+disp, (u16)(srcval & ~mask));
-		}
-		break;
-	case 3:                     /* register to register */
-		if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-			u32 *srcreg,*shiftreg;
-			u32 mask;
-
-			srcreg = DECODE_RM_LONG_REGISTER(rl);
-			DECODE_PRINTF(",");
-			shiftreg = DECODE_RM_LONG_REGISTER(rh);
-			TRACE_AND_STEP();
-			bit = *shiftreg & 0x1F;
-			mask = (0x1 << bit);
-			CONDITIONAL_SET_FLAG(*srcreg & mask,F_CF);
-			*srcreg &= ~mask;
-		} else {
-			u16 *srcreg,*shiftreg;
-			u16 mask;
-
-			srcreg = DECODE_RM_WORD_REGISTER(rl);
-			DECODE_PRINTF(",");
-			shiftreg = DECODE_RM_WORD_REGISTER(rh);
-			TRACE_AND_STEP();
-			bit = *shiftreg & 0xF;
-			mask = (u16)(0x1 << bit);
-			CONDITIONAL_SET_FLAG(*srcreg & mask,F_CF);
-			*srcreg &= ~mask;
-		}
-		break;
-	}
-	DECODE_CLEAR_SEGOVR();
-	END_OF_INSTR();
+    int mod, rl, rh;
+    uint srcoffset;
+    int bit, disp;
+
+    START_OF_INSTR();
+    DECODE_PRINTF("BTR\t");
+    FETCH_DECODE_MODRM(mod, rh, rl);
+    switch (mod) {
+    case 0:
+        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
+            u32 srcval, mask;
+            u32 *shiftreg;
+
+            srcoffset = decode_rm00_address(rl);
+            DECODE_PRINTF(",");
+            shiftreg = DECODE_RM_LONG_REGISTER(rh);
+            TRACE_AND_STEP();
+            bit = *shiftreg & 0x1F;
+            disp = (s16) * shiftreg >> 5;
+            srcval = fetch_data_long(srcoffset + disp);
+            mask = (0x1 << bit);
+            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
+            store_data_long(srcoffset + disp, srcval & ~mask);
+        }
+        else {
+            u16 srcval, mask;
+            u16 *shiftreg;
+
+            srcoffset = decode_rm00_address(rl);
+            DECODE_PRINTF(",");
+            shiftreg = DECODE_RM_WORD_REGISTER(rh);
+            TRACE_AND_STEP();
+            bit = *shiftreg & 0xF;
+            disp = (s16) * shiftreg >> 4;
+            srcval = fetch_data_word(srcoffset + disp);
+            mask = (u16) (0x1 << bit);
+            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
+            store_data_word(srcoffset + disp, (u16) (srcval & ~mask));
+        }
+        break;
+    case 1:
+        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
+            u32 srcval, mask;
+            u32 *shiftreg;
+
+            srcoffset = decode_rm01_address(rl);
+            DECODE_PRINTF(",");
+            shiftreg = DECODE_RM_LONG_REGISTER(rh);
+            TRACE_AND_STEP();
+            bit = *shiftreg & 0x1F;
+            disp = (s16) * shiftreg >> 5;
+            srcval = fetch_data_long(srcoffset + disp);
+            mask = (0x1 << bit);
+            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
+            store_data_long(srcoffset + disp, srcval & ~mask);
+        }
+        else {
+            u16 srcval, mask;
+            u16 *shiftreg;
+
+            srcoffset = decode_rm01_address(rl);
+            DECODE_PRINTF(",");
+            shiftreg = DECODE_RM_WORD_REGISTER(rh);
+            TRACE_AND_STEP();
+            bit = *shiftreg & 0xF;
+            disp = (s16) * shiftreg >> 4;
+            srcval = fetch_data_word(srcoffset + disp);
+            mask = (u16) (0x1 << bit);
+            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
+            store_data_word(srcoffset + disp, (u16) (srcval & ~mask));
+        }
+        break;
+    case 2:
+        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
+            u32 srcval, mask;
+            u32 *shiftreg;
+
+            srcoffset = decode_rm10_address(rl);
+            DECODE_PRINTF(",");
+            shiftreg = DECODE_RM_LONG_REGISTER(rh);
+            TRACE_AND_STEP();
+            bit = *shiftreg & 0x1F;
+            disp = (s16) * shiftreg >> 5;
+            srcval = fetch_data_long(srcoffset + disp);
+            mask = (0x1 << bit);
+            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
+            store_data_long(srcoffset + disp, srcval & ~mask);
+        }
+        else {
+            u16 srcval, mask;
+            u16 *shiftreg;
+
+            srcoffset = decode_rm10_address(rl);
+            DECODE_PRINTF(",");
+            shiftreg = DECODE_RM_WORD_REGISTER(rh);
+            TRACE_AND_STEP();
+            bit = *shiftreg & 0xF;
+            disp = (s16) * shiftreg >> 4;
+            srcval = fetch_data_word(srcoffset + disp);
+            mask = (u16) (0x1 << bit);
+            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
+            store_data_word(srcoffset + disp, (u16) (srcval & ~mask));
+        }
+        break;
+    case 3:                    /* register to register */
+        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
+            u32 *srcreg, *shiftreg;
+            u32 mask;
+
+            srcreg = DECODE_RM_LONG_REGISTER(rl);
+            DECODE_PRINTF(",");
+            shiftreg = DECODE_RM_LONG_REGISTER(rh);
+            TRACE_AND_STEP();
+            bit = *shiftreg & 0x1F;
+            mask = (0x1 << bit);
+            CONDITIONAL_SET_FLAG(*srcreg & mask, F_CF);
+            *srcreg &= ~mask;
+        }
+        else {
+            u16 *srcreg, *shiftreg;
+            u16 mask;
+
+            srcreg = DECODE_RM_WORD_REGISTER(rl);
+            DECODE_PRINTF(",");
+            shiftreg = DECODE_RM_WORD_REGISTER(rh);
+            TRACE_AND_STEP();
+            bit = *shiftreg & 0xF;
+            mask = (u16) (0x1 << bit);
+            CONDITIONAL_SET_FLAG(*srcreg & mask, F_CF);
+            *srcreg &= ~mask;
+        }
+        break;
+    }
+    DECODE_CLEAR_SEGOVR();
+    END_OF_INSTR();
 }
 
 /****************************************************************************
 REMARKS:
 Handles opcode 0x0f,0xb4
 ****************************************************************************/
-static void x86emuOp2_lfs_R_IMM(u8 X86EMU_UNUSED(op2))
+static void
+x86emuOp2_lfs_R_IMM(u8 X86EMU_UNUSED(op2))
 {
-	int mod, rh, rl;
+    int mod, rh, rl;
     u16 *dstreg;
     uint srcoffset;
 
@@ -1603,7 +1613,7 @@ static void x86emuOp2_lfs_R_IMM(u8 X86EMU_UNUSED(op2))
         *dstreg = fetch_data_word(srcoffset);
         M.x86.R_FS = fetch_data_word(srcoffset + 2);
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         /* UNDEFINED! */
         TRACE_AND_STEP();
     }
@@ -1615,9 +1625,10 @@ static void x86emuOp2_lfs_R_IMM(u8 X86EMU_UNUSED(op2))
 REMARKS:
 Handles opcode 0x0f,0xb5
 ****************************************************************************/
-static void x86emuOp2_lgs_R_IMM(u8 X86EMU_UNUSED(op2))
+static void
+x86emuOp2_lgs_R_IMM(u8 X86EMU_UNUSED(op2))
 {
-	int mod, rh, rl;
+    int mod, rh, rl;
     u16 *dstreg;
     uint srcoffset;
 
@@ -1652,7 +1663,7 @@ static void x86emuOp2_lgs_R_IMM(u8 X86EMU_UNUSED(op2))
         *dstreg = fetch_data_word(srcoffset);
         M.x86.R_GS = fetch_data_word(srcoffset + 2);
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         /* UNDEFINED! */
         TRACE_AND_STEP();
     }
@@ -1664,7 +1675,8 @@ static void x86emuOp2_lgs_R_IMM(u8 X86EMU_UNUSED(op2))
 REMARKS:
 Handles opcode 0x0f,0xb6
 ****************************************************************************/
-static void x86emuOp2_movzx_byte_R_RM(u8 X86EMU_UNUSED(op2))
+static void
+x86emuOp2_movzx_byte_R_RM(u8 X86EMU_UNUSED(op2))
 {
     int mod, rl, rh;
     uint srcoffset;
@@ -1685,7 +1697,8 @@ static void x86emuOp2_movzx_byte_R_RM(u8 X86EMU_UNUSED(op2))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = srcval;
-        } else {
+        }
+        else {
             u16 *destreg;
             u16 srcval;
 
@@ -1710,7 +1723,8 @@ static void x86emuOp2_movzx_byte_R_RM(u8 X86EMU_UNUSED(op2))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = srcval;
-        } else {
+        }
+        else {
             u16 *destreg;
             u16 srcval;
 
@@ -1735,7 +1749,8 @@ static void x86emuOp2_movzx_byte_R_RM(u8 X86EMU_UNUSED(op2))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = srcval;
-        } else {
+        }
+        else {
             u16 *destreg;
             u16 srcval;
 
@@ -1748,10 +1763,10 @@ static void x86emuOp2_movzx_byte_R_RM(u8 X86EMU_UNUSED(op2))
             *destreg = srcval;
         }
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
             u32 *destreg;
-            u8  *srcreg;
+            u8 *srcreg;
 
             destreg = DECODE_RM_LONG_REGISTER(rh);
             DECODE_PRINTF(",");
@@ -1759,9 +1774,10 @@ static void x86emuOp2_movzx_byte_R_RM(u8 X86EMU_UNUSED(op2))
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = *srcreg;
-        } else {
+        }
+        else {
             u16 *destreg;
-            u8  *srcreg;
+            u8 *srcreg;
 
             destreg = DECODE_RM_WORD_REGISTER(rh);
             DECODE_PRINTF(",");
@@ -1780,7 +1796,8 @@ static void x86emuOp2_movzx_byte_R_RM(u8 X86EMU_UNUSED(op2))
 REMARKS:
 Handles opcode 0x0f,0xb7
 ****************************************************************************/
-static void x86emuOp2_movzx_word_R_RM(u8 X86EMU_UNUSED(op2))
+static void
+x86emuOp2_movzx_word_R_RM(u8 X86EMU_UNUSED(op2))
 {
     int mod, rl, rh;
     uint srcoffset;
@@ -1819,7 +1836,7 @@ static void x86emuOp2_movzx_word_R_RM(u8 X86EMU_UNUSED(op2))
         TRACE_AND_STEP();
         *destreg = srcval;
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         destreg = DECODE_RM_LONG_REGISTER(rh);
         DECODE_PRINTF(",");
         srcreg = DECODE_RM_WORD_REGISTER(rl);
@@ -1836,7 +1853,8 @@ static void x86emuOp2_movzx_word_R_RM(u8 X86EMU_UNUSED(op2))
 REMARKS:
 Handles opcode 0x0f,0xba
 ****************************************************************************/
-static void x86emuOp2_btX_I(u8 X86EMU_UNUSED(op2))
+static void
+x86emuOp2_btX_I(u8 X86EMU_UNUSED(op2))
 {
     int mod, rl, rh;
     uint srcoffset;
@@ -1846,23 +1864,23 @@ static void x86emuOp2_btX_I(u8 X86EMU_UNUSED(op2))
     FETCH_DECODE_MODRM(mod, rh, rl);
     switch (rh) {
     case 4:
-	DECODE_PRINTF("BT\t");
-	break;
+        DECODE_PRINTF("BT\t");
+        break;
     case 5:
-	DECODE_PRINTF("BTS\t");
-	break;
+        DECODE_PRINTF("BTS\t");
+        break;
     case 6:
-	DECODE_PRINTF("BTR\t");
-	break;
+        DECODE_PRINTF("BTR\t");
+        break;
     case 7:
-	DECODE_PRINTF("BTC\t");
-	break;
+        DECODE_PRINTF("BTC\t");
+        break;
     default:
-	DECODE_PRINTF("ILLEGAL EXTENDED X86 OPCODE\n");
-	TRACE_REGS();
-	printk("%04x:%04x: %02X%02X ILLEGAL EXTENDED X86 OPCODE EXTENSION!\n",
-		M.x86.R_CS, M.x86.R_IP-3,op2, (mod<<6)|(rh<<3)|rl);
-	HALT_SYS();
+        DECODE_PRINTF("ILLEGAL EXTENDED X86 OPCODE\n");
+        TRACE_REGS();
+        printk("%04x:%04x: %02X%02X ILLEGAL EXTENDED X86 OPCODE EXTENSION!\n",
+               M.x86.R_CS, M.x86.R_IP - 3, op2, (mod << 6) | (rh << 3) | rl);
+        HALT_SYS();
     }
     switch (mod) {
     case 0:
@@ -1876,22 +1894,23 @@ static void x86emuOp2_btX_I(u8 X86EMU_UNUSED(op2))
             TRACE_AND_STEP();
             bit = shift & 0x1F;
             srcval = fetch_data_long(srcoffset);
-	    mask = (0x1 << bit);
-            CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
-	    switch (rh) {
-	    case 5:
-		store_data_long(srcoffset, srcval | mask);
-		break;
-	    case 6:
-		store_data_long(srcoffset, srcval & ~mask);
-		break;
-	    case 7:
-		store_data_long(srcoffset, srcval ^ mask);
-		break;
-	    default:
-		break;
-	    }
-        } else {
+            mask = (0x1 << bit);
+            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
+            switch (rh) {
+            case 5:
+                store_data_long(srcoffset, srcval | mask);
+                break;
+            case 6:
+                store_data_long(srcoffset, srcval & ~mask);
+                break;
+            case 7:
+                store_data_long(srcoffset, srcval ^ mask);
+                break;
+            default:
+                break;
+            }
+        }
+        else {
             u16 srcval, mask;
             u8 shift;
 
@@ -1901,21 +1920,21 @@ static void x86emuOp2_btX_I(u8 X86EMU_UNUSED(op2))
             TRACE_AND_STEP();
             bit = shift & 0xF;
             srcval = fetch_data_word(srcoffset);
-	    mask = (0x1 << bit);
-            CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
-	    switch (rh) {
-	    case 5:
-		store_data_word(srcoffset, srcval | mask);
-		break;
-	    case 6:
-		store_data_word(srcoffset, srcval & ~mask);
-		break;
-	    case 7:
-		store_data_word(srcoffset, srcval ^ mask);
-		break;
-	    default:
-		break;
-	    }
+            mask = (0x1 << bit);
+            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
+            switch (rh) {
+            case 5:
+                store_data_word(srcoffset, srcval | mask);
+                break;
+            case 6:
+                store_data_word(srcoffset, srcval & ~mask);
+                break;
+            case 7:
+                store_data_word(srcoffset, srcval ^ mask);
+                break;
+            default:
+                break;
+            }
         }
         break;
     case 1:
@@ -1929,22 +1948,23 @@ static void x86emuOp2_btX_I(u8 X86EMU_UNUSED(op2))
             TRACE_AND_STEP();
             bit = shift & 0x1F;
             srcval = fetch_data_long(srcoffset);
-	    mask = (0x1 << bit);
-            CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
-	    switch (rh) {
-	    case 5:
-		store_data_long(srcoffset, srcval | mask);
-		break;
-	    case 6:
-		store_data_long(srcoffset, srcval & ~mask);
-		break;
-	    case 7:
-		store_data_long(srcoffset, srcval ^ mask);
-		break;
-	    default:
-		break;
-	    }
-        } else {
+            mask = (0x1 << bit);
+            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
+            switch (rh) {
+            case 5:
+                store_data_long(srcoffset, srcval | mask);
+                break;
+            case 6:
+                store_data_long(srcoffset, srcval & ~mask);
+                break;
+            case 7:
+                store_data_long(srcoffset, srcval ^ mask);
+                break;
+            default:
+                break;
+            }
+        }
+        else {
             u16 srcval, mask;
             u8 shift;
 
@@ -1954,21 +1974,21 @@ static void x86emuOp2_btX_I(u8 X86EMU_UNUSED(op2))
             TRACE_AND_STEP();
             bit = shift & 0xF;
             srcval = fetch_data_word(srcoffset);
-	    mask = (0x1 << bit);
-            CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
-	    switch (rh) {
-	    case 5:
-		store_data_word(srcoffset, srcval | mask);
-		break;
-	    case 6:
-		store_data_word(srcoffset, srcval & ~mask);
-		break;
-	    case 7:
-		store_data_word(srcoffset, srcval ^ mask);
-		break;
-	    default:
-		break;
-	    }
+            mask = (0x1 << bit);
+            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
+            switch (rh) {
+            case 5:
+                store_data_word(srcoffset, srcval | mask);
+                break;
+            case 6:
+                store_data_word(srcoffset, srcval & ~mask);
+                break;
+            case 7:
+                store_data_word(srcoffset, srcval ^ mask);
+                break;
+            default:
+                break;
+            }
         }
         break;
     case 2:
@@ -1982,22 +2002,23 @@ static void x86emuOp2_btX_I(u8 X86EMU_UNUSED(op2))
             TRACE_AND_STEP();
             bit = shift & 0x1F;
             srcval = fetch_data_long(srcoffset);
-	    mask = (0x1 << bit);
-            CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
-	    switch (rh) {
-	    case 5:
-		store_data_long(srcoffset, srcval | mask);
-		break;
-	    case 6:
-		store_data_long(srcoffset, srcval & ~mask);
-		break;
-	    case 7:
-		store_data_long(srcoffset, srcval ^ mask);
-		break;
-	    default:
-		break;
-	    }
-        } else {
+            mask = (0x1 << bit);
+            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
+            switch (rh) {
+            case 5:
+                store_data_long(srcoffset, srcval | mask);
+                break;
+            case 6:
+                store_data_long(srcoffset, srcval & ~mask);
+                break;
+            case 7:
+                store_data_long(srcoffset, srcval ^ mask);
+                break;
+            default:
+                break;
+            }
+        }
+        else {
             u16 srcval, mask;
             u8 shift;
 
@@ -2007,74 +2028,75 @@ static void x86emuOp2_btX_I(u8 X86EMU_UNUSED(op2))
             TRACE_AND_STEP();
             bit = shift & 0xF;
             srcval = fetch_data_word(srcoffset);
-	    mask = (0x1 << bit);
-            CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
-	    switch (rh) {
-	    case 5:
-		store_data_word(srcoffset, srcval | mask);
-		break;
-	    case 6:
-		store_data_word(srcoffset, srcval & ~mask);
-		break;
-	    case 7:
-		store_data_word(srcoffset, srcval ^ mask);
-		break;
-	    default:
-		break;
-	    }
-        }
-        break;
-    case 3:                     /* register to register */
+            mask = (0x1 << bit);
+            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
+            switch (rh) {
+            case 5:
+                store_data_word(srcoffset, srcval | mask);
+                break;
+            case 6:
+                store_data_word(srcoffset, srcval & ~mask);
+                break;
+            case 7:
+                store_data_word(srcoffset, srcval ^ mask);
+                break;
+            default:
+                break;
+            }
+        }
+        break;
+    case 3:                    /* register to register */
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
             u32 *srcreg;
-	    u32 mask;
-	    u8 shift;
+            u32 mask;
+            u8 shift;
 
             srcreg = DECODE_RM_LONG_REGISTER(rl);
             DECODE_PRINTF(",");
             shift = fetch_byte_imm();
             TRACE_AND_STEP();
             bit = shift & 0x1F;
-	    mask = (0x1 << bit);
-            CONDITIONAL_SET_FLAG(*srcreg & mask,F_CF);
-	    switch (rh) {
-	    case 5:
-		*srcreg |= mask;
-		break;
-	    case 6:
-		*srcreg &= ~mask;
-		break;
-	    case 7:
-		*srcreg ^= mask;
-		break;
-	    default:
-		break;
-	    }
-        } else {
+            mask = (0x1 << bit);
+            CONDITIONAL_SET_FLAG(*srcreg & mask, F_CF);
+            switch (rh) {
+            case 5:
+                *srcreg |= mask;
+                break;
+            case 6:
+                *srcreg &= ~mask;
+                break;
+            case 7:
+                *srcreg ^= mask;
+                break;
+            default:
+                break;
+            }
+        }
+        else {
             u16 *srcreg;
-	    u16 mask;
-	    u8 shift;
+            u16 mask;
+            u8 shift;
 
             srcreg = DECODE_RM_WORD_REGISTER(rl);
             DECODE_PRINTF(",");
             shift = fetch_byte_imm();
             TRACE_AND_STEP();
             bit = shift & 0xF;
-	    mask = (0x1 << bit);
-            CONDITIONAL_SET_FLAG(*srcreg & mask,F_CF);
-	    switch (rh) {
-	    case 5:
-		*srcreg |= mask;
-		break;
-	    case 6:
-		*srcreg &= ~mask;
-		break;
-	    case 7:
-		*srcreg ^= mask;
-		break;
-	    default:
-		break;
-	    }
+            mask = (0x1 << bit);
+            CONDITIONAL_SET_FLAG(*srcreg & mask, F_CF);
+            switch (rh) {
+            case 5:
+                *srcreg |= mask;
+                break;
+            case 6:
+                *srcreg &= ~mask;
+                break;
+            case 7:
+                *srcreg ^= mask;
+                break;
+            default:
+                break;
+            }
         }
         break;
     }
@@ -2086,11 +2108,12 @@ static void x86emuOp2_btX_I(u8 X86EMU_UNUSED(op2))
 REMARKS:
 Handles opcode 0x0f,0xbb
 ****************************************************************************/
-static void x86emuOp2_btc_R(u8 X86EMU_UNUSED(op2))
+static void
+x86emuOp2_btc_R(u8 X86EMU_UNUSED(op2))
 {
     int mod, rl, rh;
     uint srcoffset;
-    int bit,disp;
+    int bit, disp;
 
     START_OF_INSTR();
     DECODE_PRINTF("BTC\t");
@@ -2098,7 +2121,7 @@ static void x86emuOp2_btc_R(u8 X86EMU_UNUSED(op2))
     switch (mod) {
     case 0:
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-            u32 srcval,mask;
+            u32 srcval, mask;
             u32 *shiftreg;
 
             srcoffset = decode_rm00_address(rl);
@@ -2106,13 +2129,14 @@ static void x86emuOp2_btc_R(u8 X86EMU_UNUSED(op2))
             shiftreg = DECODE_RM_LONG_REGISTER(rh);
             TRACE_AND_STEP();
             bit = *shiftreg & 0x1F;
-            disp = (s16)*shiftreg >> 5;
-            srcval = fetch_data_long(srcoffset+disp);
+            disp = (s16) * shiftreg >> 5;
+            srcval = fetch_data_long(srcoffset + disp);
             mask = (0x1 << bit);
-            CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
-            store_data_long(srcoffset+disp, srcval ^ mask);
-        } else {
-            u16 srcval,mask;
+            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
+            store_data_long(srcoffset + disp, srcval ^ mask);
+        }
+        else {
+            u16 srcval, mask;
             u16 *shiftreg;
 
             srcoffset = decode_rm00_address(rl);
@@ -2120,16 +2144,16 @@ static void x86emuOp2_btc_R(u8 X86EMU_UNUSED(op2))
             shiftreg = DECODE_RM_WORD_REGISTER(rh);
             TRACE_AND_STEP();
             bit = *shiftreg & 0xF;
-            disp = (s16)*shiftreg >> 4;
-            srcval = fetch_data_word(srcoffset+disp);
-			mask = (u16)(0x1 << bit);
-            CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
-			store_data_word(srcoffset+disp, (u16)(srcval ^ mask));
+            disp = (s16) * shiftreg >> 4;
+            srcval = fetch_data_word(srcoffset + disp);
+            mask = (u16) (0x1 << bit);
+            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
+            store_data_word(srcoffset + disp, (u16) (srcval ^ mask));
         }
         break;
     case 1:
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-            u32 srcval,mask;
+            u32 srcval, mask;
             u32 *shiftreg;
 
             srcoffset = decode_rm01_address(rl);
@@ -2137,13 +2161,14 @@ static void x86emuOp2_btc_R(u8 X86EMU_UNUSED(op2))
             shiftreg = DECODE_RM_LONG_REGISTER(rh);
             TRACE_AND_STEP();
             bit = *shiftreg & 0x1F;
-            disp = (s16)*shiftreg >> 5;
-            srcval = fetch_data_long(srcoffset+disp);
+            disp = (s16) * shiftreg >> 5;
+            srcval = fetch_data_long(srcoffset + disp);
             mask = (0x1 << bit);
-            CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
-            store_data_long(srcoffset+disp, srcval ^ mask);
-        } else {
-            u16 srcval,mask;
+            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
+            store_data_long(srcoffset + disp, srcval ^ mask);
+        }
+        else {
+            u16 srcval, mask;
             u16 *shiftreg;
 
             srcoffset = decode_rm01_address(rl);
@@ -2151,16 +2176,16 @@ static void x86emuOp2_btc_R(u8 X86EMU_UNUSED(op2))
             shiftreg = DECODE_RM_WORD_REGISTER(rh);
             TRACE_AND_STEP();
             bit = *shiftreg & 0xF;
-            disp = (s16)*shiftreg >> 4;
-            srcval = fetch_data_word(srcoffset+disp);
-			mask = (u16)(0x1 << bit);
-			CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
-			store_data_word(srcoffset+disp, (u16)(srcval ^ mask));
+            disp = (s16) * shiftreg >> 4;
+            srcval = fetch_data_word(srcoffset + disp);
+            mask = (u16) (0x1 << bit);
+            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
+            store_data_word(srcoffset + disp, (u16) (srcval ^ mask));
         }
         break;
     case 2:
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-            u32 srcval,mask;
+            u32 srcval, mask;
             u32 *shiftreg;
 
             srcoffset = decode_rm10_address(rl);
@@ -2168,13 +2193,14 @@ static void x86emuOp2_btc_R(u8 X86EMU_UNUSED(op2))
             shiftreg = DECODE_RM_LONG_REGISTER(rh);
             TRACE_AND_STEP();
             bit = *shiftreg & 0x1F;
-            disp = (s16)*shiftreg >> 5;
-            srcval = fetch_data_long(srcoffset+disp);
+            disp = (s16) * shiftreg >> 5;
+            srcval = fetch_data_long(srcoffset + disp);
             mask = (0x1 << bit);
-            CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
-            store_data_long(srcoffset+disp, srcval ^ mask);
-        } else {
-            u16 srcval,mask;
+            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
+            store_data_long(srcoffset + disp, srcval ^ mask);
+        }
+        else {
+            u16 srcval, mask;
             u16 *shiftreg;
 
             srcoffset = decode_rm10_address(rl);
@@ -2182,16 +2208,16 @@ static void x86emuOp2_btc_R(u8 X86EMU_UNUSED(op2))
             shiftreg = DECODE_RM_WORD_REGISTER(rh);
             TRACE_AND_STEP();
             bit = *shiftreg & 0xF;
-            disp = (s16)*shiftreg >> 4;
-            srcval = fetch_data_word(srcoffset+disp);
-			mask = (u16)(0x1 << bit);
-			CONDITIONAL_SET_FLAG(srcval & mask,F_CF);
-			store_data_word(srcoffset+disp, (u16)(srcval ^ mask));
+            disp = (s16) * shiftreg >> 4;
+            srcval = fetch_data_word(srcoffset + disp);
+            mask = (u16) (0x1 << bit);
+            CONDITIONAL_SET_FLAG(srcval & mask, F_CF);
+            store_data_word(srcoffset + disp, (u16) (srcval ^ mask));
         }
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-			u32 *srcreg,*shiftreg;
+            u32 *srcreg, *shiftreg;
             u32 mask;
 
             srcreg = DECODE_RM_LONG_REGISTER(rl);
@@ -2200,19 +2226,20 @@ static void x86emuOp2_btc_R(u8 X86EMU_UNUSED(op2))
             TRACE_AND_STEP();
             bit = *shiftreg & 0x1F;
             mask = (0x1 << bit);
-			CONDITIONAL_SET_FLAG(*srcreg & mask,F_CF);
-			*srcreg ^= mask;
-		} else {
-			u16 *srcreg,*shiftreg;
-			u16 mask;
-
-			srcreg = DECODE_RM_WORD_REGISTER(rl);
-			DECODE_PRINTF(",");
-			shiftreg = DECODE_RM_WORD_REGISTER(rh);
-			TRACE_AND_STEP();
-			bit = *shiftreg & 0xF;
-			mask = (u16)(0x1 << bit);
-            CONDITIONAL_SET_FLAG(*srcreg & mask,F_CF);
+            CONDITIONAL_SET_FLAG(*srcreg & mask, F_CF);
+            *srcreg ^= mask;
+        }
+        else {
+            u16 *srcreg, *shiftreg;
+            u16 mask;
+
+            srcreg = DECODE_RM_WORD_REGISTER(rl);
+            DECODE_PRINTF(",");
+            shiftreg = DECODE_RM_WORD_REGISTER(rh);
+            TRACE_AND_STEP();
+            bit = *shiftreg & 0xF;
+            mask = (u16) (0x1 << bit);
+            CONDITIONAL_SET_FLAG(*srcreg & mask, F_CF);
             *srcreg ^= mask;
         }
         break;
@@ -2225,7 +2252,8 @@ static void x86emuOp2_btc_R(u8 X86EMU_UNUSED(op2))
 REMARKS:
 Handles opcode 0x0f,0xbc
 ****************************************************************************/
-static void x86emuOp2_bsf(u8 X86EMU_UNUSED(op2))
+static void
+x86emuOp2_bsf(u8 X86EMU_UNUSED(op2))
 {
     int mod, rl, rh;
     uint srcoffset;
@@ -2233,105 +2261,117 @@ static void x86emuOp2_bsf(u8 X86EMU_UNUSED(op2))
     START_OF_INSTR();
     DECODE_PRINTF("BSF\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
-    switch(mod) {
+    switch (mod) {
     case 0:
-	if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-	    u32 srcval, *dstreg;
-
-	    srcoffset = decode_rm00_address(rl);
-	    DECODE_PRINTF(",");
-	    dstreg = DECODE_RM_LONG_REGISTER(rh);
-	    TRACE_AND_STEP();
-	    srcval = fetch_data_long(srcoffset);
-	    CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
-	    for(*dstreg = 0; *dstreg < 32; (*dstreg)++)
-		if ((srcval >> *dstreg) & 1) break;
-	} else {
-	    u16 srcval, *dstreg;
-
-	    srcoffset = decode_rm00_address(rl);
-	    DECODE_PRINTF(",");
-	    dstreg = DECODE_RM_WORD_REGISTER(rh);
-	    TRACE_AND_STEP();
-	    srcval = fetch_data_word(srcoffset);
-	    CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
-	    for(*dstreg = 0; *dstreg < 16; (*dstreg)++)
-		if ((srcval >> *dstreg) & 1) break;
-	}
-	break;
+        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
+            u32 srcval, *dstreg;
+
+            srcoffset = decode_rm00_address(rl);
+            DECODE_PRINTF(",");
+            dstreg = DECODE_RM_LONG_REGISTER(rh);
+            TRACE_AND_STEP();
+            srcval = fetch_data_long(srcoffset);
+            CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
+            for (*dstreg = 0; *dstreg < 32; (*dstreg)++)
+                if ((srcval >> *dstreg) & 1)
+                    break;
+        }
+        else {
+            u16 srcval, *dstreg;
+
+            srcoffset = decode_rm00_address(rl);
+            DECODE_PRINTF(",");
+            dstreg = DECODE_RM_WORD_REGISTER(rh);
+            TRACE_AND_STEP();
+            srcval = fetch_data_word(srcoffset);
+            CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
+            for (*dstreg = 0; *dstreg < 16; (*dstreg)++)
+                if ((srcval >> *dstreg) & 1)
+                    break;
+        }
+        break;
     case 1:
-	if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-	    u32 srcval, *dstreg;
-
-	    srcoffset = decode_rm01_address(rl);
-	    DECODE_PRINTF(",");
-	    dstreg = DECODE_RM_LONG_REGISTER(rh);
-	    TRACE_AND_STEP();
-	    srcval = fetch_data_long(srcoffset);
-	    CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
-	    for(*dstreg = 0; *dstreg < 32; (*dstreg)++)
-		if ((srcval >> *dstreg) & 1) break;
-	} else {
-	    u16 srcval, *dstreg;
-
-	    srcoffset = decode_rm01_address(rl);
-	    DECODE_PRINTF(",");
-	    dstreg = DECODE_RM_WORD_REGISTER(rh);
-	    TRACE_AND_STEP();
-	    srcval = fetch_data_word(srcoffset);
-	    CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
-	    for(*dstreg = 0; *dstreg < 16; (*dstreg)++)
-		if ((srcval >> *dstreg) & 1) break;
-	}
-	break;
+        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
+            u32 srcval, *dstreg;
+
+            srcoffset = decode_rm01_address(rl);
+            DECODE_PRINTF(",");
+            dstreg = DECODE_RM_LONG_REGISTER(rh);
+            TRACE_AND_STEP();
+            srcval = fetch_data_long(srcoffset);
+            CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
+            for (*dstreg = 0; *dstreg < 32; (*dstreg)++)
+                if ((srcval >> *dstreg) & 1)
+                    break;
+        }
+        else {
+            u16 srcval, *dstreg;
+
+            srcoffset = decode_rm01_address(rl);
+            DECODE_PRINTF(",");
+            dstreg = DECODE_RM_WORD_REGISTER(rh);
+            TRACE_AND_STEP();
+            srcval = fetch_data_word(srcoffset);
+            CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
+            for (*dstreg = 0; *dstreg < 16; (*dstreg)++)
+                if ((srcval >> *dstreg) & 1)
+                    break;
+        }
+        break;
     case 2:
-	if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-	    u32 srcval, *dstreg;
-
-	    srcoffset = decode_rm10_address(rl);
-	    DECODE_PRINTF(",");
-	    dstreg = DECODE_RM_LONG_REGISTER(rh);
-	    TRACE_AND_STEP();
-	    srcval = fetch_data_long(srcoffset);
-	    CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
-	    for(*dstreg = 0; *dstreg < 32; (*dstreg)++)
-		if ((srcval >> *dstreg) & 1) break;
-	} else {
-	    u16 srcval, *dstreg;
-
-	    srcoffset = decode_rm10_address(rl);
-	    DECODE_PRINTF(",");
-	    dstreg = DECODE_RM_WORD_REGISTER(rh);
-	    TRACE_AND_STEP();
-	    srcval = fetch_data_word(srcoffset);
-	    CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
-	    for(*dstreg = 0; *dstreg < 16; (*dstreg)++)
-		if ((srcval >> *dstreg) & 1) break;
-	}
-	break;
-    case 3:				/* register to register */
-	if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-	    u32 srcval, *dstreg;
-
-	    srcval = *DECODE_RM_LONG_REGISTER(rl);
-	    DECODE_PRINTF(",");
-	    dstreg = DECODE_RM_LONG_REGISTER(rh);
-	    TRACE_AND_STEP();
-	    CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
-	    for(*dstreg = 0; *dstreg < 32; (*dstreg)++)
-		if ((srcval >> *dstreg) & 1) break;
-	} else {
-	    u16 srcval, *dstreg;
-
-	    srcval = *DECODE_RM_WORD_REGISTER(rl);
-	    DECODE_PRINTF(",");
-	    dstreg = DECODE_RM_WORD_REGISTER(rh);
-	    TRACE_AND_STEP();
-	    CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
-	    for(*dstreg = 0; *dstreg < 16; (*dstreg)++)
-		if ((srcval >> *dstreg) & 1) break;
-	}
-	break;
+        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
+            u32 srcval, *dstreg;
+
+            srcoffset = decode_rm10_address(rl);
+            DECODE_PRINTF(",");
+            dstreg = DECODE_RM_LONG_REGISTER(rh);
+            TRACE_AND_STEP();
+            srcval = fetch_data_long(srcoffset);
+            CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
+            for (*dstreg = 0; *dstreg < 32; (*dstreg)++)
+                if ((srcval >> *dstreg) & 1)
+                    break;
+        }
+        else {
+            u16 srcval, *dstreg;
+
+            srcoffset = decode_rm10_address(rl);
+            DECODE_PRINTF(",");
+            dstreg = DECODE_RM_WORD_REGISTER(rh);
+            TRACE_AND_STEP();
+            srcval = fetch_data_word(srcoffset);
+            CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
+            for (*dstreg = 0; *dstreg < 16; (*dstreg)++)
+                if ((srcval >> *dstreg) & 1)
+                    break;
+        }
+        break;
+    case 3:                    /* register to register */
+        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
+            u32 srcval, *dstreg;
+
+            srcval = *DECODE_RM_LONG_REGISTER(rl);
+            DECODE_PRINTF(",");
+            dstreg = DECODE_RM_LONG_REGISTER(rh);
+            TRACE_AND_STEP();
+            CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
+            for (*dstreg = 0; *dstreg < 32; (*dstreg)++)
+                if ((srcval >> *dstreg) & 1)
+                    break;
+        }
+        else {
+            u16 srcval, *dstreg;
+
+            srcval = *DECODE_RM_WORD_REGISTER(rl);
+            DECODE_PRINTF(",");
+            dstreg = DECODE_RM_WORD_REGISTER(rh);
+            TRACE_AND_STEP();
+            CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
+            for (*dstreg = 0; *dstreg < 16; (*dstreg)++)
+                if ((srcval >> *dstreg) & 1)
+                    break;
+        }
+        break;
     }
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
@@ -2341,7 +2381,8 @@ static void x86emuOp2_bsf(u8 X86EMU_UNUSED(op2))
 REMARKS:
 Handles opcode 0x0f,0xbd
 ****************************************************************************/
-static void x86emuOp2_bsr(u8 X86EMU_UNUSED(op2))
+static void
+x86emuOp2_bsr(u8 X86EMU_UNUSED(op2))
 {
     int mod, rl, rh;
     uint srcoffset;
@@ -2349,105 +2390,117 @@ static void x86emuOp2_bsr(u8 X86EMU_UNUSED(op2))
     START_OF_INSTR();
     DECODE_PRINTF("BSR\t");
     FETCH_DECODE_MODRM(mod, rh, rl);
-    switch(mod) {
+    switch (mod) {
     case 0:
-	if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-	    u32 srcval, *dstreg;
-
-	    srcoffset = decode_rm00_address(rl);
-	    DECODE_PRINTF(",");
-	    dstreg = DECODE_RM_LONG_REGISTER(rh);
-	    TRACE_AND_STEP();
-	    srcval = fetch_data_long(srcoffset);
-	    CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
-	    for(*dstreg = 31; *dstreg > 0; (*dstreg)--)
-		if ((srcval >> *dstreg) & 1) break;
-	} else {
-	    u16 srcval, *dstreg;
-
-	    srcoffset = decode_rm00_address(rl);
-	    DECODE_PRINTF(",");
-	    dstreg = DECODE_RM_WORD_REGISTER(rh);
-	    TRACE_AND_STEP();
-	    srcval = fetch_data_word(srcoffset);
-	    CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
-	    for(*dstreg = 15; *dstreg > 0; (*dstreg)--)
-		if ((srcval >> *dstreg) & 1) break;
-	}
-	break;
+        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
+            u32 srcval, *dstreg;
+
+            srcoffset = decode_rm00_address(rl);
+            DECODE_PRINTF(",");
+            dstreg = DECODE_RM_LONG_REGISTER(rh);
+            TRACE_AND_STEP();
+            srcval = fetch_data_long(srcoffset);
+            CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
+            for (*dstreg = 31; *dstreg > 0; (*dstreg)--)
+                if ((srcval >> *dstreg) & 1)
+                    break;
+        }
+        else {
+            u16 srcval, *dstreg;
+
+            srcoffset = decode_rm00_address(rl);
+            DECODE_PRINTF(",");
+            dstreg = DECODE_RM_WORD_REGISTER(rh);
+            TRACE_AND_STEP();
+            srcval = fetch_data_word(srcoffset);
+            CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
+            for (*dstreg = 15; *dstreg > 0; (*dstreg)--)
+                if ((srcval >> *dstreg) & 1)
+                    break;
+        }
+        break;
     case 1:
-	if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-	    u32 srcval, *dstreg;
-
-	    srcoffset = decode_rm01_address(rl);
-	    DECODE_PRINTF(",");
-	    dstreg = DECODE_RM_LONG_REGISTER(rh);
-	    TRACE_AND_STEP();
-	    srcval = fetch_data_long(srcoffset);
-	    CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
-	    for(*dstreg = 31; *dstreg > 0; (*dstreg)--)
-		if ((srcval >> *dstreg) & 1) break;
-	} else {
-	    u16 srcval, *dstreg;
-
-	    srcoffset = decode_rm01_address(rl);
-	    DECODE_PRINTF(",");
-	    dstreg = DECODE_RM_WORD_REGISTER(rh);
-	    TRACE_AND_STEP();
-	    srcval = fetch_data_word(srcoffset);
-	    CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
-	    for(*dstreg = 15; *dstreg > 0; (*dstreg)--)
-		if ((srcval >> *dstreg) & 1) break;
-	}
-	break;
+        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
+            u32 srcval, *dstreg;
+
+            srcoffset = decode_rm01_address(rl);
+            DECODE_PRINTF(",");
+            dstreg = DECODE_RM_LONG_REGISTER(rh);
+            TRACE_AND_STEP();
+            srcval = fetch_data_long(srcoffset);
+            CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
+            for (*dstreg = 31; *dstreg > 0; (*dstreg)--)
+                if ((srcval >> *dstreg) & 1)
+                    break;
+        }
+        else {
+            u16 srcval, *dstreg;
+
+            srcoffset = decode_rm01_address(rl);
+            DECODE_PRINTF(",");
+            dstreg = DECODE_RM_WORD_REGISTER(rh);
+            TRACE_AND_STEP();
+            srcval = fetch_data_word(srcoffset);
+            CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
+            for (*dstreg = 15; *dstreg > 0; (*dstreg)--)
+                if ((srcval >> *dstreg) & 1)
+                    break;
+        }
+        break;
     case 2:
-	if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-	    u32 srcval, *dstreg;
-
-	    srcoffset = decode_rm10_address(rl);
-	    DECODE_PRINTF(",");
-	    dstreg = DECODE_RM_LONG_REGISTER(rh);
-	    TRACE_AND_STEP();
-	    srcval = fetch_data_long(srcoffset);
-	    CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
-	    for(*dstreg = 31; *dstreg > 0; (*dstreg)--)
-		if ((srcval >> *dstreg) & 1) break;
-	} else {
-	    u16 srcval, *dstreg;
-
-	    srcoffset = decode_rm10_address(rl);
-	    DECODE_PRINTF(",");
-	    dstreg = DECODE_RM_WORD_REGISTER(rh);
-	    TRACE_AND_STEP();
-	    srcval = fetch_data_word(srcoffset);
-	    CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
-	    for(*dstreg = 15; *dstreg > 0; (*dstreg)--)
-		if ((srcval >> *dstreg) & 1) break;
-	}
-	break;
-    case 3:				/* register to register */
-	if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-	    u32 srcval, *dstreg;
-
-	    srcval = *DECODE_RM_LONG_REGISTER(rl);
-	    DECODE_PRINTF(",");
-	    dstreg = DECODE_RM_LONG_REGISTER(rh);
-	    TRACE_AND_STEP();
-	    CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
-	    for(*dstreg = 31; *dstreg > 0; (*dstreg)--)
-		if ((srcval >> *dstreg) & 1) break;
-	} else {
-	    u16 srcval, *dstreg;
-
-	    srcval = *DECODE_RM_WORD_REGISTER(rl);
-	    DECODE_PRINTF(",");
-	    dstreg = DECODE_RM_WORD_REGISTER(rh);
-	    TRACE_AND_STEP();
-	    CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
-	    for(*dstreg = 15; *dstreg > 0; (*dstreg)--)
-		if ((srcval >> *dstreg) & 1) break;
-	}
-	break;
+        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
+            u32 srcval, *dstreg;
+
+            srcoffset = decode_rm10_address(rl);
+            DECODE_PRINTF(",");
+            dstreg = DECODE_RM_LONG_REGISTER(rh);
+            TRACE_AND_STEP();
+            srcval = fetch_data_long(srcoffset);
+            CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
+            for (*dstreg = 31; *dstreg > 0; (*dstreg)--)
+                if ((srcval >> *dstreg) & 1)
+                    break;
+        }
+        else {
+            u16 srcval, *dstreg;
+
+            srcoffset = decode_rm10_address(rl);
+            DECODE_PRINTF(",");
+            dstreg = DECODE_RM_WORD_REGISTER(rh);
+            TRACE_AND_STEP();
+            srcval = fetch_data_word(srcoffset);
+            CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
+            for (*dstreg = 15; *dstreg > 0; (*dstreg)--)
+                if ((srcval >> *dstreg) & 1)
+                    break;
+        }
+        break;
+    case 3:                    /* register to register */
+        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
+            u32 srcval, *dstreg;
+
+            srcval = *DECODE_RM_LONG_REGISTER(rl);
+            DECODE_PRINTF(",");
+            dstreg = DECODE_RM_LONG_REGISTER(rh);
+            TRACE_AND_STEP();
+            CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
+            for (*dstreg = 31; *dstreg > 0; (*dstreg)--)
+                if ((srcval >> *dstreg) & 1)
+                    break;
+        }
+        else {
+            u16 srcval, *dstreg;
+
+            srcval = *DECODE_RM_WORD_REGISTER(rl);
+            DECODE_PRINTF(",");
+            dstreg = DECODE_RM_WORD_REGISTER(rh);
+            TRACE_AND_STEP();
+            CONDITIONAL_SET_FLAG(srcval == 0, F_ZF);
+            for (*dstreg = 15; *dstreg > 0; (*dstreg)--)
+                if ((srcval >> *dstreg) & 1)
+                    break;
+        }
+        break;
     }
     DECODE_CLEAR_SEGOVR();
     END_OF_INSTR();
@@ -2457,7 +2510,8 @@ static void x86emuOp2_bsr(u8 X86EMU_UNUSED(op2))
 REMARKS:
 Handles opcode 0x0f,0xbe
 ****************************************************************************/
-static void x86emuOp2_movsx_byte_R_RM(u8 X86EMU_UNUSED(op2))
+static void
+x86emuOp2_movsx_byte_R_RM(u8 X86EMU_UNUSED(op2))
 {
     int mod, rl, rh;
     uint srcoffset;
@@ -2474,18 +2528,19 @@ static void x86emuOp2_movsx_byte_R_RM(u8 X86EMU_UNUSED(op2))
             destreg = DECODE_RM_LONG_REGISTER(rh);
             DECODE_PRINTF(",");
             srcoffset = decode_rm00_address(rl);
-            srcval = (s32)((s8)fetch_data_byte(srcoffset));
+            srcval = (s32) ((s8) fetch_data_byte(srcoffset));
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = srcval;
-        } else {
+        }
+        else {
             u16 *destreg;
             u16 srcval;
 
             destreg = DECODE_RM_WORD_REGISTER(rh);
             DECODE_PRINTF(",");
             srcoffset = decode_rm00_address(rl);
-            srcval = (s16)((s8)fetch_data_byte(srcoffset));
+            srcval = (s16) ((s8) fetch_data_byte(srcoffset));
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = srcval;
@@ -2499,18 +2554,19 @@ static void x86emuOp2_movsx_byte_R_RM(u8 X86EMU_UNUSED(op2))
             destreg = DECODE_RM_LONG_REGISTER(rh);
             DECODE_PRINTF(",");
             srcoffset = decode_rm01_address(rl);
-            srcval = (s32)((s8)fetch_data_byte(srcoffset));
+            srcval = (s32) ((s8) fetch_data_byte(srcoffset));
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = srcval;
-        } else {
+        }
+        else {
             u16 *destreg;
             u16 srcval;
 
             destreg = DECODE_RM_WORD_REGISTER(rh);
             DECODE_PRINTF(",");
             srcoffset = decode_rm01_address(rl);
-            srcval = (s16)((s8)fetch_data_byte(srcoffset));
+            srcval = (s16) ((s8) fetch_data_byte(srcoffset));
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = srcval;
@@ -2524,44 +2580,46 @@ static void x86emuOp2_movsx_byte_R_RM(u8 X86EMU_UNUSED(op2))
             destreg = DECODE_RM_LONG_REGISTER(rh);
             DECODE_PRINTF(",");
             srcoffset = decode_rm10_address(rl);
-            srcval = (s32)((s8)fetch_data_byte(srcoffset));
+            srcval = (s32) ((s8) fetch_data_byte(srcoffset));
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = srcval;
-        } else {
+        }
+        else {
             u16 *destreg;
             u16 srcval;
 
             destreg = DECODE_RM_WORD_REGISTER(rh);
             DECODE_PRINTF(",");
             srcoffset = decode_rm10_address(rl);
-            srcval = (s16)((s8)fetch_data_byte(srcoffset));
+            srcval = (s16) ((s8) fetch_data_byte(srcoffset));
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
             *destreg = srcval;
         }
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         if (M.x86.mode & SYSMODE_PREFIX_DATA) {
             u32 *destreg;
-            u8  *srcreg;
+            u8 *srcreg;
 
             destreg = DECODE_RM_LONG_REGISTER(rh);
             DECODE_PRINTF(",");
             srcreg = DECODE_RM_BYTE_REGISTER(rl);
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
-            *destreg = (s32)((s8)*srcreg);
-        } else {
+            *destreg = (s32) ((s8) * srcreg);
+        }
+        else {
             u16 *destreg;
-            u8  *srcreg;
+            u8 *srcreg;
 
             destreg = DECODE_RM_WORD_REGISTER(rh);
             DECODE_PRINTF(",");
             srcreg = DECODE_RM_BYTE_REGISTER(rl);
             DECODE_PRINTF("\n");
             TRACE_AND_STEP();
-            *destreg = (s16)((s8)*srcreg);
+            *destreg = (s16) ((s8) * srcreg);
         }
         break;
     }
@@ -2573,7 +2631,8 @@ static void x86emuOp2_movsx_byte_R_RM(u8 X86EMU_UNUSED(op2))
 REMARKS:
 Handles opcode 0x0f,0xbf
 ****************************************************************************/
-static void x86emuOp2_movsx_word_R_RM(u8 X86EMU_UNUSED(op2))
+static void
+x86emuOp2_movsx_word_R_RM(u8 X86EMU_UNUSED(op2))
 {
     int mod, rl, rh;
     uint srcoffset;
@@ -2589,7 +2648,7 @@ static void x86emuOp2_movsx_word_R_RM(u8 X86EMU_UNUSED(op2))
         destreg = DECODE_RM_LONG_REGISTER(rh);
         DECODE_PRINTF(",");
         srcoffset = decode_rm00_address(rl);
-        srcval = (s32)((s16)fetch_data_word(srcoffset));
+        srcval = (s32) ((s16) fetch_data_word(srcoffset));
         DECODE_PRINTF("\n");
         TRACE_AND_STEP();
         *destreg = srcval;
@@ -2598,7 +2657,7 @@ static void x86emuOp2_movsx_word_R_RM(u8 X86EMU_UNUSED(op2))
         destreg = DECODE_RM_LONG_REGISTER(rh);
         DECODE_PRINTF(",");
         srcoffset = decode_rm01_address(rl);
-        srcval = (s32)((s16)fetch_data_word(srcoffset));
+        srcval = (s32) ((s16) fetch_data_word(srcoffset));
         DECODE_PRINTF("\n");
         TRACE_AND_STEP();
         *destreg = srcval;
@@ -2607,18 +2666,18 @@ static void x86emuOp2_movsx_word_R_RM(u8 X86EMU_UNUSED(op2))
         destreg = DECODE_RM_LONG_REGISTER(rh);
         DECODE_PRINTF(",");
         srcoffset = decode_rm10_address(rl);
-        srcval = (s32)((s16)fetch_data_word(srcoffset));
+        srcval = (s32) ((s16) fetch_data_word(srcoffset));
         DECODE_PRINTF("\n");
         TRACE_AND_STEP();
         *destreg = srcval;
         break;
-    case 3:                     /* register to register */
+    case 3:                    /* register to register */
         destreg = DECODE_RM_LONG_REGISTER(rh);
         DECODE_PRINTF(",");
         srcreg = DECODE_RM_WORD_REGISTER(rl);
         DECODE_PRINTF("\n");
         TRACE_AND_STEP();
-        *destreg = (s32)((s16)*srcreg);
+        *destreg = (s32) ((s16) * srcreg);
         break;
     }
     DECODE_CLEAR_SEGOVR();
@@ -2626,40 +2685,41 @@ static void x86emuOp2_movsx_word_R_RM(u8 X86EMU_UNUSED(op2))
 }
 
 /* Handles opcodes 0xc8-0xcf */
-static void x86emuOp2_bswap(u8 X86EMU_UNUSED(op2))
+static void
+x86emuOp2_bswap(u8 X86EMU_UNUSED(op2))
 {
     START_OF_INSTR();
     DECODE_PRINTF("BSWAP\n");
     TRACE_AND_STEP();
 
     switch (op2) {
-	case 0xc8:
-	    M.x86.R_EAX = bswap_32(M.x86.R_EAX);
-	    break;
-	case 0xc9:
-	    M.x86.R_ECX = bswap_32(M.x86.R_ECX);
-	    break;
-	case 0xca:
-	    M.x86.R_EDX = bswap_32(M.x86.R_EDX);
-	    break;
-	case 0xcb:
-	    M.x86.R_EBX = bswap_32(M.x86.R_EBX);
-	    break;
-	case 0xcc:
-	    M.x86.R_ESP = bswap_32(M.x86.R_ESP);
-	    break;
-	case 0xcd:
-	    M.x86.R_EBP = bswap_32(M.x86.R_EBP);
-	    break;
-	case 0xce:
-	    M.x86.R_ESI = bswap_32(M.x86.R_ESI);
-	    break;
-	case 0xcf:
-	    M.x86.R_EDI = bswap_32(M.x86.R_EDI);
-	    break;
-	default:
-	    /* can't happen */
-	    break;
+    case 0xc8:
+        M.x86.R_EAX = bswap_32(M.x86.R_EAX);
+        break;
+    case 0xc9:
+        M.x86.R_ECX = bswap_32(M.x86.R_ECX);
+        break;
+    case 0xca:
+        M.x86.R_EDX = bswap_32(M.x86.R_EDX);
+        break;
+    case 0xcb:
+        M.x86.R_EBX = bswap_32(M.x86.R_EBX);
+        break;
+    case 0xcc:
+        M.x86.R_ESP = bswap_32(M.x86.R_ESP);
+        break;
+    case 0xcd:
+        M.x86.R_EBP = bswap_32(M.x86.R_EBP);
+        break;
+    case 0xce:
+        M.x86.R_ESI = bswap_32(M.x86.R_ESI);
+        break;
+    case 0xcf:
+        M.x86.R_EDI = bswap_32(M.x86.R_EDI);
+        break;
+    default:
+        /* can't happen */
+        break;
     }
 
     DECODE_CLEAR_SEGOVR();
@@ -2669,25 +2729,32 @@ static void x86emuOp2_bswap(u8 X86EMU_UNUSED(op2))
 /***************************************************************************
  * Double byte operation code table:
  **************************************************************************/
-void (*x86emu_optab2[256])(u8) =
-{
-/*  0x00 */ x86emuOp2_illegal_op,  /* Group F (ring 0 PM)      */
-/*  0x01 */ x86emuOp2_group_g,     /* Group G (ring 0 PM)      */
-/*  0x02 */ x86emuOp2_illegal_op,  /* lar (ring 0 PM)          */
-/*  0x03 */ x86emuOp2_illegal_op,  /* lsl (ring 0 PM)          */
+void (*x86emu_optab2[256]) (u8) = {
+                                        /*  0x00 */ x86emuOp2_illegal_op,
+                                        /* Group F (ring 0 PM)      */
+                                                /*  0x01 */ x86emuOp2_illegal_op,
+                                                /* Group G (ring 0 PM)      */
+                                                /*  0x02 */ x86emuOp2_illegal_op,
+                                                /* lar (ring 0 PM)          */
+                                                /*  0x03 */ x86emuOp2_illegal_op,
+                                                /* lsl (ring 0 PM)          */
 /*  0x04 */ x86emuOp2_illegal_op,
-/*  0x05 */ x86emuOp2_illegal_op,  /* loadall (undocumented)   */
-/*  0x06 */ x86emuOp2_illegal_op,  /* clts (ring 0 PM)         */
-/*  0x07 */ x86emuOp2_illegal_op,  /* loadall (undocumented)   */
-/*  0x08 */ x86emuOp2_illegal_op,  /* invd (ring 0 PM)         */
-/*  0x09 */ x86emuOp2_illegal_op,  /* wbinvd (ring 0 PM)       */
+                                                /*  0x05 */ x86emuOp2_illegal_op,
+                                                /* loadall (undocumented)   */
+                                                /*  0x06 */ x86emuOp2_illegal_op,
+                                                /* clts (ring 0 PM)         */
+                                                /*  0x07 */ x86emuOp2_illegal_op,
+                                                /* loadall (undocumented)   */
+                                                /*  0x08 */ x86emuOp2_illegal_op,
+                                                /* invd (ring 0 PM)         */
+                                                /*  0x09 */ x86emuOp2_illegal_op,
+                                                /* wbinvd (ring 0 PM)       */
 /*  0x0a */ x86emuOp2_illegal_op,
 /*  0x0b */ x86emuOp2_illegal_op,
 /*  0x0c */ x86emuOp2_illegal_op,
 /*  0x0d */ x86emuOp2_illegal_op,
 /*  0x0e */ x86emuOp2_illegal_op,
 /*  0x0f */ x86emuOp2_illegal_op,
-
 /*  0x10 */ x86emuOp2_illegal_op,
 /*  0x11 */ x86emuOp2_illegal_op,
 /*  0x12 */ x86emuOp2_illegal_op,
@@ -2704,14 +2771,19 @@ void (*x86emu_optab2[256])(u8) =
 /*  0x1d */ x86emuOp2_illegal_op,
 /*  0x1e */ x86emuOp2_illegal_op,
 /*  0x1f */ x86emuOp2_illegal_op,
-
-/*  0x20 */ x86emuOp2_illegal_op,  /* mov reg32,creg (ring 0 PM) */
-/*  0x21 */ x86emuOp2_illegal_op,  /* mov reg32,dreg (ring 0 PM) */
-/*  0x22 */ x86emuOp2_illegal_op,  /* mov creg,reg32 (ring 0 PM) */
-/*  0x23 */ x86emuOp2_illegal_op,  /* mov dreg,reg32 (ring 0 PM) */
-/*  0x24 */ x86emuOp2_illegal_op,  /* mov reg32,treg (ring 0 PM) */
+                                                /*  0x20 */ x86emuOp2_illegal_op,
+                                                /* mov reg32,creg (ring 0 PM) */
+                                                /*  0x21 */ x86emuOp2_illegal_op,
+                                                /* mov reg32,dreg (ring 0 PM) */
+                                                /*  0x22 */ x86emuOp2_illegal_op,
+                                                /* mov creg,reg32 (ring 0 PM) */
+                                                /*  0x23 */ x86emuOp2_illegal_op,
+                                                /* mov dreg,reg32 (ring 0 PM) */
+                                                /*  0x24 */ x86emuOp2_illegal_op,
+                                                /* mov reg32,treg (ring 0 PM) */
 /*  0x25 */ x86emuOp2_illegal_op,
-/*  0x26 */ x86emuOp2_illegal_op,  /* mov treg,reg32 (ring 0 PM) */
+                                                /*  0x26 */ x86emuOp2_illegal_op,
+                                                /* mov treg,reg32 (ring 0 PM) */
 /*  0x27 */ x86emuOp2_illegal_op,
 /*  0x28 */ x86emuOp2_illegal_op,
 /*  0x29 */ x86emuOp2_illegal_op,
@@ -2721,7 +2793,6 @@ void (*x86emu_optab2[256])(u8) =
 /*  0x2d */ x86emuOp2_illegal_op,
 /*  0x2e */ x86emuOp2_illegal_op,
 /*  0x2f */ x86emuOp2_illegal_op,
-
 /*  0x30 */ x86emuOp2_illegal_op,
 /*  0x31 */ x86emuOp2_rdtsc,
 /*  0x32 */ x86emuOp2_illegal_op,
@@ -2738,7 +2809,6 @@ void (*x86emu_optab2[256])(u8) =
 /*  0x3d */ x86emuOp2_illegal_op,
 /*  0x3e */ x86emuOp2_illegal_op,
 /*  0x3f */ x86emuOp2_illegal_op,
-
 /*  0x40 */ x86emuOp2_illegal_op,
 /*  0x41 */ x86emuOp2_illegal_op,
 /*  0x42 */ x86emuOp2_illegal_op,
@@ -2755,7 +2825,6 @@ void (*x86emu_optab2[256])(u8) =
 /*  0x4d */ x86emuOp2_illegal_op,
 /*  0x4e */ x86emuOp2_illegal_op,
 /*  0x4f */ x86emuOp2_illegal_op,
-
 /*  0x50 */ x86emuOp2_illegal_op,
 /*  0x51 */ x86emuOp2_illegal_op,
 /*  0x52 */ x86emuOp2_illegal_op,
@@ -2772,7 +2841,6 @@ void (*x86emu_optab2[256])(u8) =
 /*  0x5d */ x86emuOp2_illegal_op,
 /*  0x5e */ x86emuOp2_illegal_op,
 /*  0x5f */ x86emuOp2_illegal_op,
-
 /*  0x60 */ x86emuOp2_illegal_op,
 /*  0x61 */ x86emuOp2_illegal_op,
 /*  0x62 */ x86emuOp2_illegal_op,
@@ -2789,7 +2857,6 @@ void (*x86emu_optab2[256])(u8) =
 /*  0x6d */ x86emuOp2_illegal_op,
 /*  0x6e */ x86emuOp2_illegal_op,
 /*  0x6f */ x86emuOp2_illegal_op,
-
 /*  0x70 */ x86emuOp2_illegal_op,
 /*  0x71 */ x86emuOp2_illegal_op,
 /*  0x72 */ x86emuOp2_illegal_op,
@@ -2806,7 +2873,6 @@ void (*x86emu_optab2[256])(u8) =
 /*  0x7d */ x86emuOp2_illegal_op,
 /*  0x7e */ x86emuOp2_illegal_op,
 /*  0x7f */ x86emuOp2_illegal_op,
-
 /*  0x80 */ x86emuOp2_long_jump,
 /*  0x81 */ x86emuOp2_long_jump,
 /*  0x82 */ x86emuOp2_long_jump,
@@ -2823,7 +2889,6 @@ void (*x86emu_optab2[256])(u8) =
 /*  0x8d */ x86emuOp2_long_jump,
 /*  0x8e */ x86emuOp2_long_jump,
 /*  0x8f */ x86emuOp2_long_jump,
-
 /*  0x90 */ x86emuOp2_set_byte,
 /*  0x91 */ x86emuOp2_set_byte,
 /*  0x92 */ x86emuOp2_set_byte,
@@ -2840,7 +2905,6 @@ void (*x86emu_optab2[256])(u8) =
 /*  0x9d */ x86emuOp2_set_byte,
 /*  0x9e */ x86emuOp2_set_byte,
 /*  0x9f */ x86emuOp2_set_byte,
-
 /*  0xa0 */ x86emuOp2_push_FS,
 /*  0xa1 */ x86emuOp2_pop_FS,
 /*  0xa2 */ x86emuOp2_cpuid,
@@ -2857,9 +2921,10 @@ void (*x86emu_optab2[256])(u8) =
 /*  0xad */ x86emuOp2_shrd_CL,
 /*  0xae */ x86emuOp2_illegal_op,
 /*  0xaf */ x86emuOp2_imul_R_RM,
-
-/*  0xb0 */ x86emuOp2_illegal_op,  /* TODO: cmpxchg */
-/*  0xb1 */ x86emuOp2_illegal_op,  /* TODO: cmpxchg */
+                                                /*  0xb0 */ x86emuOp2_illegal_op,
+                                                /* TODO: cmpxchg */
+                                                /*  0xb1 */ x86emuOp2_illegal_op,
+                                                /* TODO: cmpxchg */
 /*  0xb2 */ x86emuOp2_lss_R_IMM,
 /*  0xb3 */ x86emuOp2_btr_R,
 /*  0xb4 */ x86emuOp2_lfs_R_IMM,
@@ -2874,9 +2939,10 @@ void (*x86emu_optab2[256])(u8) =
 /*  0xbd */ x86emuOp2_bsr,
 /*  0xbe */ x86emuOp2_movsx_byte_R_RM,
 /*  0xbf */ x86emuOp2_movsx_word_R_RM,
-
-/*  0xc0 */ x86emuOp2_illegal_op,  /* TODO: xadd */
-/*  0xc1 */ x86emuOp2_illegal_op,  /* TODO: xadd */
+                                                /*  0xc0 */ x86emuOp2_illegal_op,
+                                                /* TODO: xadd */
+                                                /*  0xc1 */ x86emuOp2_illegal_op,
+                                                /* TODO: xadd */
 /*  0xc2 */ x86emuOp2_illegal_op,
 /*  0xc3 */ x86emuOp2_illegal_op,
 /*  0xc4 */ x86emuOp2_illegal_op,
@@ -2891,7 +2957,6 @@ void (*x86emu_optab2[256])(u8) =
 /*  0xcd */ x86emuOp2_bswap,
 /*  0xce */ x86emuOp2_bswap,
 /*  0xcf */ x86emuOp2_bswap,
-
 /*  0xd0 */ x86emuOp2_illegal_op,
 /*  0xd1 */ x86emuOp2_illegal_op,
 /*  0xd2 */ x86emuOp2_illegal_op,
@@ -2908,7 +2973,6 @@ void (*x86emu_optab2[256])(u8) =
 /*  0xdd */ x86emuOp2_illegal_op,
 /*  0xde */ x86emuOp2_illegal_op,
 /*  0xdf */ x86emuOp2_illegal_op,
-
 /*  0xe0 */ x86emuOp2_illegal_op,
 /*  0xe1 */ x86emuOp2_illegal_op,
 /*  0xe2 */ x86emuOp2_illegal_op,
@@ -2925,7 +2989,6 @@ void (*x86emu_optab2[256])(u8) =
 /*  0xed */ x86emuOp2_illegal_op,
 /*  0xee */ x86emuOp2_illegal_op,
 /*  0xef */ x86emuOp2_illegal_op,
-
 /*  0xf0 */ x86emuOp2_illegal_op,
 /*  0xf1 */ x86emuOp2_illegal_op,
 /*  0xf2 */ x86emuOp2_illegal_op,
diff --git a/libs/x86emu/prim_ops.c b/libs/x86emu/prim_ops.c
index ff17c3f..24f76b4 100644
--- a/libs/x86emu/prim_ops.c
+++ b/libs/x86emu/prim_ops.c
@@ -102,18 +102,23 @@
 #define	PRIM_OPS_NO_REDEFINE_ASM
 #include "x86emu/x86emui.h"
 
+#if defined(__GNUC__)
+#if defined (__i386__) || defined(__i386) || defined(__AMD64__) || defined(__amd64__)
+#include "x86emu/prim_x86_gcc.h"
+#endif
+#endif
+
 /*------------------------- Global Variables ------------------------------*/
 
-static u32 x86emu_parity_tab[8] =
-{
-	0x96696996,
-	0x69969669,
-	0x69969669,
-	0x96696996,
-	0x69969669,
-	0x96696996,
-	0x96696996,
-	0x69969669,
+static u32 x86emu_parity_tab[8] = {
+    0x96696996,
+    0x69969669,
+    0x69969669,
+    0x96696996,
+    0x69969669,
+    0x96696996,
+    0x96696996,
+    0x69969669,
 };
 
 #define PARITY(x)   (((x86emu_parity_tab[(x) / 32] >> ((x) % 32)) & 1) == 0)
@@ -125,88 +130,96 @@ static u32 x86emu_parity_tab[8] =
 REMARKS:
 Implements the AAA instruction and side effects.
 ****************************************************************************/
-u16 aaa_word(u16 d)
+u16
+aaa_word(u16 d)
 {
-	u16	res;
-	if ((d & 0xf) > 0x9 || ACCESS_FLAG(F_AF)) {
-		d += 0x6;
-		d += 0x100;
-		SET_FLAG(F_AF);
-		SET_FLAG(F_CF);
-	} else {
-		CLEAR_FLAG(F_CF);
-		CLEAR_FLAG(F_AF);
-	}
-	res = (u16)(d & 0xFF0F);
-	CLEAR_FLAG(F_SF);
-	CONDITIONAL_SET_FLAG(res == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
-	return res;
+    u16 res;
+
+    if ((d & 0xf) > 0x9 || ACCESS_FLAG(F_AF)) {
+        d += 0x6;
+        d += 0x100;
+        SET_FLAG(F_AF);
+        SET_FLAG(F_CF);
+    }
+    else {
+        CLEAR_FLAG(F_CF);
+        CLEAR_FLAG(F_AF);
+    }
+    res = (u16) (d & 0xFF0F);
+    CLEAR_FLAG(F_SF);
+    CONDITIONAL_SET_FLAG(res == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+    return res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the AAA instruction and side effects.
 ****************************************************************************/
-u16 aas_word(u16 d)
+u16
+aas_word(u16 d)
 {
-	u16	res;
-	if ((d & 0xf) > 0x9 || ACCESS_FLAG(F_AF)) {
-		d -= 0x6;
-		d -= 0x100;
-		SET_FLAG(F_AF);
-		SET_FLAG(F_CF);
-	} else {
-		CLEAR_FLAG(F_CF);
-		CLEAR_FLAG(F_AF);
-	}
-	res = (u16)(d & 0xFF0F);
-	CLEAR_FLAG(F_SF);
-	CONDITIONAL_SET_FLAG(res == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
-	return res;
+    u16 res;
+
+    if ((d & 0xf) > 0x9 || ACCESS_FLAG(F_AF)) {
+        d -= 0x6;
+        d -= 0x100;
+        SET_FLAG(F_AF);
+        SET_FLAG(F_CF);
+    }
+    else {
+        CLEAR_FLAG(F_CF);
+        CLEAR_FLAG(F_AF);
+    }
+    res = (u16) (d & 0xFF0F);
+    CLEAR_FLAG(F_SF);
+    CONDITIONAL_SET_FLAG(res == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+    return res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the AAD instruction and side effects.
 ****************************************************************************/
-u16 aad_word(u16 d)
+u16
+aad_word(u16 d)
 {
-	u16 l;
-	u8 hb, lb;
+    u16 l;
+    u8 hb, lb;
 
-	hb = (u8)((d >> 8) & 0xff);
-	lb = (u8)((d & 0xff));
-	l = (u16)((lb + 10 * hb) & 0xFF);
+    hb = (u8) ((d >> 8) & 0xff);
+    lb = (u8) ((d & 0xff));
+    l = (u16) ((lb + 10 * hb) & 0xFF);
 
-	CLEAR_FLAG(F_CF);
-	CLEAR_FLAG(F_AF);
-	CLEAR_FLAG(F_OF);
-	CONDITIONAL_SET_FLAG(l & 0x80, F_SF);
-	CONDITIONAL_SET_FLAG(l == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(PARITY(l & 0xff), F_PF);
-	return l;
+    CLEAR_FLAG(F_CF);
+    CLEAR_FLAG(F_AF);
+    CLEAR_FLAG(F_OF);
+    CONDITIONAL_SET_FLAG(l & 0x80, F_SF);
+    CONDITIONAL_SET_FLAG(l == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(PARITY(l & 0xff), F_PF);
+    return l;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the AAM instruction and side effects.
 ****************************************************************************/
-u16 aam_word(u8 d)
+u16
+aam_word(u8 d)
 {
     u16 h, l;
 
-	h = (u16)(d / 10);
-	l = (u16)(d % 10);
-	l |= (u16)(h << 8);
+    h = (u16) (d / 10);
+    l = (u16) (d % 10);
+    l |= (u16) (h << 8);
 
-	CLEAR_FLAG(F_CF);
-	CLEAR_FLAG(F_AF);
-	CLEAR_FLAG(F_OF);
-	CONDITIONAL_SET_FLAG(l & 0x80, F_SF);
-	CONDITIONAL_SET_FLAG(l == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(PARITY(l & 0xff), F_PF);
+    CLEAR_FLAG(F_CF);
+    CLEAR_FLAG(F_AF);
+    CLEAR_FLAG(F_OF);
+    CONDITIONAL_SET_FLAG(l & 0x80, F_SF);
+    CONDITIONAL_SET_FLAG(l == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(PARITY(l & 0xff), F_PF);
     return l;
 }
 
@@ -214,155 +227,161 @@ u16 aam_word(u8 d)
 REMARKS:
 Implements the ADC instruction and side effects.
 ****************************************************************************/
-u8 adc_byte(u8 d, u8 s)
+u8
+adc_byte(u8 d, u8 s)
 {
-	register u32 res;   /* all operands in native machine order */
-	register u32 cc;
+    register u32 res;           /* all operands in native machine order */
+    register u32 cc;
 
-	if (ACCESS_FLAG(F_CF))
-		res = 1 + d + s;
-	else
-		res = d + s;
+    if (ACCESS_FLAG(F_CF))
+        res = 1 + d + s;
+    else
+        res = d + s;
 
-	CONDITIONAL_SET_FLAG(res & 0x100, F_CF);
-	CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
-	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+    CONDITIONAL_SET_FLAG(res & 0x100, F_CF);
+    CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
+    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
 
-	/* calculate the carry chain  SEE NOTE AT TOP. */
-	cc = (s & d) | ((~res) & (s | d));
-	CONDITIONAL_SET_FLAG(XOR2(cc >> 6), F_OF);
-	CONDITIONAL_SET_FLAG(cc & 0x8, F_AF);
-	return (u8)res;
+    /* calculate the carry chain  SEE NOTE AT TOP. */
+    cc = (s & d) | ((~res) & (s | d));
+    CONDITIONAL_SET_FLAG(XOR2(cc >> 6), F_OF);
+    CONDITIONAL_SET_FLAG(cc & 0x8, F_AF);
+    return (u8) res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the ADC instruction and side effects.
 ****************************************************************************/
-u16 adc_word(u16 d, u16 s)
+u16
+adc_word(u16 d, u16 s)
 {
-	register u32 res;   /* all operands in native machine order */
-	register u32 cc;
+    register u32 res;           /* all operands in native machine order */
+    register u32 cc;
 
-	if (ACCESS_FLAG(F_CF))
-		res = 1 + d + s;
-	else
-		res = d + s;
+    if (ACCESS_FLAG(F_CF))
+        res = 1 + d + s;
+    else
+        res = d + s;
 
-	CONDITIONAL_SET_FLAG(res & 0x10000, F_CF);
-	CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
-	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+    CONDITIONAL_SET_FLAG(res & 0x10000, F_CF);
+    CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
+    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
 
-	/* calculate the carry chain  SEE NOTE AT TOP. */
-	cc = (s & d) | ((~res) & (s | d));
-	CONDITIONAL_SET_FLAG(XOR2(cc >> 14), F_OF);
-	CONDITIONAL_SET_FLAG(cc & 0x8, F_AF);
-	return (u16)res;
+    /* calculate the carry chain  SEE NOTE AT TOP. */
+    cc = (s & d) | ((~res) & (s | d));
+    CONDITIONAL_SET_FLAG(XOR2(cc >> 14), F_OF);
+    CONDITIONAL_SET_FLAG(cc & 0x8, F_AF);
+    return (u16) res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the ADC instruction and side effects.
 ****************************************************************************/
-u32 adc_long(u32 d, u32 s)
+u32
+adc_long(u32 d, u32 s)
 {
-	register u32 lo;	/* all operands in native machine order */
-	register u32 hi;
-	register u32 res;
-	register u32 cc;
+    register u32 lo;            /* all operands in native machine order */
+    register u32 hi;
+    register u32 res;
+    register u32 cc;
 
-	if (ACCESS_FLAG(F_CF)) {
-		lo = 1 + (d & 0xFFFF) + (s & 0xFFFF);
-		res = 1 + d + s;
-		}
-	else {
-		lo = (d & 0xFFFF) + (s & 0xFFFF);
-		res = d + s;
-		}
-	hi = (lo >> 16) + (d >> 16) + (s >> 16);
+    if (ACCESS_FLAG(F_CF)) {
+        lo = 1 + (d & 0xFFFF) + (s & 0xFFFF);
+        res = 1 + d + s;
+    }
+    else {
+        lo = (d & 0xFFFF) + (s & 0xFFFF);
+        res = d + s;
+    }
+    hi = (lo >> 16) + (d >> 16) + (s >> 16);
 
-	CONDITIONAL_SET_FLAG(hi & 0x10000, F_CF);
-	CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
-	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+    CONDITIONAL_SET_FLAG(hi & 0x10000, F_CF);
+    CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
+    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
 
-	/* calculate the carry chain  SEE NOTE AT TOP. */
-	cc = (s & d) | ((~res) & (s | d));
-	CONDITIONAL_SET_FLAG(XOR2(cc >> 30), F_OF);
-	CONDITIONAL_SET_FLAG(cc & 0x8, F_AF);
-	return res;
+    /* calculate the carry chain  SEE NOTE AT TOP. */
+    cc = (s & d) | ((~res) & (s | d));
+    CONDITIONAL_SET_FLAG(XOR2(cc >> 30), F_OF);
+    CONDITIONAL_SET_FLAG(cc & 0x8, F_AF);
+    return res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the ADD instruction and side effects.
 ****************************************************************************/
-u8 add_byte(u8 d, u8 s)
+u8
+add_byte(u8 d, u8 s)
 {
-	register u32 res;   /* all operands in native machine order */
-	register u32 cc;
+    register u32 res;           /* all operands in native machine order */
+    register u32 cc;
 
-	res = d + s;
-	CONDITIONAL_SET_FLAG(res & 0x100, F_CF);
-	CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
-	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+    res = d + s;
+    CONDITIONAL_SET_FLAG(res & 0x100, F_CF);
+    CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
+    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
 
-	/* calculate the carry chain  SEE NOTE AT TOP. */
-	cc = (s & d) | ((~res) & (s | d));
-	CONDITIONAL_SET_FLAG(XOR2(cc >> 6), F_OF);
-	CONDITIONAL_SET_FLAG(cc & 0x8, F_AF);
-	return (u8)res;
+    /* calculate the carry chain  SEE NOTE AT TOP. */
+    cc = (s & d) | ((~res) & (s | d));
+    CONDITIONAL_SET_FLAG(XOR2(cc >> 6), F_OF);
+    CONDITIONAL_SET_FLAG(cc & 0x8, F_AF);
+    return (u8) res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the ADD instruction and side effects.
 ****************************************************************************/
-u16 add_word(u16 d, u16 s)
+u16
+add_word(u16 d, u16 s)
 {
-	register u32 res;   /* all operands in native machine order */
-	register u32 cc;
+    register u32 res;           /* all operands in native machine order */
+    register u32 cc;
 
-	res = d + s;
-	CONDITIONAL_SET_FLAG(res & 0x10000, F_CF);
-	CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
-	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+    res = d + s;
+    CONDITIONAL_SET_FLAG(res & 0x10000, F_CF);
+    CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
+    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
 
-	/* calculate the carry chain  SEE NOTE AT TOP. */
-	cc = (s & d) | ((~res) & (s | d));
-	CONDITIONAL_SET_FLAG(XOR2(cc >> 14), F_OF);
-	CONDITIONAL_SET_FLAG(cc & 0x8, F_AF);
-	return (u16)res;
+    /* calculate the carry chain  SEE NOTE AT TOP. */
+    cc = (s & d) | ((~res) & (s | d));
+    CONDITIONAL_SET_FLAG(XOR2(cc >> 14), F_OF);
+    CONDITIONAL_SET_FLAG(cc & 0x8, F_AF);
+    return (u16) res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the ADD instruction and side effects.
 ****************************************************************************/
-u32 add_long(u32 d, u32 s)
+u32
+add_long(u32 d, u32 s)
 {
-	register u32 lo;	/* all operands in native machine order */
-	register u32 hi;
-	register u32 res;
-	register u32 cc;
+    register u32 lo;            /* all operands in native machine order */
+    register u32 hi;
+    register u32 res;
+    register u32 cc;
 
-	lo = (d & 0xFFFF) + (s & 0xFFFF);
-	res = d + s;
-	hi = (lo >> 16) + (d >> 16) + (s >> 16);
+    lo = (d & 0xFFFF) + (s & 0xFFFF);
+    res = d + s;
+    hi = (lo >> 16) + (d >> 16) + (s >> 16);
 
-	CONDITIONAL_SET_FLAG(hi & 0x10000, F_CF);
-	CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
-	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+    CONDITIONAL_SET_FLAG(hi & 0x10000, F_CF);
+    CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
+    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
 
     /* calculate the carry chain  SEE NOTE AT TOP. */
     cc = (s & d) | ((~res) & (s | d));
-	CONDITIONAL_SET_FLAG(XOR2(cc >> 30), F_OF);
-	CONDITIONAL_SET_FLAG(cc & 0x8, F_AF);
+    CONDITIONAL_SET_FLAG(XOR2(cc >> 30), F_OF);
+    CONDITIONAL_SET_FLAG(cc & 0x8, F_AF);
 
     return res;
 }
@@ -371,39 +390,41 @@ u32 add_long(u32 d, u32 s)
 REMARKS:
 Implements the AND instruction and side effects.
 ****************************************************************************/
-u8 and_byte(u8 d, u8 s)
+u8
+and_byte(u8 d, u8 s)
 {
-	register u8 res;    /* all operands in native machine order */
+    register u8 res;            /* all operands in native machine order */
 
-	res = d & s;
+    res = d & s;
 
-	/* set the flags  */
-	CLEAR_FLAG(F_OF);
-	CLEAR_FLAG(F_CF);
-	CLEAR_FLAG(F_AF);
-	CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
-	CONDITIONAL_SET_FLAG(res == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(PARITY(res), F_PF);
-	return res;
+    /* set the flags  */
+    CLEAR_FLAG(F_OF);
+    CLEAR_FLAG(F_CF);
+    CLEAR_FLAG(F_AF);
+    CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
+    CONDITIONAL_SET_FLAG(res == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(PARITY(res), F_PF);
+    return res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the AND instruction and side effects.
 ****************************************************************************/
-u16 and_word(u16 d, u16 s)
+u16
+and_word(u16 d, u16 s)
 {
-    register u16 res;   /* all operands in native machine order */
+    register u16 res;           /* all operands in native machine order */
 
     res = d & s;
 
     /* set the flags  */
-	CLEAR_FLAG(F_OF);
-	CLEAR_FLAG(F_CF);
-	CLEAR_FLAG(F_AF);
-	CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
-	CONDITIONAL_SET_FLAG(res == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+    CLEAR_FLAG(F_OF);
+    CLEAR_FLAG(F_CF);
+    CLEAR_FLAG(F_AF);
+    CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
+    CONDITIONAL_SET_FLAG(res == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
     return res;
 }
 
@@ -411,433 +432,456 @@ u16 and_word(u16 d, u16 s)
 REMARKS:
 Implements the AND instruction and side effects.
 ****************************************************************************/
-u32 and_long(u32 d, u32 s)
+u32
+and_long(u32 d, u32 s)
 {
-	register u32 res;   /* all operands in native machine order */
+    register u32 res;           /* all operands in native machine order */
 
-	res = d & s;
+    res = d & s;
 
-	/* set the flags  */
-	CLEAR_FLAG(F_OF);
-	CLEAR_FLAG(F_CF);
-	CLEAR_FLAG(F_AF);
-	CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
-	CONDITIONAL_SET_FLAG(res == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
-	return res;
+    /* set the flags  */
+    CLEAR_FLAG(F_OF);
+    CLEAR_FLAG(F_CF);
+    CLEAR_FLAG(F_AF);
+    CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
+    CONDITIONAL_SET_FLAG(res == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+    return res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the CMP instruction and side effects.
 ****************************************************************************/
-u8 cmp_byte(u8 d, u8 s)
+u8
+cmp_byte(u8 d, u8 s)
 {
-	register u32 res;   /* all operands in native machine order */
-	register u32 bc;
+    register u32 res;           /* all operands in native machine order */
+    register u32 bc;
 
-	res = d - s;
-	CLEAR_FLAG(F_CF);
-	CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
-	CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+    res = d - s;
+    CLEAR_FLAG(F_CF);
+    CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
+    CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
 
-	/* calculate the borrow chain.  See note at top */
-	bc = (res & (~d | s)) | (~d & s);
-	CONDITIONAL_SET_FLAG(bc & 0x80, F_CF);
-	CONDITIONAL_SET_FLAG(XOR2(bc >> 6), F_OF);
-	CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
-	return d;
+    /* calculate the borrow chain.  See note at top */
+    bc = (res & (~d | s)) | (~d & s);
+    CONDITIONAL_SET_FLAG(bc & 0x80, F_CF);
+    CONDITIONAL_SET_FLAG(XOR2(bc >> 6), F_OF);
+    CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
+    return d;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the CMP instruction and side effects.
 ****************************************************************************/
-u16 cmp_word(u16 d, u16 s)
+u16
+cmp_word(u16 d, u16 s)
 {
-	register u32 res;   /* all operands in native machine order */
-	register u32 bc;
+    register u32 res;           /* all operands in native machine order */
+    register u32 bc;
 
-	res = d - s;
-	CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
-	CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+    res = d - s;
+    CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
+    CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
 
-	/* calculate the borrow chain.  See note at top */
+    /* calculate the borrow chain.  See note at top */
     bc = (res & (~d | s)) | (~d & s);
-	CONDITIONAL_SET_FLAG(bc & 0x8000, F_CF);
-	CONDITIONAL_SET_FLAG(XOR2(bc >> 14), F_OF);
-	CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
-	return d;
+    CONDITIONAL_SET_FLAG(bc & 0x8000, F_CF);
+    CONDITIONAL_SET_FLAG(XOR2(bc >> 14), F_OF);
+    CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
+    return d;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the CMP instruction and side effects.
 ****************************************************************************/
-u32 cmp_long(u32 d, u32 s)
+u32
+cmp_long(u32 d, u32 s)
 {
-	register u32 res;   /* all operands in native machine order */
-	register u32 bc;
+    register u32 res;           /* all operands in native machine order */
+    register u32 bc;
 
-	res = d - s;
-	CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
-	CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+    res = d - s;
+    CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
+    CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
 
-	/* calculate the borrow chain.  See note at top */
-	bc = (res & (~d | s)) | (~d & s);
-	CONDITIONAL_SET_FLAG(bc & 0x80000000, F_CF);
-	CONDITIONAL_SET_FLAG(XOR2(bc >> 30), F_OF);
-	CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
-	return d;
+    /* calculate the borrow chain.  See note at top */
+    bc = (res & (~d | s)) | (~d & s);
+    CONDITIONAL_SET_FLAG(bc & 0x80000000, F_CF);
+    CONDITIONAL_SET_FLAG(XOR2(bc >> 30), F_OF);
+    CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
+    return d;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the DAA instruction and side effects.
 ****************************************************************************/
-u8 daa_byte(u8 d)
+u8
+daa_byte(u8 d)
 {
-	u32 res = d;
-	if ((d & 0xf) > 9 || ACCESS_FLAG(F_AF)) {
-		res += 6;
-		SET_FLAG(F_AF);
-	}
-	if (res > 0x9F || ACCESS_FLAG(F_CF)) {
-		res += 0x60;
-		SET_FLAG(F_CF);
-	}
-	CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
-	CONDITIONAL_SET_FLAG((res & 0xFF) == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
-	return (u8)res;
+    u32 res = d;
+
+    if ((d & 0xf) > 9 || ACCESS_FLAG(F_AF)) {
+        res += 6;
+        SET_FLAG(F_AF);
+    }
+    if (res > 0x9F || ACCESS_FLAG(F_CF)) {
+        res += 0x60;
+        SET_FLAG(F_CF);
+    }
+    CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
+    CONDITIONAL_SET_FLAG((res & 0xFF) == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+    return (u8) res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the DAS instruction and side effects.
 ****************************************************************************/
-u8 das_byte(u8 d)
+u8
+das_byte(u8 d)
 {
-	if ((d & 0xf) > 9 || ACCESS_FLAG(F_AF)) {
-		d -= 6;
-		SET_FLAG(F_AF);
-	}
-	if (d > 0x9F || ACCESS_FLAG(F_CF)) {
-		d -= 0x60;
-		SET_FLAG(F_CF);
-	}
-	CONDITIONAL_SET_FLAG(d & 0x80, F_SF);
-	CONDITIONAL_SET_FLAG(d == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(PARITY(d & 0xff), F_PF);
-	return d;
+    if ((d & 0xf) > 9 || ACCESS_FLAG(F_AF)) {
+        d -= 6;
+        SET_FLAG(F_AF);
+    }
+    if (d > 0x9F || ACCESS_FLAG(F_CF)) {
+        d -= 0x60;
+        SET_FLAG(F_CF);
+    }
+    CONDITIONAL_SET_FLAG(d & 0x80, F_SF);
+    CONDITIONAL_SET_FLAG(d == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(PARITY(d & 0xff), F_PF);
+    return d;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the DEC instruction and side effects.
 ****************************************************************************/
-u8 dec_byte(u8 d)
+u8
+dec_byte(u8 d)
 {
-    register u32 res;   /* all operands in native machine order */
+    register u32 res;           /* all operands in native machine order */
     register u32 bc;
 
     res = d - 1;
-	CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
-	CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+    CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
+    CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
 
-	/* calculate the borrow chain.  See note at top */
-	/* based on sub_byte, uses s==1.  */
-	bc = (res & (~d | 1)) | (~d & 1);
-	/* carry flag unchanged */
-	CONDITIONAL_SET_FLAG(XOR2(bc >> 6), F_OF);
-	CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
-	return (u8)res;
+    /* calculate the borrow chain.  See note at top */
+    /* based on sub_byte, uses s==1.  */
+    bc = (res & (~d | 1)) | (~d & 1);
+    /* carry flag unchanged */
+    CONDITIONAL_SET_FLAG(XOR2(bc >> 6), F_OF);
+    CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
+    return (u8) res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the DEC instruction and side effects.
 ****************************************************************************/
-u16 dec_word(u16 d)
+u16
+dec_word(u16 d)
 {
-    register u32 res;   /* all operands in native machine order */
+    register u32 res;           /* all operands in native machine order */
     register u32 bc;
 
     res = d - 1;
-	CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
-	CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+    CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
+    CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
 
     /* calculate the borrow chain.  See note at top */
     /* based on the sub_byte routine, with s==1 */
     bc = (res & (~d | 1)) | (~d & 1);
     /* carry flag unchanged */
-	CONDITIONAL_SET_FLAG(XOR2(bc >> 14), F_OF);
-	CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
-	return (u16)res;
+    CONDITIONAL_SET_FLAG(XOR2(bc >> 14), F_OF);
+    CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
+    return (u16) res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the DEC instruction and side effects.
 ****************************************************************************/
-u32 dec_long(u32 d)
+u32
+dec_long(u32 d)
 {
-    register u32 res;   /* all operands in native machine order */
+    register u32 res;           /* all operands in native machine order */
     register u32 bc;
 
     res = d - 1;
 
-	CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
-	CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+    CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
+    CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
 
     /* calculate the borrow chain.  See note at top */
-	bc = (res & (~d | 1)) | (~d & 1);
-	/* carry flag unchanged */
-	CONDITIONAL_SET_FLAG(XOR2(bc >> 30), F_OF);
-	CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
-	return res;
+    bc = (res & (~d | 1)) | (~d & 1);
+    /* carry flag unchanged */
+    CONDITIONAL_SET_FLAG(XOR2(bc >> 30), F_OF);
+    CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
+    return res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the INC instruction and side effects.
 ****************************************************************************/
-u8 inc_byte(u8 d)
+u8
+inc_byte(u8 d)
 {
-	register u32 res;   /* all operands in native machine order */
-	register u32 cc;
+    register u32 res;           /* all operands in native machine order */
+    register u32 cc;
 
-	res = d + 1;
-	CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
-	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+    res = d + 1;
+    CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
+    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
 
-	/* calculate the carry chain  SEE NOTE AT TOP. */
-	cc = ((1 & d) | (~res)) & (1 | d);
-	CONDITIONAL_SET_FLAG(XOR2(cc >> 6), F_OF);
-	CONDITIONAL_SET_FLAG(cc & 0x8, F_AF);
-	return (u8)res;
+    /* calculate the carry chain  SEE NOTE AT TOP. */
+    cc = ((1 & d) | (~res)) & (1 | d);
+    CONDITIONAL_SET_FLAG(XOR2(cc >> 6), F_OF);
+    CONDITIONAL_SET_FLAG(cc & 0x8, F_AF);
+    return (u8) res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the INC instruction and side effects.
 ****************************************************************************/
-u16 inc_word(u16 d)
+u16
+inc_word(u16 d)
 {
-	register u32 res;   /* all operands in native machine order */
-	register u32 cc;
+    register u32 res;           /* all operands in native machine order */
+    register u32 cc;
 
-	res = d + 1;
-	CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
-	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+    res = d + 1;
+    CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
+    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
 
-	/* calculate the carry chain  SEE NOTE AT TOP. */
-	cc = (1 & d) | ((~res) & (1 | d));
-	CONDITIONAL_SET_FLAG(XOR2(cc >> 14), F_OF);
-	CONDITIONAL_SET_FLAG(cc & 0x8, F_AF);
-	return (u16)res;
+    /* calculate the carry chain  SEE NOTE AT TOP. */
+    cc = (1 & d) | ((~res) & (1 | d));
+    CONDITIONAL_SET_FLAG(XOR2(cc >> 14), F_OF);
+    CONDITIONAL_SET_FLAG(cc & 0x8, F_AF);
+    return (u16) res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the INC instruction and side effects.
 ****************************************************************************/
-u32 inc_long(u32 d)
+u32
+inc_long(u32 d)
 {
-	register u32 res;   /* all operands in native machine order */
-	register u32 cc;
+    register u32 res;           /* all operands in native machine order */
+    register u32 cc;
 
-	res = d + 1;
-	CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
-	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+    res = d + 1;
+    CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
+    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
 
-	/* calculate the carry chain  SEE NOTE AT TOP. */
-	cc = (1 & d) | ((~res) & (1 | d));
-	CONDITIONAL_SET_FLAG(XOR2(cc >> 30), F_OF);
-	CONDITIONAL_SET_FLAG(cc & 0x8, F_AF);
-	return res;
+    /* calculate the carry chain  SEE NOTE AT TOP. */
+    cc = (1 & d) | ((~res) & (1 | d));
+    CONDITIONAL_SET_FLAG(XOR2(cc >> 30), F_OF);
+    CONDITIONAL_SET_FLAG(cc & 0x8, F_AF);
+    return res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the OR instruction and side effects.
 ****************************************************************************/
-u8 or_byte(u8 d, u8 s)
+u8
+or_byte(u8 d, u8 s)
 {
-	register u8 res;    /* all operands in native machine order */
+    register u8 res;            /* all operands in native machine order */
 
-	res = d | s;
-	CLEAR_FLAG(F_OF);
-	CLEAR_FLAG(F_CF);
-	CLEAR_FLAG(F_AF);
-	CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
-	CONDITIONAL_SET_FLAG(res == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(PARITY(res), F_PF);
-	return res;
+    res = d | s;
+    CLEAR_FLAG(F_OF);
+    CLEAR_FLAG(F_CF);
+    CLEAR_FLAG(F_AF);
+    CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
+    CONDITIONAL_SET_FLAG(res == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(PARITY(res), F_PF);
+    return res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the OR instruction and side effects.
 ****************************************************************************/
-u16 or_word(u16 d, u16 s)
+u16
+or_word(u16 d, u16 s)
 {
-	register u16 res;   /* all operands in native machine order */
+    register u16 res;           /* all operands in native machine order */
 
-	res = d | s;
-	/* set the carry flag to be bit 8 */
-	CLEAR_FLAG(F_OF);
-	CLEAR_FLAG(F_CF);
-	CLEAR_FLAG(F_AF);
-	CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
-	CONDITIONAL_SET_FLAG(res == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
-	return res;
+    res = d | s;
+    /* set the carry flag to be bit 8 */
+    CLEAR_FLAG(F_OF);
+    CLEAR_FLAG(F_CF);
+    CLEAR_FLAG(F_AF);
+    CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
+    CONDITIONAL_SET_FLAG(res == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+    return res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the OR instruction and side effects.
 ****************************************************************************/
-u32 or_long(u32 d, u32 s)
+u32
+or_long(u32 d, u32 s)
 {
-	register u32 res;   /* all operands in native machine order */
+    register u32 res;           /* all operands in native machine order */
 
-	res = d | s;
+    res = d | s;
 
-	/* set the carry flag to be bit 8 */
-	CLEAR_FLAG(F_OF);
-	CLEAR_FLAG(F_CF);
-	CLEAR_FLAG(F_AF);
-	CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
-	CONDITIONAL_SET_FLAG(res == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
-	return res;
+    /* set the carry flag to be bit 8 */
+    CLEAR_FLAG(F_OF);
+    CLEAR_FLAG(F_CF);
+    CLEAR_FLAG(F_AF);
+    CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
+    CONDITIONAL_SET_FLAG(res == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+    return res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the OR instruction and side effects.
 ****************************************************************************/
-u8 neg_byte(u8 s)
+u8
+neg_byte(u8 s)
 {
     register u8 res;
     register u8 bc;
 
-	CONDITIONAL_SET_FLAG(s != 0, F_CF);
-	res = (u8)-s;
-	CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
-	CONDITIONAL_SET_FLAG(PARITY(res), F_PF);
-	/* calculate the borrow chain --- modified such that d=0.
-	   substitutiing d=0 into     bc= res&(~d|s)|(~d&s);
-	   (the one used for sub) and simplifying, since ~d=0xff...,
-	   ~d|s == 0xffff..., and res&0xfff... == res.  Similarly
-	   ~d&s == s.  So the simplified result is: */
-	bc = res | s;
-	CONDITIONAL_SET_FLAG(XOR2(bc >> 6), F_OF);
-	CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
-	return res;
+    CONDITIONAL_SET_FLAG(s != 0, F_CF);
+    res = (u8) - s;
+    CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
+    CONDITIONAL_SET_FLAG(PARITY(res), F_PF);
+    /* calculate the borrow chain --- modified such that d=0.
+       substitutiing d=0 into     bc= res&(~d|s)|(~d&s);
+       (the one used for sub) and simplifying, since ~d=0xff...,
+       ~d|s == 0xffff..., and res&0xfff... == res.  Similarly
+       ~d&s == s.  So the simplified result is: */
+    bc = res | s;
+    CONDITIONAL_SET_FLAG(XOR2(bc >> 6), F_OF);
+    CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
+    return res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the OR instruction and side effects.
 ****************************************************************************/
-u16 neg_word(u16 s)
-{
-	register u16 res;
-	register u16 bc;
-
-	CONDITIONAL_SET_FLAG(s != 0, F_CF);
-	res = (u16)-s;
-	CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
-	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
-
-	/* calculate the borrow chain --- modified such that d=0.
-	   substitutiing d=0 into     bc= res&(~d|s)|(~d&s);
-	   (the one used for sub) and simplifying, since ~d=0xff...,
-	   ~d|s == 0xffff..., and res&0xfff... == res.  Similarly
-	   ~d&s == s.  So the simplified result is: */
-	bc = res | s;
-	CONDITIONAL_SET_FLAG(XOR2(bc >> 14), F_OF);
-	CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
-	return res;
+u16
+neg_word(u16 s)
+{
+    register u16 res;
+    register u16 bc;
+
+    CONDITIONAL_SET_FLAG(s != 0, F_CF);
+    res = (u16) - s;
+    CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
+    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+
+    /* calculate the borrow chain --- modified such that d=0.
+       substitutiing d=0 into     bc= res&(~d|s)|(~d&s);
+       (the one used for sub) and simplifying, since ~d=0xff...,
+       ~d|s == 0xffff..., and res&0xfff... == res.  Similarly
+       ~d&s == s.  So the simplified result is: */
+    bc = res | s;
+    CONDITIONAL_SET_FLAG(XOR2(bc >> 14), F_OF);
+    CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
+    return res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the OR instruction and side effects.
 ****************************************************************************/
-u32 neg_long(u32 s)
+u32
+neg_long(u32 s)
 {
-	register u32 res;
-	register u32 bc;
-
-	CONDITIONAL_SET_FLAG(s != 0, F_CF);
-	res = (u32)-s;
-	CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
-	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+    register u32 res;
+    register u32 bc;
 
-	/* calculate the borrow chain --- modified such that d=0.
-	   substitutiing d=0 into     bc= res&(~d|s)|(~d&s);
-	   (the one used for sub) and simplifying, since ~d=0xff...,
-	   ~d|s == 0xffff..., and res&0xfff... == res.  Similarly
-	   ~d&s == s.  So the simplified result is: */
-	bc = res | s;
-	CONDITIONAL_SET_FLAG(XOR2(bc >> 30), F_OF);
-	CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
-	return res;
+    CONDITIONAL_SET_FLAG(s != 0, F_CF);
+    res = (u32) - s;
+    CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
+    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+
+    /* calculate the borrow chain --- modified such that d=0.
+       substitutiing d=0 into     bc= res&(~d|s)|(~d&s);
+       (the one used for sub) and simplifying, since ~d=0xff...,
+       ~d|s == 0xffff..., and res&0xfff... == res.  Similarly
+       ~d&s == s.  So the simplified result is: */
+    bc = res | s;
+    CONDITIONAL_SET_FLAG(XOR2(bc >> 30), F_OF);
+    CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
+    return res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the NOT instruction and side effects.
 ****************************************************************************/
-u8 not_byte(u8 s)
+u8
+not_byte(u8 s)
 {
-	return ~s;
+    return ~s;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the NOT instruction and side effects.
 ****************************************************************************/
-u16 not_word(u16 s)
+u16
+not_word(u16 s)
 {
-	return ~s;
+    return ~s;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the NOT instruction and side effects.
 ****************************************************************************/
-u32 not_long(u32 s)
+u32
+not_long(u32 s)
 {
-	return ~s;
+    return ~s;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the RCL instruction and side effects.
 ****************************************************************************/
-u8 rcl_byte(u8 d, u8 s)
+u8
+rcl_byte(u8 d, u8 s)
 {
     register unsigned int res, cnt, mask, cf;
 
     /* s is the rotate distance.  It varies from 0 - 8. */
-	/* have
+    /* have
 
        CF  B_7 B_6 B_5 B_4 B_3 B_2 B_1 B_0 
 
@@ -861,9 +905,9 @@ u8 rcl_byte(u8 d, u8 s)
        2) B_(7) .. B_(n)  <-  b_(8-(n+1)) .. b_0
        3) B_(n-1) <- cf
        4) B_(n-2) .. B_0 <-  b_7 .. b_(8-(n-1))
-	 */
-	res = d;
-	if ((cnt = s % 9) != 0) {
+     */
+    res = d;
+    if ((cnt = s % 9) != 0) {
         /* extract the new CARRY FLAG. */
         /* CF <-  b_(8-n)             */
         cf = (d >> (8 - cnt)) & 0x1;
@@ -872,7 +916,7 @@ u8 rcl_byte(u8 d, u8 s)
            into the range B_7 .. B_cnt */
         /* B_(7) .. B_(n)  <-  b_(8-(n+1)) .. b_0  */
         /* note that the right hand side done by the mask */
-		res = (d << cnt) & 0xff;
+        res = (d << cnt) & 0xff;
 
         /* now the high stuff which rotated around 
            into the positions B_cnt-2 .. B_0 */
@@ -884,81 +928,81 @@ u8 rcl_byte(u8 d, u8 s)
         res |= (d >> (9 - cnt)) & mask;
 
         /* if the carry flag was set, or it in.  */
-		if (ACCESS_FLAG(F_CF)) {     /* carry flag is set */
+        if (ACCESS_FLAG(F_CF)) {        /* carry flag is set */
             /*  B_(n-1) <- cf */
             res |= 1 << (cnt - 1);
         }
         /* set the new carry flag, based on the variable "cf" */
-		CONDITIONAL_SET_FLAG(cf, F_CF);
+        CONDITIONAL_SET_FLAG(cf, F_CF);
         /* OVERFLOW is set *IFF* cnt==1, then it is the 
            xor of CF and the most significant bit.  Blecck. */
         /* parenthesized this expression since it appears to
            be causing OF to be misset */
-        CONDITIONAL_SET_FLAG(cnt == 1 && XOR2(cf + ((res >> 6) & 0x2)),
-							 F_OF);
+        CONDITIONAL_SET_FLAG(cnt == 1 && XOR2(cf + ((res >> 6) & 0x2)), F_OF);
 
     }
-	return (u8)res;
+    return (u8) res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the RCL instruction and side effects.
 ****************************************************************************/
-u16 rcl_word(u16 d, u8 s)
+u16
+rcl_word(u16 d, u8 s)
 {
-	register unsigned int res, cnt, mask, cf;
+    register unsigned int res, cnt, mask, cf;
 
-	res = d;
-	if ((cnt = s % 17) != 0) {
-		cf = (d >> (16 - cnt)) & 0x1;
-		res = (d << cnt) & 0xffff;
-		mask = (1 << (cnt - 1)) - 1;
-		res |= (d >> (17 - cnt)) & mask;
-		if (ACCESS_FLAG(F_CF)) {
-			res |= 1 << (cnt - 1);
-		}
-		CONDITIONAL_SET_FLAG(cf, F_CF);
-		CONDITIONAL_SET_FLAG(cnt == 1 && XOR2(cf + ((res >> 14) & 0x2)),
-							 F_OF);
-	}
-	return (u16)res;
+    res = d;
+    if ((cnt = s % 17) != 0) {
+        cf = (d >> (16 - cnt)) & 0x1;
+        res = (d << cnt) & 0xffff;
+        mask = (1 << (cnt - 1)) - 1;
+        res |= (d >> (17 - cnt)) & mask;
+        if (ACCESS_FLAG(F_CF)) {
+            res |= 1 << (cnt - 1);
+        }
+        CONDITIONAL_SET_FLAG(cf, F_CF);
+        CONDITIONAL_SET_FLAG(cnt == 1 && XOR2(cf + ((res >> 14) & 0x2)), F_OF);
+    }
+    return (u16) res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the RCL instruction and side effects.
 ****************************************************************************/
-u32 rcl_long(u32 d, u8 s)
+u32
+rcl_long(u32 d, u8 s)
 {
-	register u32 res, cnt, mask, cf;
+    register u32 res, cnt, mask, cf;
 
-	res = d;
-	if ((cnt = s % 33) != 0) {
-		cf = (d >> (32 - cnt)) & 0x1;
-		res = (d << cnt) & 0xffffffff;
-		mask = (1 << (cnt - 1)) - 1;
-		res |= (d >> (33 - cnt)) & mask;
-		if (ACCESS_FLAG(F_CF)) {     /* carry flag is set */
-			res |= 1 << (cnt - 1);
-		}
-		CONDITIONAL_SET_FLAG(cf, F_CF);
-		CONDITIONAL_SET_FLAG(cnt == 1 && XOR2(cf + ((res >> 30) & 0x2)),
-							 F_OF);
-	}
-	return res;
+    res = d;
+    if ((cnt = s % 33) != 0) {
+        cf = (d >> (32 - cnt)) & 0x1;
+        res = (d << cnt) & 0xffffffff;
+        mask = (1 << (cnt - 1)) - 1;
+        res |= (d >> (33 - cnt)) & mask;
+        if (ACCESS_FLAG(F_CF)) {        /* carry flag is set */
+            res |= 1 << (cnt - 1);
+        }
+        CONDITIONAL_SET_FLAG(cf, F_CF);
+        CONDITIONAL_SET_FLAG(cnt == 1 && XOR2(cf + ((res >> 30) & 0x2)), F_OF);
+    }
+    return res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the RCR instruction and side effects.
 ****************************************************************************/
-u8 rcr_byte(u8 d, u8 s)
+u8
+rcr_byte(u8 d, u8 s)
 {
-	u32	res, cnt;
-	u32	mask, cf, ocf = 0;
+    u32 res, cnt;
+    u32 mask, cf, ocf = 0;
 
-	/* rotate right through carry */
+    /* rotate right through carry */
     /* 
        s is the rotate distance.  It varies from 0 - 8.
        d is the byte object rotated.  
@@ -979,9 +1023,9 @@ u8 rcr_byte(u8 d, u8 s)
        2) B_(8-(n+1)) .. B_(0)  <-  b_(7) .. b_(n)
        3) B_(8-n) <- cf
        4) B_(7) .. B_(8-(n-1)) <-  b_(n-2) .. b_(0)
-	 */
-	res = d;
-	if ((cnt = s % 9) != 0) {
+     */
+    res = d;
+    if ((cnt = s % 9) != 0) {
         /* extract the new CARRY FLAG. */
         /* CF <-  b_(n-1)              */
         if (cnt == 1) {
@@ -990,11 +1034,12 @@ u8 rcr_byte(u8 d, u8 s)
                0 if flag not set
                non-zero if flag is set.
                doing access_flag(..) != 0 casts that into either 
-			   0..1 in any representation of the flags register
+               0..1 in any representation of the flags register
                (i.e. packed bit array or unpacked.)
              */
-			ocf = ACCESS_FLAG(F_CF) != 0;
-        } else
+            ocf = ACCESS_FLAG(F_CF) != 0;
+        }
+        else
             cf = (d >> (cnt - 1)) & 0x1;
 
         /* B_(8-(n+1)) .. B_(0)  <-  b_(7) .. b_n  */
@@ -1016,93 +1061,95 @@ u8 rcr_byte(u8 d, u8 s)
         res |= (d << (9 - cnt));
 
         /* if the carry flag was set, or it in.  */
-		if (ACCESS_FLAG(F_CF)) {     /* carry flag is set */
+        if (ACCESS_FLAG(F_CF)) {        /* carry flag is set */
             /*  B_(8-n) <- cf */
             res |= 1 << (8 - cnt);
         }
         /* set the new carry flag, based on the variable "cf" */
-		CONDITIONAL_SET_FLAG(cf, F_CF);
+        CONDITIONAL_SET_FLAG(cf, F_CF);
         /* OVERFLOW is set *IFF* cnt==1, then it is the 
            xor of CF and the most significant bit.  Blecck. */
         /* parenthesized... */
-		if (cnt == 1) {
-			CONDITIONAL_SET_FLAG(XOR2(ocf + ((d >> 6) & 0x2)),
-								 F_OF);
-		}
-	}
-	return (u8)res;
+        if (cnt == 1) {
+            CONDITIONAL_SET_FLAG(XOR2(ocf + ((d >> 6) & 0x2)), F_OF);
+        }
+    }
+    return (u8) res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the RCR instruction and side effects.
 ****************************************************************************/
-u16 rcr_word(u16 d, u8 s)
+u16
+rcr_word(u16 d, u8 s)
 {
-	u32 res, cnt;
-	u32	mask, cf, ocf = 0;
+    u32 res, cnt;
+    u32 mask, cf, ocf = 0;
 
-	/* rotate right through carry */
-	res = d;
-	if ((cnt = s % 17) != 0) {
-		if (cnt == 1) {
-			cf = d & 0x1;
-			ocf = ACCESS_FLAG(F_CF) != 0;
-		} else
-			cf = (d >> (cnt - 1)) & 0x1;
-		mask = (1 << (16 - cnt)) - 1;
-		res = (d >> cnt) & mask;
-		res |= (d << (17 - cnt));
-		if (ACCESS_FLAG(F_CF)) {
-			res |= 1 << (16 - cnt);
-		}
-		CONDITIONAL_SET_FLAG(cf, F_CF);
-		if (cnt == 1) {
-			CONDITIONAL_SET_FLAG(XOR2(ocf + ((d >> 14) & 0x2)),
-								 F_OF);
-		}
-	}
-	return (u16)res;
+    /* rotate right through carry */
+    res = d;
+    if ((cnt = s % 17) != 0) {
+        if (cnt == 1) {
+            cf = d & 0x1;
+            ocf = ACCESS_FLAG(F_CF) != 0;
+        }
+        else
+            cf = (d >> (cnt - 1)) & 0x1;
+        mask = (1 << (16 - cnt)) - 1;
+        res = (d >> cnt) & mask;
+        res |= (d << (17 - cnt));
+        if (ACCESS_FLAG(F_CF)) {
+            res |= 1 << (16 - cnt);
+        }
+        CONDITIONAL_SET_FLAG(cf, F_CF);
+        if (cnt == 1) {
+            CONDITIONAL_SET_FLAG(XOR2(ocf + ((d >> 14) & 0x2)), F_OF);
+        }
+    }
+    return (u16) res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the RCR instruction and side effects.
 ****************************************************************************/
-u32 rcr_long(u32 d, u8 s)
-{
-	u32 res, cnt;
-	u32 mask, cf, ocf = 0;
-
-	/* rotate right through carry */
-	res = d;
-	if ((cnt = s % 33) != 0) {
-		if (cnt == 1) {
-			cf = d & 0x1;
-			ocf = ACCESS_FLAG(F_CF) != 0;
-		} else
-			cf = (d >> (cnt - 1)) & 0x1;
-		mask = (1 << (32 - cnt)) - 1;
-		res = (d >> cnt) & mask;
-		if (cnt != 1)
-			res |= (d << (33 - cnt));
-		if (ACCESS_FLAG(F_CF)) {     /* carry flag is set */
-			res |= 1 << (32 - cnt);
-		}
-		CONDITIONAL_SET_FLAG(cf, F_CF);
-		if (cnt == 1) {
-			CONDITIONAL_SET_FLAG(XOR2(ocf + ((d >> 30) & 0x2)),
-								 F_OF);
-		}
-	}
-	return res;
+u32
+rcr_long(u32 d, u8 s)
+{
+    u32 res, cnt;
+    u32 mask, cf, ocf = 0;
+
+    /* rotate right through carry */
+    res = d;
+    if ((cnt = s % 33) != 0) {
+        if (cnt == 1) {
+            cf = d & 0x1;
+            ocf = ACCESS_FLAG(F_CF) != 0;
+        }
+        else
+            cf = (d >> (cnt - 1)) & 0x1;
+        mask = (1 << (32 - cnt)) - 1;
+        res = (d >> cnt) & mask;
+        if (cnt != 1)
+            res |= (d << (33 - cnt));
+        if (ACCESS_FLAG(F_CF)) {        /* carry flag is set */
+            res |= 1 << (32 - cnt);
+        }
+        CONDITIONAL_SET_FLAG(cf, F_CF);
+        if (cnt == 1) {
+            CONDITIONAL_SET_FLAG(XOR2(ocf + ((d >> 30) & 0x2)), F_OF);
+        }
+    }
+    return res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the ROL instruction and side effects.
 ****************************************************************************/
-u8 rol_byte(u8 d, u8 s)
+u8
+rol_byte(u8 d, u8 s)
 {
     register unsigned int res, cnt, mask;
 
@@ -1121,87 +1168,90 @@ u8 rol_byte(u8 d, u8 s)
        IF n > 0 
        1) B_(7) .. B_(n)  <-  b_(8-(n+1)) .. b_(0)
        2) B_(n-1) .. B_(0) <-  b_(7) .. b_(8-n)
-	 */
+     */
     res = d;
-	if ((cnt = s % 8) != 0) {
-		/* B_(7) .. B_(n)  <-  b_(8-(n+1)) .. b_(0) */
-		res = (d << cnt);
+    if ((cnt = s % 8) != 0) {
+        /* B_(7) .. B_(n)  <-  b_(8-(n+1)) .. b_(0) */
+        res = (d << cnt);
 
-		/* B_(n-1) .. B_(0) <-  b_(7) .. b_(8-n) */
-		mask = (1 << cnt) - 1;
-		res |= (d >> (8 - cnt)) & mask;
+        /* B_(n-1) .. B_(0) <-  b_(7) .. b_(8-n) */
+        mask = (1 << cnt) - 1;
+        res |= (d >> (8 - cnt)) & mask;
 
-		/* set the new carry flag, Note that it is the low order
-		   bit of the result!!!                               */
-		CONDITIONAL_SET_FLAG(res & 0x1, F_CF);
-		/* OVERFLOW is set *IFF* s==1, then it is the
-		   xor of CF and the most significant bit.  Blecck. */
-		CONDITIONAL_SET_FLAG(s == 1 &&
-							 XOR2((res & 0x1) + ((res >> 6) & 0x2)),
-							 F_OF);
-	} if (s != 0) {
-		/* set the new carry flag, Note that it is the low order
-		   bit of the result!!!                               */
-		CONDITIONAL_SET_FLAG(res & 0x1, F_CF);
-	}
-	return (u8)res;
+        /* set the new carry flag, Note that it is the low order
+           bit of the result!!!                               */
+        CONDITIONAL_SET_FLAG(res & 0x1, F_CF);
+        /* OVERFLOW is set *IFF* s==1, then it is the
+           xor of CF and the most significant bit.  Blecck. */
+        CONDITIONAL_SET_FLAG(s == 1 &&
+                             XOR2((res & 0x1) + ((res >> 6) & 0x2)), F_OF);
+    }
+    if (s != 0) {
+        /* set the new carry flag, Note that it is the low order
+           bit of the result!!!                               */
+        CONDITIONAL_SET_FLAG(res & 0x1, F_CF);
+    }
+    return (u8) res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the ROL instruction and side effects.
 ****************************************************************************/
-u16 rol_word(u16 d, u8 s)
+u16
+rol_word(u16 d, u8 s)
 {
     register unsigned int res, cnt, mask;
 
-	res = d;
-	if ((cnt = s % 16) != 0) {
-		res = (d << cnt);
-		mask = (1 << cnt) - 1;
-		res |= (d >> (16 - cnt)) & mask;
-		CONDITIONAL_SET_FLAG(res & 0x1, F_CF);
-		CONDITIONAL_SET_FLAG(s == 1 &&
-							 XOR2((res & 0x1) + ((res >> 14) & 0x2)),
-							 F_OF);
-	} if (s != 0) {
-		/* set the new carry flag, Note that it is the low order
-		   bit of the result!!!                               */
-		CONDITIONAL_SET_FLAG(res & 0x1, F_CF);
-	}
-	return (u16)res;
+    res = d;
+    if ((cnt = s % 16) != 0) {
+        res = (d << cnt);
+        mask = (1 << cnt) - 1;
+        res |= (d >> (16 - cnt)) & mask;
+        CONDITIONAL_SET_FLAG(res & 0x1, F_CF);
+        CONDITIONAL_SET_FLAG(s == 1 &&
+                             XOR2((res & 0x1) + ((res >> 14) & 0x2)), F_OF);
+    }
+    if (s != 0) {
+        /* set the new carry flag, Note that it is the low order
+           bit of the result!!!                               */
+        CONDITIONAL_SET_FLAG(res & 0x1, F_CF);
+    }
+    return (u16) res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the ROL instruction and side effects.
 ****************************************************************************/
-u32 rol_long(u32 d, u8 s)
+u32
+rol_long(u32 d, u8 s)
 {
     register u32 res, cnt, mask;
 
-	res = d;
-	if ((cnt = s % 32) != 0) {
-		res = (d << cnt);
-		mask = (1 << cnt) - 1;
-		res |= (d >> (32 - cnt)) & mask;
-		CONDITIONAL_SET_FLAG(res & 0x1, F_CF);
-		CONDITIONAL_SET_FLAG(s == 1 &&
-							 XOR2((res & 0x1) + ((res >> 30) & 0x2)),
-							 F_OF);
-	} if (s != 0) {
-		/* set the new carry flag, Note that it is the low order
-		   bit of the result!!!                               */
-		CONDITIONAL_SET_FLAG(res & 0x1, F_CF);
-	}
-	return res;
+    res = d;
+    if ((cnt = s % 32) != 0) {
+        res = (d << cnt);
+        mask = (1 << cnt) - 1;
+        res |= (d >> (32 - cnt)) & mask;
+        CONDITIONAL_SET_FLAG(res & 0x1, F_CF);
+        CONDITIONAL_SET_FLAG(s == 1 &&
+                             XOR2((res & 0x1) + ((res >> 30) & 0x2)), F_OF);
+    }
+    if (s != 0) {
+        /* set the new carry flag, Note that it is the low order
+           bit of the result!!!                               */
+        CONDITIONAL_SET_FLAG(res & 0x1, F_CF);
+    }
+    return res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the ROR instruction and side effects.
 ****************************************************************************/
-u8 ror_byte(u8 d, u8 s)
+u8
+ror_byte(u8 d, u8 s)
 {
     register unsigned int res, cnt, mask;
 
@@ -1219,9 +1269,9 @@ u8 ror_byte(u8 d, u8 s)
        IF n > 0 
        1) B_(8-(n+1)) .. B_(0)  <-  b_(7) .. b_(n)
        2) B_(7) .. B_(8-n) <-  b_(n-1) .. b_(0)
-	 */
-	res = d;
-	if ((cnt = s % 8) != 0) {           /* not a typo, do nada if cnt==0 */
+     */
+    res = d;
+    if ((cnt = s % 8) != 0) {   /* not a typo, do nada if cnt==0 */
         /* B_(7) .. B_(8-n) <-  b_(n-1) .. b_(0) */
         res = (d << (8 - cnt));
 
@@ -1231,291 +1281,317 @@ u8 ror_byte(u8 d, u8 s)
 
         /* set the new carry flag, Note that it is the low order 
            bit of the result!!!                               */
-		CONDITIONAL_SET_FLAG(res & 0x80, F_CF);
-		/* OVERFLOW is set *IFF* s==1, then it is the
+        CONDITIONAL_SET_FLAG(res & 0x80, F_CF);
+        /* OVERFLOW is set *IFF* s==1, then it is the
            xor of the two most significant bits.  Blecck. */
-		CONDITIONAL_SET_FLAG(s == 1 && XOR2(res >> 6), F_OF);
-	} else if (s != 0) {
-		/* set the new carry flag, Note that it is the low order
-		   bit of the result!!!                               */
-		CONDITIONAL_SET_FLAG(res & 0x80, F_CF);
-	}
-	return (u8)res;
+        CONDITIONAL_SET_FLAG(s == 1 && XOR2(res >> 6), F_OF);
+    }
+    else if (s != 0) {
+        /* set the new carry flag, Note that it is the low order
+           bit of the result!!!                               */
+        CONDITIONAL_SET_FLAG(res & 0x80, F_CF);
+    }
+    return (u8) res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the ROR instruction and side effects.
 ****************************************************************************/
-u16 ror_word(u16 d, u8 s)
+u16
+ror_word(u16 d, u8 s)
 {
     register unsigned int res, cnt, mask;
 
-	res = d;
-	if ((cnt = s % 16) != 0) {
-		res = (d << (16 - cnt));
-		mask = (1 << (16 - cnt)) - 1;
-		res |= (d >> (cnt)) & mask;
-		CONDITIONAL_SET_FLAG(res & 0x8000, F_CF);
-		CONDITIONAL_SET_FLAG(s == 1 && XOR2(res >> 14), F_OF);
-	} else if (s != 0) {
-		/* set the new carry flag, Note that it is the low order
-		   bit of the result!!!                               */
-		CONDITIONAL_SET_FLAG(res & 0x8000, F_CF);
-	}
-	return (u16)res;
+    res = d;
+    if ((cnt = s % 16) != 0) {
+        res = (d << (16 - cnt));
+        mask = (1 << (16 - cnt)) - 1;
+        res |= (d >> (cnt)) & mask;
+        CONDITIONAL_SET_FLAG(res & 0x8000, F_CF);
+        CONDITIONAL_SET_FLAG(s == 1 && XOR2(res >> 14), F_OF);
+    }
+    else if (s != 0) {
+        /* set the new carry flag, Note that it is the low order
+           bit of the result!!!                               */
+        CONDITIONAL_SET_FLAG(res & 0x8000, F_CF);
+    }
+    return (u16) res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the ROR instruction and side effects.
 ****************************************************************************/
-u32 ror_long(u32 d, u8 s)
+u32
+ror_long(u32 d, u8 s)
 {
-	register u32 res, cnt, mask;
+    register u32 res, cnt, mask;
 
-	res = d;
-	if ((cnt = s % 32) != 0) {
-		res = (d << (32 - cnt));
-		mask = (1 << (32 - cnt)) - 1;
-		res |= (d >> (cnt)) & mask;
-		CONDITIONAL_SET_FLAG(res & 0x80000000, F_CF);
-		CONDITIONAL_SET_FLAG(s == 1 && XOR2(res >> 30), F_OF);
-	} else if (s != 0) {
-		/* set the new carry flag, Note that it is the low order
-		   bit of the result!!!                               */
-		CONDITIONAL_SET_FLAG(res & 0x80000000, F_CF);
-	}
-	return res;
+    res = d;
+    if ((cnt = s % 32) != 0) {
+        res = (d << (32 - cnt));
+        mask = (1 << (32 - cnt)) - 1;
+        res |= (d >> (cnt)) & mask;
+        CONDITIONAL_SET_FLAG(res & 0x80000000, F_CF);
+        CONDITIONAL_SET_FLAG(s == 1 && XOR2(res >> 30), F_OF);
+    }
+    else if (s != 0) {
+        /* set the new carry flag, Note that it is the low order
+           bit of the result!!!                               */
+        CONDITIONAL_SET_FLAG(res & 0x80000000, F_CF);
+    }
+    return res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the SHL instruction and side effects.
 ****************************************************************************/
-u8 shl_byte(u8 d, u8 s)
+u8
+shl_byte(u8 d, u8 s)
 {
-	unsigned int cnt, res, cf;
-
-	if (s < 8) {
-		cnt = s % 8;
+    unsigned int cnt, res, cf;
 
-		/* last bit shifted out goes into carry flag */
-		if (cnt > 0) {
-			res = d << cnt;
-			cf = d & (1 << (8 - cnt));
-			CONDITIONAL_SET_FLAG(cf, F_CF);
-			CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
-			CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
-			CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
-		} else {
-			res = (u8) d;
-		}
+    if (s < 8) {
+        cnt = s % 8;
+
+        /* last bit shifted out goes into carry flag */
+        if (cnt > 0) {
+            res = d << cnt;
+            cf = d & (1 << (8 - cnt));
+            CONDITIONAL_SET_FLAG(cf, F_CF);
+            CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
+            CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
+            CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+        }
+        else {
+            res = (u8) d;
+        }
 
-		if (cnt == 1) {
-			/* Needs simplification. */
-			CONDITIONAL_SET_FLAG(
-									(((res & 0x80) == 0x80) ^
-									 (ACCESS_FLAG(F_CF) != 0)),
-			/* was (M.x86.R_FLG&F_CF)==F_CF)), */
-									F_OF);
-		} else {
-			CLEAR_FLAG(F_OF);
-		}
-	} else {
-		res = 0;
-		CONDITIONAL_SET_FLAG((d << (s-1)) & 0x80, F_CF);
-		CLEAR_FLAG(F_OF);
-		CLEAR_FLAG(F_SF);
-		SET_FLAG(F_PF);
-		SET_FLAG(F_ZF);
+        if (cnt == 1) {
+            /* Needs simplification. */
+            CONDITIONAL_SET_FLAG((((res & 0x80) == 0x80) ^
+                                  (ACCESS_FLAG(F_CF) != 0)),
+                                 /* was (M.x86.R_FLG&F_CF)==F_CF)), */
+                                 F_OF);
+        }
+        else {
+            CLEAR_FLAG(F_OF);
+        }
     }
-	return (u8)res;
+    else {
+        res = 0;
+        CONDITIONAL_SET_FLAG((d << (s - 1)) & 0x80, F_CF);
+        CLEAR_FLAG(F_OF);
+        CLEAR_FLAG(F_SF);
+        SET_FLAG(F_PF);
+        SET_FLAG(F_ZF);
+    }
+    return (u8) res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the SHL instruction and side effects.
 ****************************************************************************/
-u16 shl_word(u16 d, u8 s)
+u16
+shl_word(u16 d, u8 s)
 {
     unsigned int cnt, res, cf;
 
-	if (s < 16) {
-		cnt = s % 16;
-		if (cnt > 0) {
-			res = d << cnt;
-			cf = d & (1 << (16 - cnt));
-			CONDITIONAL_SET_FLAG(cf, F_CF);
-			CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
-			CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
-			CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
-		} else {
-			res = (u16) d;
-		}
-
-		if (cnt == 1) {
-			CONDITIONAL_SET_FLAG(
-									(((res & 0x8000) == 0x8000) ^
-									 (ACCESS_FLAG(F_CF) != 0)),
-									F_OF);
-        } else {
-			CLEAR_FLAG(F_OF);
-        }
-    } else {
-		res = 0;
-		CONDITIONAL_SET_FLAG((d << (s-1)) & 0x8000, F_CF);
-		CLEAR_FLAG(F_OF);
-		CLEAR_FLAG(F_SF);
-		SET_FLAG(F_PF);
-		SET_FLAG(F_ZF);
-	}
-	return (u16)res;
+    if (s < 16) {
+        cnt = s % 16;
+        if (cnt > 0) {
+            res = d << cnt;
+            cf = d & (1 << (16 - cnt));
+            CONDITIONAL_SET_FLAG(cf, F_CF);
+            CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
+            CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
+            CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+        }
+        else {
+            res = (u16) d;
+        }
+
+        if (cnt == 1) {
+            CONDITIONAL_SET_FLAG((((res & 0x8000) == 0x8000) ^
+                                  (ACCESS_FLAG(F_CF) != 0)), F_OF);
+        }
+        else {
+            CLEAR_FLAG(F_OF);
+        }
+    }
+    else {
+        res = 0;
+        CONDITIONAL_SET_FLAG((d << (s - 1)) & 0x8000, F_CF);
+        CLEAR_FLAG(F_OF);
+        CLEAR_FLAG(F_SF);
+        SET_FLAG(F_PF);
+        SET_FLAG(F_ZF);
+    }
+    return (u16) res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the SHL instruction and side effects.
 ****************************************************************************/
-u32 shl_long(u32 d, u8 s)
-{
-	unsigned int cnt, res, cf;
-
-	if (s < 32) {
-		cnt = s % 32;
-		if (cnt > 0) {
-			res = d << cnt;
-			cf = d & (1 << (32 - cnt));
-			CONDITIONAL_SET_FLAG(cf, F_CF);
-			CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
-			CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
-			CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
-		} else {
-			res = d;
-		}
-		if (cnt == 1) {
-			CONDITIONAL_SET_FLAG((((res & 0x80000000) == 0x80000000) ^
-								  (ACCESS_FLAG(F_CF) != 0)), F_OF);
-		} else {
-			CLEAR_FLAG(F_OF);
-		}
-	} else {
-		res = 0;
-		CONDITIONAL_SET_FLAG((d << (s-1)) & 0x80000000, F_CF);
-		CLEAR_FLAG(F_OF);
-		CLEAR_FLAG(F_SF);
-		SET_FLAG(F_PF);
-		SET_FLAG(F_ZF);
-	}
-	return res;
+u32
+shl_long(u32 d, u8 s)
+{
+    unsigned int cnt, res, cf;
+
+    if (s < 32) {
+        cnt = s % 32;
+        if (cnt > 0) {
+            res = d << cnt;
+            cf = d & (1 << (32 - cnt));
+            CONDITIONAL_SET_FLAG(cf, F_CF);
+            CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
+            CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
+            CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+        }
+        else {
+            res = d;
+        }
+        if (cnt == 1) {
+            CONDITIONAL_SET_FLAG((((res & 0x80000000) == 0x80000000) ^
+                                  (ACCESS_FLAG(F_CF) != 0)), F_OF);
+        }
+        else {
+            CLEAR_FLAG(F_OF);
+        }
+    }
+    else {
+        res = 0;
+        CONDITIONAL_SET_FLAG((d << (s - 1)) & 0x80000000, F_CF);
+        CLEAR_FLAG(F_OF);
+        CLEAR_FLAG(F_SF);
+        SET_FLAG(F_PF);
+        SET_FLAG(F_ZF);
+    }
+    return res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the SHR instruction and side effects.
 ****************************************************************************/
-u8 shr_byte(u8 d, u8 s)
-{
-	unsigned int cnt, res, cf;
-
-	if (s < 8) {
-		cnt = s % 8;
-		if (cnt > 0) {
-			cf = d & (1 << (cnt - 1));
-			res = d >> cnt;
-			CONDITIONAL_SET_FLAG(cf, F_CF);
-			CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
-			CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
-			CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
-		} else {
-			res = (u8) d;
-		}
-
-		if (cnt == 1) {
-			CONDITIONAL_SET_FLAG(XOR2(res >> 6), F_OF);
-		} else {
-			CLEAR_FLAG(F_OF);
-		}
-	} else {
-		res = 0;
-		CONDITIONAL_SET_FLAG((d >> (s-1)) & 0x1, F_CF);
-		CLEAR_FLAG(F_OF);
-		CLEAR_FLAG(F_SF);
-		SET_FLAG(F_PF);
-		SET_FLAG(F_ZF);
-	}
-	return (u8)res;
+u8
+shr_byte(u8 d, u8 s)
+{
+    unsigned int cnt, res, cf;
+
+    if (s < 8) {
+        cnt = s % 8;
+        if (cnt > 0) {
+            cf = d & (1 << (cnt - 1));
+            res = d >> cnt;
+            CONDITIONAL_SET_FLAG(cf, F_CF);
+            CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
+            CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
+            CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+        }
+        else {
+            res = (u8) d;
+        }
+
+        if (cnt == 1) {
+            CONDITIONAL_SET_FLAG(XOR2(res >> 6), F_OF);
+        }
+        else {
+            CLEAR_FLAG(F_OF);
+        }
+    }
+    else {
+        res = 0;
+        CONDITIONAL_SET_FLAG((d >> (s - 1)) & 0x1, F_CF);
+        CLEAR_FLAG(F_OF);
+        CLEAR_FLAG(F_SF);
+        SET_FLAG(F_PF);
+        SET_FLAG(F_ZF);
+    }
+    return (u8) res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the SHR instruction and side effects.
 ****************************************************************************/
-u16 shr_word(u16 d, u8 s)
+u16
+shr_word(u16 d, u8 s)
 {
-	unsigned int cnt, res, cf;
+    unsigned int cnt, res, cf;
 
-	if (s < 16) {
-		cnt = s % 16;
-		if (cnt > 0) {
-			cf = d & (1 << (cnt - 1));
-			res = d >> cnt;
-			CONDITIONAL_SET_FLAG(cf, F_CF);
-			CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
-			CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
-			CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
-		} else {
-			res = d;
-		}
+    if (s < 16) {
+        cnt = s % 16;
+        if (cnt > 0) {
+            cf = d & (1 << (cnt - 1));
+            res = d >> cnt;
+            CONDITIONAL_SET_FLAG(cf, F_CF);
+            CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
+            CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
+            CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+        }
+        else {
+            res = d;
+        }
 
-		if (cnt == 1) {
-			CONDITIONAL_SET_FLAG(XOR2(res >> 14), F_OF);
-        } else {
-			CLEAR_FLAG(F_OF);
+        if (cnt == 1) {
+            CONDITIONAL_SET_FLAG(XOR2(res >> 14), F_OF);
         }
-	} else {
-		res = 0;
-		CLEAR_FLAG(F_CF);
-		CLEAR_FLAG(F_OF);
-		SET_FLAG(F_ZF);
-		CLEAR_FLAG(F_SF);
-		CLEAR_FLAG(F_PF);
+        else {
+            CLEAR_FLAG(F_OF);
+        }
+    }
+    else {
+        res = 0;
+        CLEAR_FLAG(F_CF);
+        CLEAR_FLAG(F_OF);
+        SET_FLAG(F_ZF);
+        CLEAR_FLAG(F_SF);
+        CLEAR_FLAG(F_PF);
     }
-	return (u16)res;
+    return (u16) res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the SHR instruction and side effects.
 ****************************************************************************/
-u32 shr_long(u32 d, u8 s)
+u32
+shr_long(u32 d, u8 s)
 {
-	unsigned int cnt, res, cf;
+    unsigned int cnt, res, cf;
 
-	if (s < 32) {
-		cnt = s % 32;
-		if (cnt > 0) {
-			cf = d & (1 << (cnt - 1));
-			res = d >> cnt;
-			CONDITIONAL_SET_FLAG(cf, F_CF);
-			CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
-			CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
-			CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
-        } else {
+    if (s < 32) {
+        cnt = s % 32;
+        if (cnt > 0) {
+            cf = d & (1 << (cnt - 1));
+            res = d >> cnt;
+            CONDITIONAL_SET_FLAG(cf, F_CF);
+            CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
+            CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
+            CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+        }
+        else {
             res = d;
         }
         if (cnt == 1) {
-			CONDITIONAL_SET_FLAG(XOR2(res >> 30), F_OF);
-        } else {
-			CLEAR_FLAG(F_OF);
+            CONDITIONAL_SET_FLAG(XOR2(res >> 30), F_OF);
+        }
+        else {
+            CLEAR_FLAG(F_OF);
         }
-    } else {
+    }
+    else {
         res = 0;
-		CLEAR_FLAG(F_CF);
-		CLEAR_FLAG(F_OF);
-		SET_FLAG(F_ZF);
-		CLEAR_FLAG(F_SF);
-		CLEAR_FLAG(F_PF);
+        CLEAR_FLAG(F_CF);
+        CLEAR_FLAG(F_OF);
+        SET_FLAG(F_ZF);
+        CLEAR_FLAG(F_SF);
+        CLEAR_FLAG(F_PF);
     }
     return res;
 }
@@ -1524,592 +1600,634 @@ u32 shr_long(u32 d, u8 s)
 REMARKS:
 Implements the SAR instruction and side effects.
 ****************************************************************************/
-u8 sar_byte(u8 d, u8 s)
+u8
+sar_byte(u8 d, u8 s)
 {
-	unsigned int cnt, res, cf, mask, sf;
+    unsigned int cnt, res, cf, mask, sf;
 
-	res = d;
-	sf = d & 0x80;
+    res = d;
+    sf = d & 0x80;
     cnt = s % 8;
-	if (cnt > 0 && cnt < 8) {
-		mask = (1 << (8 - cnt)) - 1;
-		cf = d & (1 << (cnt - 1));
-		res = (d >> cnt) & mask;
-		CONDITIONAL_SET_FLAG(cf, F_CF);
-		if (sf) {
-			res |= ~mask;
-		}
-		CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
-		CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
-		CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
-    } else if (cnt >= 8) {
+    if (cnt > 0 && cnt < 8) {
+        mask = (1 << (8 - cnt)) - 1;
+        cf = d & (1 << (cnt - 1));
+        res = (d >> cnt) & mask;
+        CONDITIONAL_SET_FLAG(cf, F_CF);
+        if (sf) {
+            res |= ~mask;
+        }
+        CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
+        CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+        CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
+    }
+    else if (cnt >= 8) {
         if (sf) {
             res = 0xff;
-			SET_FLAG(F_CF);
-			CLEAR_FLAG(F_ZF);
-			SET_FLAG(F_SF);
-			SET_FLAG(F_PF);
-		} else {
-			res = 0;
-			CLEAR_FLAG(F_CF);
-			SET_FLAG(F_ZF);
-			CLEAR_FLAG(F_SF);
-			CLEAR_FLAG(F_PF);
-		}
-	}
-	return (u8)res;
+            SET_FLAG(F_CF);
+            CLEAR_FLAG(F_ZF);
+            SET_FLAG(F_SF);
+            SET_FLAG(F_PF);
+        }
+        else {
+            res = 0;
+            CLEAR_FLAG(F_CF);
+            SET_FLAG(F_ZF);
+            CLEAR_FLAG(F_SF);
+            CLEAR_FLAG(F_PF);
+        }
+    }
+    return (u8) res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the SAR instruction and side effects.
 ****************************************************************************/
-u16 sar_word(u16 d, u8 s)
+u16
+sar_word(u16 d, u8 s)
 {
     unsigned int cnt, res, cf, mask, sf;
 
     sf = d & 0x8000;
     cnt = s % 16;
-	res = d;
-	if (cnt > 0 && cnt < 16) {
+    res = d;
+    if (cnt > 0 && cnt < 16) {
         mask = (1 << (16 - cnt)) - 1;
         cf = d & (1 << (cnt - 1));
         res = (d >> cnt) & mask;
-		CONDITIONAL_SET_FLAG(cf, F_CF);
+        CONDITIONAL_SET_FLAG(cf, F_CF);
         if (sf) {
             res |= ~mask;
         }
-		CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
-		CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
-		CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
-    } else if (cnt >= 16) {
+        CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
+        CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
+        CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+    }
+    else if (cnt >= 16) {
         if (sf) {
             res = 0xffff;
-			SET_FLAG(F_CF);
-			CLEAR_FLAG(F_ZF);
-			SET_FLAG(F_SF);
-			SET_FLAG(F_PF);
-        } else {
+            SET_FLAG(F_CF);
+            CLEAR_FLAG(F_ZF);
+            SET_FLAG(F_SF);
+            SET_FLAG(F_PF);
+        }
+        else {
             res = 0;
-			CLEAR_FLAG(F_CF);
-			SET_FLAG(F_ZF);
-			CLEAR_FLAG(F_SF);
-			CLEAR_FLAG(F_PF);
+            CLEAR_FLAG(F_CF);
+            SET_FLAG(F_ZF);
+            CLEAR_FLAG(F_SF);
+            CLEAR_FLAG(F_PF);
         }
     }
-	return (u16)res;
+    return (u16) res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the SAR instruction and side effects.
 ****************************************************************************/
-u32 sar_long(u32 d, u8 s)
+u32
+sar_long(u32 d, u8 s)
 {
     u32 cnt, res, cf, mask, sf;
 
     sf = d & 0x80000000;
     cnt = s % 32;
-	res = d;
-	if (cnt > 0 && cnt < 32) {
+    res = d;
+    if (cnt > 0 && cnt < 32) {
         mask = (1 << (32 - cnt)) - 1;
-		cf = d & (1 << (cnt - 1));
+        cf = d & (1 << (cnt - 1));
         res = (d >> cnt) & mask;
-		CONDITIONAL_SET_FLAG(cf, F_CF);
+        CONDITIONAL_SET_FLAG(cf, F_CF);
         if (sf) {
             res |= ~mask;
         }
-		CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
-		CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
-		CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
-    } else if (cnt >= 32) {
+        CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
+        CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
+        CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+    }
+    else if (cnt >= 32) {
         if (sf) {
             res = 0xffffffff;
-			SET_FLAG(F_CF);
-			CLEAR_FLAG(F_ZF);
-			SET_FLAG(F_SF);
-			SET_FLAG(F_PF);
-		} else {
-			res = 0;
-			CLEAR_FLAG(F_CF);
-			SET_FLAG(F_ZF);
-			CLEAR_FLAG(F_SF);
-			CLEAR_FLAG(F_PF);
-		}
-	}
-	return res;
+            SET_FLAG(F_CF);
+            CLEAR_FLAG(F_ZF);
+            SET_FLAG(F_SF);
+            SET_FLAG(F_PF);
+        }
+        else {
+            res = 0;
+            CLEAR_FLAG(F_CF);
+            SET_FLAG(F_ZF);
+            CLEAR_FLAG(F_SF);
+            CLEAR_FLAG(F_PF);
+        }
+    }
+    return res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the SHLD instruction and side effects.
 ****************************************************************************/
-u16 shld_word (u16 d, u16 fill, u8 s)
-{
-	unsigned int cnt, res, cf;
-
-	if (s < 16) {
-		cnt = s % 16;
-		if (cnt > 0) {
-			res = (d << cnt) | (fill >> (16-cnt));
-			cf = d & (1 << (16 - cnt));
-			CONDITIONAL_SET_FLAG(cf, F_CF);
-			CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
-			CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
-			CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
-		} else {
-			res = d;
-		}
-		if (cnt == 1) {
-			CONDITIONAL_SET_FLAG((((res & 0x8000) == 0x8000) ^
-								  (ACCESS_FLAG(F_CF) != 0)), F_OF);
-		} else {
-			CLEAR_FLAG(F_OF);
-		}
-	} else {
-		res = 0;
-		CONDITIONAL_SET_FLAG((d << (s-1)) & 0x8000, F_CF);
-		CLEAR_FLAG(F_OF);
-		CLEAR_FLAG(F_SF);
-		SET_FLAG(F_PF);
-		SET_FLAG(F_ZF);
-	}
-	return (u16)res;
+u16
+shld_word(u16 d, u16 fill, u8 s)
+{
+    unsigned int cnt, res, cf;
+
+    if (s < 16) {
+        cnt = s % 16;
+        if (cnt > 0) {
+            res = (d << cnt) | (fill >> (16 - cnt));
+            cf = d & (1 << (16 - cnt));
+            CONDITIONAL_SET_FLAG(cf, F_CF);
+            CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
+            CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
+            CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+        }
+        else {
+            res = d;
+        }
+        if (cnt == 1) {
+            CONDITIONAL_SET_FLAG((((res & 0x8000) == 0x8000) ^
+                                  (ACCESS_FLAG(F_CF) != 0)), F_OF);
+        }
+        else {
+            CLEAR_FLAG(F_OF);
+        }
+    }
+    else {
+        res = 0;
+        CONDITIONAL_SET_FLAG((d << (s - 1)) & 0x8000, F_CF);
+        CLEAR_FLAG(F_OF);
+        CLEAR_FLAG(F_SF);
+        SET_FLAG(F_PF);
+        SET_FLAG(F_ZF);
+    }
+    return (u16) res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the SHLD instruction and side effects.
 ****************************************************************************/
-u32 shld_long (u32 d, u32 fill, u8 s)
-{
-	unsigned int cnt, res, cf;
-
-	if (s < 32) {
-		cnt = s % 32;
-		if (cnt > 0) {
-			res = (d << cnt) | (fill >> (32-cnt));
-			cf = d & (1 << (32 - cnt));
-			CONDITIONAL_SET_FLAG(cf, F_CF);
-			CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
-			CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
-			CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
-		} else {
-			res = d;
-		}
-		if (cnt == 1) {
-			CONDITIONAL_SET_FLAG((((res & 0x80000000) == 0x80000000) ^
-								  (ACCESS_FLAG(F_CF) != 0)), F_OF);
-		} else {
-			CLEAR_FLAG(F_OF);
-		}
-	} else {
-		res = 0;
-		CONDITIONAL_SET_FLAG((d << (s-1)) & 0x80000000, F_CF);
-		CLEAR_FLAG(F_OF);
-		CLEAR_FLAG(F_SF);
-		SET_FLAG(F_PF);
-		SET_FLAG(F_ZF);
-	}
-	return res;
+u32
+shld_long(u32 d, u32 fill, u8 s)
+{
+    unsigned int cnt, res, cf;
+
+    if (s < 32) {
+        cnt = s % 32;
+        if (cnt > 0) {
+            res = (d << cnt) | (fill >> (32 - cnt));
+            cf = d & (1 << (32 - cnt));
+            CONDITIONAL_SET_FLAG(cf, F_CF);
+            CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
+            CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
+            CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+        }
+        else {
+            res = d;
+        }
+        if (cnt == 1) {
+            CONDITIONAL_SET_FLAG((((res & 0x80000000) == 0x80000000) ^
+                                  (ACCESS_FLAG(F_CF) != 0)), F_OF);
+        }
+        else {
+            CLEAR_FLAG(F_OF);
+        }
+    }
+    else {
+        res = 0;
+        CONDITIONAL_SET_FLAG((d << (s - 1)) & 0x80000000, F_CF);
+        CLEAR_FLAG(F_OF);
+        CLEAR_FLAG(F_SF);
+        SET_FLAG(F_PF);
+        SET_FLAG(F_ZF);
+    }
+    return res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the SHRD instruction and side effects.
 ****************************************************************************/
-u16 shrd_word (u16 d, u16 fill, u8 s)
+u16
+shrd_word(u16 d, u16 fill, u8 s)
 {
-	unsigned int cnt, res, cf;
+    unsigned int cnt, res, cf;
 
-	if (s < 16) {
-		cnt = s % 16;
-		if (cnt > 0) {
-			cf = d & (1 << (cnt - 1));
-			res = (d >> cnt) | (fill << (16 - cnt));
-			CONDITIONAL_SET_FLAG(cf, F_CF);
-			CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
-			CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
-			CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
-		} else {
-			res = d;
-		}
+    if (s < 16) {
+        cnt = s % 16;
+        if (cnt > 0) {
+            cf = d & (1 << (cnt - 1));
+            res = (d >> cnt) | (fill << (16 - cnt));
+            CONDITIONAL_SET_FLAG(cf, F_CF);
+            CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
+            CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
+            CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+        }
+        else {
+            res = d;
+        }
 
-		if (cnt == 1) {
-			CONDITIONAL_SET_FLAG(XOR2(res >> 14), F_OF);
-        } else {
-			CLEAR_FLAG(F_OF);
+        if (cnt == 1) {
+            CONDITIONAL_SET_FLAG(XOR2(res >> 14), F_OF);
+        }
+        else {
+            CLEAR_FLAG(F_OF);
         }
-	} else {
-		res = 0;
-		CLEAR_FLAG(F_CF);
-		CLEAR_FLAG(F_OF);
-		SET_FLAG(F_ZF);
-		CLEAR_FLAG(F_SF);
-		CLEAR_FLAG(F_PF);
     }
-	return (u16)res;
+    else {
+        res = 0;
+        CLEAR_FLAG(F_CF);
+        CLEAR_FLAG(F_OF);
+        SET_FLAG(F_ZF);
+        CLEAR_FLAG(F_SF);
+        CLEAR_FLAG(F_PF);
+    }
+    return (u16) res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the SHRD instruction and side effects.
 ****************************************************************************/
-u32 shrd_long (u32 d, u32 fill, u8 s)
+u32
+shrd_long(u32 d, u32 fill, u8 s)
 {
-	unsigned int cnt, res, cf;
+    unsigned int cnt, res, cf;
 
-	if (s < 32) {
-		cnt = s % 32;
-		if (cnt > 0) {
-			cf = d & (1 << (cnt - 1));
-			res = (d >> cnt) | (fill << (32 - cnt));
-			CONDITIONAL_SET_FLAG(cf, F_CF);
-			CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
-			CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
-			CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
-		} else {
-			res = d;
-		}
-		if (cnt == 1) {
-			CONDITIONAL_SET_FLAG(XOR2(res >> 30), F_OF);
-        } else {
-			CLEAR_FLAG(F_OF);
+    if (s < 32) {
+        cnt = s % 32;
+        if (cnt > 0) {
+            cf = d & (1 << (cnt - 1));
+            res = (d >> cnt) | (fill << (32 - cnt));
+            CONDITIONAL_SET_FLAG(cf, F_CF);
+            CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
+            CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
+            CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+        }
+        else {
+            res = d;
+        }
+        if (cnt == 1) {
+            CONDITIONAL_SET_FLAG(XOR2(res >> 30), F_OF);
+        }
+        else {
+            CLEAR_FLAG(F_OF);
         }
-	} else {
-		res = 0;
-		CLEAR_FLAG(F_CF);
-		CLEAR_FLAG(F_OF);
-		SET_FLAG(F_ZF);
-		CLEAR_FLAG(F_SF);
-		CLEAR_FLAG(F_PF);
     }
-	return res;
+    else {
+        res = 0;
+        CLEAR_FLAG(F_CF);
+        CLEAR_FLAG(F_OF);
+        SET_FLAG(F_ZF);
+        CLEAR_FLAG(F_SF);
+        CLEAR_FLAG(F_PF);
+    }
+    return res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the SBB instruction and side effects.
 ****************************************************************************/
-u8 sbb_byte(u8 d, u8 s)
+u8
+sbb_byte(u8 d, u8 s)
 {
-    register u32 res;   /* all operands in native machine order */
+    register u32 res;           /* all operands in native machine order */
     register u32 bc;
 
-	if (ACCESS_FLAG(F_CF))
-		res = d - s - 1;
-	else
-		res = d - s;
-	CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
-	CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+    if (ACCESS_FLAG(F_CF))
+        res = d - s - 1;
+    else
+        res = d - s;
+    CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
+    CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
 
-	/* calculate the borrow chain.  See note at top */
-	bc = (res & (~d | s)) | (~d & s);
-	CONDITIONAL_SET_FLAG(bc & 0x80, F_CF);
-	CONDITIONAL_SET_FLAG(XOR2(bc >> 6), F_OF);
-	CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
-	return (u8)res;
+    /* calculate the borrow chain.  See note at top */
+    bc = (res & (~d | s)) | (~d & s);
+    CONDITIONAL_SET_FLAG(bc & 0x80, F_CF);
+    CONDITIONAL_SET_FLAG(XOR2(bc >> 6), F_OF);
+    CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
+    return (u8) res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the SBB instruction and side effects.
 ****************************************************************************/
-u16 sbb_word(u16 d, u16 s)
+u16
+sbb_word(u16 d, u16 s)
 {
-    register u32 res;   /* all operands in native machine order */
+    register u32 res;           /* all operands in native machine order */
     register u32 bc;
 
-	if (ACCESS_FLAG(F_CF))
+    if (ACCESS_FLAG(F_CF))
         res = d - s - 1;
     else
         res = d - s;
-	CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
-	CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+    CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
+    CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
 
-	/* calculate the borrow chain.  See note at top */
-	bc = (res & (~d | s)) | (~d & s);
-	CONDITIONAL_SET_FLAG(bc & 0x8000, F_CF);
-	CONDITIONAL_SET_FLAG(XOR2(bc >> 14), F_OF);
-	CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
-	return (u16)res;
+    /* calculate the borrow chain.  See note at top */
+    bc = (res & (~d | s)) | (~d & s);
+    CONDITIONAL_SET_FLAG(bc & 0x8000, F_CF);
+    CONDITIONAL_SET_FLAG(XOR2(bc >> 14), F_OF);
+    CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
+    return (u16) res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the SBB instruction and side effects.
 ****************************************************************************/
-u32 sbb_long(u32 d, u32 s)
+u32
+sbb_long(u32 d, u32 s)
 {
-	register u32 res;   /* all operands in native machine order */
-	register u32 bc;
+    register u32 res;           /* all operands in native machine order */
+    register u32 bc;
 
-	if (ACCESS_FLAG(F_CF))
+    if (ACCESS_FLAG(F_CF))
         res = d - s - 1;
     else
         res = d - s;
-	CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
-	CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+    CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
+    CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
 
-	/* calculate the borrow chain.  See note at top */
-	bc = (res & (~d | s)) | (~d & s);
-	CONDITIONAL_SET_FLAG(bc & 0x80000000, F_CF);
-	CONDITIONAL_SET_FLAG(XOR2(bc >> 30), F_OF);
-	CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
-	return res;
+    /* calculate the borrow chain.  See note at top */
+    bc = (res & (~d | s)) | (~d & s);
+    CONDITIONAL_SET_FLAG(bc & 0x80000000, F_CF);
+    CONDITIONAL_SET_FLAG(XOR2(bc >> 30), F_OF);
+    CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
+    return res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the SUB instruction and side effects.
 ****************************************************************************/
-u8 sub_byte(u8 d, u8 s)
+u8
+sub_byte(u8 d, u8 s)
 {
-	register u32 res;   /* all operands in native machine order */
-	register u32 bc;
+    register u32 res;           /* all operands in native machine order */
+    register u32 bc;
 
-	res = d - s;
-	CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
-	CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+    res = d - s;
+    CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
+    CONDITIONAL_SET_FLAG((res & 0xff) == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
 
-	/* calculate the borrow chain.  See note at top */
-	bc = (res & (~d | s)) | (~d & s);
-	CONDITIONAL_SET_FLAG(bc & 0x80, F_CF);
-	CONDITIONAL_SET_FLAG(XOR2(bc >> 6), F_OF);
-	CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
-	return (u8)res;
+    /* calculate the borrow chain.  See note at top */
+    bc = (res & (~d | s)) | (~d & s);
+    CONDITIONAL_SET_FLAG(bc & 0x80, F_CF);
+    CONDITIONAL_SET_FLAG(XOR2(bc >> 6), F_OF);
+    CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
+    return (u8) res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the SUB instruction and side effects.
 ****************************************************************************/
-u16 sub_word(u16 d, u16 s)
+u16
+sub_word(u16 d, u16 s)
 {
-    register u32 res;   /* all operands in native machine order */
+    register u32 res;           /* all operands in native machine order */
     register u32 bc;
 
     res = d - s;
-	CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
-	CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+    CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
+    CONDITIONAL_SET_FLAG((res & 0xffff) == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
 
-	/* calculate the borrow chain.  See note at top */
-	bc = (res & (~d | s)) | (~d & s);
-	CONDITIONAL_SET_FLAG(bc & 0x8000, F_CF);
-	CONDITIONAL_SET_FLAG(XOR2(bc >> 14), F_OF);
-	CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
-	return (u16)res;
+    /* calculate the borrow chain.  See note at top */
+    bc = (res & (~d | s)) | (~d & s);
+    CONDITIONAL_SET_FLAG(bc & 0x8000, F_CF);
+    CONDITIONAL_SET_FLAG(XOR2(bc >> 14), F_OF);
+    CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
+    return (u16) res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the SUB instruction and side effects.
 ****************************************************************************/
-u32 sub_long(u32 d, u32 s)
+u32
+sub_long(u32 d, u32 s)
 {
-	register u32 res;   /* all operands in native machine order */
-	register u32 bc;
+    register u32 res;           /* all operands in native machine order */
+    register u32 bc;
 
-	res = d - s;
-	CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
-	CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+    res = d - s;
+    CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
+    CONDITIONAL_SET_FLAG((res & 0xffffffff) == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
 
-	/* calculate the borrow chain.  See note at top */
-	bc = (res & (~d | s)) | (~d & s);
-	CONDITIONAL_SET_FLAG(bc & 0x80000000, F_CF);
-	CONDITIONAL_SET_FLAG(XOR2(bc >> 30), F_OF);
-	CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
-	return res;
+    /* calculate the borrow chain.  See note at top */
+    bc = (res & (~d | s)) | (~d & s);
+    CONDITIONAL_SET_FLAG(bc & 0x80000000, F_CF);
+    CONDITIONAL_SET_FLAG(XOR2(bc >> 30), F_OF);
+    CONDITIONAL_SET_FLAG(bc & 0x8, F_AF);
+    return res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the TEST instruction and side effects.
 ****************************************************************************/
-void test_byte(u8 d, u8 s)
+void
+test_byte(u8 d, u8 s)
 {
-    register u32 res;   /* all operands in native machine order */
+    register u32 res;           /* all operands in native machine order */
 
     res = d & s;
 
-	CLEAR_FLAG(F_OF);
-	CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
-	CONDITIONAL_SET_FLAG(res == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+    CLEAR_FLAG(F_OF);
+    CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
+    CONDITIONAL_SET_FLAG(res == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
     /* AF == dont care */
-	CLEAR_FLAG(F_CF);
+    CLEAR_FLAG(F_CF);
 }
 
 /****************************************************************************
 REMARKS:
 Implements the TEST instruction and side effects.
 ****************************************************************************/
-void test_word(u16 d, u16 s)
+void
+test_word(u16 d, u16 s)
 {
-	register u32 res;   /* all operands in native machine order */
+    register u32 res;           /* all operands in native machine order */
 
-	res = d & s;
+    res = d & s;
 
-	CLEAR_FLAG(F_OF);
-	CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
-	CONDITIONAL_SET_FLAG(res == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
-	/* AF == dont care */
-	CLEAR_FLAG(F_CF);
+    CLEAR_FLAG(F_OF);
+    CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
+    CONDITIONAL_SET_FLAG(res == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+    /* AF == dont care */
+    CLEAR_FLAG(F_CF);
 }
 
 /****************************************************************************
 REMARKS:
 Implements the TEST instruction and side effects.
 ****************************************************************************/
-void test_long(u32 d, u32 s)
+void
+test_long(u32 d, u32 s)
 {
-	register u32 res;   /* all operands in native machine order */
+    register u32 res;           /* all operands in native machine order */
 
-	res = d & s;
+    res = d & s;
 
-	CLEAR_FLAG(F_OF);
-	CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
-	CONDITIONAL_SET_FLAG(res == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
-	/* AF == dont care */
-	CLEAR_FLAG(F_CF);
+    CLEAR_FLAG(F_OF);
+    CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
+    CONDITIONAL_SET_FLAG(res == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+    /* AF == dont care */
+    CLEAR_FLAG(F_CF);
 }
 
 /****************************************************************************
 REMARKS:
 Implements the XOR instruction and side effects.
 ****************************************************************************/
-u8 xor_byte(u8 d, u8 s)
+u8
+xor_byte(u8 d, u8 s)
 {
-	register u8 res;    /* all operands in native machine order */
+    register u8 res;            /* all operands in native machine order */
 
-	res = d ^ s;
-	CLEAR_FLAG(F_OF);
-	CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
-	CONDITIONAL_SET_FLAG(res == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(PARITY(res), F_PF);
-	CLEAR_FLAG(F_CF);
-	CLEAR_FLAG(F_AF);
-	return res;
+    res = d ^ s;
+    CLEAR_FLAG(F_OF);
+    CONDITIONAL_SET_FLAG(res & 0x80, F_SF);
+    CONDITIONAL_SET_FLAG(res == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(PARITY(res), F_PF);
+    CLEAR_FLAG(F_CF);
+    CLEAR_FLAG(F_AF);
+    return res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the XOR instruction and side effects.
 ****************************************************************************/
-u16 xor_word(u16 d, u16 s)
+u16
+xor_word(u16 d, u16 s)
 {
-	register u16 res;   /* all operands in native machine order */
+    register u16 res;           /* all operands in native machine order */
 
-	res = d ^ s;
-	CLEAR_FLAG(F_OF);
-	CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
-	CONDITIONAL_SET_FLAG(res == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
-	CLEAR_FLAG(F_CF);
-	CLEAR_FLAG(F_AF);
-	return res;
+    res = d ^ s;
+    CLEAR_FLAG(F_OF);
+    CONDITIONAL_SET_FLAG(res & 0x8000, F_SF);
+    CONDITIONAL_SET_FLAG(res == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+    CLEAR_FLAG(F_CF);
+    CLEAR_FLAG(F_AF);
+    return res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the XOR instruction and side effects.
 ****************************************************************************/
-u32 xor_long(u32 d, u32 s)
+u32
+xor_long(u32 d, u32 s)
 {
-	register u32 res;   /* all operands in native machine order */
+    register u32 res;           /* all operands in native machine order */
 
-	res = d ^ s;
-	CLEAR_FLAG(F_OF);
-	CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
-	CONDITIONAL_SET_FLAG(res == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
-	CLEAR_FLAG(F_CF);
-	CLEAR_FLAG(F_AF);
-	return res;
+    res = d ^ s;
+    CLEAR_FLAG(F_OF);
+    CONDITIONAL_SET_FLAG(res & 0x80000000, F_SF);
+    CONDITIONAL_SET_FLAG(res == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(PARITY(res & 0xff), F_PF);
+    CLEAR_FLAG(F_CF);
+    CLEAR_FLAG(F_AF);
+    return res;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the IMUL instruction and side effects.
 ****************************************************************************/
-void imul_byte(u8 s)
+void
+imul_byte(u8 s)
 {
-	s16 res = (s16)((s8)M.x86.R_AL * (s8)s);
+    s16 res = (s16) ((s8) M.x86.R_AL * (s8) s);
 
-	M.x86.R_AX = res;
-	if (((M.x86.R_AL & 0x80) == 0 && M.x86.R_AH == 0x00) ||
-		((M.x86.R_AL & 0x80) != 0 && M.x86.R_AH == 0xFF)) {
-		CLEAR_FLAG(F_CF);
-		CLEAR_FLAG(F_OF);
-	} else {
-		SET_FLAG(F_CF);
-		SET_FLAG(F_OF);
-	}
+    M.x86.R_AX = res;
+    if (((M.x86.R_AL & 0x80) == 0 && M.x86.R_AH == 0x00) ||
+        ((M.x86.R_AL & 0x80) != 0 && M.x86.R_AH == 0xFF)) {
+        CLEAR_FLAG(F_CF);
+        CLEAR_FLAG(F_OF);
+    }
+    else {
+        SET_FLAG(F_CF);
+        SET_FLAG(F_OF);
+    }
 }
 
 /****************************************************************************
 REMARKS:
 Implements the IMUL instruction and side effects.
 ****************************************************************************/
-void imul_word(u16 s)
+void
+imul_word(u16 s)
 {
-	s32 res = (s16)M.x86.R_AX * (s16)s;
+    s32 res = (s16) M.x86.R_AX * (s16) s;
 
-	M.x86.R_AX = (u16)res;
-	M.x86.R_DX = (u16)(res >> 16);
-	if (((M.x86.R_AX & 0x8000) == 0 && M.x86.R_DX == 0x00) ||
-		((M.x86.R_AX & 0x8000) != 0 && M.x86.R_DX == 0xFF)) {
-		CLEAR_FLAG(F_CF);
-		CLEAR_FLAG(F_OF);
-	} else {
-		SET_FLAG(F_CF);
-		SET_FLAG(F_OF);
-	}
+    M.x86.R_AX = (u16) res;
+    M.x86.R_DX = (u16) (res >> 16);
+    if (((M.x86.R_AX & 0x8000) == 0 && M.x86.R_DX == 0x00) ||
+        ((M.x86.R_AX & 0x8000) != 0 && M.x86.R_DX == 0xFF)) {
+        CLEAR_FLAG(F_CF);
+        CLEAR_FLAG(F_OF);
+    }
+    else {
+        SET_FLAG(F_CF);
+        SET_FLAG(F_OF);
+    }
 }
 
 /****************************************************************************
 REMARKS:
 Implements the IMUL instruction and side effects.
 ****************************************************************************/
-void imul_long_direct(u32 *res_lo, u32* res_hi,u32 d, u32 s)
+void
+imul_long_direct(u32 * res_lo, u32 * res_hi, u32 d, u32 s)
 {
 #ifdef	__HAS_LONG_LONG__
-	s64 res = (s32)d * (s32)s;
+    s64 res = (s64) (s32) d * (s32) s;
 
-	*res_lo = (u32)res;
-	*res_hi = (u32)(res >> 32);
+    *res_lo = (u32) res;
+    *res_hi = (u32) (res >> 32);
 #else
-	u32	d_lo,d_hi,d_sign;
-	u32	s_lo,s_hi,s_sign;
-	u32	rlo_lo,rlo_hi,rhi_lo;
-
-	if ((d_sign = d & 0x80000000) != 0)
-		d = -d;
-	d_lo = d & 0xFFFF;
-	d_hi = d >> 16;
-	if ((s_sign = s & 0x80000000) != 0)
-		s = -s;
-	s_lo = s & 0xFFFF;
-	s_hi = s >> 16;
-	rlo_lo = d_lo * s_lo;
-	rlo_hi = (d_hi * s_lo + d_lo * s_hi) + (rlo_lo >> 16);
-	rhi_lo = d_hi * s_hi + (rlo_hi >> 16);
-	*res_lo = (rlo_hi << 16) | (rlo_lo & 0xFFFF);
-	*res_hi = rhi_lo;
-	if (d_sign != s_sign) {
-		d = ~*res_lo;
-		s = (((d & 0xFFFF) + 1) >> 16) + (d >> 16);
-		*res_lo = ~*res_lo+1;
-		*res_hi = ~*res_hi+(s >> 16);
-		}
+    u32 d_lo, d_hi, d_sign;
+    u32 s_lo, s_hi, s_sign;
+    u32 rlo_lo, rlo_hi, rhi_lo;
+
+    if ((d_sign = d & 0x80000000) != 0)
+        d = -d;
+    d_lo = d & 0xFFFF;
+    d_hi = d >> 16;
+    if ((s_sign = s & 0x80000000) != 0)
+        s = -s;
+    s_lo = s & 0xFFFF;
+    s_hi = s >> 16;
+    rlo_lo = d_lo * s_lo;
+    rlo_hi = (d_hi * s_lo + d_lo * s_hi) + (rlo_lo >> 16);
+    rhi_lo = d_hi * s_hi + (rlo_hi >> 16);
+    *res_lo = (rlo_hi << 16) | (rlo_lo & 0xFFFF);
+    *res_hi = rhi_lo;
+    if (d_sign != s_sign) {
+        d = ~*res_lo;
+        s = (((d & 0xFFFF) + 1) >> 16) + (d >> 16);
+        *res_lo = ~*res_lo + 1;
+        *res_hi = ~*res_hi + (s >> 16);
+    }
 #endif
 }
 
@@ -2117,53 +2235,59 @@ void imul_long_direct(u32 *res_lo, u32* res_hi,u32 d, u32 s)
 REMARKS:
 Implements the IMUL instruction and side effects.
 ****************************************************************************/
-void imul_long(u32 s)
+void
+imul_long(u32 s)
 {
-	imul_long_direct(&M.x86.R_EAX,&M.x86.R_EDX,M.x86.R_EAX,s);
-	if (((M.x86.R_EAX & 0x80000000) == 0 && M.x86.R_EDX == 0x00) ||
-		((M.x86.R_EAX & 0x80000000) != 0 && M.x86.R_EDX == 0xFF)) {
-		CLEAR_FLAG(F_CF);
-		CLEAR_FLAG(F_OF);
-	} else {
-		SET_FLAG(F_CF);
-		SET_FLAG(F_OF);
-	}
+    imul_long_direct(&M.x86.R_EAX, &M.x86.R_EDX, M.x86.R_EAX, s);
+    if (((M.x86.R_EAX & 0x80000000) == 0 && M.x86.R_EDX == 0x00) ||
+        ((M.x86.R_EAX & 0x80000000) != 0 && M.x86.R_EDX == 0xFF)) {
+        CLEAR_FLAG(F_CF);
+        CLEAR_FLAG(F_OF);
+    }
+    else {
+        SET_FLAG(F_CF);
+        SET_FLAG(F_OF);
+    }
 }
 
 /****************************************************************************
 REMARKS:
 Implements the MUL instruction and side effects.
 ****************************************************************************/
-void mul_byte(u8 s)
+void
+mul_byte(u8 s)
 {
-	u16 res = (u16)(M.x86.R_AL * s);
+    u16 res = (u16) (M.x86.R_AL * s);
 
-	M.x86.R_AX = res;
-	if (M.x86.R_AH == 0) {
-		CLEAR_FLAG(F_CF);
-		CLEAR_FLAG(F_OF);
-	} else {
-		SET_FLAG(F_CF);
-		SET_FLAG(F_OF);
-	}
+    M.x86.R_AX = res;
+    if (M.x86.R_AH == 0) {
+        CLEAR_FLAG(F_CF);
+        CLEAR_FLAG(F_OF);
+    }
+    else {
+        SET_FLAG(F_CF);
+        SET_FLAG(F_OF);
+    }
 }
 
 /****************************************************************************
 REMARKS:
 Implements the MUL instruction and side effects.
 ****************************************************************************/
-void mul_word(u16 s)
+void
+mul_word(u16 s)
 {
-	u32 res = M.x86.R_AX * s;
+    u32 res = M.x86.R_AX * s;
 
-	M.x86.R_AX = (u16)res;
-	M.x86.R_DX = (u16)(res >> 16);
-	if (M.x86.R_DX == 0) {
-		CLEAR_FLAG(F_CF);
-		CLEAR_FLAG(F_OF);
-    } else {
-		SET_FLAG(F_CF);
-		SET_FLAG(F_OF);
+    M.x86.R_AX = (u16) res;
+    M.x86.R_DX = (u16) (res >> 16);
+    if (M.x86.R_DX == 0) {
+        CLEAR_FLAG(F_CF);
+        CLEAR_FLAG(F_OF);
+    }
+    else {
+        SET_FLAG(F_CF);
+        SET_FLAG(F_OF);
     }
 }
 
@@ -2171,36 +2295,38 @@ void mul_word(u16 s)
 REMARKS:
 Implements the MUL instruction and side effects.
 ****************************************************************************/
-void mul_long(u32 s)
+void
+mul_long(u32 s)
 {
 #ifdef	__HAS_LONG_LONG__
-	u64 res = (u32)M.x86.R_EAX * (u32)s;
+    u64 res = (u64) M.x86.R_EAX * s;
 
-	M.x86.R_EAX = (u32)res;
-	M.x86.R_EDX = (u32)(res >> 32);
+    M.x86.R_EAX = (u32) res;
+    M.x86.R_EDX = (u32) (res >> 32);
 #else
-	u32	a,a_lo,a_hi;
-	u32	s_lo,s_hi;
-	u32	rlo_lo,rlo_hi,rhi_lo;
-
-	a = M.x86.R_EAX;
-	a_lo = a & 0xFFFF;
-	a_hi = a >> 16;
-	s_lo = s & 0xFFFF;
-	s_hi = s >> 16;
-	rlo_lo = a_lo * s_lo;
-	rlo_hi = (a_hi * s_lo + a_lo * s_hi) + (rlo_lo >> 16);
-	rhi_lo = a_hi * s_hi + (rlo_hi >> 16);
-	M.x86.R_EAX = (rlo_hi << 16) | (rlo_lo & 0xFFFF);
-	M.x86.R_EDX = rhi_lo;
+    u32 a, a_lo, a_hi;
+    u32 s_lo, s_hi;
+    u32 rlo_lo, rlo_hi, rhi_lo;
+
+    a = M.x86.R_EAX;
+    a_lo = a & 0xFFFF;
+    a_hi = a >> 16;
+    s_lo = s & 0xFFFF;
+    s_hi = s >> 16;
+    rlo_lo = a_lo * s_lo;
+    rlo_hi = (a_hi * s_lo + a_lo * s_hi) + (rlo_lo >> 16);
+    rhi_lo = a_hi * s_hi + (rlo_hi >> 16);
+    M.x86.R_EAX = (rlo_hi << 16) | (rlo_lo & 0xFFFF);
+    M.x86.R_EDX = rhi_lo;
 #endif
 
-	if (M.x86.R_EDX == 0) {
-		CLEAR_FLAG(F_CF);
-		CLEAR_FLAG(F_OF);
-	} else {
-		SET_FLAG(F_CF);
-		SET_FLAG(F_OF);
+    if (M.x86.R_EDX == 0) {
+        CLEAR_FLAG(F_CF);
+        CLEAR_FLAG(F_OF);
+    }
+    else {
+        SET_FLAG(F_CF);
+        SET_FLAG(F_OF);
     }
 }
 
@@ -2208,309 +2334,319 @@ void mul_long(u32 s)
 REMARKS:
 Implements the IDIV instruction and side effects.
 ****************************************************************************/
-void idiv_byte(u8 s)
+void
+idiv_byte(u8 s)
 {
     s32 dvd, div, mod;
 
-	dvd = (s16)M.x86.R_AX;
-	if (s == 0) {
-		x86emu_intr_raise(0);
+    dvd = (s16) M.x86.R_AX;
+    if (s == 0) {
+        x86emu_intr_raise(0);
+        return;
+    }
+    div = dvd / (s8) s;
+    mod = dvd % (s8) s;
+    if (abs(div) > 0x7f) {
+        x86emu_intr_raise(0);
         return;
-	}
-	div = dvd / (s8)s;
-	mod = dvd % (s8)s;
-	if (abs(div) > 0x7f) {
-		x86emu_intr_raise(0);
-		return;
-	}
-	M.x86.R_AL = (s8) div;
-	M.x86.R_AH = (s8) mod;
+    }
+    M.x86.R_AL = (s8) div;
+    M.x86.R_AH = (s8) mod;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the IDIV instruction and side effects.
 ****************************************************************************/
-void idiv_word(u16 s)
+void
+idiv_word(u16 s)
 {
-	s32 dvd, div, mod;
+    s32 dvd, div, mod;
 
-	dvd = (((s32)M.x86.R_DX) << 16) | M.x86.R_AX;
-	if (s == 0) {
-		x86emu_intr_raise(0);
-		return;
-	}
-	div = dvd / (s16)s;
-	mod = dvd % (s16)s;
-	if (abs(div) > 0x7fff) {
-		x86emu_intr_raise(0);
-		return;
-	}
-	CLEAR_FLAG(F_CF);
-	CLEAR_FLAG(F_SF);
-	CONDITIONAL_SET_FLAG(div == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(PARITY(mod & 0xff), F_PF);
+    dvd = (((s32) M.x86.R_DX) << 16) | M.x86.R_AX;
+    if (s == 0) {
+        x86emu_intr_raise(0);
+        return;
+    }
+    div = dvd / (s16) s;
+    mod = dvd % (s16) s;
+    if (abs(div) > 0x7fff) {
+        x86emu_intr_raise(0);
+        return;
+    }
+    CLEAR_FLAG(F_CF);
+    CLEAR_FLAG(F_SF);
+    CONDITIONAL_SET_FLAG(div == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(PARITY(mod & 0xff), F_PF);
 
-	M.x86.R_AX = (u16)div;
-	M.x86.R_DX = (u16)mod;
+    M.x86.R_AX = (u16) div;
+    M.x86.R_DX = (u16) mod;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the IDIV instruction and side effects.
 ****************************************************************************/
-void idiv_long(u32 s)
+void
+idiv_long(u32 s)
 {
 #ifdef	__HAS_LONG_LONG__
-	s64 dvd, div, mod;
-
-	dvd = (((s64)M.x86.R_EDX) << 32) | M.x86.R_EAX;
-	if (s == 0) {
-		x86emu_intr_raise(0);
-		return;
-	}
-	div = dvd / (s32)s;
-	mod = dvd % (s32)s;
-	if (abs(div) > 0x7fffffff) {
-		x86emu_intr_raise(0);
-		return;
-	}
+    s64 dvd, div, mod;
+
+    dvd = (((s64) M.x86.R_EDX) << 32) | M.x86.R_EAX;
+    if (s == 0) {
+        x86emu_intr_raise(0);
+        return;
+    }
+    div = dvd / (s32) s;
+    mod = dvd % (s32) s;
+    if (abs(div) > 0x7fffffff) {
+        x86emu_intr_raise(0);
+        return;
+    }
 #else
-	s32 div = 0, mod;
-	s32 h_dvd = M.x86.R_EDX;
-	u32 l_dvd = M.x86.R_EAX;
-	u32 abs_s = s & 0x7FFFFFFF;
-	u32 abs_h_dvd = h_dvd & 0x7FFFFFFF;
-	u32 h_s = abs_s >> 1;
-	u32 l_s = abs_s << 31;
-	int counter = 31;
-	int carry;
-
-	if (s == 0) {
-		x86emu_intr_raise(0);
-		return;
-	}
-	do {
-		div <<= 1;
-		carry = (l_dvd >= l_s) ? 0 : 1;
-		
-		if (abs_h_dvd < (h_s + carry)) {
-			h_s >>= 1;
-			l_s = abs_s << (--counter);
-			continue;
-		} else {
-			abs_h_dvd -= (h_s + carry);
-			l_dvd = carry ? ((0xFFFFFFFF - l_s) + l_dvd + 1)
-				: (l_dvd - l_s);
-			h_s >>= 1;
-			l_s = abs_s << (--counter);
-			div |= 1;
-			continue;
-		}
-		
-	} while (counter > -1);
-	/* overflow */
-	if (abs_h_dvd || (l_dvd > abs_s)) {
-		x86emu_intr_raise(0);
-		return;
-	}
-	/* sign */
-	div |= ((h_dvd & 0x10000000) ^ (s & 0x10000000));
-	mod = l_dvd;
+    s32 div = 0, mod;
+    s32 h_dvd = M.x86.R_EDX;
+    u32 l_dvd = M.x86.R_EAX;
+    u32 abs_s = s & 0x7FFFFFFF;
+    u32 abs_h_dvd = h_dvd & 0x7FFFFFFF;
+    u32 h_s = abs_s >> 1;
+    u32 l_s = abs_s << 31;
+    int counter = 31;
+    int carry;
+
+    if (s == 0) {
+        x86emu_intr_raise(0);
+        return;
+    }
+    do {
+        div <<= 1;
+        carry = (l_dvd >= l_s) ? 0 : 1;
+
+        if (abs_h_dvd < (h_s + carry)) {
+            h_s >>= 1;
+            l_s = abs_s << (--counter);
+            continue;
+        }
+        else {
+            abs_h_dvd -= (h_s + carry);
+            l_dvd = carry ? ((0xFFFFFFFF - l_s) + l_dvd + 1)
+                : (l_dvd - l_s);
+            h_s >>= 1;
+            l_s = abs_s << (--counter);
+            div |= 1;
+            continue;
+        }
+
+    } while (counter > -1);
+    /* overflow */
+    if (abs_h_dvd || (l_dvd > abs_s)) {
+        x86emu_intr_raise(0);
+        return;
+    }
+    /* sign */
+    div |= ((h_dvd & 0x10000000) ^ (s & 0x10000000));
+    mod = l_dvd;
 
 #endif
-	CLEAR_FLAG(F_CF);
-	CLEAR_FLAG(F_AF);
-	CLEAR_FLAG(F_SF);
-	SET_FLAG(F_ZF);
-	CONDITIONAL_SET_FLAG(PARITY(mod & 0xff), F_PF);
+    CLEAR_FLAG(F_CF);
+    CLEAR_FLAG(F_AF);
+    CLEAR_FLAG(F_SF);
+    SET_FLAG(F_ZF);
+    CONDITIONAL_SET_FLAG(PARITY(mod & 0xff), F_PF);
 
-	M.x86.R_EAX = (u32)div;
-	M.x86.R_EDX = (u32)mod;
+    M.x86.R_EAX = (u32) div;
+    M.x86.R_EDX = (u32) mod;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the DIV instruction and side effects.
 ****************************************************************************/
-void div_byte(u8 s)
+void
+div_byte(u8 s)
 {
-	u32 dvd, div, mod;
+    u32 dvd, div, mod;
 
-	dvd = M.x86.R_AX;
+    dvd = M.x86.R_AX;
     if (s == 0) {
-		x86emu_intr_raise(0);
+        x86emu_intr_raise(0);
         return;
     }
-	div = dvd / (u8)s;
-	mod = dvd % (u8)s;
-	if (abs(div) > 0xff) {
-		x86emu_intr_raise(0);
+    div = dvd / (u8) s;
+    mod = dvd % (u8) s;
+    if (abs(div) > 0xff) {
+        x86emu_intr_raise(0);
         return;
-	}
-	M.x86.R_AL = (u8)div;
-	M.x86.R_AH = (u8)mod;
+    }
+    M.x86.R_AL = (u8) div;
+    M.x86.R_AH = (u8) mod;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the DIV instruction and side effects.
 ****************************************************************************/
-void div_word(u16 s)
+void
+div_word(u16 s)
 {
-	u32 dvd, div, mod;
+    u32 dvd, div, mod;
 
-	dvd = (((u32)M.x86.R_DX) << 16) | M.x86.R_AX;
-	if (s == 0) {
-		x86emu_intr_raise(0);
+    dvd = (((u32) M.x86.R_DX) << 16) | M.x86.R_AX;
+    if (s == 0) {
+        x86emu_intr_raise(0);
+        return;
+    }
+    div = dvd / (u16) s;
+    mod = dvd % (u16) s;
+    if (abs(div) > 0xffff) {
+        x86emu_intr_raise(0);
         return;
     }
-	div = dvd / (u16)s;
-	mod = dvd % (u16)s;
-	if (abs(div) > 0xffff) {
-		x86emu_intr_raise(0);
-		return;
-	}
-	CLEAR_FLAG(F_CF);
-	CLEAR_FLAG(F_SF);
-	CONDITIONAL_SET_FLAG(div == 0, F_ZF);
-	CONDITIONAL_SET_FLAG(PARITY(mod & 0xff), F_PF);
+    CLEAR_FLAG(F_CF);
+    CLEAR_FLAG(F_SF);
+    CONDITIONAL_SET_FLAG(div == 0, F_ZF);
+    CONDITIONAL_SET_FLAG(PARITY(mod & 0xff), F_PF);
 
-	M.x86.R_AX = (u16)div;
-	M.x86.R_DX = (u16)mod;
+    M.x86.R_AX = (u16) div;
+    M.x86.R_DX = (u16) mod;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the DIV instruction and side effects.
 ****************************************************************************/
-void div_long(u32 s)
+void
+div_long(u32 s)
 {
 #ifdef	__HAS_LONG_LONG__
-	u64 dvd, div, mod;
-
-	dvd = (((u64)M.x86.R_EDX) << 32) | M.x86.R_EAX;
-	if (s == 0) {
-		x86emu_intr_raise(0);
-		return;
-	}
-	div = dvd / (u32)s;
-	mod = dvd % (u32)s;
-	if (abs(div) > 0xffffffff) {
-		x86emu_intr_raise(0);
-		return;
-	}
+    u64 dvd, div, mod;
+
+    dvd = (((u64) M.x86.R_EDX) << 32) | M.x86.R_EAX;
+    if (s == 0) {
+        x86emu_intr_raise(0);
+        return;
+    }
+    div = dvd / (u32) s;
+    mod = dvd % (u32) s;
+    if (abs(div) > 0xffffffff) {
+        x86emu_intr_raise(0);
+        return;
+    }
 #else
-	s32 div = 0, mod;
-	s32 h_dvd = M.x86.R_EDX;
-	u32 l_dvd = M.x86.R_EAX;
-
-	u32 h_s = s;
-	u32 l_s = 0;
-	int counter = 32;
-	int carry;
-		
-	if (s == 0) {
-		x86emu_intr_raise(0);
-		return;
-	}
-	do {
-		div <<= 1;
-		carry = (l_dvd >= l_s) ? 0 : 1;
-		
-		if (h_dvd < (h_s + carry)) {
-			h_s >>= 1;
-			l_s = s << (--counter);
-			continue;
-		} else {
-			h_dvd -= (h_s + carry);
-			l_dvd = carry ? ((0xFFFFFFFF - l_s) + l_dvd + 1)
-				: (l_dvd - l_s);
-			h_s >>= 1;
-			l_s = s << (--counter);
-			div |= 1;
-			continue;
-		}
-		
-	} while (counter > -1);
-	/* overflow */
-	if (h_dvd || (l_dvd > s)) {
-		x86emu_intr_raise(0);
-		return;
-	}
-	mod = l_dvd;
+    s32 div = 0, mod;
+    s32 h_dvd = M.x86.R_EDX;
+    u32 l_dvd = M.x86.R_EAX;
+
+    u32 h_s = s;
+    u32 l_s = 0;
+    int counter = 32;
+    int carry;
+
+    if (s == 0) {
+        x86emu_intr_raise(0);
+        return;
+    }
+    do {
+        div <<= 1;
+        carry = (l_dvd >= l_s) ? 0 : 1;
+
+        if (h_dvd < (h_s + carry)) {
+            h_s >>= 1;
+            l_s = s << (--counter);
+            continue;
+        }
+        else {
+            h_dvd -= (h_s + carry);
+            l_dvd = carry ? ((0xFFFFFFFF - l_s) + l_dvd + 1)
+                : (l_dvd - l_s);
+            h_s >>= 1;
+            l_s = s << (--counter);
+            div |= 1;
+            continue;
+        }
+
+    } while (counter > -1);
+    /* overflow */
+    if (h_dvd || (l_dvd > s)) {
+        x86emu_intr_raise(0);
+        return;
+    }
+    mod = l_dvd;
 #endif
-	CLEAR_FLAG(F_CF);
-	CLEAR_FLAG(F_AF);
-	CLEAR_FLAG(F_SF);
-	SET_FLAG(F_ZF);
-	CONDITIONAL_SET_FLAG(PARITY(mod & 0xff), F_PF);
+    CLEAR_FLAG(F_CF);
+    CLEAR_FLAG(F_AF);
+    CLEAR_FLAG(F_SF);
+    SET_FLAG(F_ZF);
+    CONDITIONAL_SET_FLAG(PARITY(mod & 0xff), F_PF);
 
-	M.x86.R_EAX = (u32)div;
-	M.x86.R_EDX = (u32)mod;
+    M.x86.R_EAX = (u32) div;
+    M.x86.R_EDX = (u32) mod;
 }
 
 /****************************************************************************
 REMARKS:
 Implements the IN string instruction and side effects.
 ****************************************************************************/
-void ins(int size)
+void
+ins(int size)
 {
-	int inc = size;
+    int inc = size;
 
-	if (ACCESS_FLAG(F_DF)) {
-		inc = -size;
-	}
-	if (M.x86.mode & (SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE)) {
+    if (ACCESS_FLAG(F_DF)) {
+        inc = -size;
+    }
+    if (M.x86.mode & (SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE)) {
         /* dont care whether REPE or REPNE */
         /* in until CX is ZERO. */
-		u32 count = ((M.x86.mode & SYSMODE_PREFIX_DATA) ?
-					 M.x86.R_ECX : M.x86.R_CX);
+        u32 count = ((M.x86.mode & SYSMODE_PREFIX_DATA) ?
+                     M.x86.R_ECX : M.x86.R_CX);
         switch (size) {
-          case 1:
+        case 1:
             while (count--) {
-				store_data_byte_abs(M.x86.R_ES, M.x86.R_DI,
-									(*sys_inb)(M.x86.R_DX));
-				M.x86.R_DI += inc;
+                store_data_byte_abs(M.x86.R_ES, M.x86.R_DI,
+                                    (*sys_inb) (M.x86.R_DX));
+                M.x86.R_DI += inc;
             }
             break;
 
-          case 2:
+        case 2:
             while (count--) {
-				store_data_word_abs(M.x86.R_ES, M.x86.R_DI,
-									(*sys_inw)(M.x86.R_DX));
-				M.x86.R_DI += inc;
+                store_data_word_abs(M.x86.R_ES, M.x86.R_DI,
+                                    (*sys_inw) (M.x86.R_DX));
+                M.x86.R_DI += inc;
             }
             break;
-          case 4:
+        case 4:
             while (count--) {
-				store_data_long_abs(M.x86.R_ES, M.x86.R_DI,
-									(*sys_inl)(M.x86.R_DX));
-				M.x86.R_DI += inc;
+                store_data_long_abs(M.x86.R_ES, M.x86.R_DI,
+                                    (*sys_inl) (M.x86.R_DX));
+                M.x86.R_DI += inc;
+                break;
             }
-            break;
         }
-		M.x86.R_CX = 0;
-		if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-			M.x86.R_ECX = 0;
+        M.x86.R_CX = 0;
+        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
+            M.x86.R_ECX = 0;
         }
-		M.x86.mode &= ~(SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE);
-    } else {
+        M.x86.mode &= ~(SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE);
+    }
+    else {
         switch (size) {
-          case 1:
-			store_data_byte_abs(M.x86.R_ES, M.x86.R_DI,
-								(*sys_inb)(M.x86.R_DX));
+        case 1:
+            store_data_byte_abs(M.x86.R_ES, M.x86.R_DI,
+                                (*sys_inb) (M.x86.R_DX));
             break;
-          case 2:
-			store_data_word_abs(M.x86.R_ES, M.x86.R_DI,
-								(*sys_inw)(M.x86.R_DX));
+        case 2:
+            store_data_word_abs(M.x86.R_ES, M.x86.R_DI,
+                                (*sys_inw) (M.x86.R_DX));
             break;
-          case 4:
-			store_data_long_abs(M.x86.R_ES, M.x86.R_DI,
-								(*sys_inl)(M.x86.R_DX));
+        case 4:
+            store_data_long_abs(M.x86.R_ES, M.x86.R_DI,
+                                (*sys_inl) (M.x86.R_DX));
             break;
         }
-		M.x86.R_DI += inc;
+        M.x86.R_DI += inc;
     }
 }
 
@@ -2518,63 +2654,65 @@ void ins(int size)
 REMARKS:
 Implements the OUT string instruction and side effects.
 ****************************************************************************/
-void outs(int size)
+void
+outs(int size)
 {
     int inc = size;
 
-	if (ACCESS_FLAG(F_DF)) {
+    if (ACCESS_FLAG(F_DF)) {
         inc = -size;
     }
-	if (M.x86.mode & (SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE)) {
+    if (M.x86.mode & (SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE)) {
         /* dont care whether REPE or REPNE */
         /* out until CX is ZERO. */
-		u32 count = ((M.x86.mode & SYSMODE_PREFIX_DATA) ?
-					 M.x86.R_ECX : M.x86.R_CX);
+        u32 count = ((M.x86.mode & SYSMODE_PREFIX_DATA) ?
+                     M.x86.R_ECX : M.x86.R_CX);
         switch (size) {
-          case 1:
+        case 1:
             while (count--) {
-				(*sys_outb)(M.x86.R_DX,
-						 fetch_data_byte_abs(M.x86.R_ES, M.x86.R_SI));
-				M.x86.R_SI += inc;
+                (*sys_outb) (M.x86.R_DX,
+                             fetch_data_byte_abs(M.x86.R_ES, M.x86.R_SI));
+                M.x86.R_SI += inc;
             }
             break;
 
-          case 2:
+        case 2:
             while (count--) {
-				(*sys_outw)(M.x86.R_DX,
-						 fetch_data_word_abs(M.x86.R_ES, M.x86.R_SI));
-				M.x86.R_SI += inc;
+                (*sys_outw) (M.x86.R_DX,
+                             fetch_data_word_abs(M.x86.R_ES, M.x86.R_SI));
+                M.x86.R_SI += inc;
             }
             break;
-          case 4:
+        case 4:
             while (count--) {
-				(*sys_outl)(M.x86.R_DX,
-						 fetch_data_long_abs(M.x86.R_ES, M.x86.R_SI));
-				M.x86.R_SI += inc;
+                (*sys_outl) (M.x86.R_DX,
+                             fetch_data_long_abs(M.x86.R_ES, M.x86.R_SI));
+                M.x86.R_SI += inc;
+                break;
             }
-            break;
         }
-		M.x86.R_CX = 0;
-		if (M.x86.mode & SYSMODE_PREFIX_DATA) {
-			M.x86.R_ECX = 0;
+        M.x86.R_CX = 0;
+        if (M.x86.mode & SYSMODE_PREFIX_DATA) {
+            M.x86.R_ECX = 0;
         }
-		M.x86.mode &= ~(SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE);
-    } else {
+        M.x86.mode &= ~(SYSMODE_PREFIX_REPE | SYSMODE_PREFIX_REPNE);
+    }
+    else {
         switch (size) {
-          case 1:
-			(*sys_outb)(M.x86.R_DX,
-					 fetch_data_byte_abs(M.x86.R_ES, M.x86.R_SI));
+        case 1:
+            (*sys_outb) (M.x86.R_DX,
+                         fetch_data_byte_abs(M.x86.R_ES, M.x86.R_SI));
             break;
-          case 2:
-			(*sys_outw)(M.x86.R_DX,
-					 fetch_data_word_abs(M.x86.R_ES, M.x86.R_SI));
+        case 2:
+            (*sys_outw) (M.x86.R_DX,
+                         fetch_data_word_abs(M.x86.R_ES, M.x86.R_SI));
             break;
-          case 4:
-			(*sys_outl)(M.x86.R_DX,
-					 fetch_data_long_abs(M.x86.R_ES, M.x86.R_SI));
+        case 4:
+            (*sys_outl) (M.x86.R_DX,
+                         fetch_data_long_abs(M.x86.R_ES, M.x86.R_SI));
             break;
         }
-		M.x86.R_SI += inc;
+        M.x86.R_SI += inc;
     }
 }
 
@@ -2585,11 +2723,12 @@ addr	- Address to fetch word from
 REMARKS:
 Fetches a word from emulator memory using an absolute address.
 ****************************************************************************/
-u16 mem_access_word(int addr)
+u16
+mem_access_word(int addr)
 {
-DB(	if (CHECK_MEM_ACCESS())
-	  x86emu_check_mem_access(addr);)
-	return (*sys_rdw)(addr);
+    DB(if (CHECK_MEM_ACCESS())
+       x86emu_check_mem_access(addr);)
+        return (*sys_rdw) (addr);
 }
 
 /****************************************************************************
@@ -2598,12 +2737,13 @@ Pushes a word onto the stack.
 
 NOTE: Do not inline this, as (*sys_wrX) is already inline!
 ****************************************************************************/
-void push_word(u16 w)
+void
+push_word(u16 w)
 {
-DB(	if (CHECK_SP_ACCESS())
-	  x86emu_check_sp_access();)
-	M.x86.R_SP -= 2;
-	(*sys_wrw)(((u32)M.x86.R_SS << 4)  + M.x86.R_SP, w);
+    DB(if (CHECK_SP_ACCESS())
+       x86emu_check_sp_access();)
+        M.x86.R_SP -= 2;
+    (*sys_wrw) (((u32) M.x86.R_SS << 4) + M.x86.R_SP, w);
 }
 
 /****************************************************************************
@@ -2612,12 +2752,13 @@ Pushes a long onto the stack.
 
 NOTE: Do not inline this, as (*sys_wrX) is already inline!
 ****************************************************************************/
-void push_long(u32 w)
+void
+push_long(u32 w)
 {
-DB(	if (CHECK_SP_ACCESS())
-	  x86emu_check_sp_access();)
-	M.x86.R_SP -= 4;
-	(*sys_wrl)(((u32)M.x86.R_SS << 4)  + M.x86.R_SP, w);
+    DB(if (CHECK_SP_ACCESS())
+       x86emu_check_sp_access();)
+        M.x86.R_SP -= 4;
+    (*sys_wrl) (((u32) M.x86.R_SS << 4) + M.x86.R_SP, w);
 }
 
 /****************************************************************************
@@ -2626,15 +2767,16 @@ Pops a word from the stack.
 
 NOTE: Do not inline this, as (*sys_rdX) is already inline!
 ****************************************************************************/
-u16 pop_word(void)
+u16
+pop_word(void)
 {
-	register u16 res;
+    register u16 res;
 
-DB(	if (CHECK_SP_ACCESS())
-	  x86emu_check_sp_access();)
-	res = (*sys_rdw)(((u32)M.x86.R_SS << 4)  + M.x86.R_SP);
-	M.x86.R_SP += 2;
-	return res;
+    DB(if (CHECK_SP_ACCESS())
+       x86emu_check_sp_access();)
+        res = (*sys_rdw) (((u32) M.x86.R_SS << 4) + M.x86.R_SP);
+    M.x86.R_SP += 2;
+    return res;
 }
 
 /****************************************************************************
@@ -2643,14 +2785,15 @@ Pops a long from the stack.
 
 NOTE: Do not inline this, as (*sys_rdX) is already inline!
 ****************************************************************************/
-u32 pop_long(void)
+u32
+pop_long(void)
 {
     register u32 res;
 
-DB(	if (CHECK_SP_ACCESS())
-	  x86emu_check_sp_access();)
-	res = (*sys_rdl)(((u32)M.x86.R_SS << 4)  + M.x86.R_SP);
-	M.x86.R_SP += 4;
+    DB(if (CHECK_SP_ACCESS())
+       x86emu_check_sp_access();)
+        res = (*sys_rdl) (((u32) M.x86.R_SS << 4) + M.x86.R_SP);
+    M.x86.R_SP += 4;
     return res;
 }
 
@@ -2658,45 +2801,59 @@ DB(	if (CHECK_SP_ACCESS())
 REMARKS:
 CPUID takes EAX/ECX as inputs, writes EAX/EBX/ECX/EDX as output
 ****************************************************************************/
-void cpuid (void)
-{
-	u32 feature = M.x86.R_EAX;
-
-	switch (feature) {
-	case 0:
-		/* Regardless if we have real data from the hardware, the emulator
-		 * will only support upto feature 1, which we set in register EAX.
-		 * Registers EBX:EDX:ECX contain a string identifying the CPU.
-		 */
-		M.x86.R_EAX = 1;
-		/* EBX:EDX:ECX = "GenuineIntel" */
-		M.x86.R_EBX = 0x756e6547;
-		M.x86.R_EDX = 0x49656e69;
-		M.x86.R_ECX = 0x6c65746e;
-		break;
-	case 1:
-		/* If we don't have x86 compatible hardware, we return values from an
-		 * Intel 486dx4; which was one of the first processors to have CPUID.
-		 */
-		M.x86.R_EAX = 0x00000480;
-		M.x86.R_EBX = 0x00000000;
-		M.x86.R_ECX = 0x00000000;
-		M.x86.R_EDX = 0x00000002;	/* VME */
-		/* In the case that we have hardware CPUID instruction, we make sure
-		 * that the features reported are limited to TSC and VME.
-		 */
-		M.x86.R_EDX &= 0x00000012;
-		break;
-	default:
-		/* Finally, we don't support any additional features.  Most CPUs
-		 * return all zeros when queried for invalid or unsupported feature
-		 * numbers.
-		 */
-		M.x86.R_EAX = 0;
-		M.x86.R_EBX = 0;
-		M.x86.R_ECX = 0;
-		M.x86.R_EDX = 0;
-		break;
-	}
-}
+void
+cpuid(void)
+{
+    u32 feature = M.x86.R_EAX;
 
+#ifdef X86EMU_HAS_HW_CPUID
+    /* If the platform allows it, we will base our values on the real
+     * results from the CPUID instruction.  We limit support to the
+     * first two features, and the results of those are sanitized.
+     */
+    if (feature <= 1)
+        hw_cpuid(&M.x86.R_EAX, &M.x86.R_EBX, &M.x86.R_ECX, &M.x86.R_EDX);
+#endif
+
+    switch (feature) {
+    case 0:
+        /* Regardless if we have real data from the hardware, the emulator
+         * will only support upto feature 1, which we set in register EAX.
+         * Registers EBX:EDX:ECX contain a string identifying the CPU.
+         */
+        M.x86.R_EAX = 1;
+#ifndef X86EMU_HAS_HW_CPUID
+        /* EBX:EDX:ECX = "GenuineIntel" */
+        M.x86.R_EBX = 0x756e6547;
+        M.x86.R_EDX = 0x49656e69;
+        M.x86.R_ECX = 0x6c65746e;
+#endif
+        break;
+    case 1:
+#ifndef X86EMU_HAS_HW_CPUID
+        /* If we don't have x86 compatible hardware, we return values from an
+         * Intel 486dx4; which was one of the first processors to have CPUID.
+         */
+        M.x86.R_EAX = 0x00000480;
+        M.x86.R_EBX = 0x00000000;
+        M.x86.R_ECX = 0x00000000;
+        M.x86.R_EDX = 0x00000002;       /* VME */
+#else
+        /* In the case that we have hardware CPUID instruction, we make sure
+         * that the features reported are limited to TSC and VME.
+         */
+        M.x86.R_EDX &= 0x00000012;
+#endif
+        break;
+    default:
+        /* Finally, we don't support any additional features.  Most CPUs
+         * return all zeros when queried for invalid or unsupported feature
+         * numbers.
+         */
+        M.x86.R_EAX = 0;
+        M.x86.R_EBX = 0;
+        M.x86.R_ECX = 0;
+        M.x86.R_EDX = 0;
+        break;
+    }
+}
diff --git a/libs/x86emu/sys.c b/libs/x86emu/sys.c
index 4d90ea3..c514dde 100644
--- a/libs/x86emu/sys.c
+++ b/libs/x86emu/sys.c
@@ -47,223 +47,133 @@
 #include "x86emu/prim_ops.h"
 #ifndef NO_SYS_HEADERS
 #include <string.h>
-#endif                                                                                           
-/*------------------------- Global Variables ------------------------------*/
+#endif
 
-X86EMU_sysEnv		_X86EMU_env;		/* Global emulator machine state */
-X86EMU_intrFuncs	_X86EMU_intrTab[256];
+#ifdef __GNUC__
 
-/*----------------------------- Implementation ----------------------------*/
-#if defined(__alpha__) || defined(__alpha)
-/* to cope with broken egcs-1.1.2 :-(((( */
-
-#define ALPHA_UALOADS
-/*
- * inline functions to do unaligned accesses
- * from linux/include/asm-alpha/unaligned.h
- */
-
-/*
- * EGCS 1.1 knows about arbitrary unaligned loads.  Define some
- * packed structures to talk about such things with.
- */
-
-#if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
-struct __una_u64 { unsigned long  x __attribute__((packed)); };
-struct __una_u32 { unsigned int   x __attribute__((packed)); };
-struct __una_u16 { unsigned short x __attribute__((packed)); };
-#endif
+/* Define some packed structures to use with unaligned accesses */
+
+struct __una_u64 {
+    u64 x __attribute__ ((packed));
+};
+struct __una_u32 {
+    u32 x __attribute__ ((packed));
+};
+struct __una_u16 {
+    u16 x __attribute__ ((packed));
+};
+
+/* Elemental unaligned loads */
 
-static __inline__ unsigned long ldq_u(unsigned long * r11)
+static __inline__ u64
+ldq_u(u64 * p)
 {
-#if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
-	const struct __una_u64 *ptr = (const struct __una_u64 *) r11;
-	return ptr->x;
-#else
-	unsigned long r1,r2;
-	__asm__("ldq_u %0,%3\n\t"
-		"ldq_u %1,%4\n\t"
-		"extql %0,%2,%0\n\t"
-		"extqh %1,%2,%1"
-		:"=&r" (r1), "=&r" (r2)
-		:"r" (r11),
-		 "m" (*r11),
-		 "m" (*(const unsigned long *)(7+(char *) r11)));
-	return r1 | r2;
-#endif
+    const struct __una_u64 *ptr = (const struct __una_u64 *) p;
+
+    return ptr->x;
 }
 
-static __inline__ unsigned long ldl_u(unsigned int * r11)
+static __inline__ u32
+ldl_u(u32 * p)
 {
-#if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
-	const struct __una_u32 *ptr = (const struct __una_u32 *) r11;
-	return ptr->x;
-#else
-	unsigned long r1,r2;
-	__asm__("ldq_u %0,%3\n\t"
-		"ldq_u %1,%4\n\t"
-		"extll %0,%2,%0\n\t"
-		"extlh %1,%2,%1"
-		:"=&r" (r1), "=&r" (r2)
-		:"r" (r11),
-		 "m" (*r11),
-		 "m" (*(const unsigned long *)(3+(char *) r11)));
-	return r1 | r2;
-#endif
+    const struct __una_u32 *ptr = (const struct __una_u32 *) p;
+
+    return ptr->x;
 }
 
-static __inline__ unsigned long ldw_u(unsigned short * r11)
+static __inline__ u16
+ldw_u(u16 * p)
 {
-#if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
-	const struct __una_u16 *ptr = (const struct __una_u16 *) r11;
-	return ptr->x;
-#else
-	unsigned long r1,r2;
-	__asm__("ldq_u %0,%3\n\t"
-		"ldq_u %1,%4\n\t"
-		"extwl %0,%2,%0\n\t"
-		"extwh %1,%2,%1"
-		:"=&r" (r1), "=&r" (r2)
-		:"r" (r11),
-		 "m" (*r11),
-		 "m" (*(const unsigned long *)(1+(char *) r11)));
-	return r1 | r2;
-#endif
+    const struct __una_u16 *ptr = (const struct __una_u16 *) p;
+
+    return ptr->x;
 }
 
-/*
- * Elemental unaligned stores 
- */
+/* Elemental unaligned stores */
 
-static __inline__ void stq_u(unsigned long r5, unsigned long * r11)
+static __inline__ void
+stq_u(u64 val, u64 * p)
 {
-#if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
-	struct __una_u64 *ptr = (struct __una_u64 *) r11;
-	ptr->x = r5;
-#else
-	unsigned long r1,r2,r3,r4;
-
-	__asm__("ldq_u %3,%1\n\t"
-		"ldq_u %2,%0\n\t"
-		"insqh %6,%7,%5\n\t"
-		"insql %6,%7,%4\n\t"
-		"mskqh %3,%7,%3\n\t"
-		"mskql %2,%7,%2\n\t"
-		"bis %3,%5,%3\n\t"
-		"bis %2,%4,%2\n\t"
-		"stq_u %3,%1\n\t"
-		"stq_u %2,%0"
-		:"=m" (*r11),
-		 "=m" (*(unsigned long *)(7+(char *) r11)),
-		 "=&r" (r1), "=&r" (r2), "=&r" (r3), "=&r" (r4)
-		:"r" (r5), "r" (r11));
-#endif
+    struct __una_u64 *ptr = (struct __una_u64 *) p;
+
+    ptr->x = val;
 }
 
-static __inline__ void stl_u(unsigned long r5, unsigned int * r11)
+static __inline__ void
+stl_u(u32 val, u32 * p)
 {
-#if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
-	struct __una_u32 *ptr = (struct __una_u32 *) r11;
-	ptr->x = r5;
-#else
-	unsigned long r1,r2,r3,r4;
-
-	__asm__("ldq_u %3,%1\n\t"
-		"ldq_u %2,%0\n\t"
-		"inslh %6,%7,%5\n\t"
-		"insll %6,%7,%4\n\t"
-		"msklh %3,%7,%3\n\t"
-		"mskll %2,%7,%2\n\t"
-		"bis %3,%5,%3\n\t"
-		"bis %2,%4,%2\n\t"
-		"stq_u %3,%1\n\t"
-		"stq_u %2,%0"
-		:"=m" (*r11),
-		 "=m" (*(unsigned long *)(3+(char *) r11)),
-		 "=&r" (r1), "=&r" (r2), "=&r" (r3), "=&r" (r4)
-		:"r" (r5), "r" (r11));
-#endif
+    struct __una_u32 *ptr = (struct __una_u32 *) p;
+
+    ptr->x = val;
 }
 
-static __inline__ void stw_u(unsigned long r5, unsigned short * r11)
+static __inline__ void
+stw_u(u16 val, u16 * p)
 {
-#if defined(__GNUC__) && ((__GNUC__ > 2) || (__GNUC_MINOR__ >= 91))
-	struct __una_u16 *ptr = (struct __una_u16 *) r11;
-	ptr->x = r5;
-#else
-	unsigned long r1,r2,r3,r4;
-
-	__asm__("ldq_u %3,%1\n\t"
-		"ldq_u %2,%0\n\t"
-		"inswh %6,%7,%5\n\t"
-		"inswl %6,%7,%4\n\t"
-		"mskwh %3,%7,%3\n\t"
-		"mskwl %2,%7,%2\n\t"
-		"bis %3,%5,%3\n\t"
-		"bis %2,%4,%2\n\t"
-		"stq_u %3,%1\n\t"
-		"stq_u %2,%0"
-		:"=m" (*r11),
-		 "=m" (*(unsigned long *)(1+(char *) r11)),
-		 "=&r" (r1), "=&r" (r2), "=&r" (r3), "=&r" (r4)
-		:"r" (r5), "r" (r11));
-#endif
+    struct __una_u16 *ptr = (struct __una_u16 *) p;
+
+    ptr->x = val;
 }
+#else                           /* !__GNUC__ */
 
-#elif defined(__GNUC__) && ((__GNUC__ < 3)) && \
-             (defined (__ia64__) || defined (ia64__))
-#define IA64_UALOADS
-/*
- * EGCS 1.1 knows about arbitrary unaligned loads.  Define some
- * packed structures to talk about such things with.
- */
-struct __una_u64 { unsigned long  x __attribute__((packed)); };
-struct __una_u32 { unsigned int   x __attribute__((packed)); };
-struct __una_u16 { unsigned short x __attribute__((packed)); };
-
-static __inline__ unsigned long
-__uldq (const unsigned long * r11)
+static __inline__ u64
+ldq_u(u64 * p)
 {
-    const struct __una_u64 *ptr = (const struct __una_u64 *) r11;
-    return ptr->x;
+    u64 ret;
+
+    memmove(&ret, p, sizeof(*p));
+    return ret;
 }
 
-static __inline__ unsigned long
-uldl (const unsigned int * r11)
+static __inline__ u32
+ldl_u(u32 * p)
 {
-    const struct __una_u32 *ptr = (const struct __una_u32 *) r11;
-    return ptr->x;
+    u32 ret;
+
+    memmove(&ret, p, sizeof(*p));
+    return ret;
 }
 
-static __inline__ unsigned long
-uldw (const unsigned short * r11)
+static __inline__ u16
+ldw_u(u16 * p)
 {
-    const struct __una_u16 *ptr = (const struct __una_u16 *) r11;
-    return ptr->x;
+    u16 ret;
+
+    memmove(&ret, p, sizeof(*p));
+    return ret;
 }
 
 static __inline__ void
-ustq (unsigned long r5, unsigned long * r11)
+stq_u(u64 val, u64 * p)
 {
-    struct __una_u64 *ptr = (struct __una_u64 *) r11;
-    ptr->x = r5;
+    u64 tmp = val;
+
+    memmove(p, &tmp, sizeof(*p));
 }
 
 static __inline__ void
-ustl (unsigned long r5, unsigned int * r11)
+stl_u(u32 val, u32 * p)
 {
-    struct __una_u32 *ptr = (struct __una_u32 *) r11;
-    ptr->x = r5;
+    u32 tmp = val;
+
+    memmove(p, &tmp, sizeof(*p));
 }
 
 static __inline__ void
-ustw (unsigned long r5, unsigned short * r11)
+stw_u(u16 val, u16 * p)
 {
-    struct __una_u16 *ptr = (struct __una_u16 *) r11;
-    ptr->x = r5;
+    u16 tmp = val;
+
+    memmove(p, &tmp, sizeof(*p));
 }
 
-#endif
+#endif                          /* __GNUC__ */
+/*------------------------- Global Variables ------------------------------*/
+
+X86EMU_sysEnv _X86EMU_env;      /* Global emulator machine state */
+X86EMU_intrFuncs _X86EMU_intrTab[256];
+
+/*----------------------------- Implementation ----------------------------*/
 
 /****************************************************************************
 PARAMETERS:
@@ -275,19 +185,20 @@ Byte value read from emulator memory.
 REMARKS:
 Reads a byte value from the emulator memory. 
 ****************************************************************************/
-u8 X86API rdb(
-    u32 addr)
+u8 X86API
+rdb(u32 addr)
 {
-	u8 val;
-
-	if (addr > M.mem_size - 1) {
-		DB(printk("mem_read: address %#lx out of range!\n", addr);)
-		HALT_SYS();
-		}
-	val = *(u8*)(M.mem_base + addr);
-DB(	if (DEBUG_MEM_TRACE())
-		printk("%#08x 1 -> %#x\n", addr, val);)
-	return val;
+    u8 val;
+
+    if (addr > M.mem_size - 1) {
+        DB(printk("mem_read: address %#lx out of range!\n", addr);
+            )
+            HALT_SYS();
+    }
+    val = *(u8 *) (M.mem_base + addr);
+    DB(if (DEBUG_MEM_TRACE())
+       printk("%#08x 1 -> %#x\n", addr, val);)
+        return val;
 }
 
 /****************************************************************************
@@ -300,32 +211,27 @@ Word value read from emulator memory.
 REMARKS:
 Reads a word value from the emulator memory.
 ****************************************************************************/
-u16 X86API rdw(
-	u32 addr)
+u16 X86API
+rdw(u32 addr)
 {
-	u16 val = 0;
+    u16 val = 0;
 
-	if (addr > M.mem_size - 2) {
-		DB(printk("mem_read: address %#lx out of range!\n", addr);)
-		HALT_SYS();
-		}
+    if (addr > M.mem_size - 2) {
+        DB(printk("mem_read: address %#lx out of range!\n", addr);
+            )
+            HALT_SYS();
+    }
 #ifdef __BIG_ENDIAN__
-	if (addr & 0x1) {
-		val = (*(u8*)(M.mem_base + addr) |
-			  (*(u8*)(M.mem_base + addr + 1) << 8));
-		}
-	else
-#endif
-#if defined(ALPHA_UALOADS)
-		val = ldw_u((u16*)(M.mem_base + addr));
-#elif  defined(IA64_UALOADS)
-      val = uldw((u16*)(M.mem_base + addr));
-#else
-		val = *(u16*)(M.mem_base + addr);
+    if (addr & 0x1) {
+        val = (*(u8 *) (M.mem_base + addr) |
+               (*(u8 *) (M.mem_base + addr + 1) << 8));
+    }
+    else
 #endif
-		DB(	if (DEBUG_MEM_TRACE())
-		printk("%#08x 2 -> %#x\n", addr, val);)
-    return val;
+        val = ldw_u((u16 *) (M.mem_base + addr));
+    DB(if (DEBUG_MEM_TRACE())
+       printk("%#08x 2 -> %#x\n", addr, val);)
+        return val;
 }
 
 /****************************************************************************
@@ -337,34 +243,29 @@ Long value read from emulator memory.
 REMARKS:
 Reads a long value from the emulator memory. 
 ****************************************************************************/
-u32 X86API rdl(
-	u32 addr)
+u32 X86API
+rdl(u32 addr)
 {
-	u32 val = 0;
+    u32 val = 0;
 
-	if (addr > M.mem_size - 4) {
-		DB(printk("mem_read: address %#lx out of range!\n", addr);)
-		HALT_SYS();
-		}
+    if (addr > M.mem_size - 4) {
+        DB(printk("mem_read: address %#lx out of range!\n", addr);
+            )
+            HALT_SYS();
+    }
 #ifdef __BIG_ENDIAN__
-	if (addr & 0x3) {
-		val = (*(u8*)(M.mem_base + addr + 0) |
-			  (*(u8*)(M.mem_base + addr + 1) << 8) |
-			  (*(u8*)(M.mem_base + addr + 2) << 16) |
-			  (*(u8*)(M.mem_base + addr + 3) << 24));
-		}
-	else
-#endif
-#if defined(ALPHA_UALOADS)
-		val = ldl_u((u32*)(M.mem_base + addr));
-#elif  defined(IA64_UALOADS)
-        val = uldl((u32*)(M.mem_base + addr));
-#else
-		val = *(u32*)(M.mem_base + addr);
+    if (addr & 0x3) {
+        val = (*(u8 *) (M.mem_base + addr + 0) |
+               (*(u8 *) (M.mem_base + addr + 1) << 8) |
+               (*(u8 *) (M.mem_base + addr + 2) << 16) |
+               (*(u8 *) (M.mem_base + addr + 3) << 24));
+    }
+    else
 #endif
-DB(	if (DEBUG_MEM_TRACE())
-		printk("%#08x 4 -> %#x\n", addr, val);)
-	return val;
+        val = ldl_u((u32 *) (M.mem_base + addr));
+    DB(if (DEBUG_MEM_TRACE())
+       printk("%#08x 4 -> %#x\n", addr, val);)
+        return val;
 }
 
 /****************************************************************************
@@ -375,17 +276,17 @@ val		- Value to store
 REMARKS:
 Writes a byte value to emulator memory.
 ****************************************************************************/
-void X86API wrb(
-	u32 addr,
-	u8 val)
+void X86API
+wrb(u32 addr, u8 val)
 {
-DB(	if (DEBUG_MEM_TRACE())
-		printk("%#08x 1 <- %#x\n", addr, val);)
-    if (addr > M.mem_size - 1) {
-		DB(printk("mem_write: address %#lx out of range!\n", addr);)
-		HALT_SYS();
-		}
-	*(u8*)(M.mem_base + addr) = val;
+    DB(if (DEBUG_MEM_TRACE())
+       printk("%#08x 1 <- %#x\n", addr, val);)
+        if (addr > M.mem_size - 1) {
+            DB(printk("mem_write: address %#lx out of range!\n", addr);
+                )
+                HALT_SYS();
+        }
+    *(u8 *) (M.mem_base + addr) = val;
 }
 
 /****************************************************************************
@@ -396,30 +297,24 @@ val		- Value to store
 REMARKS:
 Writes a word value to emulator memory.
 ****************************************************************************/
-void X86API wrw(
-	u32 addr,
-	u16 val)
+void X86API
+wrw(u32 addr, u16 val)
 {
-DB(	if (DEBUG_MEM_TRACE())
-		printk("%#08x 2 <- %#x\n", addr, val);)
-	if (addr > M.mem_size - 2) {
-		DB(printk("mem_write: address %#lx out of range!\n", addr);)
-		HALT_SYS();
-		}
+    DB(if (DEBUG_MEM_TRACE())
+       printk("%#08x 2 <- %#x\n", addr, val);)
+        if (addr > M.mem_size - 2) {
+            DB(printk("mem_write: address %#lx out of range!\n", addr);
+                )
+                HALT_SYS();
+        }
 #ifdef __BIG_ENDIAN__
-	if (addr & 0x1) {
-		*(u8*)(M.mem_base + addr + 0) = (val >> 0) & 0xff;
-		*(u8*)(M.mem_base + addr + 1) = (val >> 8) & 0xff;
-		}
-	else
-#endif
-#if defined(ALPHA_UALOADS)
-	 stw_u(val,(u16*)(M.mem_base + addr));
-#elif defined(IA64_UALOADS)
-     ustw(val,(u16*)(M.mem_base + addr));
-#else
-	 *(u16*)(M.mem_base + addr) = val;
+    if (addr & 0x1) {
+        *(u8 *) (M.mem_base + addr + 0) = (val >> 0) & 0xff;
+        *(u8 *) (M.mem_base + addr + 1) = (val >> 8) & 0xff;
+    }
+    else
 #endif
+        stw_u(val, (u16 *) (M.mem_base + addr));
 }
 
 /****************************************************************************
@@ -430,32 +325,26 @@ val		- Value to store
 REMARKS:
 Writes a long value to emulator memory. 
 ****************************************************************************/
-void X86API wrl(
-	u32 addr,
-	u32 val)
+void X86API
+wrl(u32 addr, u32 val)
 {
-DB(	if (DEBUG_MEM_TRACE())
-		printk("%#08x 4 <- %#x\n", addr, val);)
-	if (addr > M.mem_size - 4) {
-		DB(printk("mem_write: address %#lx out of range!\n", addr);)
-		HALT_SYS();
-		}
+    DB(if (DEBUG_MEM_TRACE())
+       printk("%#08x 4 <- %#x\n", addr, val);)
+        if (addr > M.mem_size - 4) {
+            DB(printk("mem_write: address %#lx out of range!\n", addr);
+                )
+                HALT_SYS();
+        }
 #ifdef __BIG_ENDIAN__
-	if (addr & 0x1) {
-		*(u8*)(M.mem_base + addr + 0) = (val >>  0) & 0xff;
-		*(u8*)(M.mem_base + addr + 1) = (val >>  8) & 0xff;
-		*(u8*)(M.mem_base + addr + 2) = (val >> 16) & 0xff;
-		*(u8*)(M.mem_base + addr + 3) = (val >> 24) & 0xff;
-		}
-	else
-#endif
-#if defined(ALPHA_UALOADS)
-	 stl_u(val,(u32*)(M.mem_base + addr));
-#elif defined(IA64_UALOADS)
-     ustl(val,(u32*)(M.mem_base + addr));
-#else
-	 *(u32*)(M.mem_base + addr) = val;
+    if (addr & 0x1) {
+        *(u8 *) (M.mem_base + addr + 0) = (val >> 0) & 0xff;
+        *(u8 *) (M.mem_base + addr + 1) = (val >> 8) & 0xff;
+        *(u8 *) (M.mem_base + addr + 2) = (val >> 16) & 0xff;
+        *(u8 *) (M.mem_base + addr + 3) = (val >> 24) & 0xff;
+    }
+    else
 #endif
+        stl_u(val, (u32 *) (M.mem_base + addr));
 }
 
 /****************************************************************************
@@ -466,12 +355,12 @@ RETURN:
 REMARKS:
 Default PIO byte read function. Doesn't perform real inb.
 ****************************************************************************/
-static u8 X86API p_inb(
-	X86EMU_pioAddr addr)
+static u8 X86API
+p_inb(X86EMU_pioAddr addr)
 {
-DB(	if (DEBUG_IO_TRACE())
-		printk("inb %#04x \n", addr);)
-	return 0;
+    DB(if (DEBUG_IO_TRACE())
+       printk("inb %#04x \n", addr);)
+        return 0;
 }
 
 /****************************************************************************
@@ -482,12 +371,12 @@ RETURN:
 REMARKS:
 Default PIO word read function. Doesn't perform real inw.
 ****************************************************************************/
-static u16 X86API p_inw(
-	X86EMU_pioAddr addr)
+static u16 X86API
+p_inw(X86EMU_pioAddr addr)
 {
-DB(	if (DEBUG_IO_TRACE())
-		printk("inw %#04x \n", addr);)
-	return 0;
+    DB(if (DEBUG_IO_TRACE())
+       printk("inw %#04x \n", addr);)
+        return 0;
 }
 
 /****************************************************************************
@@ -498,12 +387,12 @@ RETURN:
 REMARKS:
 Default PIO long read function. Doesn't perform real inl.
 ****************************************************************************/
-static u32 X86API p_inl(
-	X86EMU_pioAddr addr)
+static u32 X86API
+p_inl(X86EMU_pioAddr addr)
 {
-DB(	if (DEBUG_IO_TRACE())
-		printk("inl %#04x \n", addr);)
-	return 0;
+    DB(if (DEBUG_IO_TRACE())
+       printk("inl %#04x \n", addr);)
+        return 0;
 }
 
 /****************************************************************************
@@ -513,13 +402,12 @@ val     - Value to store
 REMARKS:
 Default PIO byte write function. Doesn't perform real outb.
 ****************************************************************************/
-static void X86API p_outb(
-	X86EMU_pioAddr addr,
-	u8 val)
+static void X86API
+p_outb(X86EMU_pioAddr addr, u8 val)
 {
-DB(	if (DEBUG_IO_TRACE())
-		printk("outb %#02x -> %#04x \n", val, addr);)
-    return;
+    DB(if (DEBUG_IO_TRACE())
+       printk("outb %#02x -> %#04x \n", val, addr);)
+        return;
 }
 
 /****************************************************************************
@@ -529,13 +417,12 @@ val     - Value to store
 REMARKS:
 Default PIO word write function. Doesn't perform real outw.
 ****************************************************************************/
-static void X86API p_outw(
-	X86EMU_pioAddr addr,
-	u16 val)
+static void X86API
+p_outw(X86EMU_pioAddr addr, u16 val)
 {
-DB(	if (DEBUG_IO_TRACE())
-		printk("outw %#04x -> %#04x \n", val, addr);)
-	return;
+    DB(if (DEBUG_IO_TRACE())
+       printk("outw %#04x -> %#04x \n", val, addr);)
+        return;
 }
 
 /****************************************************************************
@@ -545,29 +432,29 @@ val     - Value to store
 REMARKS:
 Default PIO ;ong write function. Doesn't perform real outl.
 ****************************************************************************/
-static void X86API p_outl(
-	X86EMU_pioAddr addr,
-	u32 val)
+static void X86API
+p_outl(X86EMU_pioAddr addr, u32 val)
 {
-DB(	if (DEBUG_IO_TRACE())
-		printk("outl %#08x -> %#04x \n", val, addr);)
-    return;
+    DB(if (DEBUG_IO_TRACE())
+       printk("outl %#08x -> %#04x \n", val, addr);)
+        return;
 }
 
 /*------------------------- Global Variables ------------------------------*/
 
-u8  	(X86APIP sys_rdb)(u32 addr) 			            = rdb;
-u16 	(X86APIP sys_rdw)(u32 addr) 			            = rdw;
-u32 	(X86APIP sys_rdl)(u32 addr) 			            = rdl;
-void 	(X86APIP sys_wrb)(u32 addr,u8 val) 		            = wrb;
-void 	(X86APIP sys_wrw)(u32 addr,u16 val) 	            = wrw;
-void 	(X86APIP sys_wrl)(u32 addr,u32 val) 	            = wrl;
-u8  	(X86APIP sys_inb)(X86EMU_pioAddr addr)	            = p_inb;
-u16 	(X86APIP sys_inw)(X86EMU_pioAddr addr)	            = p_inw;
-u32 	(X86APIP sys_inl)(X86EMU_pioAddr addr)              = p_inl;
-void 	(X86APIP sys_outb)(X86EMU_pioAddr addr, u8 val) 	= p_outb;
-void 	(X86APIP sys_outw)(X86EMU_pioAddr addr, u16 val)	= p_outw;
-void 	(X86APIP sys_outl)(X86EMU_pioAddr addr, u32 val)	= p_outl;
+u8(X86APIP sys_rdb) (u32 addr) = rdb;
+u16(X86APIP sys_rdw) (u32 addr) = rdw;
+u32(X86APIP sys_rdl) (u32 addr) = rdl;
+void (X86APIP sys_wrb) (u32 addr, u8 val) = wrb;
+void (X86APIP sys_wrw) (u32 addr, u16 val) = wrw;
+void (X86APIP sys_wrl) (u32 addr, u32 val) = wrl;
+
+u8(X86APIP sys_inb) (X86EMU_pioAddr addr) = p_inb;
+u16(X86APIP sys_inw) (X86EMU_pioAddr addr) = p_inw;
+u32(X86APIP sys_inl) (X86EMU_pioAddr addr) = p_inl;
+void (X86APIP sys_outb) (X86EMU_pioAddr addr, u8 val) = p_outb;
+void (X86APIP sys_outw) (X86EMU_pioAddr addr, u16 val) = p_outw;
+void (X86APIP sys_outl) (X86EMU_pioAddr addr, u32 val) = p_outl;
 
 /*----------------------------- Setup -------------------------------------*/
 
@@ -580,8 +467,8 @@ This function is used to set the pointers to functions which access
 memory space, allowing the user application to override these functions
 and hook them out as necessary for their application.
 ****************************************************************************/
-void X86EMU_setupMemFuncs(
-	X86EMU_memFuncs *funcs)
+void
+X86EMU_setupMemFuncs(X86EMU_memFuncs * funcs)
 {
     sys_rdb = funcs->rdb;
     sys_rdw = funcs->rdw;
@@ -600,8 +487,8 @@ This function is used to set the pointers to functions which access
 I/O space, allowing the user application to override these functions
 and hook them out as necessary for their application.
 ****************************************************************************/
-void X86EMU_setupPioFuncs(
-	X86EMU_pioFuncs *funcs)
+void
+X86EMU_setupPioFuncs(X86EMU_pioFuncs * funcs)
 {
     sys_inb = funcs->inb;
     sys_inw = funcs->inw;
@@ -624,17 +511,17 @@ in the emulator via the interrupt vector table. This allows the application
 to get control when the code being emulated executes specific software
 interrupts.
 ****************************************************************************/
-void X86EMU_setupIntrFuncs(
-	X86EMU_intrFuncs funcs[])
+void
+X86EMU_setupIntrFuncs(X86EMU_intrFuncs funcs[])
 {
     int i;
-    
-	for (i=0; i < 256; i++)
-		_X86EMU_intrTab[i] = NULL;
-	if (funcs) {
-		for (i = 0; i < 256; i++)
-			_X86EMU_intrTab[i] = funcs[i];
-		}
+
+    for (i = 0; i < 256; i++)
+        _X86EMU_intrTab[i] = NULL;
+    if (funcs) {
+        for (i = 0; i < 256; i++)
+            _X86EMU_intrTab[i] = funcs[i];
+    }
 }
 
 /****************************************************************************
@@ -649,15 +536,15 @@ so that the code in the emulator will continue processing the software
 interrupt as per normal. This essentially allows system code to actively
 hook and handle certain software interrupts as necessary.
 ****************************************************************************/
-void X86EMU_prepareForInt(
-	int num)
+void
+X86EMU_prepareForInt(int num)
 {
-    push_word((u16)M.x86.R_FLG);
+    push_word((u16) M.x86.R_FLG);
     CLEAR_FLAG(F_IF);
     CLEAR_FLAG(F_TF);
     push_word(M.x86.R_CS);
     M.x86.R_CS = mem_access_word(num * 4 + 2);
     push_word(M.x86.R_IP);
     M.x86.R_IP = mem_access_word(num * 4);
-	M.x86.intr = 0;
+    M.x86.intr = 0;
 }
diff --git a/libs/x86emu/validate.c b/libs/x86emu/validate.c
index 239f6c1..4c36e1d 100644
--- a/libs/x86emu/validate.c
+++ b/libs/x86emu/validate.c
@@ -591,58 +591,62 @@
         printk("passed\n");                                                 \
 }
 
-void printk(const char *fmt, ...)
+void
+printk(const char *fmt, ...)
 {
     va_list argptr;
+
     va_start(argptr, fmt);
     vfprintf(stdout, fmt, argptr);
     fflush(stdout);
     va_end(argptr);
 }
 
-char * print_flags(char *buf,ulong flags)
+char *
+print_flags(char *buf, ulong flags)
 {
     char *separator = "";
 
     buf[0] = 0;
     if (flags & F_CF) {
-        strcat(buf,separator);
-        strcat(buf,"CF");
+        strcat(buf, separator);
+        strcat(buf, "CF");
         separator = ",";
-        }
+    }
     if (flags & F_PF) {
-        strcat(buf,separator);
-        strcat(buf,"PF");
+        strcat(buf, separator);
+        strcat(buf, "PF");
         separator = ",";
-        }
+    }
     if (flags & F_AF) {
-        strcat(buf,separator);
-        strcat(buf,"AF");
+        strcat(buf, separator);
+        strcat(buf, "AF");
         separator = ",";
-        }
+    }
     if (flags & F_ZF) {
-        strcat(buf,separator);
-        strcat(buf,"ZF");
+        strcat(buf, separator);
+        strcat(buf, "ZF");
         separator = ",";
-        }
+    }
     if (flags & F_SF) {
-        strcat(buf,separator);
-        strcat(buf,"SF");
+        strcat(buf, separator);
+        strcat(buf, "SF");
         separator = ",";
-        }
+    }
     if (flags & F_OF) {
-        strcat(buf,separator);
-        strcat(buf,"OF");
+        strcat(buf, separator);
+        strcat(buf, "OF");
         separator = ",";
-        }
+    }
     if (separator[0] == 0)
-        strcpy(buf,"None");
+        strcpy(buf, "None");
     return buf;
 }
 
-int main(int argc)
+int
+main(int argc)
 {
-    ulong   def_flags;
+    ulong def_flags;
     int trace = false;
 
     if (argc > 1)
@@ -673,7 +677,7 @@ int main(int argc)
     VAL_LONG_LONG_BINARY(cmp_long);
 
     VAL_BYTE_UNARY(daa_byte);
-    VAL_BYTE_UNARY(das_byte);   // Fails for 0x9A (out of range anyway)
+    VAL_BYTE_UNARY(das_byte);   /* Fails for 0x9A (out of range anyway) */
 
     VAL_BYTE_UNARY(dec_byte);
     VAL_WORD_UNARY(dec_word);
diff --git a/libs/x86emu/x86emu.h b/libs/x86emu/x86emu.h
index 795e2d6..501dd91 100644
--- a/libs/x86emu/x86emu.h
+++ b/libs/x86emu/x86emu.h
@@ -56,7 +56,7 @@ typedef int X86EMU_pioAddr;
 /*---------------------- Macros and type definitions ----------------------*/
 
 #ifdef PACK
-# pragma	PACK   /* Don't pack structs with function pointers! */
+#pragma	PACK                    /* Don't pack structs with function pointers! */
 #endif
 
 /****************************************************************************
@@ -81,13 +81,13 @@ outw    - Function to write a word to an I/O port
 outl    - Function to write a dword to an I/O port
 ****************************************************************************/
 typedef struct {
-	u8  	(X86APIP inb)(X86EMU_pioAddr addr);
-	u16 	(X86APIP inw)(X86EMU_pioAddr addr);
-	u32 	(X86APIP inl)(X86EMU_pioAddr addr);
-	void 	(X86APIP outb)(X86EMU_pioAddr addr, u8 val);
-	void 	(X86APIP outw)(X86EMU_pioAddr addr, u16 val);
-	void 	(X86APIP outl)(X86EMU_pioAddr addr, u32 val);
-	} X86EMU_pioFuncs;
+    u8(X86APIP inb) (X86EMU_pioAddr addr);
+    u16(X86APIP inw) (X86EMU_pioAddr addr);
+    u32(X86APIP inl) (X86EMU_pioAddr addr);
+    void (X86APIP outb) (X86EMU_pioAddr addr, u8 val);
+    void (X86APIP outw) (X86EMU_pioAddr addr, u16 val);
+    void (X86APIP outl) (X86EMU_pioAddr addr, u32 val);
+} X86EMU_pioFuncs;
 
 /****************************************************************************
 REMARKS:
@@ -112,13 +112,13 @@ wrw    	- Function to write a word to an address
 wrl    	- Function to write a dword to an address
 ****************************************************************************/
 typedef struct {
-	u8  	(X86APIP rdb)(u32 addr);
-	u16 	(X86APIP rdw)(u32 addr);
-	u32 	(X86APIP rdl)(u32 addr);
-	void 	(X86APIP wrb)(u32 addr, u8 val);
-	void 	(X86APIP wrw)(u32 addr, u16 val);
-	void	(X86APIP wrl)(u32 addr, u32 val);
-	} X86EMU_memFuncs;
+    u8(X86APIP rdb) (u32 addr);
+    u16(X86APIP rdw) (u32 addr);
+    u32(X86APIP rdl) (u32 addr);
+    void (X86APIP wrb) (u32 addr, u8 val);
+    void (X86APIP wrw) (u32 addr, u16 val);
+    void (X86APIP wrl) (u32 addr, u32 val);
+} X86EMU_memFuncs;
 
 /****************************************************************************
   Here are the default memory read and write
@@ -132,29 +132,29 @@ extern void X86API wrw(u32 addr, u16 val);
 extern void X86API wrl(u32 addr, u32 val);
 
 #ifdef END_PACK
-# pragma	END_PACK
+#pragma	END_PACK
 #endif
 
 /*--------------------- type definitions -----------------------------------*/
 
-typedef void (X86APIP X86EMU_intrFuncs)(int num);
+typedef void (X86APIP X86EMU_intrFuncs) (int num);
 extern X86EMU_intrFuncs _X86EMU_intrTab[256];
 
 /*-------------------------- Function Prototypes --------------------------*/
 
 #ifdef  __cplusplus
-extern "C" {            			/* Use "C" linkage when in C++ mode */
+extern "C" {                    /* Use "C" linkage when in C++ mode */
 #endif
 
-void 	X86EMU_setupMemFuncs(X86EMU_memFuncs *funcs);
-void 	X86EMU_setupPioFuncs(X86EMU_pioFuncs *funcs);
-void 	X86EMU_setupIntrFuncs(X86EMU_intrFuncs funcs[]);
-void 	X86EMU_prepareForInt(int num);
+    void X86EMU_setupMemFuncs(X86EMU_memFuncs * funcs);
+    void X86EMU_setupPioFuncs(X86EMU_pioFuncs * funcs);
+    void X86EMU_setupIntrFuncs(X86EMU_intrFuncs funcs[]);
+    void X86EMU_prepareForInt(int num);
 
 /* decode.c */
 
-void 	X86EMU_exec(void);
-void 	X86EMU_halt_sys(void);
+    void X86EMU_exec(void);
+    void X86EMU_halt_sys(void);
 
 #ifdef	DEBUG
 #define	HALT_SYS()	\
@@ -166,8 +166,8 @@ void 	X86EMU_halt_sys(void);
 
 /* Debug options */
 
-#define DEBUG_DECODE_F          0x000001 /* print decoded instruction  */
-#define DEBUG_TRACE_F           0x000002 /* dump regs before/after execution */
+#define DEBUG_DECODE_F          0x000001        /* print decoded instruction  */
+#define DEBUG_TRACE_F           0x000002        /* dump regs before/after execution */
 #define DEBUG_STEP_F            0x000004
 #define DEBUG_DISASSEMBLE_F     0x000008
 #define DEBUG_BREAK_F           0x000010
@@ -175,24 +175,23 @@ void 	X86EMU_halt_sys(void);
 #define DEBUG_SAVE_IP_CS_F      0x000040
 #define DEBUG_FS_F              0x000080
 #define DEBUG_PROC_F            0x000100
-#define DEBUG_SYSINT_F          0x000200 /* bios system interrupts. */
+#define DEBUG_SYSINT_F          0x000200        /* bios system interrupts. */
 #define DEBUG_TRACECALL_F       0x000400
 #define DEBUG_INSTRUMENT_F      0x000800
-#define DEBUG_MEM_TRACE_F       0x001000 
-#define DEBUG_IO_TRACE_F        0x002000 
+#define DEBUG_MEM_TRACE_F       0x001000
+#define DEBUG_IO_TRACE_F        0x002000
 #define DEBUG_TRACECALL_REGS_F  0x004000
-#define DEBUG_DECODE_NOPRINT_F  0x008000 
+#define DEBUG_DECODE_NOPRINT_F  0x008000
 #define DEBUG_EXIT              0x010000
 #define DEBUG_SYS_F             (DEBUG_SVC_F|DEBUG_FS_F|DEBUG_PROC_F)
 
-void 	X86EMU_trace_regs(void);
-void 	X86EMU_trace_xregs(void);
-void 	X86EMU_dump_memory(u16 seg, u16 off, u32 amt);
-int 	X86EMU_trace_on(void);
-int 	X86EMU_trace_off(void);
+    void X86EMU_trace_regs(void);
+    void X86EMU_trace_xregs(void);
+    void X86EMU_dump_memory(u16 seg, u16 off, u32 amt);
+    int X86EMU_trace_on(void);
+    int X86EMU_trace_off(void);
 
 #ifdef  __cplusplus
-}                       			/* End of "C" linkage for C++   	*/
+}                               /* End of "C" linkage for C++           */
 #endif
-
-#endif /* __X86EMU_X86EMU_H */
+#endif                          /* __X86EMU_X86EMU_H */
diff --git a/libs/x86emu/x86emu/debug.h b/libs/x86emu/x86emu/debug.h
index 47aacb6..385b804 100644
--- a/libs/x86emu/x86emu/debug.h
+++ b/libs/x86emu/x86emu/debug.h
@@ -45,65 +45,65 @@
 
 #define CHECK_IP_FETCH_F                0x1
 #define CHECK_SP_ACCESS_F               0x2
-#define CHECK_MEM_ACCESS_F              0x4 /*using regular linear pointer */
-#define CHECK_DATA_ACCESS_F             0x8 /*using segment:offset*/
+#define CHECK_MEM_ACCESS_F              0x4     /*using regular linear pointer */
+#define CHECK_DATA_ACCESS_F             0x8     /*using segment:offset */
 
 #ifdef DEBUG
-# define CHECK_IP_FETCH()              	(M.x86.check & CHECK_IP_FETCH_F)
-# define CHECK_SP_ACCESS()             	(M.x86.check & CHECK_SP_ACCESS_F)
-# define CHECK_MEM_ACCESS()            	(M.x86.check & CHECK_MEM_ACCESS_F)
-# define CHECK_DATA_ACCESS()           	(M.x86.check & CHECK_DATA_ACCESS_F)
+#define CHECK_IP_FETCH()              	(M.x86.check & CHECK_IP_FETCH_F)
+#define CHECK_SP_ACCESS()             	(M.x86.check & CHECK_SP_ACCESS_F)
+#define CHECK_MEM_ACCESS()            	(M.x86.check & CHECK_MEM_ACCESS_F)
+#define CHECK_DATA_ACCESS()           	(M.x86.check & CHECK_DATA_ACCESS_F)
 #else
-# define CHECK_IP_FETCH()
-# define CHECK_SP_ACCESS()
-# define CHECK_MEM_ACCESS()
-# define CHECK_DATA_ACCESS()
+#define CHECK_IP_FETCH()
+#define CHECK_SP_ACCESS()
+#define CHECK_MEM_ACCESS()
+#define CHECK_DATA_ACCESS()
 #endif
 
 #ifdef DEBUG
-# define DEBUG_INSTRUMENT()    	(M.x86.debug & DEBUG_INSTRUMENT_F)
-# define DEBUG_DECODE()        	(M.x86.debug & DEBUG_DECODE_F)
-# define DEBUG_TRACE()         	(M.x86.debug & DEBUG_TRACE_F)
-# define DEBUG_STEP()          	(M.x86.debug & DEBUG_STEP_F)
-# define DEBUG_DISASSEMBLE()   	(M.x86.debug & DEBUG_DISASSEMBLE_F)
-# define DEBUG_BREAK()         	(M.x86.debug & DEBUG_BREAK_F)
-# define DEBUG_SVC()           	(M.x86.debug & DEBUG_SVC_F)
-# define DEBUG_SAVE_IP_CS()     (M.x86.debug & DEBUG_SAVE_IP_CS_F)
-
-# define DEBUG_FS()            	(M.x86.debug & DEBUG_FS_F)
-# define DEBUG_PROC()          	(M.x86.debug & DEBUG_PROC_F)
-# define DEBUG_SYSINT()        	(M.x86.debug & DEBUG_SYSINT_F)
-# define DEBUG_TRACECALL()     	(M.x86.debug & DEBUG_TRACECALL_F)
-# define DEBUG_TRACECALLREGS() 	(M.x86.debug & DEBUG_TRACECALL_REGS_F)
-# define DEBUG_SYS()           	(M.x86.debug & DEBUG_SYS_F)
-# define DEBUG_MEM_TRACE()     	(M.x86.debug & DEBUG_MEM_TRACE_F)
-# define DEBUG_IO_TRACE()      	(M.x86.debug & DEBUG_IO_TRACE_F)
-# define DEBUG_DECODE_NOPRINT() (M.x86.debug & DEBUG_DECODE_NOPRINT_F)
+#define DEBUG_INSTRUMENT()    	(M.x86.debug & DEBUG_INSTRUMENT_F)
+#define DEBUG_DECODE()        	(M.x86.debug & DEBUG_DECODE_F)
+#define DEBUG_TRACE()         	(M.x86.debug & DEBUG_TRACE_F)
+#define DEBUG_STEP()          	(M.x86.debug & DEBUG_STEP_F)
+#define DEBUG_DISASSEMBLE()   	(M.x86.debug & DEBUG_DISASSEMBLE_F)
+#define DEBUG_BREAK()         	(M.x86.debug & DEBUG_BREAK_F)
+#define DEBUG_SVC()           	(M.x86.debug & DEBUG_SVC_F)
+#define DEBUG_SAVE_IP_CS()     (M.x86.debug & DEBUG_SAVE_IP_CS_F)
+
+#define DEBUG_FS()            	(M.x86.debug & DEBUG_FS_F)
+#define DEBUG_PROC()          	(M.x86.debug & DEBUG_PROC_F)
+#define DEBUG_SYSINT()        	(M.x86.debug & DEBUG_SYSINT_F)
+#define DEBUG_TRACECALL()     	(M.x86.debug & DEBUG_TRACECALL_F)
+#define DEBUG_TRACECALLREGS() 	(M.x86.debug & DEBUG_TRACECALL_REGS_F)
+#define DEBUG_SYS()           	(M.x86.debug & DEBUG_SYS_F)
+#define DEBUG_MEM_TRACE()     	(M.x86.debug & DEBUG_MEM_TRACE_F)
+#define DEBUG_IO_TRACE()      	(M.x86.debug & DEBUG_IO_TRACE_F)
+#define DEBUG_DECODE_NOPRINT() (M.x86.debug & DEBUG_DECODE_NOPRINT_F)
 #else
-# define DEBUG_INSTRUMENT()    	0
-# define DEBUG_DECODE()        	0
-# define DEBUG_TRACE()         	0
-# define DEBUG_STEP()          	0
-# define DEBUG_DISASSEMBLE()   	0
-# define DEBUG_BREAK()         	0
-# define DEBUG_SVC()           	0
-# define DEBUG_SAVE_IP_CS()     0
-# define DEBUG_FS()            	0
-# define DEBUG_PROC()          	0
-# define DEBUG_SYSINT()        	0
-# define DEBUG_TRACECALL()     	0
-# define DEBUG_TRACECALLREGS() 	0
-# define DEBUG_SYS()           	0
-# define DEBUG_MEM_TRACE()     	0
-# define DEBUG_IO_TRACE()      	0
-# define DEBUG_DECODE_NOPRINT() 0
+#define DEBUG_INSTRUMENT()    	0
+#define DEBUG_DECODE()        	0
+#define DEBUG_TRACE()         	0
+#define DEBUG_STEP()          	0
+#define DEBUG_DISASSEMBLE()   	0
+#define DEBUG_BREAK()         	0
+#define DEBUG_SVC()           	0
+#define DEBUG_SAVE_IP_CS()     0
+#define DEBUG_FS()            	0
+#define DEBUG_PROC()          	0
+#define DEBUG_SYSINT()        	0
+#define DEBUG_TRACECALL()     	0
+#define DEBUG_TRACECALLREGS() 	0
+#define DEBUG_SYS()           	0
+#define DEBUG_MEM_TRACE()     	0
+#define DEBUG_IO_TRACE()      	0
+#define DEBUG_DECODE_NOPRINT() 0
 #endif
 
 #ifdef DEBUG
 
-# define DECODE_PRINTF(x)     	if (DEBUG_DECODE()) \
+#define DECODE_PRINTF(x)     	if (DEBUG_DECODE()) \
 									x86emu_decode_printf(x)
-# define DECODE_PRINTF2(x,y)  	if (DEBUG_DECODE()) \
+#define DECODE_PRINTF2(x,y)  	if (DEBUG_DECODE()) \
 									x86emu_decode_printf2(x,y)
 
 /*
@@ -123,10 +123,10 @@
 		M.x86.saved_ip = y;                          			\
 	}
 #else
-# define INC_DECODED_INST_LEN(x)
-# define DECODE_PRINTF(x)
-# define DECODE_PRINTF2(x,y)
-# define SAVE_IP_CS(x,y)
+#define INC_DECODED_INST_LEN(x)
+#define DECODE_PRINTF(x)
+#define DECODE_PRINTF2(x,y)
+#define SAVE_IP_CS(x,y)
 #endif
 
 #ifdef DEBUG
@@ -137,13 +137,13 @@
 	}                                                   	\
 	if (DEBUG_TRACE() || DEBUG_DECODE()) X86EMU_trace_regs()
 #else
-# define TRACE_REGS()
+#define TRACE_REGS()
 #endif
 
 #ifdef DEBUG
-# define SINGLE_STEP()		if (DEBUG_STEP()) x86emu_single_step()
+#define SINGLE_STEP()		if (DEBUG_STEP()) x86emu_single_step()
 #else
-# define SINGLE_STEP()
+#define SINGLE_STEP()
 #endif
 
 #define TRACE_AND_STEP()	\
@@ -151,29 +151,29 @@
 	SINGLE_STEP()
 
 #ifdef DEBUG
-# define START_OF_INSTR()
-# define END_OF_INSTR()		EndOfTheInstructionProcedure: x86emu_end_instr();
-# define END_OF_INSTR_NO_TRACE()	x86emu_end_instr();
+#define START_OF_INSTR()
+#define END_OF_INSTR()		EndOfTheInstructionProcedure: x86emu_end_instr();
+#define END_OF_INSTR_NO_TRACE()	x86emu_end_instr();
 #else
-# define START_OF_INSTR()
-# define END_OF_INSTR()
-# define END_OF_INSTR_NO_TRACE()
+#define START_OF_INSTR()
+#define END_OF_INSTR()
+#define END_OF_INSTR_NO_TRACE()
 #endif
 
 #ifdef DEBUG
-# define  CALL_TRACE(u,v,w,x,s)                                 \
+#define  CALL_TRACE(u,v,w,x,s)                                 \
 	if (DEBUG_TRACECALLREGS())									\
 		x86emu_dump_regs();                                     \
 	if (DEBUG_TRACECALL())                                     	\
 		printk("%04x:%04x: CALL %s%04x:%04x\n", u , v, s, w, x);
-# define RETURN_TRACE(n,u,v)                                    \
+#define RETURN_TRACE(n,u,v)                                    \
 	if (DEBUG_TRACECALLREGS())									\
 		x86emu_dump_regs();                                     \
 	if (DEBUG_TRACECALL())                                     	\
 		printk("%04x:%04x: %s\n",u,v,n);
 #else
-# define CALL_TRACE(u,v,w,x,s)
-# define RETURN_TRACE(n,u,v)
+#define CALL_TRACE(u,v,w,x,s)
+#define RETURN_TRACE(n,u,v)
 #endif
 
 #ifdef DEBUG
@@ -185,26 +185,25 @@
 /*-------------------------- Function Prototypes --------------------------*/
 
 #ifdef  __cplusplus
-extern "C" {            			/* Use "C" linkage when in C++ mode */
+extern "C" {                    /* Use "C" linkage when in C++ mode */
 #endif
 
-extern void x86emu_inc_decoded_inst_len (int x);
-extern void x86emu_decode_printf (char *x);
-extern void x86emu_decode_printf2 (char *x, int y);
-extern void x86emu_just_disassemble (void);
-extern void x86emu_single_step (void);
-extern void x86emu_end_instr (void);
-extern void x86emu_dump_regs (void);
-extern void x86emu_dump_xregs (void);
-extern void x86emu_print_int_vect (u16 iv);
-extern void x86emu_instrument_instruction (void);
-extern void x86emu_check_ip_access (void);
-extern void x86emu_check_sp_access (void);
-extern void x86emu_check_mem_access (u32 p);
-extern void x86emu_check_data_access (uint s, uint o);
+    extern void x86emu_inc_decoded_inst_len(int x);
+    extern void x86emu_decode_printf(const char *x);
+    extern void x86emu_decode_printf2(const char *x, int y);
+    extern void x86emu_just_disassemble(void);
+    extern void x86emu_single_step(void);
+    extern void x86emu_end_instr(void);
+    extern void x86emu_dump_regs(void);
+    extern void x86emu_dump_xregs(void);
+    extern void x86emu_print_int_vect(u16 iv);
+    extern void x86emu_instrument_instruction(void);
+    extern void x86emu_check_ip_access(void);
+    extern void x86emu_check_sp_access(void);
+    extern void x86emu_check_mem_access(u32 p);
+    extern void x86emu_check_data_access(uint s, uint o);
 
 #ifdef  __cplusplus
-}                       			/* End of "C" linkage for C++   	*/
+}                               /* End of "C" linkage for C++           */
 #endif
-
-#endif /* __X86EMU_DEBUG_H */
+#endif                          /* __X86EMU_DEBUG_H */
diff --git a/libs/x86emu/x86emu/decode.h b/libs/x86emu/x86emu/decode.h
index 61cd4dc..49a1f7b 100644
--- a/libs/x86emu/x86emu/decode.h
+++ b/libs/x86emu/x86emu/decode.h
@@ -52,37 +52,36 @@
 /*-------------------------- Function Prototypes --------------------------*/
 
 #ifdef  __cplusplus
-extern "C" {            			/* Use "C" linkage when in C++ mode */
+extern "C" {                    /* Use "C" linkage when in C++ mode */
 #endif
 
-void 	x86emu_intr_raise (u8 type);
-void    fetch_decode_modrm (int *mod,int *regh,int *regl);
-u8      fetch_byte_imm (void);
-u16     fetch_word_imm (void);
-u32     fetch_long_imm (void);
-u8      fetch_data_byte (uint offset);
-u8      fetch_data_byte_abs (uint segment, uint offset);
-u16     fetch_data_word (uint offset);
-u16     fetch_data_word_abs (uint segment, uint offset);
-u32     fetch_data_long (uint offset);
-u32     fetch_data_long_abs (uint segment, uint offset);
-void    store_data_byte (uint offset, u8 val);
-void    store_data_byte_abs (uint segment, uint offset, u8 val);
-void    store_data_word (uint offset, u16 val);
-void    store_data_word_abs (uint segment, uint offset, u16 val);
-void    store_data_long (uint offset, u32 val);
-void    store_data_long_abs (uint segment, uint offset, u32 val);
-u8* 	decode_rm_byte_register(int reg);
-u16* 	decode_rm_word_register(int reg);
-u32* 	decode_rm_long_register(int reg);
-u16* 	decode_rm_seg_register(int reg);
-u32	decode_rm00_address(int rm);
-u32	decode_rm01_address(int rm);
-u32	decode_rm10_address(int rm);
-u32	decode_sib_address(int sib, int mod);
+    void x86emu_intr_raise(u8 type);
+    void fetch_decode_modrm(int *mod, int *regh, int *regl);
+    u8 fetch_byte_imm(void);
+    u16 fetch_word_imm(void);
+    u32 fetch_long_imm(void);
+    u8 fetch_data_byte(uint offset);
+    u8 fetch_data_byte_abs(uint segment, uint offset);
+    u16 fetch_data_word(uint offset);
+    u16 fetch_data_word_abs(uint segment, uint offset);
+    u32 fetch_data_long(uint offset);
+    u32 fetch_data_long_abs(uint segment, uint offset);
+    void store_data_byte(uint offset, u8 val);
+    void store_data_byte_abs(uint segment, uint offset, u8 val);
+    void store_data_word(uint offset, u16 val);
+    void store_data_word_abs(uint segment, uint offset, u16 val);
+    void store_data_long(uint offset, u32 val);
+    void store_data_long_abs(uint segment, uint offset, u32 val);
+    u8 *decode_rm_byte_register(int reg);
+    u16 *decode_rm_word_register(int reg);
+    u32 *decode_rm_long_register(int reg);
+    u16 *decode_rm_seg_register(int reg);
+    u32 decode_rm00_address(int rm);
+    u32 decode_rm01_address(int rm);
+    u32 decode_rm10_address(int rm);
+    u32 decode_sib_address(int sib, int mod);
 
 #ifdef  __cplusplus
-}                       			/* End of "C" linkage for C++   	*/
+}                               /* End of "C" linkage for C++           */
 #endif
-
-#endif /* __X86EMU_DECODE_H */
+#endif                          /* __X86EMU_DECODE_H */
diff --git a/libs/x86emu/x86emu/fpu.h b/libs/x86emu/x86emu/fpu.h
index 5fb2714..1c11498 100644
--- a/libs/x86emu/x86emu/fpu.h
+++ b/libs/x86emu/x86emu/fpu.h
@@ -40,22 +40,21 @@
 #define __X86EMU_FPU_H
 
 #ifdef  __cplusplus
-extern "C" {            			/* Use "C" linkage when in C++ mode */
+extern "C" {                    /* Use "C" linkage when in C++ mode */
 #endif
 
 /* these have to be defined, whether 8087 support compiled in or not. */
 
-extern void x86emuOp_esc_coprocess_d8 (u8 op1);
-extern void x86emuOp_esc_coprocess_d9 (u8 op1);
-extern void x86emuOp_esc_coprocess_da (u8 op1);
-extern void x86emuOp_esc_coprocess_db (u8 op1);
-extern void x86emuOp_esc_coprocess_dc (u8 op1);
-extern void x86emuOp_esc_coprocess_dd (u8 op1);
-extern void x86emuOp_esc_coprocess_de (u8 op1);
-extern void x86emuOp_esc_coprocess_df (u8 op1);
+    extern void x86emuOp_esc_coprocess_d8(u8 op1);
+    extern void x86emuOp_esc_coprocess_d9(u8 op1);
+    extern void x86emuOp_esc_coprocess_da(u8 op1);
+    extern void x86emuOp_esc_coprocess_db(u8 op1);
+    extern void x86emuOp_esc_coprocess_dc(u8 op1);
+    extern void x86emuOp_esc_coprocess_dd(u8 op1);
+    extern void x86emuOp_esc_coprocess_de(u8 op1);
+    extern void x86emuOp_esc_coprocess_df(u8 op1);
 
 #ifdef  __cplusplus
-}                       			/* End of "C" linkage for C++   	*/
+}                               /* End of "C" linkage for C++           */
 #endif
-
-#endif /* __X86EMU_FPU_H */
+#endif                          /* __X86EMU_FPU_H */
diff --git a/libs/x86emu/x86emu/fpu_regs.h b/libs/x86emu/x86emu/fpu_regs.h
index e59b807..5a780e6 100644
--- a/libs/x86emu/x86emu/fpu_regs.h
+++ b/libs/x86emu/x86emu/fpu_regs.h
@@ -42,23 +42,23 @@
 #ifdef X86_FPU_SUPPORT
 
 #ifdef PACK
-# pragma PACK
+#pragma PACK
 #endif
 
 /* Basic 8087 register can hold any of the following values: */
 
 union x86_fpu_reg_u {
-    s8                  tenbytes[10];
-    double              dval;
-    float               fval;
-    s16                 sval;
-    s32                 lval;
-	};
+    s8 tenbytes[10];
+    double dval;
+    float fval;
+    s16 sval;
+    s32 lval;
+};
 
 struct x86_fpu_reg {
-	union x86_fpu_reg_u reg;
-	char                tag;
-	};
+    union x86_fpu_reg_u reg;
+    char tag;
+};
 
 /*
  * Since we are not going to worry about the problems of aliasing
@@ -83,14 +83,14 @@ struct x86_fpu_reg {
 #define  X86_FPU_STKTOP  0
 
 struct x86_fpu_registers {
-    struct x86_fpu_reg  x86_fpu_stack[8];
-    int                 x86_fpu_flags;
-    int                 x86_fpu_config;         /* rounding modes, etc. */
-    short               x86_fpu_tos, x86_fpu_bos;
-	};
+    struct x86_fpu_reg x86_fpu_stack[8];
+    int x86_fpu_flags;
+    int x86_fpu_config;         /* rounding modes, etc. */
+    short x86_fpu_tos, x86_fpu_bos;
+};
 
 #ifdef END_PACK
-# pragma END_PACK
+#pragma END_PACK
 #endif
 
 /*
@@ -104,16 +104,16 @@ struct x86_fpu_registers {
  * instructions.
  */
 
-#endif /* X86_FPU_SUPPORT */
+#endif                          /* X86_FPU_SUPPORT */
 
 #ifdef DEBUG
-# define DECODE_PRINTINSTR32(t,mod,rh,rl)     	\
+#define DECODE_PRINTINSTR32(t,mod,rh,rl)     	\
 	DECODE_PRINTF(t[(mod<<3)+(rh)]);
-# define DECODE_PRINTINSTR256(t,mod,rh,rl)    	\
+#define DECODE_PRINTINSTR256(t,mod,rh,rl)    	\
 	DECODE_PRINTF(t[(mod<<6)+(rh<<3)+(rl)]);
 #else
-# define DECODE_PRINTINSTR32(t,mod,rh,rl)
-# define DECODE_PRINTINSTR256(t,mod,rh,rl)
+#define DECODE_PRINTINSTR32(t,mod,rh,rl)
+#define DECODE_PRINTINSTR256(t,mod,rh,rl)
 #endif
 
-#endif /* __X86EMU_FPU_REGS_H */
+#endif                          /* __X86EMU_FPU_REGS_H */
diff --git a/libs/x86emu/x86emu/ops.h b/libs/x86emu/x86emu/ops.h
index 65ea676..1bc07a4 100644
--- a/libs/x86emu/x86emu/ops.h
+++ b/libs/x86emu/x86emu/ops.h
@@ -39,7 +39,7 @@
 #ifndef __X86EMU_OPS_H
 #define __X86EMU_OPS_H
 
-extern void (*x86emu_optab[0x100])(u8 op1);
-extern void (*x86emu_optab2[0x100])(u8 op2);
+extern void (*x86emu_optab[0x100]) (u8 op1);
+extern void (*x86emu_optab2[0x100]) (u8 op2);
 
-#endif /* __X86EMU_OPS_H */
+#endif                          /* __X86EMU_OPS_H */
diff --git a/libs/x86emu/x86emu/prim_asm.h b/libs/x86emu/x86emu/prim_asm.h
index e023cf8..aca132b 100644
--- a/libs/x86emu/x86emu/prim_asm.h
+++ b/libs/x86emu/x86emu/prim_asm.h
@@ -49,14 +49,16 @@
 #define	__HAVE_INLINE_ASSEMBLER__
 #endif
 
-u32		get_flags_asm(void);
+u32 get_flags_asm(void);
+
 #pragma aux get_flags_asm =			\
 	"pushf"                         \
 	"pop	eax"                  	\
 	value [eax]                     \
 	modify exact [eax];
 
-u16     aaa_word_asm(u32 *flags,u16 d);
+u16 aaa_word_asm(u32 * flags, u16 d);
+
 #pragma aux aaa_word_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -67,7 +69,8 @@ u16     aaa_word_asm(u32 *flags,u16 d);
 	value [ax]                      \
 	modify exact [ax];
 
-u16     aas_word_asm(u32 *flags,u16 d);
+u16 aas_word_asm(u32 * flags, u16 d);
+
 #pragma aux aas_word_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -78,7 +81,8 @@ u16     aas_word_asm(u32 *flags,u16 d);
 	value [ax]                      \
 	modify exact [ax];
 
-u16     aad_word_asm(u32 *flags,u16 d);
+u16 aad_word_asm(u32 * flags, u16 d);
+
 #pragma aux aad_word_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -89,7 +93,8 @@ u16     aad_word_asm(u32 *flags,u16 d);
 	value [ax]                      \
 	modify exact [ax];
 
-u16     aam_word_asm(u32 *flags,u8 d);
+u16 aam_word_asm(u32 * flags, u8 d);
+
 #pragma aux aam_word_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -100,7 +105,8 @@ u16     aam_word_asm(u32 *flags,u8 d);
 	value [ax]                      \
 	modify exact [ax];
 
-u8      adc_byte_asm(u32 *flags,u8 d, u8 s);
+u8 adc_byte_asm(u32 * flags, u8 d, u8 s);
+
 #pragma aux adc_byte_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -111,7 +117,8 @@ u8      adc_byte_asm(u32 *flags,u8 d, u8 s);
 	value [al]                      \
 	modify exact [al bl];
 
-u16     adc_word_asm(u32 *flags,u16 d, u16 s);
+u16 adc_word_asm(u32 * flags, u16 d, u16 s);
+
 #pragma aux adc_word_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -122,7 +129,8 @@ u16     adc_word_asm(u32 *flags,u16 d, u16 s);
 	value [ax]                      \
 	modify exact [ax bx];
 
-u32     adc_long_asm(u32 *flags,u32 d, u32 s);
+u32 adc_long_asm(u32 * flags, u32 d, u32 s);
+
 #pragma aux adc_long_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -133,7 +141,8 @@ u32     adc_long_asm(u32 *flags,u32 d, u32 s);
 	value [eax]                     \
 	modify exact [eax ebx];
 
-u8      add_byte_asm(u32 *flags,u8 d, u8 s);
+u8 add_byte_asm(u32 * flags, u8 d, u8 s);
+
 #pragma aux add_byte_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -144,7 +153,8 @@ u8      add_byte_asm(u32 *flags,u8 d, u8 s);
 	value [al]                      \
 	modify exact [al bl];
 
-u16     add_word_asm(u32 *flags,u16 d, u16 s);
+u16 add_word_asm(u32 * flags, u16 d, u16 s);
+
 #pragma aux add_word_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -155,7 +165,8 @@ u16     add_word_asm(u32 *flags,u16 d, u16 s);
 	value [ax]                      \
 	modify exact [ax bx];
 
-u32     add_long_asm(u32 *flags,u32 d, u32 s);
+u32 add_long_asm(u32 * flags, u32 d, u32 s);
+
 #pragma aux add_long_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -166,7 +177,8 @@ u32     add_long_asm(u32 *flags,u32 d, u32 s);
 	value [eax]                     \
 	modify exact [eax ebx];
 
-u8      and_byte_asm(u32 *flags,u8 d, u8 s);
+u8 and_byte_asm(u32 * flags, u8 d, u8 s);
+
 #pragma aux and_byte_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -177,7 +189,8 @@ u8      and_byte_asm(u32 *flags,u8 d, u8 s);
 	value [al]                      \
 	modify exact [al bl];
 
-u16     and_word_asm(u32 *flags,u16 d, u16 s);
+u16 and_word_asm(u32 * flags, u16 d, u16 s);
+
 #pragma aux and_word_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -188,7 +201,8 @@ u16     and_word_asm(u32 *flags,u16 d, u16 s);
 	value [ax]                      \
 	modify exact [ax bx];
 
-u32     and_long_asm(u32 *flags,u32 d, u32 s);
+u32 and_long_asm(u32 * flags, u32 d, u32 s);
+
 #pragma aux and_long_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -199,7 +213,8 @@ u32     and_long_asm(u32 *flags,u32 d, u32 s);
 	value [eax]                     \
 	modify exact [eax ebx];
 
-u8      cmp_byte_asm(u32 *flags,u8 d, u8 s);
+u8 cmp_byte_asm(u32 * flags, u8 d, u8 s);
+
 #pragma aux cmp_byte_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -210,7 +225,8 @@ u8      cmp_byte_asm(u32 *flags,u8 d, u8 s);
 	value [al]                      \
 	modify exact [al bl];
 
-u16     cmp_word_asm(u32 *flags,u16 d, u16 s);
+u16 cmp_word_asm(u32 * flags, u16 d, u16 s);
+
 #pragma aux cmp_word_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -221,7 +237,8 @@ u16     cmp_word_asm(u32 *flags,u16 d, u16 s);
 	value [ax]                      \
 	modify exact [ax bx];
 
-u32     cmp_long_asm(u32 *flags,u32 d, u32 s);
+u32 cmp_long_asm(u32 * flags, u32 d, u32 s);
+
 #pragma aux cmp_long_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -232,7 +249,8 @@ u32     cmp_long_asm(u32 *flags,u32 d, u32 s);
 	value [eax]                     \
 	modify exact [eax ebx];
 
-u8      daa_byte_asm(u32 *flags,u8 d);
+u8 daa_byte_asm(u32 * flags, u8 d);
+
 #pragma aux daa_byte_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -243,7 +261,8 @@ u8      daa_byte_asm(u32 *flags,u8 d);
 	value [al]                      \
 	modify exact [al];
 
-u8      das_byte_asm(u32 *flags,u8 d);
+u8 das_byte_asm(u32 * flags, u8 d);
+
 #pragma aux das_byte_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -254,7 +273,8 @@ u8      das_byte_asm(u32 *flags,u8 d);
 	value [al]                      \
 	modify exact [al];
 
-u8      dec_byte_asm(u32 *flags,u8 d);
+u8 dec_byte_asm(u32 * flags, u8 d);
+
 #pragma aux dec_byte_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -265,7 +285,8 @@ u8      dec_byte_asm(u32 *flags,u8 d);
 	value [al]                      \
 	modify exact [al];
 
-u16     dec_word_asm(u32 *flags,u16 d);
+u16 dec_word_asm(u32 * flags, u16 d);
+
 #pragma aux dec_word_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -276,7 +297,8 @@ u16     dec_word_asm(u32 *flags,u16 d);
 	value [ax]                      \
 	modify exact [ax];
 
-u32     dec_long_asm(u32 *flags,u32 d);
+u32 dec_long_asm(u32 * flags, u32 d);
+
 #pragma aux dec_long_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -287,7 +309,8 @@ u32     dec_long_asm(u32 *flags,u32 d);
 	value [eax]                     \
 	modify exact [eax];
 
-u8      inc_byte_asm(u32 *flags,u8 d);
+u8 inc_byte_asm(u32 * flags, u8 d);
+
 #pragma aux inc_byte_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -298,7 +321,8 @@ u8      inc_byte_asm(u32 *flags,u8 d);
 	value [al]                      \
 	modify exact [al];
 
-u16     inc_word_asm(u32 *flags,u16 d);
+u16 inc_word_asm(u32 * flags, u16 d);
+
 #pragma aux inc_word_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -309,7 +333,8 @@ u16     inc_word_asm(u32 *flags,u16 d);
 	value [ax]                      \
 	modify exact [ax];
 
-u32     inc_long_asm(u32 *flags,u32 d);
+u32 inc_long_asm(u32 * flags, u32 d);
+
 #pragma aux inc_long_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -320,7 +345,8 @@ u32     inc_long_asm(u32 *flags,u32 d);
 	value [eax]                     \
 	modify exact [eax];
 
-u8      or_byte_asm(u32 *flags,u8 d, u8 s);
+u8 or_byte_asm(u32 * flags, u8 d, u8 s);
+
 #pragma aux or_byte_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -331,7 +357,8 @@ u8      or_byte_asm(u32 *flags,u8 d, u8 s);
 	value [al]                      \
 	modify exact [al bl];
 
-u16     or_word_asm(u32 *flags,u16 d, u16 s);
+u16 or_word_asm(u32 * flags, u16 d, u16 s);
+
 #pragma aux or_word_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -342,7 +369,8 @@ u16     or_word_asm(u32 *flags,u16 d, u16 s);
 	value [ax]                      \
 	modify exact [ax bx];
 
-u32     or_long_asm(u32 *flags,u32 d, u32 s);
+u32 or_long_asm(u32 * flags, u32 d, u32 s);
+
 #pragma aux or_long_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -353,7 +381,8 @@ u32     or_long_asm(u32 *flags,u32 d, u32 s);
 	value [eax]                     \
 	modify exact [eax ebx];
 
-u8      neg_byte_asm(u32 *flags,u8 d);
+u8 neg_byte_asm(u32 * flags, u8 d);
+
 #pragma aux neg_byte_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -364,7 +393,8 @@ u8      neg_byte_asm(u32 *flags,u8 d);
 	value [al]                      \
 	modify exact [al];
 
-u16     neg_word_asm(u32 *flags,u16 d);
+u16 neg_word_asm(u32 * flags, u16 d);
+
 #pragma aux neg_word_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -375,7 +405,8 @@ u16     neg_word_asm(u32 *flags,u16 d);
 	value [ax]                      \
 	modify exact [ax];
 
-u32     neg_long_asm(u32 *flags,u32 d);
+u32 neg_long_asm(u32 * flags, u32 d);
+
 #pragma aux neg_long_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -386,7 +417,8 @@ u32     neg_long_asm(u32 *flags,u32 d);
 	value [eax]                     \
 	modify exact [eax];
 
-u8      not_byte_asm(u32 *flags,u8 d);
+u8 not_byte_asm(u32 * flags, u8 d);
+
 #pragma aux not_byte_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -397,7 +429,8 @@ u8      not_byte_asm(u32 *flags,u8 d);
 	value [al]                      \
 	modify exact [al];
 
-u16     not_word_asm(u32 *flags,u16 d);
+u16 not_word_asm(u32 * flags, u16 d);
+
 #pragma aux not_word_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -408,7 +441,8 @@ u16     not_word_asm(u32 *flags,u16 d);
 	value [ax]                      \
 	modify exact [ax];
 
-u32     not_long_asm(u32 *flags,u32 d);
+u32 not_long_asm(u32 * flags, u32 d);
+
 #pragma aux not_long_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -419,7 +453,8 @@ u32     not_long_asm(u32 *flags,u32 d);
 	value [eax]                     \
 	modify exact [eax];
 
-u8      rcl_byte_asm(u32 *flags,u8 d, u8 s);
+u8 rcl_byte_asm(u32 * flags, u8 d, u8 s);
+
 #pragma aux rcl_byte_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -430,7 +465,8 @@ u8      rcl_byte_asm(u32 *flags,u8 d, u8 s);
 	value [al]                      \
 	modify exact [al cl];
 
-u16     rcl_word_asm(u32 *flags,u16 d, u8 s);
+u16 rcl_word_asm(u32 * flags, u16 d, u8 s);
+
 #pragma aux rcl_word_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -441,7 +477,8 @@ u16     rcl_word_asm(u32 *flags,u16 d, u8 s);
 	value [ax]                      \
 	modify exact [ax cl];
 
-u32     rcl_long_asm(u32 *flags,u32 d, u8 s);
+u32 rcl_long_asm(u32 * flags, u32 d, u8 s);
+
 #pragma aux rcl_long_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -452,7 +489,8 @@ u32     rcl_long_asm(u32 *flags,u32 d, u8 s);
 	value [eax]                     \
 	modify exact [eax cl];
 
-u8      rcr_byte_asm(u32 *flags,u8 d, u8 s);
+u8 rcr_byte_asm(u32 * flags, u8 d, u8 s);
+
 #pragma aux rcr_byte_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -463,7 +501,8 @@ u8      rcr_byte_asm(u32 *flags,u8 d, u8 s);
 	value [al]                      \
 	modify exact [al cl];
 
-u16     rcr_word_asm(u32 *flags,u16 d, u8 s);
+u16 rcr_word_asm(u32 * flags, u16 d, u8 s);
+
 #pragma aux rcr_word_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -474,7 +513,8 @@ u16     rcr_word_asm(u32 *flags,u16 d, u8 s);
 	value [ax]                      \
 	modify exact [ax cl];
 
-u32     rcr_long_asm(u32 *flags,u32 d, u8 s);
+u32 rcr_long_asm(u32 * flags, u32 d, u8 s);
+
 #pragma aux rcr_long_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -485,7 +525,8 @@ u32     rcr_long_asm(u32 *flags,u32 d, u8 s);
 	value [eax]                     \
 	modify exact [eax cl];
 
-u8      rol_byte_asm(u32 *flags,u8 d, u8 s);
+u8 rol_byte_asm(u32 * flags, u8 d, u8 s);
+
 #pragma aux rol_byte_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -496,7 +537,8 @@ u8      rol_byte_asm(u32 *flags,u8 d, u8 s);
 	value [al]                      \
 	modify exact [al cl];
 
-u16     rol_word_asm(u32 *flags,u16 d, u8 s);
+u16 rol_word_asm(u32 * flags, u16 d, u8 s);
+
 #pragma aux rol_word_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -507,7 +549,8 @@ u16     rol_word_asm(u32 *flags,u16 d, u8 s);
 	value [ax]                      \
 	modify exact [ax cl];
 
-u32     rol_long_asm(u32 *flags,u32 d, u8 s);
+u32 rol_long_asm(u32 * flags, u32 d, u8 s);
+
 #pragma aux rol_long_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -518,7 +561,8 @@ u32     rol_long_asm(u32 *flags,u32 d, u8 s);
 	value [eax]                     \
 	modify exact [eax cl];
 
-u8      ror_byte_asm(u32 *flags,u8 d, u8 s);
+u8 ror_byte_asm(u32 * flags, u8 d, u8 s);
+
 #pragma aux ror_byte_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -529,7 +573,8 @@ u8      ror_byte_asm(u32 *flags,u8 d, u8 s);
 	value [al]                      \
 	modify exact [al cl];
 
-u16     ror_word_asm(u32 *flags,u16 d, u8 s);
+u16 ror_word_asm(u32 * flags, u16 d, u8 s);
+
 #pragma aux ror_word_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -540,7 +585,8 @@ u16     ror_word_asm(u32 *flags,u16 d, u8 s);
 	value [ax]                      \
 	modify exact [ax cl];
 
-u32     ror_long_asm(u32 *flags,u32 d, u8 s);
+u32 ror_long_asm(u32 * flags, u32 d, u8 s);
+
 #pragma aux ror_long_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -551,7 +597,8 @@ u32     ror_long_asm(u32 *flags,u32 d, u8 s);
 	value [eax]                     \
 	modify exact [eax cl];
 
-u8      shl_byte_asm(u32 *flags,u8 d, u8 s);
+u8 shl_byte_asm(u32 * flags, u8 d, u8 s);
+
 #pragma aux shl_byte_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -562,7 +609,8 @@ u8      shl_byte_asm(u32 *flags,u8 d, u8 s);
 	value [al]                      \
 	modify exact [al cl];
 
-u16     shl_word_asm(u32 *flags,u16 d, u8 s);
+u16 shl_word_asm(u32 * flags, u16 d, u8 s);
+
 #pragma aux shl_word_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -573,7 +621,8 @@ u16     shl_word_asm(u32 *flags,u16 d, u8 s);
 	value [ax]                      \
 	modify exact [ax cl];
 
-u32     shl_long_asm(u32 *flags,u32 d, u8 s);
+u32 shl_long_asm(u32 * flags, u32 d, u8 s);
+
 #pragma aux shl_long_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -584,7 +633,8 @@ u32     shl_long_asm(u32 *flags,u32 d, u8 s);
 	value [eax]                     \
 	modify exact [eax cl];
 
-u8      shr_byte_asm(u32 *flags,u8 d, u8 s);
+u8 shr_byte_asm(u32 * flags, u8 d, u8 s);
+
 #pragma aux shr_byte_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -595,7 +645,8 @@ u8      shr_byte_asm(u32 *flags,u8 d, u8 s);
 	value [al]                      \
 	modify exact [al cl];
 
-u16     shr_word_asm(u32 *flags,u16 d, u8 s);
+u16 shr_word_asm(u32 * flags, u16 d, u8 s);
+
 #pragma aux shr_word_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -606,7 +657,8 @@ u16     shr_word_asm(u32 *flags,u16 d, u8 s);
 	value [ax]                      \
 	modify exact [ax cl];
 
-u32     shr_long_asm(u32 *flags,u32 d, u8 s);
+u32 shr_long_asm(u32 * flags, u32 d, u8 s);
+
 #pragma aux shr_long_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -617,7 +669,8 @@ u32     shr_long_asm(u32 *flags,u32 d, u8 s);
 	value [eax]                     \
 	modify exact [eax cl];
 
-u8      sar_byte_asm(u32 *flags,u8 d, u8 s);
+u8 sar_byte_asm(u32 * flags, u8 d, u8 s);
+
 #pragma aux sar_byte_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -628,7 +681,8 @@ u8      sar_byte_asm(u32 *flags,u8 d, u8 s);
 	value [al]                      \
 	modify exact [al cl];
 
-u16     sar_word_asm(u32 *flags,u16 d, u8 s);
+u16 sar_word_asm(u32 * flags, u16 d, u8 s);
+
 #pragma aux sar_word_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -639,7 +693,8 @@ u16     sar_word_asm(u32 *flags,u16 d, u8 s);
 	value [ax]                      \
 	modify exact [ax cl];
 
-u32     sar_long_asm(u32 *flags,u32 d, u8 s);
+u32 sar_long_asm(u32 * flags, u32 d, u8 s);
+
 #pragma aux sar_long_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -650,7 +705,8 @@ u32     sar_long_asm(u32 *flags,u32 d, u8 s);
 	value [eax]                     \
 	modify exact [eax cl];
 
-u16		shld_word_asm(u32 *flags,u16 d, u16 fill, u8 s);
+u16 shld_word_asm(u32 * flags, u16 d, u16 fill, u8 s);
+
 #pragma aux shld_word_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -661,7 +717,8 @@ u16		shld_word_asm(u32 *flags,u16 d, u16 fill, u8 s);
 	value [ax]                      \
 	modify exact [ax dx cl];
 
-u32     shld_long_asm(u32 *flags,u32 d, u32 fill, u8 s);
+u32 shld_long_asm(u32 * flags, u32 d, u32 fill, u8 s);
+
 #pragma aux shld_long_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -672,7 +729,8 @@ u32     shld_long_asm(u32 *flags,u32 d, u32 fill, u8 s);
 	value [eax]                     \
 	modify exact [eax edx cl];
 
-u16		shrd_word_asm(u32 *flags,u16 d, u16 fill, u8 s);
+u16 shrd_word_asm(u32 * flags, u16 d, u16 fill, u8 s);
+
 #pragma aux shrd_word_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -683,7 +741,8 @@ u16		shrd_word_asm(u32 *flags,u16 d, u16 fill, u8 s);
 	value [ax]                      \
 	modify exact [ax dx cl];
 
-u32     shrd_long_asm(u32 *flags,u32 d, u32 fill, u8 s);
+u32 shrd_long_asm(u32 * flags, u32 d, u32 fill, u8 s);
+
 #pragma aux shrd_long_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -694,7 +753,8 @@ u32     shrd_long_asm(u32 *flags,u32 d, u32 fill, u8 s);
 	value [eax]                     \
 	modify exact [eax edx cl];
 
-u8      sbb_byte_asm(u32 *flags,u8 d, u8 s);
+u8 sbb_byte_asm(u32 * flags, u8 d, u8 s);
+
 #pragma aux sbb_byte_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -705,7 +765,8 @@ u8      sbb_byte_asm(u32 *flags,u8 d, u8 s);
 	value [al]                      \
 	modify exact [al bl];
 
-u16     sbb_word_asm(u32 *flags,u16 d, u16 s);
+u16 sbb_word_asm(u32 * flags, u16 d, u16 s);
+
 #pragma aux sbb_word_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -716,7 +777,8 @@ u16     sbb_word_asm(u32 *flags,u16 d, u16 s);
 	value [ax]                      \
 	modify exact [ax bx];
 
-u32     sbb_long_asm(u32 *flags,u32 d, u32 s);
+u32 sbb_long_asm(u32 * flags, u32 d, u32 s);
+
 #pragma aux sbb_long_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -727,7 +789,8 @@ u32     sbb_long_asm(u32 *flags,u32 d, u32 s);
 	value [eax]                     \
 	modify exact [eax ebx];
 
-u8      sub_byte_asm(u32 *flags,u8 d, u8 s);
+u8 sub_byte_asm(u32 * flags, u8 d, u8 s);
+
 #pragma aux sub_byte_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -738,7 +801,8 @@ u8      sub_byte_asm(u32 *flags,u8 d, u8 s);
 	value [al]                      \
 	modify exact [al bl];
 
-u16     sub_word_asm(u32 *flags,u16 d, u16 s);
+u16 sub_word_asm(u32 * flags, u16 d, u16 s);
+
 #pragma aux sub_word_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -749,7 +813,8 @@ u16     sub_word_asm(u32 *flags,u16 d, u16 s);
 	value [ax]                      \
 	modify exact [ax bx];
 
-u32     sub_long_asm(u32 *flags,u32 d, u32 s);
+u32 sub_long_asm(u32 * flags, u32 d, u32 s);
+
 #pragma aux sub_long_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -760,7 +825,8 @@ u32     sub_long_asm(u32 *flags,u32 d, u32 s);
 	value [eax]                     \
 	modify exact [eax ebx];
 
-void	test_byte_asm(u32 *flags,u8 d, u8 s);
+void test_byte_asm(u32 * flags, u8 d, u8 s);
+
 #pragma aux test_byte_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -770,7 +836,8 @@ void	test_byte_asm(u32 *flags,u8 d, u8 s);
 	parm [edi] [al] [bl]            \
 	modify exact [al bl];
 
-void	test_word_asm(u32 *flags,u16 d, u16 s);
+void test_word_asm(u32 * flags, u16 d, u16 s);
+
 #pragma aux test_word_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -780,7 +847,8 @@ void	test_word_asm(u32 *flags,u16 d, u16 s);
 	parm [edi] [ax] [bx]            \
 	modify exact [ax bx];
 
-void	test_long_asm(u32 *flags,u32 d, u32 s);
+void test_long_asm(u32 * flags, u32 d, u32 s);
+
 #pragma aux test_long_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -790,7 +858,8 @@ void	test_long_asm(u32 *flags,u32 d, u32 s);
 	parm [edi] [eax] [ebx]          \
 	modify exact [eax ebx];
 
-u8      xor_byte_asm(u32 *flags,u8 d, u8 s);
+u8 xor_byte_asm(u32 * flags, u8 d, u8 s);
+
 #pragma aux xor_byte_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -801,7 +870,8 @@ u8      xor_byte_asm(u32 *flags,u8 d, u8 s);
 	value [al]                      \
 	modify exact [al bl];
 
-u16     xor_word_asm(u32 *flags,u16 d, u16 s);
+u16 xor_word_asm(u32 * flags, u16 d, u16 s);
+
 #pragma aux xor_word_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -812,7 +882,8 @@ u16     xor_word_asm(u32 *flags,u16 d, u16 s);
 	value [ax]                      \
 	modify exact [ax bx];
 
-u32     xor_long_asm(u32 *flags,u32 d, u32 s);
+u32 xor_long_asm(u32 * flags, u32 d, u32 s);
+
 #pragma aux xor_long_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -823,7 +894,8 @@ u32     xor_long_asm(u32 *flags,u32 d, u32 s);
 	value [eax]                     \
 	modify exact [eax ebx];
 
-void    imul_byte_asm(u32 *flags,u16 *ax,u8 d,u8 s);
+void imul_byte_asm(u32 * flags, u16 * ax, u8 d, u8 s);
+
 #pragma aux imul_byte_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -834,7 +906,8 @@ void    imul_byte_asm(u32 *flags,u16 *ax,u8 d,u8 s);
 	parm [edi] [esi] [al] [bl]      \
 	modify exact [esi ax bl];
 
-void    imul_word_asm(u32 *flags,u16 *ax,u16 *dx,u16 d,u16 s);
+void imul_word_asm(u32 * flags, u16 * ax, u16 * dx, u16 d, u16 s);
+
 #pragma aux imul_word_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -846,7 +919,8 @@ void    imul_word_asm(u32 *flags,u16 *ax,u16 *dx,u16 d,u16 s);
 	parm [edi] [esi] [ecx] [ax] [bx]\
 	modify exact [esi edi ax bx dx];
 
-void    imul_long_asm(u32 *flags,u32 *eax,u32 *edx,u32 d,u32 s);
+void imul_long_asm(u32 * flags, u32 * eax, u32 * edx, u32 d, u32 s);
+
 #pragma aux imul_long_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -858,7 +932,8 @@ void    imul_long_asm(u32 *flags,u32 *eax,u32 *edx,u32 d,u32 s);
 	parm [edi] [esi] [ecx] [eax] [ebx] \
 	modify exact [esi edi eax ebx edx];
 
-void    mul_byte_asm(u32 *flags,u16 *ax,u8 d,u8 s);
+void mul_byte_asm(u32 * flags, u16 * ax, u8 d, u8 s);
+
 #pragma aux mul_byte_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -869,7 +944,8 @@ void    mul_byte_asm(u32 *flags,u16 *ax,u8 d,u8 s);
 	parm [edi] [esi] [al] [bl]      \
 	modify exact [esi ax bl];
 
-void    mul_word_asm(u32 *flags,u16 *ax,u16 *dx,u16 d,u16 s);
+void mul_word_asm(u32 * flags, u16 * ax, u16 * dx, u16 d, u16 s);
+
 #pragma aux mul_word_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -881,7 +957,8 @@ void    mul_word_asm(u32 *flags,u16 *ax,u16 *dx,u16 d,u16 s);
 	parm [edi] [esi] [ecx] [ax] [bx]\
 	modify exact [esi edi ax bx dx];
 
-void    mul_long_asm(u32 *flags,u32 *eax,u32 *edx,u32 d,u32 s);
+void mul_long_asm(u32 * flags, u32 * eax, u32 * edx, u32 d, u32 s);
+
 #pragma aux mul_long_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -893,7 +970,8 @@ void    mul_long_asm(u32 *flags,u32 *eax,u32 *edx,u32 d,u32 s);
 	parm [edi] [esi] [ecx] [eax] [ebx] \
 	modify exact [esi edi eax ebx edx];
 
-void	idiv_byte_asm(u32 *flags,u8 *al,u8 *ah,u16 d,u8 s);
+void idiv_byte_asm(u32 * flags, u8 * al, u8 * ah, u16 d, u8 s);
+
 #pragma aux idiv_byte_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -905,7 +983,8 @@ void	idiv_byte_asm(u32 *flags,u8 *al,u8 *ah,u16 d,u8 s);
 	parm [edi] [esi] [ecx] [ax] [bl]\
 	modify exact [esi edi ax bl];
 
-void	idiv_word_asm(u32 *flags,u16 *ax,u16 *dx,u16 dlo,u16 dhi,u16 s);
+void idiv_word_asm(u32 * flags, u16 * ax, u16 * dx, u16 dlo, u16 dhi, u16 s);
+
 #pragma aux idiv_word_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -917,7 +996,8 @@ void	idiv_word_asm(u32 *flags,u16 *ax,u16 *dx,u16 dlo,u16 dhi,u16 s);
 	parm [edi] [esi] [ecx] [ax] [dx] [bx]\
 	modify exact [esi edi ax dx bx];
 
-void	idiv_long_asm(u32 *flags,u32 *eax,u32 *edx,u32 dlo,u32 dhi,u32 s);
+void idiv_long_asm(u32 * flags, u32 * eax, u32 * edx, u32 dlo, u32 dhi, u32 s);
+
 #pragma aux idiv_long_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -929,7 +1009,8 @@ void	idiv_long_asm(u32 *flags,u32 *eax,u32 *edx,u32 dlo,u32 dhi,u32 s);
 	parm [edi] [esi] [ecx] [eax] [edx] [ebx]\
 	modify exact [esi edi eax edx ebx];
 
-void	div_byte_asm(u32 *flags,u8 *al,u8 *ah,u16 d,u8 s);
+void div_byte_asm(u32 * flags, u8 * al, u8 * ah, u16 d, u8 s);
+
 #pragma aux div_byte_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -941,7 +1022,8 @@ void	div_byte_asm(u32 *flags,u8 *al,u8 *ah,u16 d,u8 s);
 	parm [edi] [esi] [ecx] [ax] [bl]\
 	modify exact [esi edi ax bl];
 
-void	div_word_asm(u32 *flags,u16 *ax,u16 *dx,u16 dlo,u16 dhi,u16 s);
+void div_word_asm(u32 * flags, u16 * ax, u16 * dx, u16 dlo, u16 dhi, u16 s);
+
 #pragma aux div_word_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -953,7 +1035,8 @@ void	div_word_asm(u32 *flags,u16 *ax,u16 *dx,u16 dlo,u16 dhi,u16 s);
 	parm [edi] [esi] [ecx] [ax] [dx] [bx]\
 	modify exact [esi edi ax dx bx];
 
-void	div_long_asm(u32 *flags,u32 *eax,u32 *edx,u32 dlo,u32 dhi,u32 s);
+void div_long_asm(u32 * flags, u32 * eax, u32 * edx, u32 dlo, u32 dhi, u32 s);
+
 #pragma aux div_long_asm =			\
 	"push	[edi]"            		\
 	"popf"                         	\
@@ -967,4 +1050,4 @@ void	div_long_asm(u32 *flags,u32 *eax,u32 *edx,u32 dlo,u32 dhi,u32 s);
 
 #endif
 
-#endif /* __X86EMU_PRIM_ASM_H */
+#endif                          /* __X86EMU_PRIM_ASM_H */
diff --git a/libs/x86emu/x86emu/prim_ops.h b/libs/x86emu/x86emu/prim_ops.h
index bea8357..0f0e78d 100644
--- a/libs/x86emu/x86emu/prim_ops.h
+++ b/libs/x86emu/x86emu/prim_ops.h
@@ -40,102 +40,102 @@
 #define __X86EMU_PRIM_OPS_H
 
 #ifdef  __cplusplus
-extern "C" {            			/* Use "C" linkage when in C++ mode */
+extern "C" {                    /* Use "C" linkage when in C++ mode */
 #endif
 
-u16     aaa_word (u16 d);
-u16     aas_word (u16 d);
-u16     aad_word (u16 d);
-u16     aam_word (u8 d);
-u8      adc_byte (u8 d, u8 s);
-u16     adc_word (u16 d, u16 s);
-u32     adc_long (u32 d, u32 s);
-u8      add_byte (u8 d, u8 s);
-u16     add_word (u16 d, u16 s);
-u32     add_long (u32 d, u32 s);
-u8      and_byte (u8 d, u8 s);
-u16     and_word (u16 d, u16 s);
-u32     and_long (u32 d, u32 s);
-u8      cmp_byte (u8 d, u8 s);
-u16     cmp_word (u16 d, u16 s);
-u32     cmp_long (u32 d, u32 s);
-u8      daa_byte (u8 d);
-u8      das_byte (u8 d);
-u8      dec_byte (u8 d);
-u16     dec_word (u16 d);
-u32     dec_long (u32 d);
-u8      inc_byte (u8 d);
-u16     inc_word (u16 d);
-u32     inc_long (u32 d);
-u8      or_byte (u8 d, u8 s);
-u16     or_word (u16 d, u16 s);
-u32     or_long (u32 d, u32 s);
-u8      neg_byte (u8 s);
-u16     neg_word (u16 s);
-u32     neg_long (u32 s);
-u8      not_byte (u8 s);
-u16     not_word (u16 s);
-u32     not_long (u32 s);
-u8      rcl_byte (u8 d, u8 s);
-u16     rcl_word (u16 d, u8 s);
-u32     rcl_long (u32 d, u8 s);
-u8      rcr_byte (u8 d, u8 s);
-u16     rcr_word (u16 d, u8 s);
-u32     rcr_long (u32 d, u8 s);
-u8      rol_byte (u8 d, u8 s);
-u16     rol_word (u16 d, u8 s);
-u32     rol_long (u32 d, u8 s);
-u8      ror_byte (u8 d, u8 s);
-u16     ror_word (u16 d, u8 s);
-u32     ror_long (u32 d, u8 s);
-u8      shl_byte (u8 d, u8 s);
-u16     shl_word (u16 d, u8 s);
-u32     shl_long (u32 d, u8 s);
-u8      shr_byte (u8 d, u8 s);
-u16     shr_word (u16 d, u8 s);
-u32     shr_long (u32 d, u8 s);
-u8      sar_byte (u8 d, u8 s);
-u16     sar_word (u16 d, u8 s);
-u32     sar_long (u32 d, u8 s);
-u16     shld_word (u16 d, u16 fill, u8 s);
-u32     shld_long (u32 d, u32 fill, u8 s);
-u16     shrd_word (u16 d, u16 fill, u8 s);
-u32     shrd_long (u32 d, u32 fill, u8 s);
-u8      sbb_byte (u8 d, u8 s);
-u16     sbb_word (u16 d, u16 s);
-u32     sbb_long (u32 d, u32 s);
-u8      sub_byte (u8 d, u8 s);
-u16     sub_word (u16 d, u16 s);
-u32     sub_long (u32 d, u32 s);
-void    test_byte (u8 d, u8 s);
-void    test_word (u16 d, u16 s);
-void    test_long (u32 d, u32 s);
-u8      xor_byte (u8 d, u8 s);
-u16     xor_word (u16 d, u16 s);
-u32     xor_long (u32 d, u32 s);
-void    imul_byte (u8 s);
-void    imul_word (u16 s);
-void    imul_long (u32 s);
-void 	imul_long_direct(u32 *res_lo, u32* res_hi,u32 d, u32 s);
-void    mul_byte (u8 s);
-void    mul_word (u16 s);
-void    mul_long (u32 s);
-void    idiv_byte (u8 s);
-void    idiv_word (u16 s);
-void    idiv_long (u32 s);
-void    div_byte (u8 s);
-void    div_word (u16 s);
-void    div_long (u32 s);
-void    ins (int size);
-void    outs (int size);
-u16     mem_access_word (int addr);
-void    push_word (u16 w);
-void    push_long (u32 w);
-u16     pop_word (void);
-u32		pop_long (void);
+    u16 aaa_word(u16 d);
+    u16 aas_word(u16 d);
+    u16 aad_word(u16 d);
+    u16 aam_word(u8 d);
+    u8 adc_byte(u8 d, u8 s);
+    u16 adc_word(u16 d, u16 s);
+    u32 adc_long(u32 d, u32 s);
+    u8 add_byte(u8 d, u8 s);
+    u16 add_word(u16 d, u16 s);
+    u32 add_long(u32 d, u32 s);
+    u8 and_byte(u8 d, u8 s);
+    u16 and_word(u16 d, u16 s);
+    u32 and_long(u32 d, u32 s);
+    u8 cmp_byte(u8 d, u8 s);
+    u16 cmp_word(u16 d, u16 s);
+    u32 cmp_long(u32 d, u32 s);
+    u8 daa_byte(u8 d);
+    u8 das_byte(u8 d);
+    u8 dec_byte(u8 d);
+    u16 dec_word(u16 d);
+    u32 dec_long(u32 d);
+    u8 inc_byte(u8 d);
+    u16 inc_word(u16 d);
+    u32 inc_long(u32 d);
+    u8 or_byte(u8 d, u8 s);
+    u16 or_word(u16 d, u16 s);
+    u32 or_long(u32 d, u32 s);
+    u8 neg_byte(u8 s);
+    u16 neg_word(u16 s);
+    u32 neg_long(u32 s);
+    u8 not_byte(u8 s);
+    u16 not_word(u16 s);
+    u32 not_long(u32 s);
+    u8 rcl_byte(u8 d, u8 s);
+    u16 rcl_word(u16 d, u8 s);
+    u32 rcl_long(u32 d, u8 s);
+    u8 rcr_byte(u8 d, u8 s);
+    u16 rcr_word(u16 d, u8 s);
+    u32 rcr_long(u32 d, u8 s);
+    u8 rol_byte(u8 d, u8 s);
+    u16 rol_word(u16 d, u8 s);
+    u32 rol_long(u32 d, u8 s);
+    u8 ror_byte(u8 d, u8 s);
+    u16 ror_word(u16 d, u8 s);
+    u32 ror_long(u32 d, u8 s);
+    u8 shl_byte(u8 d, u8 s);
+    u16 shl_word(u16 d, u8 s);
+    u32 shl_long(u32 d, u8 s);
+    u8 shr_byte(u8 d, u8 s);
+    u16 shr_word(u16 d, u8 s);
+    u32 shr_long(u32 d, u8 s);
+    u8 sar_byte(u8 d, u8 s);
+    u16 sar_word(u16 d, u8 s);
+    u32 sar_long(u32 d, u8 s);
+    u16 shld_word(u16 d, u16 fill, u8 s);
+    u32 shld_long(u32 d, u32 fill, u8 s);
+    u16 shrd_word(u16 d, u16 fill, u8 s);
+    u32 shrd_long(u32 d, u32 fill, u8 s);
+    u8 sbb_byte(u8 d, u8 s);
+    u16 sbb_word(u16 d, u16 s);
+    u32 sbb_long(u32 d, u32 s);
+    u8 sub_byte(u8 d, u8 s);
+    u16 sub_word(u16 d, u16 s);
+    u32 sub_long(u32 d, u32 s);
+    void test_byte(u8 d, u8 s);
+    void test_word(u16 d, u16 s);
+    void test_long(u32 d, u32 s);
+    u8 xor_byte(u8 d, u8 s);
+    u16 xor_word(u16 d, u16 s);
+    u32 xor_long(u32 d, u32 s);
+    void imul_byte(u8 s);
+    void imul_word(u16 s);
+    void imul_long(u32 s);
+    void imul_long_direct(u32 * res_lo, u32 * res_hi, u32 d, u32 s);
+    void mul_byte(u8 s);
+    void mul_word(u16 s);
+    void mul_long(u32 s);
+    void idiv_byte(u8 s);
+    void idiv_word(u16 s);
+    void idiv_long(u32 s);
+    void div_byte(u8 s);
+    void div_word(u16 s);
+    void div_long(u32 s);
+    void ins(int size);
+    void outs(int size);
+    u16 mem_access_word(int addr);
+    void push_word(u16 w);
+    void push_long(u32 w);
+    u16 pop_word(void);
+    u32 pop_long(void);
+    void cpuid(void);
 
 #ifdef  __cplusplus
-}                       			/* End of "C" linkage for C++   	*/
+}                               /* End of "C" linkage for C++           */
 #endif
-
-#endif /* __X86EMU_PRIM_OPS_H */
+#endif                          /* __X86EMU_PRIM_OPS_H */
diff --git a/libs/x86emu/x86emu/prim_x86_gcc.h b/libs/x86emu/x86emu/prim_x86_gcc.h
new file mode 100644
index 0000000..646ec9d
--- /dev/null
+++ b/libs/x86emu/x86emu/prim_x86_gcc.h
@@ -0,0 +1,77 @@
+/****************************************************************************
+*
+* Inline helpers for x86emu
+*
+* Copyright (C) 2008 Bart Trojanowski, Symbio Technologies, LLC
+*
+*  ========================================================================
+*
+*  Permission to use, copy, modify, distribute, and sell this software and
+*  its documentation for any purpose is hereby granted without fee,
+*  provided that the above copyright notice appear in all copies and that
+*  both that copyright notice and this permission notice appear in
+*  supporting documentation, and that the name of the authors not be used
+*  in advertising or publicity pertaining to distribution of the software
+*  without specific, written prior permission.  The authors makes no
+*  representations about the suitability of this software for any purpose.
+*  It is provided "as is" without express or implied warranty.
+*
+*  THE AUTHORS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+*  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+*  EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+*  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
+*  USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
+*  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+*  PERFORMANCE OF THIS SOFTWARE.
+*
+*  ========================================================================
+*
+* Language:     GNU C
+* Environment:  GCC on i386 or x86-64
+* Developer:    Bart Trojanowski
+*
+* Description:  This file defines a few x86 macros that can be used by the
+*               emulator to execute native instructions.
+*
+*               For PIC vs non-PIC code refer to:
+*               http://sam.zoy.org/blog/2007-04-13-shlib-with-non-pic-code-have-inline-assembly-and-pic-mix-well
+*
+****************************************************************************/
+#ifndef __X86EMU_PRIM_X86_GCC_H
+#define __X86EMU_PRIM_X86_GCC_H
+
+#include "x86emu/types.h"
+
+#if !defined(__GNUC__) || !(defined (__i386__) || defined(__i386) || defined(__AMD64__) || defined(__amd64__))
+#error This file is intended to be used by gcc on i386 or x86-64 system
+#endif
+
+#if defined(__PIC__) && defined(__i386__)
+
+#define X86EMU_HAS_HW_CPUID 1
+static inline void
+hw_cpuid(u32 * a, u32 * b, u32 * c, u32 * d)
+{
+    __asm__ __volatile__("pushl %%ebx      \n\t"
+                         "cpuid            \n\t"
+                         "movl %%ebx, %1   \n\t"
+                         "popl %%ebx       \n\t":"=a"(*a), "=r"(*b),
+                         "=c"(*c), "=d"(*d)
+                         :"a"(*a), "c"(*c)
+                         :"cc");
+}
+
+#else                           /* ! (__PIC__ && __i386__) */
+
+#define x86EMU_HAS_HW_CPUID 1
+static inline void
+hw_cpuid(u32 * a, u32 * b, u32 * c, u32 * d)
+{
+    __asm__ __volatile__("cpuid":"=a"(*a), "=b"(*b), "=c"(*c), "=d"(*d)
+                         :"a"(*a), "c"(*c)
+                         :"cc");
+}
+
+#endif                          /* __PIC__ && __i386__ */
+
+#endif                          /* __X86EMU_PRIM_X86_GCC_H */
diff --git a/libs/x86emu/x86emu/regs.h b/libs/x86emu/x86emu/regs.h
index 52cf8e4..6bd0611 100644
--- a/libs/x86emu/x86emu/regs.h
+++ b/libs/x86emu/x86emu/regs.h
@@ -42,7 +42,7 @@
 /*---------------------- Macros and type definitions ----------------------*/
 
 #ifdef PACK
-# pragma PACK
+#pragma PACK
 #endif
 
 /*
@@ -64,48 +64,48 @@
 
 typedef struct {
     u32 e_reg;
-	} I32_reg_t;
+} I32_reg_t;
 
 typedef struct {
-	u16 filler0, x_reg;
-	} I16_reg_t;
+    u16 filler0, x_reg;
+} I16_reg_t;
 
 typedef struct {
-	u8 filler0, filler1, h_reg, l_reg;
-	} I8_reg_t;
+    u8 filler0, filler1, h_reg, l_reg;
+} I8_reg_t;
 
-#else /* !__BIG_ENDIAN__ */
+#else                           /* !__BIG_ENDIAN__ */
 
 typedef struct {
     u32 e_reg;
-	} I32_reg_t;
+} I32_reg_t;
 
 typedef struct {
-	u16 x_reg;
-	} I16_reg_t;
+    u16 x_reg;
+} I16_reg_t;
 
 typedef struct {
-	u8 l_reg, h_reg;
-	} I8_reg_t;
+    u8 l_reg, h_reg;
+} I8_reg_t;
 
-#endif /* BIG_ENDIAN */
+#endif                          /* BIG_ENDIAN */
 
 typedef union {
-	I32_reg_t   I32_reg;
-	I16_reg_t   I16_reg;
-	I8_reg_t    I8_reg;
-	} i386_general_register;
+    I32_reg_t I32_reg;
+    I16_reg_t I16_reg;
+    I8_reg_t I8_reg;
+} i386_general_register;
 
 struct i386_general_regs {
-	i386_general_register A, B, C, D;
-	};
+    i386_general_register A, B, C, D;
+};
 
 typedef struct i386_general_regs Gen_reg_t;
 
 struct i386_special_regs {
-	i386_general_register SP, BP, SI, DI, IP;
-	u32 FLAGS;
-	};
+    i386_general_register SP, BP, SI, DI, IP;
+    u32 FLAGS;
+};
 
 /*  
  * Segment registers here represent the 16 bit quantities
@@ -114,7 +114,7 @@ struct i386_special_regs {
 
 struct i386_segment_regs {
     u16 CS, DS, SS, ES, FS, GS;
-	};
+};
 
 /* 8 bit registers */
 #define R_AH  gen.A.I8_reg.h_reg
@@ -258,9 +258,9 @@ struct i386_segment_regs {
 #define  INTR_HALTED          0x4
 
 typedef struct {
-    struct i386_general_regs    gen;
-    struct i386_special_regs    spc;
-    struct i386_segment_regs    seg;
+    struct i386_general_regs gen;
+    struct i386_special_regs spc;
+    struct i386_segment_regs seg;
     /*
      * MODE contains information on:
      *  REPE prefix             2 bits  repe,repne
@@ -273,21 +273,21 @@ typedef struct {
      *  Extern interrupt        1 bits
      *  Halted                  1 bits
      */
-    u32                         mode;
-    volatile int                intr;   /* mask of pending interrupts */
-	int                         debug;
+    u32 mode;
+    volatile int intr;          /* mask of pending interrupts */
+    int debug;
 #ifdef DEBUG
-	int                         check;
-    u16                         saved_ip;
-    u16                         saved_cs;
-    int                         enc_pos;
-    int                         enc_str_pos;
-    char                        decode_buf[32]; /* encoded byte stream  */
-    char                        decoded_buf[256]; /* disassembled strings */
+    int check;
+    u16 saved_ip;
+    u16 saved_cs;
+    int enc_pos;
+    int enc_str_pos;
+    char decode_buf[32];        /* encoded byte stream  */
+    char decoded_buf[256];      /* disassembled strings */
 #endif
-    u8                          intno;
-    u8                          __pad[3];
-	} X86EMU_regs;
+    u8 intno;
+    u8 __pad[3];
+} X86EMU_regs;
 
 /****************************************************************************
 REMARKS:
@@ -300,20 +300,20 @@ private			- private data pointer
 x86			- X86 registers
 ****************************************************************************/
 typedef struct {
-	unsigned long	mem_base;
-	unsigned long	mem_size;
-	void*        	private;
-	X86EMU_regs		x86;
-	} X86EMU_sysEnv;
+    unsigned long mem_base;
+    unsigned long mem_size;
+    void *private;
+    X86EMU_regs x86;
+} X86EMU_sysEnv;
 
 #ifdef END_PACK
-# pragma END_PACK
+#pragma END_PACK
 #endif
 
 /*----------------------------- Global Variables --------------------------*/
 
 #ifdef  __cplusplus
-extern "C" {            			/* Use "C" linkage when in C++ mode */
+extern "C" {                    /* Use "C" linkage when in C++ mode */
 #endif
 
 /* Global emulator machine state.
@@ -321,17 +321,16 @@ extern "C" {            			/* Use "C" linkage when in C++ mode */
  * We keep it global to avoid pointer dereferences in the code for speed.
  */
 
-extern    X86EMU_sysEnv	_X86EMU_env;
+    extern X86EMU_sysEnv _X86EMU_env;
 #define   M             _X86EMU_env
 
 /*-------------------------- Function Prototypes --------------------------*/
 
 /* Function to log information at runtime */
 
-void	printk(const char *fmt, ...);
+    void printk(const char *fmt, ...);
 
 #ifdef  __cplusplus
-}                       			/* End of "C" linkage for C++   	*/
+}                               /* End of "C" linkage for C++           */
 #endif
-
-#endif /* __X86EMU_REGS_H */
+#endif                          /* __X86EMU_REGS_H */
diff --git a/libs/x86emu/x86emu/types.h b/libs/x86emu/x86emu/types.h
index c0c09c1..5a6ef01 100644
--- a/libs/x86emu/x86emu/types.h
+++ b/libs/x86emu/x86emu/types.h
@@ -36,7 +36,6 @@
 *
 ****************************************************************************/
 
-
 #ifndef __X86EMU_TYPES_H
 #define __X86EMU_TYPES_H
 
@@ -61,46 +60,21 @@
 
 /*---------------------- Macros and type definitions ----------------------*/
 
-/* Currently only for Linux/32bit */
-#undef  __HAS_LONG_LONG__
-#if defined(__GNUC__) && !defined(NO_LONG_LONG)
-#define __HAS_LONG_LONG__
-#endif
+#include <stdint.h>
 
-/* Taken from Xmd.h */
-#undef NUM32
-#if defined (_LP64) || \
-    defined(__alpha) || defined(__alpha__) || \
-    defined(__ia64__) || defined(ia64) || \
-    defined(__sparc64__) || \
-    defined(__s390x__) || \
-    (defined(__hppa__) && defined(__LP64)) || \
-    defined(__amd64__) || defined(amd64) || \
-    (defined(__sgi) && (_MIPS_SZLONG == 64))
-#define NUM32 int
-#else
-#define NUM32 long
-#endif
+typedef uint8_t u8;
+typedef uint16_t u16;
+typedef uint32_t u32;
+typedef uint64_t u64;
 
-typedef unsigned char 		u8;
-typedef unsigned short 		u16;
-typedef unsigned NUM32 		u32;
-#ifdef __HAS_LONG_LONG__
-typedef unsigned long long 	u64;
-#endif
+typedef int8_t s8;
+typedef int16_t s16;
+typedef int32_t s32;
+typedef int64_t s64;
 
-typedef char 				s8;
-typedef short 				s16;
-typedef NUM32 				s32;
-#ifdef __HAS_LONG_LONG__
-typedef long long 			s64;
-#endif
-
-typedef unsigned int			uint;
-typedef int 				sint;
+typedef unsigned int uint;
+typedef int sint;
 
 typedef u16 X86EMU_pioAddr;
 
-#undef NUM32
-
-#endif	/* __X86EMU_TYPES_H */
+#endif                          /* __X86EMU_TYPES_H */
diff --git a/libs/x86emu/x86emu/x86emui.h b/libs/x86emu/x86emu/x86emui.h
index 112ee36..f11dc10 100644
--- a/libs/x86emu/x86emu/x86emui.h
+++ b/libs/x86emu/x86emu/x86emui.h
@@ -38,7 +38,6 @@
 *
 ****************************************************************************/
 
-
 #ifndef __X86EMU_X86EMUI_H
 #define __X86EMU_X86EMUI_H
 
@@ -74,29 +73,28 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#endif                                                                                           
+#endif
 /*--------------------------- Inline Functions ----------------------------*/
 
 #ifdef  __cplusplus
-extern "C" {            			/* Use "C" linkage when in C++ mode */
+extern "C" {                    /* Use "C" linkage when in C++ mode */
 #endif
 
-extern u8  	(X86APIP sys_rdb)(u32 addr);
-extern u16 	(X86APIP sys_rdw)(u32 addr);
-extern u32 	(X86APIP sys_rdl)(u32 addr);
-extern void (X86APIP sys_wrb)(u32 addr,u8 val);
-extern void (X86APIP sys_wrw)(u32 addr,u16 val);
-extern void (X86APIP sys_wrl)(u32 addr,u32 val);
+    extern u8(X86APIP sys_rdb) (u32 addr);
+    extern u16(X86APIP sys_rdw) (u32 addr);
+    extern u32(X86APIP sys_rdl) (u32 addr);
+    extern void (X86APIP sys_wrb) (u32 addr, u8 val);
+    extern void (X86APIP sys_wrw) (u32 addr, u16 val);
+    extern void (X86APIP sys_wrl) (u32 addr, u32 val);
 
-extern u8  	(X86APIP sys_inb)(X86EMU_pioAddr addr);
-extern u16 	(X86APIP sys_inw)(X86EMU_pioAddr addr);
-extern u32 	(X86APIP sys_inl)(X86EMU_pioAddr addr);
-extern void (X86APIP sys_outb)(X86EMU_pioAddr addr,u8 val);
-extern void (X86APIP sys_outw)(X86EMU_pioAddr addr,u16 val);
-extern void	(X86APIP sys_outl)(X86EMU_pioAddr addr,u32 val);
+    extern u8(X86APIP sys_inb) (X86EMU_pioAddr addr);
+    extern u16(X86APIP sys_inw) (X86EMU_pioAddr addr);
+    extern u32(X86APIP sys_inl) (X86EMU_pioAddr addr);
+    extern void (X86APIP sys_outb) (X86EMU_pioAddr addr, u8 val);
+    extern void (X86APIP sys_outw) (X86EMU_pioAddr addr, u16 val);
+    extern void (X86APIP sys_outl) (X86EMU_pioAddr addr, u32 val);
 
 #ifdef  __cplusplus
-}                       			/* End of "C" linkage for C++   	*/
+}                               /* End of "C" linkage for C++           */
 #endif
-
-#endif /* __X86EMU_X86EMUI_H */
+#endif                          /* __X86EMU_X86EMUI_H */
-- 
1.9.1

