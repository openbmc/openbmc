From e58cb210a7c15352040a411d11a8383eac0defda Mon Sep 17 00:00:00 2001
From: Jianchuan Wang <jianchuan.wang@windriver.com>
Date: Tue, 30 Sep 2014 12:16:17 +0800
Subject: [PATCH] xfsprogs: generate crctable which is moved into runtime from
 compile

After upgraded, There is a compile error except x86,
Because crc32.c need two arraies crc32table_le and crc32ctable_le from crc32table.h,
which are generated by gen_crc32table.c relative to different platforms.
For this, move the function implementation from gen_crc32table.c to crc.c

Upstream-Status: Pending

Signed-off-by: Jianchuan Wang <jianchuan.wang@windriver.com>
---
 libxfs/Makefile | 23 ++----------------
 libxfs/crc32.c  | 75 +++++++++++++++++++++++++++++++++++++++++++++++++++++++--
 2 files changed, 75 insertions(+), 23 deletions(-)

diff --git a/libxfs/Makefile b/libxfs/Makefile
index ae15a5d..7670159 100644
--- a/libxfs/Makefile
+++ b/libxfs/Makefile
@@ -10,7 +10,7 @@ LT_CURRENT = 0
 LT_REVISION = 0
 LT_AGE = 0
 
-HFILES = xfs.h init.h xfs_dir2_priv.h crc32defs.h crc32table.h
+HFILES = xfs.h init.h xfs_dir2_priv.h crc32defs.h
 CFILES = cache.c \
 	crc32.c \
 	init.c kmem.c logitem.c radix-tree.c rdwr.c trans.c util.c \
@@ -43,7 +43,6 @@ CFILES = cache.c \
 CFILES += $(PKG_PLATFORM).c
 PCFILES = darwin.c freebsd.c irix.c linux.c
 LSRCFILES = $(shell echo $(PCFILES) | sed -e "s/$(PKG_PLATFORM).c//g")
-LSRCFILES += gen_crc32table.c
 
 #
 # Tracing flags:
@@ -61,25 +60,7 @@ LTLIBS = $(LIBPTHREAD) $(LIBRT)
 # don't try linking xfs_repair with a debug libxfs.
 DEBUG = -DNDEBUG
 
-LDIRT = gen_crc32table crc32table.h crc32selftest
-
-default: crc32selftest ltdepend $(LTLIBRARY)
-
-crc32table.h: gen_crc32table.c
-	@echo "    [CC]     gen_crc32table"
-	$(Q) $(CC) $(CFLAGS) -o gen_crc32table $<
-	@echo "    [GENERATE] $@"
-	$(Q) ./gen_crc32table > crc32table.h
-
-# The selftest binary will return an error if it fails. This is made a
-# dependency of the build process so that we refuse to build the tools on broken
-# systems/architectures. Hence we make sure that xfsprogs will never use a
-# busted CRC calculation at build time and hence avoid putting bad CRCs down on
-# disk.
-crc32selftest: gen_crc32table.c crc32table.h crc32.c
-	@echo "    [TEST]    CRC32"
-	$(Q) $(CC) $(CFLAGS) -D CRC32_SELFTEST=1 crc32.c -o $@
-	$(Q) ./$@
+default: ltdepend $(LTLIBRARY)
 
 include $(BUILDRULES)
 
diff --git a/libxfs/crc32.c b/libxfs/crc32.c
index 0f847d2..be5fbc3 100644
--- a/libxfs/crc32.c
+++ b/libxfs/crc32.c
@@ -55,8 +55,6 @@ typedef __u32	u64;
 # define tobe(x) (x)
 #endif
 
-#include "crc32table.h"
-
 #if CRC_LE_BITS > 8 || CRC_BE_BITS > 8
 
 /* implements slicing-by-4 or slicing-by-8 algorithm */
@@ -183,13 +181,86 @@ u32 __pure crc32c_le(u32 crc, unsigned char const *p, size_t len)
 	return crc32_le_generic(crc, p, len, NULL, CRC32C_POLY_LE);
 }
 #else
+
+#include <stdio.h>
+#include "crc32defs.h"
+#include <inttypes.h>
+
+#define ENTRIES_PER_LINE 4
+
+#if CRC_LE_BITS > 8
+# define LE_TABLE_ROWS (CRC_LE_BITS/8)
+# define LE_TABLE_SIZE 256
+#else
+# define LE_TABLE_ROWS 1
+# define LE_TABLE_SIZE (1 << CRC_LE_BITS)
+#endif
+
+#if CRC_BE_BITS > 8
+# define BE_TABLE_ROWS (CRC_BE_BITS/8)
+# define BE_TABLE_SIZE 256
+#else
+# define BE_TABLE_ROWS 1
+# define BE_TABLE_SIZE (1 << CRC_BE_BITS)
+#endif
+
+static uint32_t crc32table_le[LE_TABLE_ROWS][256];
+static uint32_t crc32ctable_le[LE_TABLE_ROWS][256];
+
+static uint32_t crc32table_le_init = 0;
+static uint32_t crc32ctable_le_init = 0;
+
+/*
+ * big endian ordered CRC not used by XFS.
+static uint32_t crc32table_be[BE_TABLE_ROWS][256];
+ */
+
+/**
+ * crc32init_le() - allocate and initialize LE table data
+ *
+ * crc is the crc of the byte i; other entries are filled in based on the
+ * fact that crctable[i^j] = crctable[i] ^ crctable[j].
+ *
+ */
+static void crc32init_le_generic(const uint32_t polynomial,
+				 uint32_t (*tab)[256])
+{
+	unsigned i, j;
+	uint32_t crc = 1;
+
+	tab[0][0] = 0;
+
+	for (i = LE_TABLE_SIZE >> 1; i; i >>= 1) {
+		crc = (crc >> 1) ^ ((crc & 1) ? polynomial : 0);
+		for (j = 0; j < LE_TABLE_SIZE; j += 2 * i)
+			tab[0][i + j] = crc ^ tab[0][j];
+	}
+	for (i = 0; i < LE_TABLE_SIZE; i++) {
+		crc = tab[0][i];
+		for (j = 1; j < LE_TABLE_ROWS; j++) {
+			crc = tab[0][crc & 0xff] ^ (crc >> 8);
+			tab[j][i] = crc;
+		}
+	}
+}
+
 u32 __pure crc32_le(u32 crc, unsigned char const *p, size_t len)
 {
+	if (crc32table_le_init == 0) {
+		crc32init_le_generic(CRCPOLY_LE, crc32table_le);
+		crc32table_le_init == 1;
+	}	
+
 	return crc32_le_generic(crc, p, len,
 			(const u32 (*)[256])crc32table_le, CRCPOLY_LE);
 }
 u32 __pure crc32c_le(u32 crc, unsigned char const *p, size_t len)
 {
+	if (crc32ctable_le_init == 0) {
+		crc32init_le_generic(CRC32C_POLY_LE, crc32ctable_le);
+		crc32ctable_le_init == 1;
+	}
+
 	return crc32_le_generic(crc, p, len,
 			(const u32 (*)[256])crc32ctable_le, CRC32C_POLY_LE);
 }
-- 
1.9.1

