From 2946797e145ae66d47ab88fa81f9dc36ace83dd5 Mon Sep 17 00:00:00 2001
From: "Edward A. James" <eajames@us.ibm.com>
Date: Fri, 19 May 2017 16:45:06 -0500
Subject: [PATCH 1/2] drivers: fsi: occ: Add in-kernel API

Signed-off-by: Edward A. James <eajames@us.ibm.com>
---
 drivers/fsi/occ.c   | 142 ++++++++++++++++++++++++++++++++++++++++++----------
 include/linux/occ.h |  27 ++++++++++
 2 files changed, 143 insertions(+), 26 deletions(-)
 create mode 100644 include/linux/occ.h

diff --git a/drivers/fsi/occ.c b/drivers/fsi/occ.c
index 37242b3..fa54ad7 100644
--- a/drivers/fsi/occ.c
+++ b/drivers/fsi/occ.c
@@ -107,38 +107,45 @@ static void occ_enqueue_xfr(struct occ_xfr *xfr)
 		queue_work(occ_wq, &occ->work);
 }
 
-static int occ_open(struct inode *inode, struct file *file)
+static struct occ_client *occ_open_common(struct occ *occ, unsigned long flags)
 {
 	struct occ_client *client;
-	struct miscdevice *mdev = file->private_data;
-	struct occ *occ = to_occ(mdev);
 
 	client = kzalloc(sizeof(*client), GFP_KERNEL);
 	if (!client)
-		return -ENOMEM;
+		return NULL;
 
 	client->occ = occ;
 	spin_lock_init(&client->lock);
 	init_waitqueue_head(&client->wait);
 
-	if (file->f_flags & O_NONBLOCK)
+	if (flags & O_NONBLOCK)
 		set_bit(CLIENT_NONBLOCKING, &client->flags);
 
+	return client;
+}
+
+static int occ_open(struct inode *inode, struct file *file)
+{
+	struct occ_client *client;
+	struct miscdevice *mdev = file->private_data;
+	struct occ *occ = to_occ(mdev);
+
+	client = occ_open_common(occ, file->f_flags);
+	if (!client)
+		return -ENOMEM;
+
 	file->private_data = client;
 
 	return 0;
 }
 
-static ssize_t occ_read(struct file *file, char __user *buf, size_t len,
-			loff_t *offset)
+static ssize_t occ_read_common(struct occ_client *client, char *kbuf,
+			       char __user *ubuf, size_t len)
 {
 	int rc;
 	size_t bytes;
 	struct occ_xfr *xfr;
-	struct occ_client *client = file->private_data;
-
-	if (!access_ok(VERIFY_WRITE, buf, len))
-		return -EFAULT;
 
 	if (len > OCC_SRAM_BYTES)
 		return -EINVAL;
@@ -190,10 +197,16 @@ static ssize_t occ_read(struct file *file, char __user *buf, size_t len,
 		goto done;
 	}
 
-	if (copy_to_user(buf, &xfr->buf[client->read_offset], bytes)) {
-		rc = -EFAULT;
-		goto done;
+	bytes = min(len, xfr->resp_data_length - client->read_offset);
+	if (ubuf) {
+		if (copy_to_user(ubuf, &xfr->buf[client->read_offset], bytes))
+		{
+			rc = -EFAULT;
+			goto done;
+		}
 	}
+	else
+		memcpy(kbuf, &xfr->buf[client->read_offset], bytes);
 
 	client->read_offset += bytes;
 
@@ -210,18 +223,25 @@ done:
 	return rc;
 }
 
-static ssize_t occ_write(struct file *file, const char __user *buf,
-			 size_t len, loff_t *offset)
+static ssize_t occ_read(struct file *file, char __user *buf, size_t len,
+			loff_t *offset)
+{
+	struct occ_client *client = file->private_data;
+
+	if (!access_ok(VERIFY_WRITE, buf, len))
+		return -EFAULT;
+
+	return occ_read_common(client, NULL, buf, len);
+}
+
+static ssize_t occ_write_common(struct occ_client *client, const char *kbuf,
+				const char __user *ubuf, size_t len)
 {
 	int rc;
 	unsigned int i, j;
 	u8 tmp;
 	u16 data_length, checksum = 0;
 	struct occ_xfr *xfr;
-	struct occ_client *client = file->private_data;
-
-	if (!access_ok(VERIFY_READ, buf, len))
-		return -EFAULT;
 
 	if (len > (OCC_CMD_DATA_BYTES + 3) || len < 3)
 		return -EINVAL;
@@ -240,11 +260,15 @@ static ssize_t occ_write(struct file *file, const char __user *buf,
 
 	xfr->buf[0] = 1;
 
-	if (copy_from_user(&xfr->buf[1], buf, len)) {
-		kfree(xfr);
-		rc = -EFAULT;
-		goto done;
+	if (ubuf) {
+		if (copy_from_user(&xfr->buf[1], ubuf, len)) {
+			kfree(xfr);
+			rc = -EFAULT;
+			goto done;
+		}
 	}
+	else
+		memcpy(&xfr->buf[1], kbuf, len);
 
 	data_length = (xfr->buf[2] << 8) + xfr->buf[3];
 	if (data_length > OCC_CMD_DATA_BYTES) {
@@ -284,10 +308,20 @@ done:
 	return rc;
 }
 
-static int occ_release(struct inode *inode, struct file *file)
+static ssize_t occ_write(struct file *file, const char __user *buf,
+			 size_t len, loff_t *offset)
 {
-	struct occ_xfr *xfr;
 	struct occ_client *client = file->private_data;
+
+	if (!access_ok(VERIFY_READ, buf, len))
+		return -EFAULT;
+
+	return occ_write_common(client, NULL, buf, len);
+}
+
+static int occ_release_common(struct occ_client *client)
+{
+	struct occ_xfr *xfr;
 	struct occ *occ = client->occ;
 
 	spin_lock_irq(&client->lock);
@@ -326,6 +360,13 @@ static int occ_release(struct inode *inode, struct file *file)
 	return 0;
 }
 
+static int occ_release(struct inode *inode, struct file *file)
+{
+	struct occ_client *client = file->private_data;
+
+	return occ_release_common(client);
+}
+
 static const struct file_operations occ_fops = {
 	.owner = THIS_MODULE,
 	.open = occ_open,
@@ -531,6 +572,43 @@ done:
 		goto again;
 }
 
+struct occ_client *occ_drv_open(struct device *dev, unsigned long flags)
+{
+	struct occ *occ = dev_get_drvdata(dev);
+
+	return occ_open_common(occ, flags);
+}
+EXPORT_SYMBOL_GPL(occ_drv_open);
+
+int occ_drv_read(struct occ_client *client, char *buf, size_t len)
+{
+	return occ_read_common(client, buf, NULL, len);
+}
+EXPORT_SYMBOL_GPL(occ_drv_read);
+
+int occ_drv_write(struct occ_client *client, const char *buf, size_t len)
+{
+	return occ_write_common(client, buf, NULL, len);
+}
+EXPORT_SYMBOL_GPL(occ_drv_write);
+
+void occ_drv_release(struct occ_client *client)
+{
+	occ_release_common(client);
+}
+EXPORT_SYMBOL_GPL(occ_drv_release);
+
+static int occ_unregister_child(struct device *dev, void *data)
+{
+	struct platform_device *child = to_platform_device(dev);
+
+	of_device_unregister(child);
+	if (dev->of_node)
+		of_node_clear_flag(dev->of_node, OF_POPULATED);
+
+	return 0;
+}
+
 static int occ_probe(struct platform_device *pdev)
 {
 	int rc, child_idx = 0;
@@ -564,6 +642,16 @@ static int occ_probe(struct platform_device *pdev)
 		} else
 			occ->idx = ida_simple_get(&occ_ida, 1, INT_MAX,
 						  GFP_KERNEL);
+
+		/* create platform devs for dts child nodes (hwmon, etc) */
+		for_each_child_of_node(dev->of_node, np) {
+			snprintf(child_name, sizeof(child_name), "occ%d-dev%d",
+				 occ->idx, child_idx++);
+			child = of_platform_device_create(np, child_name, dev);
+			if (!child)
+				dev_warn(dev,
+					 "failed to create child node dev\n");
+		}
 	} else
 		occ->idx = ida_simple_get(&occ_ida, 1, INT_MAX, GFP_KERNEL);
 
@@ -592,6 +680,8 @@ static int occ_remove(struct platform_device *pdev)
 
 	misc_deregister(&occ->mdev);
 
+	device_for_each_child(&pdev->dev, NULL, occ_unregister_child);
+
 	spin_lock_irq(&occ->list_lock);
 	list_for_each_entry_safe(xfr, tmp, &occ->xfrs, link) {
 		client = xfr->client;
diff --git a/include/linux/occ.h b/include/linux/occ.h
new file mode 100644
index 0000000..d78332c
--- /dev/null
+++ b/include/linux/occ.h
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) IBM Corporation 2017
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERGCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __OCC_H__
+#define __OCC_H__
+
+struct device;
+struct occ_client;
+
+extern struct occ_client *occ_drv_open(struct device *dev,
+				       unsigned long flags);
+extern int occ_drv_read(struct occ_client *client, char *buf, size_t len);
+extern int occ_drv_write(struct occ_client *client, const char *buf,
+			 size_t len);
+extern void occ_drv_release(struct occ_client *client);
+
+#endif /* __OCC_H__ */
-- 
1.8.3.1

