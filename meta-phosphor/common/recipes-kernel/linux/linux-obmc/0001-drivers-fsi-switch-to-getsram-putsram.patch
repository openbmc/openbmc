From 839233ccc8725597d6e4620c19824a46fc901eac Mon Sep 17 00:00:00 2001
From: "Edward A. James" <eajames@us.ibm.com>
Date: Wed, 31 May 2017 13:49:29 -0500
Subject: [PATCH] drivers: fsi: switch to getsram/putsram

Significantly faster and should no longer require manual OCB channel
setup.

Signed-off-by: Edward A. James <eajames@us.ibm.com>
---
 drivers/fsi/occ.c | 284 +++++++++++++++++++++++++++++++++---------------------
 1 file changed, 175 insertions(+), 109 deletions(-)

diff --git a/drivers/fsi/occ.c b/drivers/fsi/occ.c
index b91e03c..1fe67bf 100644
--- a/drivers/fsi/occ.c
+++ b/drivers/fsi/occ.c
@@ -26,6 +26,7 @@
 #define OCC_SRAM_BYTES		4096
 #define OCC_CMD_DATA_BYTES	4090
 #define OCC_RESP_DATA_BYTES	4089
+#define OCC_SRAM_DELAY_MS	25
 
 struct occ {
 	struct device *sbefifo;
@@ -36,6 +37,7 @@ struct occ {
 	spinlock_t list_lock;
 	spinlock_t occ_lock;
 	struct work_struct work;
+	struct delayed_work dwork;
 };
 
 #define to_occ(x)	container_of((x), struct occ, mdev)
@@ -77,6 +79,7 @@ enum {
 	XFR_COMPLETE,
 	XFR_CANCELED,
 	XFR_WAITING,
+	XFR_PUT_DONE,
 };
 
 struct occ_xfr {
@@ -361,109 +364,177 @@ static int occ_release(struct inode *inode, struct file *file)
 	.release = occ_release,
 };
 
-static int occ_getscom(struct device *sbefifo, u32 address, u8 *data)
+static int occ_write_sbefifo(struct sbefifo_client *client, const char *buf,
+			     ssize_t len)
 {
 	int rc;
-	u32 buf[4];
+	ssize_t total = 0;
+
+	do {
+		rc = sbefifo_drv_write(client, &buf[total], len - total);
+		if (rc < 0)
+			return rc;
+		else if (!rc)
+			break;
+
+		total += rc;
+	} while (total < len);
+
+	return (total == len) ? 0 : -EMSGSIZE;
+}
+
+static int occ_read_sbefifo(struct sbefifo_client *client, char *buf,
+			    ssize_t len)
+{
+	int rc;
+	ssize_t total = 0;
+
+	do {
+		rc = sbefifo_drv_read(client, &buf[total], len - total);
+		if (rc < 0)
+			return rc;
+		else if (!rc)
+			break;
+
+		total += rc;
+	} while (total < len);
+
+	return (total == len) ? 0 : -EMSGSIZE;
+}
+
+static int occ_getsram(struct device *sbefifo, u32 address, u8 *data,
+		       ssize_t len)
+{
+	int rc;
+	u8 *resp;
+	u32 buf[5];
+	u32 data_len = ((len + 7) / 8) * 8;
 	struct sbefifo_client *client;
-	const size_t len = sizeof(buf);
 
-	buf[0] = cpu_to_be32(0x4);
-	buf[1] = cpu_to_be32(0xa201);
-	buf[2] = 0;
+	buf[0] = cpu_to_be32(0x5);
+	buf[1] = cpu_to_be32(0xa403);
+	buf[2] = cpu_to_be32(1);
 	buf[3] = cpu_to_be32(address);
+	buf[4] = cpu_to_be32(data_len);
 
 	client = sbefifo_drv_open(sbefifo, 0);
 	if (!client)
 		return -ENODEV;
 
-	rc = sbefifo_drv_write(client, (const char *)buf, len);
-	if (rc < 0)
+	rc = occ_write_sbefifo(client, (const char *)buf, sizeof(buf));
+	if (rc)
 		goto done;
-	else if (rc != len) {
-		rc = -EMSGSIZE;
+	
+	resp = kzalloc(data_len, GFP_KERNEL);
+	if (!resp) {
+		rc = -ENOMEM;
 		goto done;
 	}
 
-	rc = sbefifo_drv_read(client, (char *)buf, len);
-	if (rc < 0)
-		goto done;
-	else if (rc != len) {
-		rc = -EMSGSIZE;
-		goto done;
-	}
+	rc = occ_read_sbefifo(client, (char *)resp, data_len);
+	if (rc)
+		goto free;
 
 	/* check for good response */
-	if ((be32_to_cpu(buf[2]) >> 16) != 0xC0DE) {
-		rc = -EFAULT;
-		goto done;
-	}
+	rc = occ_read_sbefifo(client, (char *)buf, 8);
+	if (rc)
+		goto free;
 
-	rc = 0;
+	if ((be32_to_cpu(buf[0]) == data_len) &&
+	    (be32_to_cpu(buf[1]) == 0xC0DEA403))
+		memcpy(data, resp, len);
+	else
+		rc = -EFAULT;
 
-	memcpy(data, buf, sizeof(u64));
+free:
+	kfree(resp);
 
 done:
 	sbefifo_drv_release(client);
 	return rc;
 }
 
-static int occ_putscom(struct device *sbefifo, u32 address, u8 *data)
+static int occ_putsram(struct device *sbefifo, u32 address, u8 *data,
+		       ssize_t len)
 {
 	int rc;
-	u32 buf[6];
+	u32 *buf;
+	u32 data_len = ((len + 7) / 8) * 8;
+	size_t cmd_len = data_len + 20;
 	struct sbefifo_client *client;
-	const size_t len = sizeof(buf);
 
-	buf[0] = cpu_to_be32(0x6);
-	buf[1] = cpu_to_be32(0xa202);
-	buf[2] = 0;
+	buf = kzalloc(cmd_len, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	buf[0] = cpu_to_be32(0x5 + (data_len / 4));
+	buf[1] = cpu_to_be32(0xa404);
+	buf[2] = cpu_to_be32(1);
 	buf[3] = cpu_to_be32(address);
-	memcpy(&buf[4], data, sizeof(u64));
+	buf[4] = cpu_to_be32(data_len);
+
+	memcpy(&buf[5], data, len);
 
 	client = sbefifo_drv_open(sbefifo, 0);
-	if (!client)
-		return -ENODEV;
+	if (!client) {
+		rc = -ENODEV;
+		goto free;
+	}
 
-	rc = sbefifo_drv_write(client, (const char *)buf, len);
-	if (rc < 0)
-		goto done;
-	else if (rc != len) {
-		rc = -EMSGSIZE;
+	rc = occ_write_sbefifo(client, (const char *)buf, cmd_len);
+	if (rc)
 		goto done;
-	}
 
-	rc = 0;
+	rc = occ_read_sbefifo(client, (char *)buf, 8);
+	if (rc)
+		goto done;
 
-	/* ignore response */
-	sbefifo_drv_read(client, (char *)buf, len);
+	/* check for good response */
+	if ((be32_to_cpu(buf[0]) != data_len) ||
+	    (be32_to_cpu(buf[1]) != 0xC0DEA404))
+		rc = -EFAULT;
 
 done:
 	sbefifo_drv_release(client);
+free:
+	kfree(buf);
 	return rc;
 }
 
-static int occ_putscom_u32(struct device *sbefifo, u32 address, u32 data0,
-			   u32 data1)
+static int occ_worker_finish_xfr(struct occ *occ, struct occ_xfr *xfr)
 {
-	u8 buf[8];
-	u32 raw_data0 = cpu_to_be32(data0), raw_data1 = cpu_to_be32(data1);
+	int empty, waiting, canceled;
+	struct occ_client *client = xfr->client;
+
+	/* lock client to prevent race with read() */
+	spin_lock_irq(&client->lock);
+	set_bit(XFR_COMPLETE, &xfr->flags);
+	waiting = test_bit(XFR_WAITING, &xfr->flags);
+	spin_unlock(&client->lock);
+
+	spin_lock_irq(&occ->list_lock);
+	clear_bit(XFR_IN_PROGRESS, &xfr->flags);
+	list_del(&xfr->link);
+	empty = list_empty(&occ->xfrs);
+	canceled = test_bit(XFR_CANCELED, &xfr->flags);
+	spin_unlock(&occ->list_lock);
 
-	memcpy(buf, &raw_data0, 4);
-	memcpy(buf + 4, &raw_data1, 4);
+	if (waiting)
+		wake_up_interruptible(&client->wait);
+	else if (canceled) {
+		kfree(xfr);
+		kfree(xfr->client);
+	}
 
-	return occ_putscom(sbefifo, address, buf);
+	return !empty;
 }
 
-static void occ_worker(struct work_struct *work)
+static void occ_worker_putsram(struct work_struct *work)
 {
-	int i, empty, canceled, waiting, rc;
-	u16 resp_data_length;
+	int rc = 0;
+	struct occ_xfr *xfr;
 	struct occ *occ = container_of(work, struct occ, work);
 	struct device *sbefifo = occ->sbefifo;
-	struct occ_client *client;
-	struct occ_xfr *xfr;
-	struct occ_response *resp;
 
 again:
 	spin_lock_irq(&occ->list_lock);
@@ -474,86 +545,79 @@ static void occ_worker(struct work_struct *work)
 	}
 
 	set_bit(XFR_IN_PROGRESS, &xfr->flags);
-	spin_unlock(&occ->list_lock);
-
-	resp = (struct occ_response *)xfr->buf;
 
+	spin_unlock(&occ->list_lock);
 	spin_lock_irq(&occ->occ_lock);
 
-	/* set address reg to occ sram command buffer */
-	rc = occ_putscom_u32(sbefifo, 0x6D050, 0xFFFBE000, 0);
+	rc = occ_putsram(sbefifo, 0xFFFBE000, xfr->buf,
+			 xfr->cmd_data_length);
 	if (rc)
 		goto done;
 
-	/* write cmd data */
-	for (i = 0; i < xfr->cmd_data_length; i += 8) {
-		rc = occ_putscom(sbefifo, 0x6D055, &xfr->buf[i]);
-		if (rc)
-			goto done;
+	set_bit(XFR_PUT_DONE, &xfr->flags);
+	queue_delayed_work(occ_wq, &occ->dwork,
+			   msecs_to_jiffies(OCC_SRAM_DELAY_MS));
+
+done:
+	spin_unlock(&occ->occ_lock);
+
+	if (rc) {
+		xfr->rc = rc;
+		if (occ_worker_finish_xfr(occ, xfr))
+			goto again;
 	}
+}
 
-	/* trigger attention */
-	rc = occ_putscom_u32(sbefifo, 0x6D035, 0x20010000, 0);
-	if (rc)
-		goto done;
+static void occ_worker_getsram(struct work_struct *work)
+{
+	int rc = 0;
+	u16 resp_data_length;
+	struct occ_xfr *xfr;
+	struct delayed_work *dwork = to_delayed_work(work);
+	struct occ *occ = container_of(dwork, struct occ, dwork);
+	struct device *sbefifo = occ->sbefifo;
 
-	/* set address reg to occ sram response buffer */
-	rc = occ_putscom_u32(sbefifo, 0x6D050, 0xFFFBF000, 0);
-	if (rc)
-		goto done;
+	spin_lock_irq(&occ->list_lock);
+	xfr = list_first_entry(&occ->xfrs, struct occ_xfr, link);
+	if (!xfr) {
+		spin_unlock(&occ->list_lock);
+		return;
+	}
 
-	rc = occ_getscom(sbefifo, 0x6D055, xfr->buf);
+	if (test_bit(XFR_CANCELED, &xfr->flags)) {
+		rc = -ECANCELED;
+		spin_unlock(&occ->list_lock);
+		goto finish;
+	}
+
+	spin_unlock(&occ->list_lock);
+	spin_lock_irq(&occ->occ_lock);
+
+	rc = occ_getsram(sbefifo, 0xFFFBF000, xfr->buf, 8);
 	if (rc)
 		goto done;
 
-	xfr->resp_data_length += 8;
-
 	resp_data_length = (xfr->buf[3] << 8) + xfr->buf[4];
 	if (resp_data_length > OCC_RESP_DATA_BYTES) {
 		rc = -EDOM;
 		goto done;
 	}
 
-	/* already read 3 bytes of resp data, but also need 2 bytes chksum */
-	for (i = 8; i < resp_data_length + 7; i += 8) {
-		rc = occ_getscom(sbefifo, 0x6D055, &xfr->buf[i]);
-		if (rc)
-			goto done;
-
-		xfr->resp_data_length += 8;
-	}
+	/* already got 3 bytes resp, also need 2 bytes checksum */
+	rc = occ_getsram(sbefifo, 0xFFFBF008, &xfr->buf[8],
+			 resp_data_length - 1);
+	if (rc)
+		goto done;
 
-	/* no errors, got all data */
 	xfr->resp_data_length = resp_data_length + 7;
 
 done:
 	spin_unlock(&occ->occ_lock);
 
+finish:
 	xfr->rc = rc;
-	client = xfr->client;
-
-	/* lock client to prevent race with read() */
-	spin_lock_irq(&client->lock);
-	set_bit(XFR_COMPLETE, &xfr->flags);
-	waiting = test_bit(XFR_WAITING, &xfr->flags);
-	spin_unlock(&client->lock);
-
-	spin_lock_irq(&occ->list_lock);
-	clear_bit(XFR_IN_PROGRESS, &xfr->flags);
-	list_del(&xfr->link);
-	empty = list_empty(&occ->xfrs);
-	canceled = test_bit(XFR_CANCELED, &xfr->flags);
-	spin_unlock(&occ->list_lock);
-
-	if (waiting)
-		wake_up_interruptible(&client->wait);
-	else if (canceled) {
-		kfree(xfr);
-		kfree(xfr->client);
-	}
-
-	if (!empty)
-		goto again;
+	if (occ_worker_finish_xfr(occ, xfr))
+		queue_work(occ_wq, &occ->work);
 }
 
 struct occ_client *occ_drv_open(struct device *dev, unsigned long flags)
@@ -612,7 +676,8 @@ static int occ_probe(struct platform_device *pdev)
 	INIT_LIST_HEAD(&occ->xfrs);
 	spin_lock_init(&occ->list_lock);
 	spin_lock_init(&occ->occ_lock);
-	INIT_WORK(&occ->work, occ_worker);
+	INIT_WORK(&occ->work, occ_worker_putsram);
+	INIT_DELAYED_WORK(&occ->dwork, occ_worker_getsram);
 
 	if (dev->of_node) {
 		rc = of_property_read_u32(dev->of_node, "reg", &reg);
@@ -688,6 +753,7 @@ static int occ_remove(struct platform_device *pdev)
 	spin_unlock(&occ->list_lock);
 
 	flush_work(&occ->work);
+	flush_delayed_work(&occ->dwork);
 
 	ida_simple_remove(&occ_ida, occ->idx);
 
-- 
1.8.3.1

